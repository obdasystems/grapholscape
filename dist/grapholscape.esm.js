/**
 * MIT License
 *
 * Copyright (c) 2018-2023 OBDA Systems
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import cytoscape from 'cytoscape';
import cola from 'cytoscape-cola';
import klay from 'cytoscape-klay';
import edgehandles from 'cytoscape-edgehandles';
import popper from 'cytoscape-popper';
import undoredo from 'cytoscape-undo-redo';
import cy_svg from 'cytoscape-svg';
import automove from 'cytoscape-automove';
import tippy from 'tippy.js';
import '@lit-labs/virtualizer';
import edgeEditing from 'cytoscape-edge-editing';
import $$1 from 'jquery';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var WidgetEnum$1;
(function (WidgetEnum) {
    WidgetEnum["DIAGRAM_SELECTOR"] = "diagram-selector";
    WidgetEnum["ENTITY_DETAILS"] = "details";
    WidgetEnum["ENTITY_SELECTOR"] = "entity-selector";
    WidgetEnum["FILTERS"] = "filters";
    WidgetEnum["FIT_BUTTON"] = "fit-button";
    WidgetEnum["FULLSCREEN_BUTTON"] = "fullscreen-button";
    WidgetEnum["ONTOLOGY_EXPLORER"] = "ontology-explorer";
    WidgetEnum["ONTOLOGY_INFO"] = "ontology-info";
    WidgetEnum["OWL_VISUALIZER"] = "owl-visualizer";
    WidgetEnum["RENDERER_SELECTOR"] = "renderer-selector";
    WidgetEnum["LAYOUT_SETTINGS"] = "layout-settings";
    WidgetEnum["SETTINGS"] = "settings";
    WidgetEnum["ZOOM_TOOLS"] = "zoom-tools";
    WidgetEnum["NEW_CLASS"] = "new-class";
    WidgetEnum["NEW_DIAGRAM"] = "new-diagram";
    WidgetEnum["NEW_DATAPROPERTY"] = "new-dataproperty";
    WidgetEnum["NEW_OBJECTPROPERTY"] = "new-objectproperty";
    WidgetEnum["INITIAL_RENDERER_SELECTOR"] = "initial-renderer-selector";
    /** @internal */
    WidgetEnum["CLASS_INSTANCE_DETAILS"] = "class-instance-details";
    /** @internal */
    WidgetEnum["INSTANCES_EXPLORER"] = "instances-explorer";
    /** @internal */
    WidgetEnum["NAVIGATION_MENU"] = "naviagtion-menu";
    /** @internal */
    WidgetEnum["VKG_PREFERENCES"] = "vkg-preferences";
    WidgetEnum["INCREMENTAL_INITIAL_MENU"] = "incremental-initial-menu";
})(WidgetEnum$1 || (WidgetEnum$1 = {}));

const NAMESPACE = 'obda-systems.grapholscape';
const getNamespacedKey = (key) => `${NAMESPACE}-${key}`;
const getKeyWithoutNamespace = (key) => key.substring(NAMESPACE.length + 1);
const valueToStore = (v) => JSON.stringify(v);
const valueFromStorage = (v) => JSON.parse(v);
/**
 * Load config from local storage
 */
function loadConfig() {
    const config = {};
    if (storageAvailable() && isAnySettingSaved()) {
        Object.keys(window.localStorage)
            .filter(k => k.startsWith(NAMESPACE)) // take only local storage items written by grapholscape
            .forEach(k => {
            const configKey = getKeyWithoutNamespace(k);
            const value = valueFromStorage(window.localStorage.getItem(k));
            if (Object.values(WidgetEnum$1).includes(configKey)) {
                if (!config.widgets)
                    config.widgets = {};
                config.widgets[configKey] = value;
            }
            else {
                config[configKey] = value;
            }
        });
    }
    return config;
}
/**
 * Store a single setting in local storage
 * @param {string} k the key of the setting to store
 * @param {any} value the value of the setting to store
 */
function storeConfigEntry(k, value) {
    if (storageAvailable())
        window.localStorage.setItem(getNamespacedKey(k), valueToStore(value));
}
function storageAvailable() {
    let storage = window.localStorage;
    try {
        var x = '__storage_test__';
        storage.setItem(x, x);
        storage.removeItem(x);
        return true;
    }
    catch (e) {
        return e instanceof DOMException && (
        // everything except Firefox
        e.code === 22 ||
            // Firefox
            e.code === 1014 ||
            // test name field too, because code might not be present
            // everything except Firefox
            e.name === 'QuotaExceededError' ||
            // Firefox
            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
            // acknowledge QuotaExceededError only if there's something already stored
            (storage && storage.length !== 0);
    }
}
/**
 * @returns Whether there is any local storage in setting belonging to grapholscape
 */
function isAnySettingSaved() {
    if (storageAvailable()) {
        return Object.keys(window.localStorage).some(k => k.startsWith(NAMESPACE));
    }
    return false;
}
function clearLocalStorage() {
    Object.keys(window.localStorage)
        .filter(k => k.startsWith(NAMESPACE))
        .forEach(k => window.localStorage.removeItem(k));
}

var cytoscapeDefaultConfig = {
    layout: { name: 'preset' },
    autoungrabify: true,
    maxZoom: 2.5,
    minZoom: 0.02,
    wheelSensitivity: 0.2,
};
const liteOptions = {
    layout: { name: 'preset' },
    autoungrabify: false,
    maxZoom: 2.5,
    minZoom: 0.02,
    wheelSensitivity: 0.2,
};
const floatyOptions = {
    layout: { name: 'preset' },
    autoungrabify: false,
    maxZoom: 2.5,
    minZoom: 0.02,
    wheelSensitivity: 0.2,
};

var Language;
(function (Language) {
    Language["DE"] = "de";
    Language["EN"] = "en";
    Language["ES"] = "es";
    Language["FR"] = "fr";
    Language["IT"] = "it";
})(Language || (Language = {}));

var downloadBlob = (blob, fileName) => {
    let a = document.createElement('a');
    document.body.appendChild(a);
    a.style.setProperty('style', 'none');
    let url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    window.URL.revokeObjectURL(url);
    a.remove();
};

cytoscape.use(cy_svg);
let options = {
    output: 'blob',
    full: true,
    bg: '',
};
function toPNG(fileName, cy, backgroundColor) {
    if (!checkParams(fileName, cy))
        return;
    options.bg = backgroundColor;
    if (cy)
        downloadBlob(cy.png(options), fileName);
}
function toSVG(fileName, cy, backgroundColor) {
    if (!checkParams(fileName, cy))
        return;
    options.bg = backgroundColor;
    let svg_content = cy.svg(options);
    let blob = new Blob([svg_content], { type: "image/svg+xml;charset=utf-8" });
    downloadBlob(blob, fileName);
}
function checkParams(fileName, cy) {
    if (!fileName || (typeof (fileName) !== 'string')) {
        console.error('Unable to export using an undefined file name');
        return false;
    }
    if (!cy) {
        console.error('Unable to export: cytoscape instance is undefined');
        return false;
    }
    return true;
}

/**
 * Class representing a namespace
 * @property {string[]} prefixes - array of prefixes
 * @property {string} value - namespace lexical form
 * @property {boolean} standard - bool saying if the namespace is standard or user defined
 */
class Namespace {
    constructor(prefixes, value, standard = false) {
        this.prefixes = prefixes;
        this.value = value;
        this.standard = standard;
    }
    get prefixes() {
        return Array.from(this._prefixes);
    }
    set prefixes(value) {
        this._prefixes = value;
    }
    set value(val) {
        this._value = val;
    }
    get value() {
        return this._value;
    }
    toString() {
        return this._value;
    }
    set standard(value) {
        this._standard = value;
    }
    /**
     * Wether the namespace is standard (`true`) or user defined (`false`)
     */
    isStandard() {
        return this._standard ? true : false;
    }
    /**
     * Check if the passed prefix is assigned to this namespace
     * @param prefix the prefix to check
     */
    hasPrefix(prefix) {
        return this.prefixes.includes(prefix);
    }
    addPrefix(newPrefix) {
        this._prefixes.push(newPrefix);
    }
}

class Iri {
    constructor(iri, namespaces, remainder) {
        let isPrefixed = false;
        this.namespace = namespaces.find(n => {
            if (iri.includes(n.toString()))
                return true;
            for (let prefix of n.prefixes) {
                if (iri === `${prefix}:${iri.split(':')[1]}`) {
                    isPrefixed = true;
                    return true;
                }
            }
        });
        if (remainder) {
            this.remainder = remainder;
            const ns = iri.split(remainder)[0];
            if (iri === ns.concat(remainder)) {
                this.namespace = new Namespace([], ns);
            }
            else {
                this.remainder = iri;
            }
        }
        else {
            if (!this.namespace) {
                console.warn(`Namespace not found for [${iri}]. The prefix undefined has been assigned`);
                // try {
                //   const uri = new URL(iri)
                //   this.remainder = uri.hash || uri.pathname.slice(uri.pathname.lastIndexOf('/') + 1)
                //   this.namespace = new Namespace([], uri.toString().slice(0, uri.toString().length - this.remainder.length))
                // } catch (e) {
                //   this.remainder = iri
                // }
                this.remainder = iri;
            }
            else {
                this.remainder = isPrefixed ? iri.split(':')[1] : iri.slice(this.namespace.toString().length);
            }
        }
    }
    set remainder(value) {
        this._remainder = value;
    }
    get remainder() {
        return this._remainder;
    }
    set namespace(value) {
        this._namespace = value;
    }
    get namespace() {
        return this._namespace;
    }
    get prefix() {
        var _a;
        return (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.prefixes[0];
    }
    get fullIri() {
        var _a;
        return ((_a = this.namespace) === null || _a === void 0 ? void 0 : _a.toString()) ? `${this.namespace.toString()}${this.remainder}` : this.remainder;
    }
    get prefixed() {
        return this.prefix || this.prefix === '' ? `${this.prefix}:${this.remainder}` : `${this.remainder}`;
    }
    equals(iriToCheck) {
        if (typeof iriToCheck !== 'string') {
            iriToCheck = iriToCheck.fullIri;
        }
        if (this.fullIri === iriToCheck || this.prefixed === iriToCheck)
            return true;
        if (!this.namespace)
            return false;
        for (let prefix of this.namespace.prefixes) {
            if (`${prefix}:${this.remainder}` === iriToCheck) {
                return true;
            }
        }
        return false;
    }
    hasPrefix(prefixToCheck) {
        var _a;
        return ((_a = this.namespace) === null || _a === void 0 ? void 0 : _a.hasPrefix(prefixToCheck)) || false;
    }
}

const DefaultNamespaces = {
    RDFS: new Namespace(['rdfs'], 'http://www.w3.org/2000/01/rdf-schema#'),
    OWL: new Namespace(['owl'], 'http://www.w3.org/2002/07/owl#'),
};
const AnnotationProperty = {
    label: new Iri(`${DefaultNamespaces.RDFS.value}label`, [DefaultNamespaces.RDFS]),
    comment: new Iri(`${DefaultNamespaces.RDFS.value}comment`, [DefaultNamespaces.RDFS]),
    author: new Iri(`${DefaultNamespaces.RDFS.value}author`, [DefaultNamespaces.RDFS]),
    seeAlso: new Iri(`${DefaultNamespaces.RDFS.value}seeAlso`, [DefaultNamespaces.RDFS]),
    isDefinedBy: new Iri(`${DefaultNamespaces.RDFS.value}isDefinedBy`, [DefaultNamespaces.RDFS]),
    deprecated: new Iri(`${DefaultNamespaces.OWL.value}deprecated`, [DefaultNamespaces.OWL]),
    versionInfo: new Iri(`${DefaultNamespaces.OWL.value}versionInfo`, [DefaultNamespaces.OWL]),
    priorVersion: new Iri(`${DefaultNamespaces.OWL.value}priorVersion`, [DefaultNamespaces.OWL]),
    backCompatibleWith: new Iri(`${DefaultNamespaces.OWL.value}backCompatibleWith`, [DefaultNamespaces.OWL]),
    incompatibleWith: new Iri(`${DefaultNamespaces.OWL.value}incompatibleWith`, [DefaultNamespaces.OWL]),
};
class AnnotatedElement {
    constructor() {
        this._annotations = [];
    }
    set annotations(annotations) {
        this._annotations = annotations;
    }
    addAnnotation(newAnnotation) {
        for (let annotation of this._annotations) {
            if (annotation.equals(newAnnotation)) {
                return;
            }
        }
        this._annotations.push(newAnnotation);
    }
    removeAnnotation(annotation) {
        this._annotations = this._annotations.filter(a => !a.equals(annotation));
    }
    getAnnotations(language, annotationProperty) {
        return this._annotations.filter(ann => {
            let shouldAdd = true;
            if (language && ann.language !== language) {
                shouldAdd = false;
            }
            if (annotationProperty && !annotationProperty.equals(ann.property)) {
                shouldAdd = false;
            }
            return shouldAdd;
        });
    }
    getLabels(language) {
        return this.getAnnotations(language, AnnotationProperty.label);
    }
    getComments(language) {
        return this.getAnnotations(language, AnnotationProperty.comment);
    }
}

/* tslint:disable */
const BASE_PATH = "https://virtserver.swaggerhub.com/PEPE_2/Grapholscape_Model/1.0.0".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
const DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(configuration = DefaultConfig) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            }
            catch (e) {
                for (const middleware of this.middleware) {
                    if (middleware.onError) {
                        response = (yield middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined,
                        })) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    }
                    else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    request(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = yield this.createFetchParams(context, initOverrides);
            const response = yield this.fetchApi(url, init);
            if (response && (response.status >= 200 && response.status < 300)) {
                return response;
            }
            throw new ResponseError(response, 'Response returned an error code');
        });
    }
    createFetchParams(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.configuration.basePath + context.path;
            if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                // only add the querystring to the URL if there are query parameters.
                // this is done to avoid urls ending with a "?" character which buggy webservers
                // do not handle correctly sometimes.
                url += '?' + this.configuration.queryParamsStringify(context.query);
            }
            const headers = Object.assign({}, this.configuration.headers, context.headers);
            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
            const initOverrideFn = typeof initOverrides === "function"
                ? initOverrides
                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });
            const initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials,
            };
            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({
                init: initParams,
                context,
            })));
            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||
                    overriddenInit.body instanceof URLSearchParams ||
                    isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body) });
            return { url, init };
        });
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg) {
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: fn(data[key]) })), {});
}
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
}
class VoidApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
}
class BlobApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.blob();
        });
    }
    ;
}
class TextApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.text();
        });
    }
    ;
}

/* tslint:disable */
/**
 * Check if a given object implements the Annotation interface.
 */
function instanceOfAnnotation(value) {
    let isInstance = true;
    isInstance = isInstance && "lexicalForm" in value;
    isInstance = isInstance && "property" in value;
    return isInstance;
}
function AnnotationFromJSON(json) {
    return AnnotationFromJSONTyped(json);
}
function AnnotationFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'lexicalForm': json['lexicalForm'],
        'property': json['property'],
        'language': !exists(json, 'language') ? undefined : json['language'],
        'datatype': !exists(json, 'datatype') ? undefined : json['datatype'],
    };
}
function AnnotationToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'lexicalForm': value.lexicalForm,
        'property': value.property,
        'language': value.language,
        'datatype': value.datatype,
    };
}

/* tslint:disable */
/* eslint-disable */
/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
var FunctionPropertiesEnum;
(function (FunctionPropertiesEnum) {
    FunctionPropertiesEnum["FUNCTIONAL"] = "functional";
    FunctionPropertiesEnum["INVERSE_FUNCTIONAL"] = "inverseFunctional";
    FunctionPropertiesEnum["TRANSITIVE"] = "transitive";
    FunctionPropertiesEnum["SYMMETRIC"] = "symmetric";
    FunctionPropertiesEnum["ASYMMETRIC"] = "asymmetric";
    FunctionPropertiesEnum["REFLEXIVE"] = "reflexive";
    FunctionPropertiesEnum["IRREFLEXIVE"] = "irreflexive";
})(FunctionPropertiesEnum || (FunctionPropertiesEnum = {}));
function FunctionPropertiesEnumFromJSON(json) {
    return FunctionPropertiesEnumFromJSONTyped(json);
}
function FunctionPropertiesEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
function FunctionPropertiesEnumToJSON(value) {
    return value;
}

/* tslint:disable */
/**
 * Check if a given object implements the Entity interface.
 */
function instanceOfEntity(value) {
    let isInstance = true;
    isInstance = isInstance && "fullIri" in value;
    return isInstance;
}
function EntityFromJSON(json) {
    return EntityFromJSONTyped(json);
}
function EntityFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'fullIri': json['fullIri'],
        'annotations': !exists(json, 'annotations') ? undefined : (json['annotations'].map(AnnotationFromJSON)),
        'datatype': !exists(json, 'datatype') ? undefined : json['datatype'],
        'isDataPropertyFunctional': !exists(json, 'isDataPropertyFunctional') ? undefined : json['isDataPropertyFunctional'],
        'functionProperties': !exists(json, 'functionProperties') ? undefined : (json['functionProperties'].map(FunctionPropertiesEnumFromJSON)),
    };
}
function EntityToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'fullIri': value.fullIri,
        'annotations': value.annotations === undefined ? undefined : (value.annotations.map(AnnotationToJSON)),
        'datatype': value.datatype,
        'isDataPropertyFunctional': value.isDataPropertyFunctional,
        'functionProperties': value.functionProperties === undefined ? undefined : (value.functionProperties.map(FunctionPropertiesEnumToJSON)),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the AnnotationOp interface.
 */
function instanceOfAnnotationOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    return isInstance;
}
function AnnotationOpFromJSON(json) {
    return AnnotationOpFromJSONTyped(json);
}
function AnnotationOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': AnnotationFromJSON(json['subject']),
        'previousState': !exists(json, 'previousState') ? undefined : AnnotationFromJSON(json['previousState']),
        'entity': !exists(json, 'entity') ? undefined : EntityFromJSON(json['entity']),
    };
}
function AnnotationOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': AnnotationToJSON(value.subject),
        'previousState': AnnotationToJSON(value.previousState),
        'entity': EntityToJSON(value.entity),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the DataPropertyValue interface.
 */
function instanceOfDataPropertyValue(value) {
    let isInstance = true;
    isInstance = isInstance && "value" in value;
    isInstance = isInstance && "iri" in value;
    return isInstance;
}
function DataPropertyValueFromJSON(json) {
    return DataPropertyValueFromJSONTyped(json);
}
function DataPropertyValueFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'value': json['value'],
        'iri': json['iri'],
        'language': !exists(json, 'language') ? undefined : json['language'],
        'datatype': !exists(json, 'datatype') ? undefined : json['datatype'],
    };
}
function DataPropertyValueToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'value': value.value,
        'iri': value.iri,
        'language': value.language,
        'datatype': value.datatype,
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClassInstanceEntity interface.
 */
function instanceOfClassInstanceEntity(value) {
    let isInstance = true;
    isInstance = isInstance && "fullIri" in value;
    return isInstance;
}
function ClassInstanceEntityFromJSON(json) {
    return ClassInstanceEntityFromJSONTyped(json);
}
function ClassInstanceEntityFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'fullIri': json['fullIri'],
        'annotations': !exists(json, 'annotations') ? undefined : (json['annotations'].map(AnnotationFromJSON)),
        'datatype': !exists(json, 'datatype') ? undefined : json['datatype'],
        'isDataPropertyFunctional': !exists(json, 'isDataPropertyFunctional') ? undefined : json['isDataPropertyFunctional'],
        'functionProperties': !exists(json, 'functionProperties') ? undefined : (json['functionProperties'].map(FunctionPropertiesEnumFromJSON)),
        'parentClasses': !exists(json, 'parentClasses') ? undefined : json['parentClasses'],
        'dataProperties': !exists(json, 'dataProperties') ? undefined : (json['dataProperties'].map(DataPropertyValueFromJSON)),
        'shortIri': !exists(json, 'shortIri') ? undefined : json['shortIri'],
    };
}
function ClassInstanceEntityToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'fullIri': value.fullIri,
        'annotations': value.annotations === undefined ? undefined : (value.annotations.map(AnnotationToJSON)),
        'datatype': value.datatype,
        'isDataPropertyFunctional': value.isDataPropertyFunctional,
        'functionProperties': value.functionProperties === undefined ? undefined : (value.functionProperties.map(FunctionPropertiesEnumToJSON)),
        'parentClasses': value.parentClasses,
        'dataProperties': value.dataProperties === undefined ? undefined : (value.dataProperties.map(DataPropertyValueToJSON)),
        'shortIri': value.shortIri,
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the ClassInstanceEntityAllOf interface.
 */
function instanceOfClassInstanceEntityAllOf(value) {
    let isInstance = true;
    return isInstance;
}
function ClassInstanceEntityAllOfFromJSON(json) {
    return ClassInstanceEntityAllOfFromJSONTyped(json);
}
function ClassInstanceEntityAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'parentClasses': !exists(json, 'parentClasses') ? undefined : json['parentClasses'],
        'dataProperties': !exists(json, 'dataProperties') ? undefined : (json['dataProperties'].map(DataPropertyValueFromJSON)),
        'shortIri': !exists(json, 'shortIri') ? undefined : json['shortIri'],
    };
}
function ClassInstanceEntityAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'parentClasses': value.parentClasses,
        'dataProperties': value.dataProperties === undefined ? undefined : (value.dataProperties.map(DataPropertyValueToJSON)),
        'shortIri': value.shortIri,
    };
}

/* tslint:disable */
/* eslint-disable */
/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Position interface.
 */
function instanceOfPosition(value) {
    let isInstance = true;
    isInstance = isInstance && "x" in value;
    isInstance = isInstance && "y" in value;
    return isInstance;
}
function PositionFromJSON(json) {
    return PositionFromJSONTyped(json);
}
function PositionFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'x': json['x'],
        'y': json['y'],
    };
}
function PositionToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'x': value.x,
        'y': value.y,
    };
}

/* tslint:disable */
/* eslint-disable */
/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Contiene tutti i tipi di nodi/archi orginirari dal Graphol per evitare di duplicare gli enumeratori. Nella rappresentazione Floaty/vkg vengono usati questi valori.
 * NODI class data-property class-instance (vkg) individual (floaty) union disjoint-union
 * ARCHI object-property instance-of input inclusion equivalence attribute-edge complete-union complete-disjoint-union
 * @export
 * @enum {string}
 */
var TypesEnum;
(function (TypesEnum) {
    TypesEnum["CLASS"] = "class";
    TypesEnum["OBJECT_PROPERTY"] = "object-property";
    TypesEnum["DATA_PROPERTY"] = "data-property";
    TypesEnum["INDIVIDUAL"] = "individual";
    TypesEnum["CLASS_INSTANCE"] = "class-instance";
    TypesEnum["DOMAIN_RESTRICTION"] = "domain-restriction";
    TypesEnum["RANGE_RESTRICTION"] = "range-restriction";
    TypesEnum["UNION"] = "union";
    TypesEnum["COMPLETE_UNION"] = "complete-union";
    TypesEnum["DISJOINT_UNION"] = "disjoint-union";
    TypesEnum["COMPLETE_DISJOINT_UNION"] = "complete-disjoint-union";
    TypesEnum["COMPLEMENT"] = "complement";
    TypesEnum["INTERSECTION"] = "intersection";
    TypesEnum["ENUMERATION"] = "enumeration";
    TypesEnum["HAS_KEY"] = "has-key";
    TypesEnum["ROLE_INVERSE"] = "role-inverse";
    TypesEnum["ROLE_CHAIN"] = "role-chain";
    TypesEnum["DATATYPE_RESTRICTION"] = "datatype-restriction";
    TypesEnum["VALUE_DOMAIN"] = "value-domain";
    TypesEnum["PROPERTY_ASSERTION"] = "property-assertion";
    TypesEnum["LITERAL"] = "literal";
    TypesEnum["FACET"] = "facet";
    TypesEnum["NEUTRAL"] = "neutral";
    TypesEnum["VALUE"] = "value";
    TypesEnum["INCLUSION"] = "inclusion";
    TypesEnum["EQUIVALENCE"] = "equivalence";
    TypesEnum["INSTANCE_OF"] = "instance-of";
    TypesEnum["INPUT"] = "input";
    TypesEnum["SAME"] = "same";
    TypesEnum["DIFFERENT"] = "different";
    TypesEnum["MEMBERSHIP"] = "membership";
    TypesEnum["ATTRIBUTE_EDGE"] = "attribute-edge";
})(TypesEnum || (TypesEnum = {}));
function TypesEnumFromJSON(json) {
    return TypesEnumFromJSONTyped(json);
}
function TypesEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
function TypesEnumToJSON(value) {
    return value;
}

/* tslint:disable */
/**
 * Check if a given object implements the Edge interface.
 */
function instanceOfEdge(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "sourceId" in value;
    isInstance = isInstance && "targetId" in value;
    return isInstance;
}
function EdgeFromJSON(json) {
    return EdgeFromJSONTyped(json);
}
function EdgeFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'originalId': !exists(json, 'originalId') ? undefined : json['originalId'],
        'diagramId': !exists(json, 'diagramId') ? undefined : json['diagramId'],
        'displayedName': !exists(json, 'displayedName') ? undefined : json['displayedName'],
        'iri': !exists(json, 'iri') ? undefined : json['iri'],
        'type': TypesEnumFromJSON(json['type']),
        'sourceId': json['sourceId'],
        'targetId': json['targetId'],
        'breakpoints': !exists(json, 'breakpoints') ? undefined : (json['breakpoints'].map(PositionFromJSON)),
    };
}
function EdgeToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'originalId': value.originalId,
        'diagramId': value.diagramId,
        'displayedName': value.displayedName,
        'iri': value.iri,
        'type': TypesEnumToJSON(value.type),
        'sourceId': value.sourceId,
        'targetId': value.targetId,
        'breakpoints': value.breakpoints === undefined ? undefined : (value.breakpoints.map(PositionToJSON)),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the Node interface.
 */
function instanceOfNode(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "type" in value;
    return isInstance;
}
function NodeFromJSON(json) {
    return NodeFromJSONTyped(json);
}
function NodeFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'originalId': !exists(json, 'originalId') ? undefined : json['originalId'],
        'diagramId': !exists(json, 'diagramId') ? undefined : json['diagramId'],
        'displayedName': !exists(json, 'displayedName') ? undefined : json['displayedName'],
        'iri': !exists(json, 'iri') ? undefined : json['iri'],
        'type': TypesEnumFromJSON(json['type']),
        'position': !exists(json, 'position') ? undefined : PositionFromJSON(json['position']),
        'labelPosition': !exists(json, 'labelPosition') ? undefined : PositionFromJSON(json['labelPosition']),
    };
}
function NodeToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'originalId': value.originalId,
        'diagramId': value.diagramId,
        'displayedName': value.displayedName,
        'iri': value.iri,
        'type': TypesEnumToJSON(value.type),
        'position': PositionToJSON(value.position),
        'labelPosition': PositionToJSON(value.labelPosition),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the Viewport interface.
 */
function instanceOfViewport(value) {
    let isInstance = true;
    isInstance = isInstance && "pan" in value;
    isInstance = isInstance && "zoom" in value;
    return isInstance;
}
function ViewportFromJSON(json) {
    return ViewportFromJSONTyped(json);
}
function ViewportFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'pan': PositionFromJSON(json['pan']),
        'zoom': json['zoom'],
    };
}
function ViewportToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'pan': PositionToJSON(value.pan),
        'zoom': value.zoom,
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the Diagram interface.
 */
function instanceOfDiagram(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "name" in value;
    return isInstance;
}
function DiagramFromJSON(json) {
    return DiagramFromJSONTyped(json);
}
function DiagramFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'name': json['name'],
        'nodes': !exists(json, 'nodes') ? undefined : (json['nodes'].map(NodeFromJSON)),
        'edges': !exists(json, 'edges') ? undefined : (json['edges'].map(EdgeFromJSON)),
        'lastViewportState': !exists(json, 'lastViewportState') ? undefined : ViewportFromJSON(json['lastViewportState']),
    };
}
function DiagramToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'name': value.name,
        'nodes': value.nodes === undefined ? undefined : (value.nodes.map(NodeToJSON)),
        'edges': value.edges === undefined ? undefined : (value.edges.map(EdgeToJSON)),
        'lastViewportState': ViewportToJSON(value.lastViewportState),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the DiagramOp interface.
 */
function instanceOfDiagramOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    return isInstance;
}
function DiagramOpFromJSON(json) {
    return DiagramOpFromJSONTyped(json);
}
function DiagramOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': DiagramFromJSON(json['subject']),
        'previousState': !exists(json, 'previousState') ? undefined : DiagramFromJSON(json['previousState']),
    };
}
function DiagramOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': DiagramToJSON(value.subject),
        'previousState': DiagramToJSON(value.previousState),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the EdgeAllOf interface.
 */
function instanceOfEdgeAllOf(value) {
    let isInstance = true;
    isInstance = isInstance && "sourceId" in value;
    isInstance = isInstance && "targetId" in value;
    return isInstance;
}
function EdgeAllOfFromJSON(json) {
    return EdgeAllOfFromJSONTyped(json);
}
function EdgeAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'sourceId': json['sourceId'],
        'targetId': json['targetId'],
        'breakpoints': !exists(json, 'breakpoints') ? undefined : (json['breakpoints'].map(PositionFromJSON)),
    };
}
function EdgeAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'sourceId': value.sourceId,
        'targetId': value.targetId,
        'breakpoints': value.breakpoints === undefined ? undefined : (value.breakpoints.map(PositionToJSON)),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the Element interface.
 */
function instanceOfElement(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "type" in value;
    return isInstance;
}
function ElementFromJSON(json) {
    return ElementFromJSONTyped(json);
}
function ElementFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'originalId': !exists(json, 'originalId') ? undefined : json['originalId'],
        'diagramId': !exists(json, 'diagramId') ? undefined : json['diagramId'],
        'displayedName': !exists(json, 'displayedName') ? undefined : json['displayedName'],
        'iri': !exists(json, 'iri') ? undefined : json['iri'],
        'type': TypesEnumFromJSON(json['type']),
    };
}
function ElementToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'originalId': value.originalId,
        'diagramId': value.diagramId,
        'displayedName': value.displayedName,
        'iri': value.iri,
        'type': TypesEnumToJSON(value.type),
    };
}

/* tslint:disable */
function ElementOpPreviousStateFromJSON(json) {
    return ElementOpPreviousStateFromJSONTyped(json);
}
function ElementOpPreviousStateFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return Object.assign(Object.assign({}, EdgeFromJSONTyped(json)), NodeFromJSONTyped(json));
}
function ElementOpPreviousStateToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    if (instanceOfEdge(value)) {
        return EdgeToJSON(value);
    }
    if (instanceOfNode(value)) {
        return NodeToJSON(value);
    }
    return {};
}

/* tslint:disable */
/**
 * Check if a given object implements the HierarchySuperclassesInner interface.
 */
function instanceOfHierarchySuperclassesInner(value) {
    let isInstance = true;
    isInstance = isInstance && "classEntity" in value;
    isInstance = isInstance && "complete" in value;
    return isInstance;
}
function HierarchySuperclassesInnerFromJSON(json) {
    return HierarchySuperclassesInnerFromJSONTyped(json);
}
function HierarchySuperclassesInnerFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'classEntity': EntityFromJSON(json['classEntity']),
        'complete': json['complete'],
    };
}
function HierarchySuperclassesInnerToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'classEntity': EntityToJSON(value.classEntity),
        'complete': value.complete,
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the Hierarchy interface.
 */
function instanceOfHierarchy(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "inputs" in value;
    isInstance = isInstance && "superclasses" in value;
    return isInstance;
}
function HierarchyFromJSON(json) {
    return HierarchyFromJSONTyped(json);
}
function HierarchyFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'type': TypesEnumFromJSON(json['type']),
        'inputs': (json['inputs'].map(EntityFromJSON)),
        'superclasses': (json['superclasses'].map(HierarchySuperclassesInnerFromJSON)),
    };
}
function HierarchyToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'type': TypesEnumToJSON(value.type),
        'inputs': (value.inputs.map(EntityToJSON)),
        'superclasses': (value.superclasses.map(HierarchySuperclassesInnerToJSON)),
    };
}

/* tslint:disable */
function ElementOpSubjectFromJSON(json) {
    return ElementOpSubjectFromJSONTyped(json);
}
function ElementOpSubjectFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return Object.assign(Object.assign(Object.assign({}, EdgeFromJSONTyped(json)), HierarchyFromJSONTyped(json)), NodeFromJSONTyped(json));
}
function ElementOpSubjectToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    if (instanceOfEdge(value)) {
        return EdgeToJSON(value);
    }
    if (instanceOfHierarchy(value)) {
        return HierarchyToJSON(value);
    }
    if (instanceOfNode(value)) {
        return NodeToJSON(value);
    }
    return {};
}

/* tslint:disable */
/**
 * Check if a given object implements the ElementOp interface.
 */
function instanceOfElementOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    return isInstance;
}
function ElementOpFromJSON(json) {
    return ElementOpFromJSONTyped(json);
}
function ElementOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': ElementOpSubjectFromJSON(json['subject']),
        'previousState': !exists(json, 'previousState') ? undefined : ElementOpPreviousStateFromJSON(json['previousState']),
        'involvedElements': !exists(json, 'involvedElements') ? undefined : (json['involvedElements'].map(ElementOpSubjectFromJSON)),
    };
}
function ElementOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': ElementOpSubjectToJSON(value.subject),
        'previousState': ElementOpPreviousStateToJSON(value.previousState),
        'involvedElements': value.involvedElements === undefined ? undefined : (value.involvedElements.map(ElementOpSubjectToJSON)),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the EntityOp interface.
 */
function instanceOfEntityOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    return isInstance;
}
function EntityOpFromJSON(json) {
    return EntityOpFromJSONTyped(json);
}
function EntityOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': EntityFromJSON(json['subject']),
        'previousState': !exists(json, 'previousState') ? undefined : EntityFromJSON(json['previousState']),
        'involvedElements': !exists(json, 'involvedElements') ? undefined : (json['involvedElements'].map(ElementOpSubjectFromJSON)),
    };
}
function EntityOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': EntityToJSON(value.subject),
        'previousState': EntityToJSON(value.previousState),
        'involvedElements': value.involvedElements === undefined ? undefined : (value.involvedElements.map(ElementOpSubjectToJSON)),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the HierarchyOp interface.
 */
function instanceOfHierarchyOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    isInstance = isInstance && "diagramId" in value;
    return isInstance;
}
function HierarchyOpFromJSON(json) {
    return HierarchyOpFromJSONTyped(json);
}
function HierarchyOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': HierarchyFromJSON(json['subject']),
        'diagramId': json['diagramId'],
        'previousState': !exists(json, 'previousState') ? undefined : HierarchyFromJSON(json['previousState']),
    };
}
function HierarchyOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': HierarchyToJSON(value.subject),
        'diagramId': value.diagramId,
        'previousState': HierarchyToJSON(value.previousState),
    };
}

/* tslint:disable */
/* eslint-disable */
/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Check if a given object implements the Namespace interface.
 */
function instanceOfNamespace(value) {
    let isInstance = true;
    isInstance = isInstance && "value" in value;
    isInstance = isInstance && "prefixes" in value;
    return isInstance;
}
function NamespaceFromJSON(json) {
    return NamespaceFromJSONTyped(json);
}
function NamespaceFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'value': json['value'],
        'prefixes': json['prefixes'],
    };
}
function NamespaceToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'value': value.value,
        'prefixes': value.prefixes,
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the NamespaceOp interface.
 */
function instanceOfNamespaceOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    return isInstance;
}
function NamespaceOpFromJSON(json) {
    return NamespaceOpFromJSONTyped(json);
}
function NamespaceOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': NamespaceFromJSON(json['subject']),
        'previousState': !exists(json, 'previousState') ? undefined : NamespaceFromJSON(json['previousState']),
    };
}
function NamespaceOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': NamespaceToJSON(value.subject),
        'previousState': NamespaceToJSON(value.previousState),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the NodeAllOf interface.
 */
function instanceOfNodeAllOf(value) {
    let isInstance = true;
    return isInstance;
}
function NodeAllOfFromJSON(json) {
    return NodeAllOfFromJSONTyped(json);
}
function NodeAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'position': !exists(json, 'position') ? undefined : PositionFromJSON(json['position']),
        'labelPosition': !exists(json, 'labelPosition') ? undefined : PositionFromJSON(json['labelPosition']),
    };
}
function NodeAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'position': PositionToJSON(value.position),
        'labelPosition': PositionToJSON(value.labelPosition),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the PropertyOp interface.
 */
function instanceOfPropertyOp(value) {
    let isInstance = true;
    isInstance = isInstance && "subject" in value;
    return isInstance;
}
function PropertyOpFromJSON(json) {
    return PropertyOpFromJSONTyped(json);
}
function PropertyOpFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'subject': EntityFromJSON(json['subject']),
        'previousState': !exists(json, 'previousState') ? undefined : EntityFromJSON(json['previousState']),
    };
}
function PropertyOpToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'subject': EntityToJSON(value.subject),
        'previousState': EntityToJSON(value.previousState),
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the Theme interface.
 */
function instanceOfTheme(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    return isInstance;
}
function ThemeFromJSON(json) {
    return ThemeFromJSONTyped(json);
}
function ThemeFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'name': !exists(json, 'name') ? undefined : json['name'],
        'colours': !exists(json, 'colours') ? undefined : json['colours'],
    };
}
function ThemeToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'name': value.name,
        'colours': value.colours,
    };
}

/* tslint:disable */
/**
* @export
* @enum {string}
*/
var RDFGraphConfigEntityNameTypeEnum;
(function (RDFGraphConfigEntityNameTypeEnum) {
    RDFGraphConfigEntityNameTypeEnum["LABEL"] = "label";
    RDFGraphConfigEntityNameTypeEnum["PREFIXED_IRI"] = "prefixed_iri";
    RDFGraphConfigEntityNameTypeEnum["FULL_IRI"] = "full_iri";
})(RDFGraphConfigEntityNameTypeEnum || (RDFGraphConfigEntityNameTypeEnum = {}));
/**
* @export
* @enum {string}
*/
var RDFGraphConfigFiltersEnum;
(function (RDFGraphConfigFiltersEnum) {
    RDFGraphConfigFiltersEnum["ALL"] = "all";
    RDFGraphConfigFiltersEnum["DATA_PROPERTY"] = "data-property";
    RDFGraphConfigFiltersEnum["VALUE_DOMAIN"] = "value-domain";
    RDFGraphConfigFiltersEnum["INDIVIDUAL"] = "individual";
    RDFGraphConfigFiltersEnum["UNIVERSAL_QUANTIFIER"] = "universal_quantifier";
    RDFGraphConfigFiltersEnum["COMPLEMENT"] = "complement";
    RDFGraphConfigFiltersEnum["HAS_KEY"] = "has-key";
})(RDFGraphConfigFiltersEnum || (RDFGraphConfigFiltersEnum = {}));
/**
 * Check if a given object implements the RDFGraphConfig interface.
 */
function instanceOfRDFGraphConfig(value) {
    let isInstance = true;
    return isInstance;
}
function RDFGraphConfigFromJSON(json) {
    return RDFGraphConfigFromJSONTyped(json);
}
function RDFGraphConfigFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'themes': !exists(json, 'themes') ? undefined : (json['themes'].map(ThemeFromJSON)),
        'selectedTheme': !exists(json, 'selectedTheme') ? undefined : json['selectedTheme'],
        'language': !exists(json, 'language') ? undefined : json['language'],
        'entityNameType': !exists(json, 'entityNameType') ? undefined : json['entityNameType'],
        'renderers': !exists(json, 'renderers') ? undefined : json['renderers'],
        'widgets': !exists(json, 'widgets') ? undefined : json['widgets'],
        'filters': !exists(json, 'filters') ? undefined : json['filters'],
    };
}
function RDFGraphConfigToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'themes': value.themes === undefined ? undefined : (value.themes.map(ThemeToJSON)),
        'selectedTheme': value.selectedTheme,
        'language': value.language,
        'entityNameType': value.entityNameType,
        'renderers': value.renderers,
        'widgets': value.widgets,
        'filters': value.filters,
    };
}

/* tslint:disable */
/**
 * Check if a given object implements the RDFGraphMetadata interface.
 */
function instanceOfRDFGraphMetadata(value) {
    let isInstance = true;
    isInstance = isInstance && "namespaces" in value;
    return isInstance;
}
function RDFGraphMetadataFromJSON(json) {
    return RDFGraphMetadataFromJSONTyped(json);
}
function RDFGraphMetadataFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'name': !exists(json, 'name') ? undefined : json['name'],
        'iri': !exists(json, 'iri') ? undefined : json['iri'],
        'version': !exists(json, 'version') ? undefined : json['version'],
        'languages': !exists(json, 'languages') ? undefined : json['languages'],
        'defaultLanguage': !exists(json, 'defaultLanguage') ? undefined : json['defaultLanguage'],
        'namespaces': (json['namespaces'].map(NamespaceFromJSON)),
        'annotations': !exists(json, 'annotations') ? undefined : (json['annotations'].map(AnnotationFromJSON)),
    };
}
function RDFGraphMetadataToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'iri': value.iri,
        'version': value.version,
        'languages': value.languages,
        'defaultLanguage': value.defaultLanguage,
        'namespaces': (value.namespaces.map(NamespaceToJSON)),
        'annotations': value.annotations === undefined ? undefined : (value.annotations.map(AnnotationToJSON)),
    };
}

/* tslint:disable */
/**
* @export
* @enum {string}
*/
var RDFGraphModelTypeEnum;
(function (RDFGraphModelTypeEnum) {
    RDFGraphModelTypeEnum["ONTOLOGY"] = "ontology";
    RDFGraphModelTypeEnum["VKG"] = "vkg";
    RDFGraphModelTypeEnum["RDF"] = "rdf";
})(RDFGraphModelTypeEnum || (RDFGraphModelTypeEnum = {}));
/**
 * Check if a given object implements the RDFGraph interface.
 */
function instanceOfRDFGraph(value) {
    let isInstance = true;
    isInstance = isInstance && "diagrams" in value;
    isInstance = isInstance && "entities" in value;
    isInstance = isInstance && "metadata" in value;
    isInstance = isInstance && "modelType" in value;
    return isInstance;
}
function RDFGraphFromJSON(json) {
    return RDFGraphFromJSONTyped(json);
}
function RDFGraphFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'diagrams': (json['diagrams'].map(DiagramFromJSON)),
        'entities': (json['entities'].map(EntityFromJSON)),
        'classInstanceEntities': !exists(json, 'classInstanceEntities') ? undefined : (json['classInstanceEntities'].map(ClassInstanceEntityFromJSON)),
        'metadata': RDFGraphMetadataFromJSON(json['metadata']),
        'config': !exists(json, 'config') ? undefined : RDFGraphConfigFromJSON(json['config']),
        'selectedDiagramId': !exists(json, 'selectedDiagramId') ? undefined : json['selectedDiagramId'],
        'modelType': json['modelType'],
    };
}
function RDFGraphToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'diagrams': (value.diagrams.map(DiagramToJSON)),
        'entities': (value.entities.map(EntityToJSON)),
        'classInstanceEntities': value.classInstanceEntities === undefined ? undefined : (value.classInstanceEntities.map(ClassInstanceEntityToJSON)),
        'metadata': RDFGraphMetadataToJSON(value.metadata),
        'config': RDFGraphConfigToJSON(value.config),
        'selectedDiagramId': value.selectedDiagramId,
        'modelType': value.modelType,
    };
}

/* tslint:disable */

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BASE_PATH: BASE_PATH,
    Configuration: Configuration,
    DefaultConfig: DefaultConfig,
    BaseAPI: BaseAPI,
    ResponseError: ResponseError,
    FetchError: FetchError,
    RequiredError: RequiredError,
    COLLECTION_FORMATS: COLLECTION_FORMATS,
    exists: exists,
    querystring: querystring,
    mapValues: mapValues,
    canConsumeForm: canConsumeForm,
    JSONApiResponse: JSONApiResponse,
    VoidApiResponse: VoidApiResponse,
    BlobApiResponse: BlobApiResponse,
    TextApiResponse: TextApiResponse,
    instanceOfAnnotation: instanceOfAnnotation,
    AnnotationFromJSON: AnnotationFromJSON,
    AnnotationFromJSONTyped: AnnotationFromJSONTyped,
    AnnotationToJSON: AnnotationToJSON,
    instanceOfAnnotationOp: instanceOfAnnotationOp,
    AnnotationOpFromJSON: AnnotationOpFromJSON,
    AnnotationOpFromJSONTyped: AnnotationOpFromJSONTyped,
    AnnotationOpToJSON: AnnotationOpToJSON,
    instanceOfClassInstanceEntity: instanceOfClassInstanceEntity,
    ClassInstanceEntityFromJSON: ClassInstanceEntityFromJSON,
    ClassInstanceEntityFromJSONTyped: ClassInstanceEntityFromJSONTyped,
    ClassInstanceEntityToJSON: ClassInstanceEntityToJSON,
    instanceOfClassInstanceEntityAllOf: instanceOfClassInstanceEntityAllOf,
    ClassInstanceEntityAllOfFromJSON: ClassInstanceEntityAllOfFromJSON,
    ClassInstanceEntityAllOfFromJSONTyped: ClassInstanceEntityAllOfFromJSONTyped,
    ClassInstanceEntityAllOfToJSON: ClassInstanceEntityAllOfToJSON,
    instanceOfDataPropertyValue: instanceOfDataPropertyValue,
    DataPropertyValueFromJSON: DataPropertyValueFromJSON,
    DataPropertyValueFromJSONTyped: DataPropertyValueFromJSONTyped,
    DataPropertyValueToJSON: DataPropertyValueToJSON,
    instanceOfDiagram: instanceOfDiagram,
    DiagramFromJSON: DiagramFromJSON,
    DiagramFromJSONTyped: DiagramFromJSONTyped,
    DiagramToJSON: DiagramToJSON,
    instanceOfDiagramOp: instanceOfDiagramOp,
    DiagramOpFromJSON: DiagramOpFromJSON,
    DiagramOpFromJSONTyped: DiagramOpFromJSONTyped,
    DiagramOpToJSON: DiagramOpToJSON,
    instanceOfEdge: instanceOfEdge,
    EdgeFromJSON: EdgeFromJSON,
    EdgeFromJSONTyped: EdgeFromJSONTyped,
    EdgeToJSON: EdgeToJSON,
    instanceOfEdgeAllOf: instanceOfEdgeAllOf,
    EdgeAllOfFromJSON: EdgeAllOfFromJSON,
    EdgeAllOfFromJSONTyped: EdgeAllOfFromJSONTyped,
    EdgeAllOfToJSON: EdgeAllOfToJSON,
    instanceOfElement: instanceOfElement,
    ElementFromJSON: ElementFromJSON,
    ElementFromJSONTyped: ElementFromJSONTyped,
    ElementToJSON: ElementToJSON,
    instanceOfElementOp: instanceOfElementOp,
    ElementOpFromJSON: ElementOpFromJSON,
    ElementOpFromJSONTyped: ElementOpFromJSONTyped,
    ElementOpToJSON: ElementOpToJSON,
    ElementOpPreviousStateFromJSON: ElementOpPreviousStateFromJSON,
    ElementOpPreviousStateFromJSONTyped: ElementOpPreviousStateFromJSONTyped,
    ElementOpPreviousStateToJSON: ElementOpPreviousStateToJSON,
    ElementOpSubjectFromJSON: ElementOpSubjectFromJSON,
    ElementOpSubjectFromJSONTyped: ElementOpSubjectFromJSONTyped,
    ElementOpSubjectToJSON: ElementOpSubjectToJSON,
    instanceOfEntity: instanceOfEntity,
    EntityFromJSON: EntityFromJSON,
    EntityFromJSONTyped: EntityFromJSONTyped,
    EntityToJSON: EntityToJSON,
    instanceOfEntityOp: instanceOfEntityOp,
    EntityOpFromJSON: EntityOpFromJSON,
    EntityOpFromJSONTyped: EntityOpFromJSONTyped,
    EntityOpToJSON: EntityOpToJSON,
    get FunctionPropertiesEnum () { return FunctionPropertiesEnum; },
    FunctionPropertiesEnumFromJSON: FunctionPropertiesEnumFromJSON,
    FunctionPropertiesEnumFromJSONTyped: FunctionPropertiesEnumFromJSONTyped,
    FunctionPropertiesEnumToJSON: FunctionPropertiesEnumToJSON,
    instanceOfHierarchy: instanceOfHierarchy,
    HierarchyFromJSON: HierarchyFromJSON,
    HierarchyFromJSONTyped: HierarchyFromJSONTyped,
    HierarchyToJSON: HierarchyToJSON,
    instanceOfHierarchyOp: instanceOfHierarchyOp,
    HierarchyOpFromJSON: HierarchyOpFromJSON,
    HierarchyOpFromJSONTyped: HierarchyOpFromJSONTyped,
    HierarchyOpToJSON: HierarchyOpToJSON,
    instanceOfHierarchySuperclassesInner: instanceOfHierarchySuperclassesInner,
    HierarchySuperclassesInnerFromJSON: HierarchySuperclassesInnerFromJSON,
    HierarchySuperclassesInnerFromJSONTyped: HierarchySuperclassesInnerFromJSONTyped,
    HierarchySuperclassesInnerToJSON: HierarchySuperclassesInnerToJSON,
    instanceOfNamespace: instanceOfNamespace,
    NamespaceFromJSON: NamespaceFromJSON,
    NamespaceFromJSONTyped: NamespaceFromJSONTyped,
    NamespaceToJSON: NamespaceToJSON,
    instanceOfNamespaceOp: instanceOfNamespaceOp,
    NamespaceOpFromJSON: NamespaceOpFromJSON,
    NamespaceOpFromJSONTyped: NamespaceOpFromJSONTyped,
    NamespaceOpToJSON: NamespaceOpToJSON,
    instanceOfNode: instanceOfNode,
    NodeFromJSON: NodeFromJSON,
    NodeFromJSONTyped: NodeFromJSONTyped,
    NodeToJSON: NodeToJSON,
    instanceOfNodeAllOf: instanceOfNodeAllOf,
    NodeAllOfFromJSON: NodeAllOfFromJSON,
    NodeAllOfFromJSONTyped: NodeAllOfFromJSONTyped,
    NodeAllOfToJSON: NodeAllOfToJSON,
    instanceOfPosition: instanceOfPosition,
    PositionFromJSON: PositionFromJSON,
    PositionFromJSONTyped: PositionFromJSONTyped,
    PositionToJSON: PositionToJSON,
    instanceOfPropertyOp: instanceOfPropertyOp,
    PropertyOpFromJSON: PropertyOpFromJSON,
    PropertyOpFromJSONTyped: PropertyOpFromJSONTyped,
    PropertyOpToJSON: PropertyOpToJSON,
    get RDFGraphModelTypeEnum () { return RDFGraphModelTypeEnum; },
    instanceOfRDFGraph: instanceOfRDFGraph,
    RDFGraphFromJSON: RDFGraphFromJSON,
    RDFGraphFromJSONTyped: RDFGraphFromJSONTyped,
    RDFGraphToJSON: RDFGraphToJSON,
    get RDFGraphConfigEntityNameTypeEnum () { return RDFGraphConfigEntityNameTypeEnum; },
    get RDFGraphConfigFiltersEnum () { return RDFGraphConfigFiltersEnum; },
    instanceOfRDFGraphConfig: instanceOfRDFGraphConfig,
    RDFGraphConfigFromJSON: RDFGraphConfigFromJSON,
    RDFGraphConfigFromJSONTyped: RDFGraphConfigFromJSONTyped,
    RDFGraphConfigToJSON: RDFGraphConfigToJSON,
    instanceOfRDFGraphMetadata: instanceOfRDFGraphMetadata,
    RDFGraphMetadataFromJSON: RDFGraphMetadataFromJSON,
    RDFGraphMetadataFromJSONTyped: RDFGraphMetadataFromJSONTyped,
    RDFGraphMetadataToJSON: RDFGraphMetadataToJSON,
    instanceOfTheme: instanceOfTheme,
    ThemeFromJSON: ThemeFromJSON,
    ThemeFromJSONTyped: ThemeFromJSONTyped,
    ThemeToJSON: ThemeToJSON,
    get TypesEnum () { return TypesEnum; },
    TypesEnumFromJSON: TypesEnumFromJSON,
    TypesEnumFromJSONTyped: TypesEnumFromJSONTyped,
    TypesEnumToJSON: TypesEnumToJSON,
    instanceOfViewport: instanceOfViewport,
    ViewportFromJSON: ViewportFromJSON,
    ViewportFromJSONTyped: ViewportFromJSONTyped,
    ViewportToJSON: ViewportToJSON
});

var RendererStatesEnum;
(function (RendererStatesEnum) {
    RendererStatesEnum["GRAPHOL"] = "graphol";
    RendererStatesEnum["GRAPHOL_LITE"] = "lite";
    RendererStatesEnum["FLOATY"] = "floaty";
    RendererStatesEnum["INCREMENTAL"] = "incremental";
})(RendererStatesEnum || (RendererStatesEnum = {}));

/**
 * # Ontology
 * Class used as the Model of the whole app.
 */
class Ontology extends AnnotatedElement {
    /**
     * @param {string} name
     * @param {string} version
     * @param {Namespace[]} namespaces
     * @param {Diagram[]} diagrams
     */
    constructor(name, version, iri, namespaces = [], diagrams = []) {
        super();
        this.namespaces = [];
        this.diagrams = [];
        this.languages = [];
        this._entities = new Map();
        // computed only in floaty
        this.hierarchiesBySubclassMap = new Map();
        this.hierarchiesBySuperclassMap = new Map();
        /** @type {string} */
        this.name = name;
        /** @type {string} */
        this.version = version;
        /** @type {Namespace[]} */
        this.namespaces = namespaces;
        /** @type {Diagram[]} */
        this.diagrams = diagrams;
        this.iri = iri;
    }
    /** @param {Namespace} namespace */
    addNamespace(namespace) {
        this.namespaces.push(namespace);
    }
    /**
     * Get the Namspace object given its IRI string
     * @param {string} iriValue the IRI assigned to the namespace
     * @returns {Namespace}
     */
    getNamespace(iriValue) {
        return this.namespaces.find(ns => ns.toString() === iriValue);
    }
    /**
     * Get the Namespace given one of its prefixes
     * @param {string} prefix
     * @returns {Namespace}
     */
    getNamespaceFromPrefix(prefix) {
        return this.namespaces.find(ns => ns.hasPrefix(prefix));
    }
    /** @param {Diagram} diagram */
    addDiagram(diagram) {
        this.diagrams.push(diagram);
    }
    /**
     * Get the diagram with the given id
     */
    getDiagram(diagramId) {
        if (diagramId < 0 || diagramId > this.diagrams.length)
            return;
        return this.diagrams.find(diagram => diagram.id === diagramId);
    }
    getDiagramByName(name) {
        return this.diagrams.find(d => d.name.toLowerCase() === (name === null || name === void 0 ? void 0 : name.toLowerCase()));
    }
    addEntity(entity) {
        this.entities.set(entity.iri.fullIri, entity);
    }
    getEntity(iri) {
        for (let entity of this.entities.values()) {
            if (entity.iri.equals(iri)) {
                return entity;
            }
        }
        console.warn(`Can't find any entity with iri = "${iri}"`);
    }
    getEntitiesByType(entityType) {
        return Array.from(this.entities).filter(([_, entity]) => entity.is(entityType)).map(([_, entity]) => entity);
    }
    getEntityFromOccurrence(entityOccurrence) {
        const diagram = this.getDiagram(entityOccurrence.diagramId);
        if (!diagram)
            return;
        if (entityOccurrence.iri) {
            const entity = this.getEntity(entityOccurrence.iri);
            if (entity)
                return entity;
        }
        console.warn(`Can't find occurrence ${entityOccurrence.toString()} in any diagram's representation`);
        return undefined;
    }
    getGrapholElement(elementId, diagramId, renderState = RendererStatesEnum.GRAPHOL) {
        var _a, _b, _c;
        if (diagramId || diagramId === 0)
            return (_b = (_a = this.getDiagram(diagramId)) === null || _a === void 0 ? void 0 : _a.representations.get(renderState)) === null || _b === void 0 ? void 0 : _b.grapholElements.get(elementId);
        for (let diagram of this.diagrams) {
            const elem = (_c = diagram.representations.get(renderState)) === null || _c === void 0 ? void 0 : _c.grapholElements.get(elementId);
            if (elem)
                return elem;
        }
    }
    getGrapholNode(nodeId, diagramId, renderState = RendererStatesEnum.GRAPHOL) {
        try {
            const node = this.getGrapholElement(nodeId, diagramId, renderState);
            return node;
        }
        catch (e) {
            console.error(e);
        }
    }
    getGrapholEdge(edgeId, diagramId, renderState = RendererStatesEnum.GRAPHOL) {
        try {
            const edge = this.getGrapholElement(edgeId, diagramId, renderState);
            return edge;
        }
        catch (e) {
            console.error(e);
        }
    }
    // /**
    //  * Get an element in the ontology by id, searching in every diagram
    //  * @param {string} elem_id - The `id` of the elem to retrieve
    //  * @returns {cytoscape.CollectionReturnValue} The cytoscape object representation.
    //  */
    // getElem(elem_id: string): cytoscape.CollectionReturnValue {
    //   for (let diagram of this.diagrams) {
    //     let node = diagram.cy.$id(elem_id)
    //     if (node.length > 0) return node
    //   }
    // }
    /**
     * Retrieve an entity by its IRI.
     * @param {string} iri - The IRI in full or prefixed form.
     * i.e. : `grapholscape:world` or `https://examples/grapholscape/world`
     * @returns {cytoscape.CollectionReturnValue} The cytoscape object representation.
     */
    // getEntity(iri: string): cytoscape.CollectionReturnValue {
    //   if (this.getEntityOccurrences(iri)) return this.getEntityOccurrences(iri)[0]
    // }
    /**
     * Retrieve all occurrences of an entity by its IRI.
     * @param {string} iri - The IRI in full or prefixed form.
     * i.e. : `grapholscape:world` or `https://examples/grapholscape/world`
     * @returns An array of EntityOccurrence objects
     */
    getEntityOccurrences(iri, diagramId, renderState) {
        var _a, _b;
        // return this.entities[iri] || this.entities[this.prefixedToFullIri(iri)]
        return diagramId || diagramId === 0
            ? (_a = this.getEntity(iri)) === null || _a === void 0 ? void 0 : _a.getOccurrencesByDiagramId(diagramId, renderState)
            : (_b = this.getEntity(iri)) === null || _b === void 0 ? void 0 : _b.occurrences;
    }
    // /**
    //  * Get an element in the ontology by its id and its diagram id
    //  * @param {string} elemID - The id of the element to retrieve
    //  * @param {number} diagramID - the id of the diagram containing the element
    //  * @returns {cytoscape.CollectionReturnValue} The element in cytoscape object representation
    //  */
    // getElemByDiagramAndId(elemID: string, diagramID: number): cytoscape.CollectionReturnValue {
    //   let diagram = this.getDiagram(diagramID)
    //   if (diagram) {
    //     return diagram.cy.$id(elemID)
    //   }
    // }
    /**
     * Get the entities in the ontology
     * @returns {Object.<string, cytoscape.CollectionReturnValue[]>} a map of IRIs, with an array of entity occurrences (object[iri].occurrences)
     */
    // getEntities(): { [s: string]: cytoscape.CollectionReturnValue[] } {
    //   let entities = {}
    //   this.diagrams.forEach(diagram => {
    //     diagram.cy.$('.predicate').forEach(entity => {
    //       let iri = entity.data('iri').fullIri
    //       if (!Object.keys(entities).includes(iri)) {
    //         entities[iri] = []
    //       }
    //       entities[iri].push(entity)
    //     })
    //   })
    //   //this._entities = entities
    //   return entities
    // }
    /**
     * Check if entity has the specified iri in full or prefixed form
     * @param {Entity} entity
     * @param {string} iri
     * @returns {boolean}
     */
    // checkEntityIri(entity: Entity, iri: string): boolean {
    //   /** @type {Iri} */
    //   let entityIri: Iri = entity.data('iri') || entity.data.iri
    //   return entityIri.fullIri === iri ||
    //     entityIri.prefixed === iri
    // }
    /**
     * Retrieve the full IRI given a prefixed IRI
     * @param {string} prefixedIri a prefixed IRI
     * @returns {string} full IRI
     */
    prefixedToFullIri(prefixedIri) {
        if (!prefixedIri || typeof (prefixedIri) !== 'string')
            return;
        for (let namespace of this.namespaces) {
            let prefix = namespace.prefixes.find(p => prefixedIri.includes(p + ':'));
            if (prefix)
                return prefixedIri.replace(prefix + ':', namespace.toString());
            else if (prefixedIri.startsWith(':') && namespace.prefixes.some(p => p === '')) {
                return prefixedIri.replace(':', namespace.toString());
            }
        }
    }
    computeDatatypesOnDataProperties() {
        let cyElement, representation, datatypeNode, datatype, occurrences;
        this.entities.forEach((dataPropertyEntity, _) => {
            if (dataPropertyEntity.is(TypesEnum.DATA_PROPERTY)) {
                occurrences = dataPropertyEntity.occurrences.get(RendererStatesEnum.GRAPHOL);
                if (!occurrences)
                    return;
                // retrieve datatype for dataproperties
                occurrences.forEach(occurrence => {
                    var _a;
                    representation = (_a = this.getDiagram(occurrence.diagramId)) === null || _a === void 0 ? void 0 : _a.representations.get(RendererStatesEnum.GRAPHOL);
                    cyElement = representation === null || representation === void 0 ? void 0 : representation.cy.$id(occurrence.id);
                    if (cyElement && cyElement.nonempty()) {
                        datatypeNode = cyElement
                            .neighborhood(`node[type = "${TypesEnum.RANGE_RESTRICTION}"]`)
                            .neighborhood(`node[type = "${TypesEnum.VALUE_DOMAIN}"]`);
                        if (datatypeNode.nonempty()) {
                            datatype = datatypeNode.first().data('displayedName');
                            dataPropertyEntity.datatype = datatype;
                            representation === null || representation === void 0 ? void 0 : representation.updateElement(occurrence.id);
                        }
                    }
                });
            }
        });
    }
    get isEntitiesEmpty() { return (!this._entities || Object.keys(this._entities).length === 0); }
    get entities() { return this._entities; }
    set entities(newEntities) {
        this._entities = newEntities;
    }
}

class GrapholElement {
    constructor(_id, _type) {
        this._id = _id;
        this._type = _type;
    }
    get id() { return this._id; }
    set id(value) {
        this._id = value;
    }
    get type() { return this._type; }
    set type(type) {
        this._type = type;
    }
    get displayedName() { return this._displayedName; }
    set displayedName(displayedName) {
        this._displayedName = displayedName;
    }
    get originalId() { return this._originalId; }
    set originalId(id) { this._originalId = id; }
    get iri() { return this._iri; }
    set iri(iri) { this._iri = iri; }
    get diagramId() { return this._diagramId; }
    set diagramId(newdiagramId) {
        this._diagramId = newdiagramId;
    }
    /**
     * Check if element is of a certain type
     * @param type
     */
    is(type) {
        return this.type === type;
    }
    /**
     *
     * @returns whether node is an entity
     */
    isEntity() {
        switch (this.type) {
            case TypesEnum.CLASS:
            case TypesEnum.DATA_PROPERTY:
            case TypesEnum.OBJECT_PROPERTY:
            case TypesEnum.INDIVIDUAL:
            case TypesEnum.CLASS_INSTANCE:
                return true;
        }
        return false;
    }
    getCytoscapeRepr(grapholEntity) {
        const result = {
            data: {
                id: this.id,
                type: this.type || undefined,
                displayedName: this.displayedName || undefined,
                originalId: this.originalId || undefined,
                iri: this.iri || (grapholEntity === null || grapholEntity === void 0 ? void 0 : grapholEntity.iri.fullIri),
                datatype: grapholEntity === null || grapholEntity === void 0 ? void 0 : grapholEntity.datatype,
            }
        };
        // Set functionality for data/object properties
        if ((grapholEntity === null || grapholEntity === void 0 ? void 0 : grapholEntity.is(TypesEnum.DATA_PROPERTY)) || (grapholEntity === null || grapholEntity === void 0 ? void 0 : grapholEntity.is(TypesEnum.OBJECT_PROPERTY))) {
            result.data[FunctionPropertiesEnum.FUNCTIONAL] = grapholEntity.hasFunctionProperty(FunctionPropertiesEnum.FUNCTIONAL);
            result.data[FunctionPropertiesEnum.INVERSE_FUNCTIONAL] = grapholEntity.hasFunctionProperty(FunctionPropertiesEnum.INVERSE_FUNCTIONAL);
        }
        return [result];
    }
    clone() {
        const cloneObj = new GrapholElement(this.id, this.type);
        Object.assign(cloneObj, this);
        return cloneObj;
    }
    json() {
        const result = {
            id: this.id,
            type: this.type,
            originalId: this.originalId,
            diagramId: this.diagramId,
            displayedName: this.displayedName,
            iri: this.iri,
        };
        return result;
    }
    equals(grapholElement) {
        return this === grapholElement ||
            (this.id === grapholElement.id &&
                this.diagramId === grapholElement.diagramId);
    }
}

class GrapholEdge extends GrapholElement {
    static newFromSwagger(n) {
        const instance = new GrapholEdge(n.id, n.type);
        if (n.type === TypesEnum.COMPLETE_DISJOINT_UNION ||
            n.type === TypesEnum.COMPLETE_UNION) {
            instance.targetLabel = 'C';
        }
        Object.entries(n).forEach(([key, value]) => {
            if (n[key] && key !== 'id' && key !== 'type') {
                if (key === 'breakpoints') {
                    instance.addBreakPoint(value);
                }
                else {
                    instance[key] = value;
                }
            }
        });
        return instance;
    }
    constructor(id, type) {
        super(id, type);
        this._breakpoints = [];
        this.isHierarchy = () => {
            return this.is(TypesEnum.UNION) ||
                this.is(TypesEnum.COMPLETE_UNION) ||
                this.is(TypesEnum.DISJOINT_UNION) ||
                this.is(TypesEnum.COMPLETE_DISJOINT_UNION);
        };
    }
    addBreakPoint(breakpoint) {
        if (!this._breakpoints)
            this._breakpoints = [];
        this._breakpoints.push(breakpoint);
    }
    computeBreakpointsDistancesWeights(sourcePosition, targetPosition) {
        this.breakpoints.forEach(breakpoint => {
            breakpoint.setSourceTarget(sourcePosition, targetPosition);
        });
    }
    get sourceEndpoint() {
        return this._sourceEndpoint;
    }
    set sourceEndpoint(endpoint) {
        if (!endpoint || endpoint.x !== 0 || endpoint.y !== 0)
            this._sourceEndpoint = endpoint;
    }
    get targetEndpoint() {
        return this._targetEndpoint;
    }
    set targetEndpoint(endpoint) {
        if (!endpoint || endpoint.x !== 0 || endpoint.y !== 0)
            this._targetEndpoint = endpoint;
    }
    /**
     * Returns an array of mid-edge breakpoints (without source/target endpoints)
     */
    get breakpoints() {
        return this._breakpoints.slice(1, -1);
    }
    /**
     * Returns an array of all the breakpoints (including source/target endpoints)
     */
    get controlpoints() {
        return this._breakpoints;
    }
    set controlpoints(newControlPoints) {
        this._breakpoints = newControlPoints;
    }
    get sourceId() {
        return this._sourceId;
    }
    set sourceId(sourceId) {
        this._sourceId = sourceId;
    }
    get targetId() {
        return this._targetId;
    }
    set targetId(targetId) {
        this._targetId = targetId;
    }
    get targetLabel() {
        return this._targetLabel;
    }
    set targetLabel(targetLabel) {
        this._targetLabel = targetLabel;
    }
    get sourceLabel() {
        return this._sourceLabel;
    }
    set sourceLabel(sourceLabel) {
        this._sourceLabel = sourceLabel;
    }
    get type() { return super.type; }
    set type(newType) {
        super.type = newType;
        if (this.is(TypesEnum.SAME) || this.is(TypesEnum.DIFFERENT))
            this.displayedName = this.type;
    }
    getCytoscapeRepr(grapholEntity) {
        let result = super.getCytoscapeRepr(grapholEntity);
        Object.assign(result[0].data, {
            type: this.type || undefined,
            source: this.sourceId,
            target: this.targetId,
            sourceLabel: this.sourceLabel || undefined,
            targetLabel: this.targetLabel || undefined,
            sourceEndpoint: this.sourceEndpoint ? [this.sourceEndpoint.x, this.sourceEndpoint.y] : undefined,
            targetEndpoint: this.targetEndpoint ? [this.targetEndpoint.x, this.targetEndpoint.y] : undefined,
            segmentDistances: this.breakpoints.length > 0 ? this.breakpoints.map(b => b.distance) : undefined,
            segmentWeights: this.breakpoints.length > 0 ? this.breakpoints.map(b => b.weight) : undefined,
        });
        result[0].classes = this.type.toString();
        return result;
    }
    clone() {
        const cloneObj = new GrapholEdge(this.id, this.type);
        Object.assign(cloneObj, this);
        return cloneObj;
    }
    json() {
        const result = super.json();
        result.sourceId = this.sourceId;
        result.targetId = this.targetId;
        result.breakpoints = this.breakpoints;
        return result;
    }
}
function isGrapholEdge(elem) {
    return elem.sourceId !== undefined;
}

const LABEL_HEIGHT = 23;
class GrapholNode extends GrapholElement {
    constructor() {
        super(...arguments);
        this._x = 0;
        this._y = 0;
        this._labelHeight = LABEL_HEIGHT;
        this._labelXcentered = true;
        this._labelYcentered = true;
        this.isHierarchy = () => {
            return this.is(TypesEnum.UNION) || this.is(TypesEnum.DISJOINT_UNION);
        };
    }
    static newFromSwagger(n) {
        const instance = new GrapholNode(n.id, n.type);
        Object.entries(n).forEach(([key, value]) => {
            var _a, _b;
            if (n[key] && key !== 'id' && key !== 'type') {
                if (key === 'labelPosition') {
                    instance.labelXpos = (_a = n.labelPosition) === null || _a === void 0 ? void 0 : _a.x;
                    instance.labelYpos = (_b = n.labelPosition) === null || _b === void 0 ? void 0 : _b.y;
                }
                else {
                    instance[key] = value;
                }
            }
        });
        return instance;
    }
    get position() { return { x: this.x, y: this.y }; }
    set position(pos) {
        this._x = pos.x;
        this._y = pos.y;
    }
    get x() { return this._x; }
    set x(valX) { this._x = valX; }
    get y() { return this._y; }
    set y(valY) { this._y = valY; }
    get shape() { return this._shape; }
    set shape(shape) {
        this._shape = shape;
    }
    get hierarchyID() { return this._hierarchyID; }
    set hierarchyID(hierarchyID) {
        this._hierarchyID = hierarchyID;
    }
    get hierarchyForcedComplete() { return this._hierarchyForcedComplete; }
    set hierarchyForcedComplete(complete) {
        this._hierarchyForcedComplete = complete;
    }
    get identity() { return this._identity; }
    set identity(identity) {
        this._identity = identity;
    }
    get width() { return this._width; }
    set width(width) {
        this._width = width >= 0 ? width : -width;
    }
    get height() { return this._height; }
    set height(height) {
        this._height = height >= 0 ? height : -height;
        if (this.type === TypesEnum.FACET) {
            this._height = 40;
        }
    }
    get fillColor() { return this._fillColor; }
    set fillColor(fillColor) {
        this._fillColor = fillColor;
    }
    get labelXpos() { return this._labelXpos; }
    set labelXpos(labelXpos) {
        this._labelXpos = labelXpos;
        if (labelXpos === 0) {
            this._labelXcentered = true;
        }
    }
    setLabelXposFromXML(labelXpos) {
        if (labelXpos === this.position.x) {
            this.labelXpos = 0;
        }
        else {
            this.labelXpos = labelXpos - this.position.x;
        }
    }
    get labelHeight() { return this._labelHeight; }
    set labelHeight(value) {
        this._labelHeight = value;
    }
    get labelYpos() { return this._labelYpos; }
    set labelYpos(labelYpos) {
        this._labelYpos = labelYpos;
        if (labelYpos === 0) {
            this._labelYcentered = true;
        }
    }
    setLabelYposFromXML(labelYpos) {
        if (labelYpos === this.position.y) {
            this.labelYpos = 0;
        }
        else {
            this.labelYpos = labelYpos - this.y;
        }
    }
    get isLabelXcentered() { return this._labelXcentered; }
    get isLabelYcentered() { return this._labelYcentered; }
    get fontSize() { return this._fontSize; }
    set fontSize(value) {
        this._fontSize = value;
    }
    get inputs() { return this._inputs; }
    set inputs(inputs) {
        this._inputs = inputs;
    }
    get shapePoints() { return this._shapePoints; }
    set shapePoints(shapePoints) {
        this._shapePoints = shapePoints;
    }
    get fakeNodes() { return this._fakeNodes; }
    addFakeNode(newFakeNode) {
        if (!this._fakeNodes)
            this._fakeNodes = [];
        this._fakeNodes.push(newFakeNode);
    }
    getCytoscapeRepr(grapholEntity) {
        const fakeNodesCytoscapeRepr = [];
        const thisCytoscapeRepr = super.getCytoscapeRepr(grapholEntity);
        thisCytoscapeRepr[0].position = this.position;
        Object.assign(thisCytoscapeRepr[0].data, {
            shape: this.shape || undefined,
            height: this.height || undefined,
            width: this.width || undefined,
            fillColor: this.fillColor || undefined,
            shapePoints: this.shapePoints || undefined,
            labelXpos: this.labelXpos || this.labelXpos == 0 ? this.labelXpos : undefined,
            labelYpos: this.labelYpos || this.labelYpos == 0 ? this.labelYpos : undefined,
            labelXcentered: this.isLabelXcentered,
            labelYcentered: this.isLabelYcentered,
            identity: this.identity,
            hierarchyID: this.hierarchyID,
            hierarchyForcedComplete: this.hierarchyForcedComplete
        });
        if (!this.type)
            console.log(this);
        thisCytoscapeRepr[0].classes = this.type.toString();
        if (this.fakeNodes) {
            this.fakeNodes.forEach(fakeNode => {
                const fakeCyNode = fakeNode.getCytoscapeRepr(grapholEntity);
                fakeNodesCytoscapeRepr.push(...fakeCyNode);
            });
        }
        return [...fakeNodesCytoscapeRepr, ...thisCytoscapeRepr];
    }
    clone() {
        const cloneObj = new GrapholNode(this.id, this.type);
        Object.assign(cloneObj, this);
        return cloneObj;
    }
    json() {
        const result = super.json();
        result.position = this.position;
        if (this.labelXpos !== undefined && this.labelYpos !== undefined) {
            result.labelPosition = {
                x: this.labelXpos,
                y: this.labelYpos,
            };
        }
        return result;
    }
}
function isGrapholNode(elem) {
    return elem.isLabelXcentered !== undefined;
}

class DiagramRepresentation {
    constructor(cyConfig = cytoscapeDefaultConfig) {
        this._grapholElements = new Map();
        this._hasEverBeenRendered = false;
        this.cy = cytoscape(cyConfig);
    }
    get cy() {
        return this._cy;
    }
    set cy(newCy) {
        this._cy = newCy;
    }
    get hasEverBeenRendered() {
        return this._hasEverBeenRendered;
    }
    set hasEverBeenRendered(value) {
        this._hasEverBeenRendered = value;
    }
    /**
     * Add a new element (node or edge) to the diagram
     * @param newElement the GrapholElement to add to the diagram
     */
    addElement(newElement, grapholEntity) {
        this.grapholElements.set(newElement.id, newElement);
        // Every elem can have a set of fake elements to build a custom shape
        const cyElems = newElement.getCytoscapeRepr(grapholEntity);
        return this.cy.add(cyElems);
    }
    removeElement(elementId) {
        this.grapholElements.delete(elementId);
        this.cy.$id(elementId).remove();
    }
    clear() {
        this.cy.elements().remove();
        this.grapholElements.clear();
    }
    updateElement(elementIdOrObj, updatePosition = true) {
        let grapholElement;
        if (typeof elementIdOrObj === 'string') {
            grapholElement = this.grapholElements.get(elementIdOrObj);
        }
        else {
            grapholElement = elementIdOrObj;
        }
        if (!grapholElement)
            return;
        const cyElement = this.cy.$id(grapholElement.id);
        if (cyElement.empty()) {
            return;
        }
        if (updatePosition && isGrapholNode(grapholElement) && grapholElement.position !== cyElement.position()) {
            cyElement.position(grapholElement.position);
        }
        if (isGrapholEdge(grapholElement)) {
            cyElement.move({
                source: grapholElement.sourceId,
                target: grapholElement.targetId
            });
        }
        const iri = cyElement.data().iri;
        cyElement.data(grapholElement.getCytoscapeRepr()[0].data);
        // iri should be always preserved
        cyElement.data().iri = iri;
    }
    containsEntity(iriOrGrapholEntity) {
        let iri;
        if (iriOrGrapholEntity.iri !== undefined) {
            iri = iriOrGrapholEntity.iri;
        }
        else {
            iri = iriOrGrapholEntity;
        }
        for (let [_, grapholElement] of this.grapholElements) {
            if (grapholElement.iri && iri.equals(grapholElement.iri)) {
                return true;
            }
        }
        return false;
    }
    filter(elementId, filterTag) {
        const element = this.cy.$id(elementId);
        if (element.hasClass('filtered'))
            return;
        const classesToAdd = ['filtered', filterTag];
        element.addClass(classesToAdd.join(' '));
        // Filter fake nodes!
        this.cy.nodes(`[parent_node_id = "${element.id()}"]`).addClass(classesToAdd.join(' '));
        // ARCHI IN USCITA
        //var selector = `[source = "${element.data('id')}"]`
        element.outgoers('edge').forEach(e => {
            let neighbour = e.target();
            // if inclusion[IN] + equivalence[IN] + all[OUT] == 0 => filter!!
            let number_edges_in_out = getNumberEdgesInOut(neighbour);
            if (!e.target().hasClass(classesToAdd[0]) && (number_edges_in_out <= 0 || e.data('type') === TypesEnum.INPUT)) {
                this.filter(e.target().id(), filterTag);
            }
        });
        // ARCHI IN ENTRATA
        element.incomers('edge').forEach(e => {
            let neighbour = e.source();
            // if Isa[IN] + equivalence[IN] + all[OUT] == 0 => filter!!
            let number_edges_in_out = getNumberEdgesInOut(neighbour);
            if (!e.source().hasClass(classesToAdd[0]) && number_edges_in_out === 0) {
                this.filter(e.source().id(), filterTag);
            }
        });
        function getNumberEdgesInOut(neighbour) {
            let count = neighbour.outgoers('edge').size() + neighbour.incomers(`edge[type != "${TypesEnum.INPUT}"]`).size();
            neighbour.outgoers('node').forEach(node => {
                if (node.hasClass(classesToAdd[0])) {
                    count--;
                }
            });
            neighbour.incomers(`edge[type != "${TypesEnum.INPUT}"]`).forEach(e => {
                if (e.source().hasClass(classesToAdd[0])) {
                    count--;
                }
            });
            return count;
        }
    }
    unfilter(elementId, filterTag) {
        const classToRemove = ['filtered', filterTag];
        const element = this.cy.$id(elementId);
        if (element.hasClass('filtered') && element.hasClass(filterTag)) {
            this.cy.$id(elementId).removeClass(classToRemove.join(' '));
            this.cy.$(`.${filterTag}`).removeClass(classToRemove.join(' '));
        }
    }
    getNewId(nodeOrEdge) {
        let newId = nodeOrEdge === 'node' ? 'n' : 'e';
        let count = this.cy.elements().length;
        if (count) {
            count = count + 1;
            while (!this.cy.$id(newId + count).empty()) {
                count = count + 1;
            }
            return newId + count;
        }
        return newId + 0;
    }
    get grapholElements() {
        return this._grapholElements;
    }
    set grapholElements(newElementMap) {
        this._grapholElements = newElementMap;
    }
    /**
     * Getter
     */
    get nodes() {
        return this.cy.nodes().jsons();
    }
    /**
     * Getter
     */
    get edges() {
        return this.cy.edges().jsons();
    }
    get nodesCounter() { return this.cy.nodes().length; }
    get edgesCounter() { return this.cy.edges().length; }
}

/**
 * @property {string} name - diagram's name
 * @property {string | number} id - diagram's identifier
 */
class Diagram {
    /**
     * @param {string} name
     * @param {number} id
     */
    constructor(name, id) {
        this.representations = new Map([[RendererStatesEnum.GRAPHOL, new DiagramRepresentation()]]);
        this.name = name;
        this.id = id;
        this.representations.set(RendererStatesEnum.GRAPHOL, new DiagramRepresentation());
    }
    /**
     * Add a new element (node or edge) to the diagram's representation
     * @param newElement the GrapholElement to add to the diagram
     */
    addElement(newElement, grapholEntity) {
        var _a;
        (_a = this.representations.get(RendererStatesEnum.GRAPHOL)) === null || _a === void 0 ? void 0 : _a.addElement(newElement, grapholEntity);
    }
    /**
     * Delete every element from a diagram
     * @param rendererState optional, if you pass a particular rendererState, only its representation will be cleared.
     * If you don't pass any rendererState, all representations will be cleared
     */
    clear(rendererState) {
        var _a;
        rendererState
            ? (_a = this.representations.get(rendererState)) === null || _a === void 0 ? void 0 : _a.clear()
            : this.representations.forEach(r => r.clear());
    }
    removeElement(elementId, rendererState) {
        var _a;
        (_a = this.representations.get(rendererState)) === null || _a === void 0 ? void 0 : _a.removeElement(elementId);
    }
    containsEntity(iriOrGrapholEntity, rendererState) {
        var _a;
        return (_a = this.representations.get(rendererState)) === null || _a === void 0 ? void 0 : _a.containsEntity(iriOrGrapholEntity);
    }
}

class IncrementalDiagram extends Diagram {
    constructor() {
        super('Incremental', IncrementalDiagram.ID);
        this.representations = new Map([[RendererStatesEnum.INCREMENTAL, new DiagramRepresentation(floatyOptions)]]);
    }
    addElement(newElement, grapholEntity) {
        var _a;
        (_a = this.representation) === null || _a === void 0 ? void 0 : _a.addElement(newElement, grapholEntity);
    }
    removeElement(elementId) {
        var _a;
        (_a = this.representation) === null || _a === void 0 ? void 0 : _a.removeElement(elementId);
    }
    containsEntity(iriOrGrapholEntity) {
        var _a;
        return (_a = this.representation) === null || _a === void 0 ? void 0 : _a.containsEntity(iriOrGrapholEntity);
    }
    get representation() {
        return this.representations.get(RendererStatesEnum.INCREMENTAL);
    }
}
IncrementalDiagram.ID = -1;

const UNDEFINED_LANGUAGE = '_';
class Annotation {
    constructor(property, lexicalForm, language, datatype) {
        this._property = property;
        this.lexicalForm = lexicalForm;
        this.language = language || UNDEFINED_LANGUAGE;
        this.datatype = datatype || '';
    }
    equals(annotation) {
        return this.datatype === annotation.datatype &&
            this.lexicalForm === annotation.lexicalForm &&
            this.language === annotation.language &&
            this._property.equals(annotation.property);
    }
    get property() {
        return this._property.fullIri;
    }
    get kind() {
        return this._property.remainder;
    }
}

/**
 * Shapes assigned to Graphol nodes. These are [Cytoscape.js shapes](https =//js.cytoscape.org/#style/node-body)
 * @enum {string}
 * @property {string} RECTANGLE rectangle
 * @property {string} DIAMOND diamond
 * @property {string} ELLIPSE ellipse
 * @property {string} HEXAGON hexagon
 * @property {string} ROUND_RECTANGLE roundrectangle
 * @property {string} OCTAGON octagon
 * @property {string} POLYGON polygon
 */
var Shape$1;
(function (Shape) {
    /** @type {"rectangle"} */
    Shape["RECTANGLE"] = "rectangle";
    /** @type {"diamond"} */
    Shape["DIAMOND"] = "diamond";
    /** @type {"ellipse"} */
    Shape["ELLIPSE"] = "ellipse";
    /** @type {"hexagon"} */
    Shape["HEXAGON"] = "hexagon";
    /** @type {"roundrectangle"} */
    Shape["ROUND_RECTANGLE"] = "roundrectangle";
    /** @type {"octagon"} */
    Shape["OCTAGON"] = "octagon";
    /** @type {"polygon"} */
    Shape["POLYGON"] = "polygon";
})(Shape$1 || (Shape$1 = {}));
const POLYGON_POINTS = '-0.9 -1 1 -1 0.9 1 -1 1';
const GrapholNodesEnum = {
    [TypesEnum.CLASS]: {
        TYPE: TypesEnum.CLASS,
        SHAPE: Shape$1.RECTANGLE,
        IDENTITY: TypesEnum.CLASS
    },
    [TypesEnum.DOMAIN_RESTRICTION]: {
        TYPE: TypesEnum.DOMAIN_RESTRICTION,
        SHAPE: Shape$1.RECTANGLE,
        IDENTITY: TypesEnum.CLASS,
    },
    [TypesEnum.RANGE_RESTRICTION]: {
        TYPE: TypesEnum.RANGE_RESTRICTION,
        SHAPE: Shape$1.RECTANGLE,
        IDENTITY: TypesEnum.NEUTRAL
    },
    [TypesEnum.OBJECT_PROPERTY]: {
        TYPE: TypesEnum.OBJECT_PROPERTY,
        SHAPE: Shape$1.DIAMOND,
        IDENTITY: TypesEnum.OBJECT_PROPERTY
    },
    [TypesEnum.DATA_PROPERTY]: {
        TYPE: TypesEnum.DATA_PROPERTY,
        SHAPE: Shape$1.ELLIPSE,
        IDENTITY: TypesEnum.DATA_PROPERTY
    },
    [TypesEnum.UNION]: {
        TYPE: TypesEnum.UNION,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.NEUTRAL,
        LABEL: 'or',
    },
    [TypesEnum.DISJOINT_UNION]: {
        TYPE: TypesEnum.DISJOINT_UNION,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.NEUTRAL
    },
    [TypesEnum.COMPLEMENT]: {
        TYPE: TypesEnum.COMPLEMENT,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.NEUTRAL,
        LABEL: 'not',
    },
    [TypesEnum.INTERSECTION]: {
        TYPE: TypesEnum.INTERSECTION,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.NEUTRAL,
        LABEL: 'and',
    },
    [TypesEnum.ENUMERATION]: {
        TYPE: TypesEnum.ENUMERATION,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.NEUTRAL,
        LABEL: 'oneOf',
    },
    [TypesEnum.HAS_KEY]: {
        TYPE: TypesEnum.HAS_KEY,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.NEUTRAL,
        LABEL: 'key'
    },
    [TypesEnum.ROLE_INVERSE]: {
        TYPE: TypesEnum.ROLE_INVERSE,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.OBJECT_PROPERTY,
        LABEL: 'inv',
    },
    [TypesEnum.ROLE_CHAIN]: {
        TYPE: TypesEnum.ROLE_CHAIN,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.OBJECT_PROPERTY,
        LABEL: 'chain',
    },
    [TypesEnum.DATATYPE_RESTRICTION]: {
        TYPE: TypesEnum.DATATYPE_RESTRICTION,
        SHAPE: Shape$1.HEXAGON,
        IDENTITY: TypesEnum.VALUE_DOMAIN,
        LABEL: 'data',
    },
    [TypesEnum.VALUE_DOMAIN]: {
        TYPE: TypesEnum.VALUE_DOMAIN,
        SHAPE: Shape$1.ROUND_RECTANGLE,
        IDENTITY: TypesEnum.VALUE_DOMAIN
    },
    [TypesEnum.PROPERTY_ASSERTION]: {
        TYPE: TypesEnum.PROPERTY_ASSERTION,
        SHAPE: Shape$1.RECTANGLE,
        IDENTITY: TypesEnum.NEUTRAL
    },
    [TypesEnum.LITERAL]: {
        TYPE: TypesEnum.LITERAL,
        SHAPE: Shape$1.OCTAGON,
        IDENTITY: TypesEnum.VALUE
    },
    [TypesEnum.INDIVIDUAL]: {
        TYPE: TypesEnum.INDIVIDUAL,
        SHAPE: Shape$1.OCTAGON,
        IDENTITY: TypesEnum.INDIVIDUAL
    },
    [TypesEnum.FACET]: {
        TYPE: TypesEnum.FACET,
        SHAPE: Shape$1.POLYGON,
        SHAPE_POINTS: POLYGON_POINTS,
        IDENTITY: TypesEnum.FACET
    },
    [TypesEnum.CLASS_INSTANCE]: {
        TYPE: TypesEnum.CLASS_INSTANCE,
        SHAPE: Shape$1.ELLIPSE,
        IDENTITY: TypesEnum.CLASS_INSTANCE,
    }
};

class GrapholscapeTheme {
    constructor(id, colours, name) {
        this.colours = {};
        this._id = id;
        this.name = name || '';
        if (colours) {
            this.colours = colours;
        }
    }
    get id() { return this._id; }
    get name() { return this._name || this.id; }
    set name(newName) { this._name = newName; }
    getColour(name) {
        return this.colours[name];
    }
    setColour(name, colourValue) {
        this.colours[name] = colourValue;
    }
}

var ColoursNames;
(function (ColoursNames) {
    // foreground
    /** Foreground color, used for main texts */
    ColoursNames["fg_default"] = "fg-default";
    /** Foreground muted, should be darker than default. Used for secondary text */
    ColoursNames["fg_muted"] = "fg-muted";
    /** Foreground muted, should be lighter and softer than default.
     * Used for placeholders, tips and text used for clarifying UI objects
     */
    ColoursNames["fg_subtle"] = "fg-subtle";
    /** Foreground text colour placed on a surface of a emphasy color such as accent, danger, success and so on */
    ColoursNames["fg_on_emphasis"] = "fg-on-emphasis";
    // background
    /** Main background surface colours used in UI widgets */
    ColoursNames["bg_default"] = "bg-default";
    /** Background color to create a higher or lower level with respect to bg_default color */
    ColoursNames["bg_inset"] = "bg-inset";
    // borders
    /** Borders main color */
    ColoursNames["border_default"] = "border-default";
    /** Softer than default, used for creating softer separations between UI objects */
    ColoursNames["border_subtle"] = "border-subtle";
    ColoursNames["shadow"] = "shadow";
    // neutral
    /** Used to emphasize secondary elements or texts. Like active elements */
    ColoursNames["neutral"] = "neutral";
    /** Emphasize secondary elements, should be darker than default */
    ColoursNames["neutral_muted"] = "neutral-muted";
    /** Emphasize secondary elements, used for active elements borders */
    ColoursNames["neutral_subtle"] = "neutral-subtle";
    // accent
    /** Primary color for selected/active elements in diagram or activable elemnts like toggles */
    ColoursNames["accent"] = "accent";
    /** Primary color in darker tone, used for decorations like surfaces or borders */
    ColoursNames["accent_muted"] = "accent-muted";
    /** Primary color in lighter tone, used for decorations like toggle's background color */
    ColoursNames["accent_subtle"] = "accent-subtle";
    // role colors
    /** Color for denoting a successful action */
    ColoursNames["success"] = "success";
    /** Denote successful action in darker tone, used for texts or borders */
    ColoursNames["success_muted"] = "success-muted";
    /** Denote successful action in lighter tone, used for backgrounds or surfaces */
    ColoursNames["success_subtle"] = "success-subtle";
    /** Color for denoting warnings */
    ColoursNames["attention"] = "attention";
    /** Color for denoting warnings in darker tone, used for texts or borders */
    ColoursNames["attention_muted"] = "attention-muted";
    /** Color for denoting warnings in lighter tone, used for backgrounds or surfaces */
    ColoursNames["attention_subtle"] = "attention-subtle";
    /** Color for denoting errors */
    ColoursNames["danger"] = "danger";
    /** Color for denoting errors in darker tone, used for texts or borders */
    ColoursNames["danger_muted"] = "danger-muted";
    /** Color for denoting errors in lighter tone, used for backgrounds or surfaces */
    ColoursNames["danger_subtle"] = "danger-subtle";
    // entities
    /** Color used for classes' nodes bodies */
    ColoursNames["class"] = "class";
    /** Color used for classes' nodes borders */
    ColoursNames["class_contrast"] = "class-contrast";
    /** Color used for object properties' nodes bodies */
    ColoursNames["object_property"] = "object-property";
    /** Color used for object properties' nodes borders */
    ColoursNames["object_property_contrast"] = "object-property-contrast";
    /** Color used for data properties' nodes bodies */
    ColoursNames["data_property"] = "data-property";
    /** Color used for data properties' nodes borders */
    ColoursNames["data_property_contrast"] = "data-property-contrast";
    /** Color used for individual's nodes bodies */
    ColoursNames["individual"] = "individual";
    /** Color used for individual's nodes borders */
    ColoursNames["individual_contrast"] = "individual-contrast";
    // graph colors
    /** Background color used in the diagram canvas */
    ColoursNames["bg_graph"] = "bg-graph";
    /** Body color for nodes that are white in plain Graphol */
    ColoursNames["bg_node_light"] = "bg-node-light";
    /** Body color for nodes that are black in plain Graphol */
    ColoursNames["bg_node_dark"] = "bg-node-dark";
    /** Body border color */
    ColoursNames["border_node"] = "border-node";
    /** Nodes/Edges label color */
    ColoursNames["label"] = "label";
    /** Opposite color of label */
    ColoursNames["label_contrast"] = "label-contrast";
    /** Edges lines color */
    ColoursNames["edge"] = "edge";
    // Instances Colors
    ColoursNames["class_instance"] = "class-instance";
    ColoursNames["class_instance_contrast"] = "class-instance-contrast";
})(ColoursNames || (ColoursNames = {}));

var DefaultThemesEnum;
(function (DefaultThemesEnum) {
    DefaultThemesEnum["GRAPHOLSCAPE"] = "grapholscape";
    DefaultThemesEnum["GRAPHOL"] = "graphol";
    DefaultThemesEnum["DARK"] = "dark";
})(DefaultThemesEnum || (DefaultThemesEnum = {}));
const gscapeColourMap = {
    // graph colours
    [ColoursNames.bg_graph]: '#fafafa',
    [ColoursNames.edge]: '#000',
    [ColoursNames.bg_node_light]: '#fcfcfc',
    [ColoursNames.bg_node_dark]: '#000',
    [ColoursNames.border_node]: '#000',
    [ColoursNames.label]: '#000',
    [ColoursNames.label_contrast]: '#fcfcfc',
    [ColoursNames.class]: '#F9F3A6',
    [ColoursNames.class_contrast]: '#B08D00',
    [ColoursNames.object_property]: '#AACDE1',
    [ColoursNames.object_property_contrast]: '#065A85',
    [ColoursNames.data_property]: '#C7DAAD',
    [ColoursNames.data_property_contrast]: '#4B7900',
    [ColoursNames.individual]: '#d3b3ef',
    [ColoursNames.individual_contrast]: '#9875b7',
    // UI colours
    [ColoursNames.fg_default]: '#24292f',
    [ColoursNames.fg_muted]: '#57606a',
    [ColoursNames.fg_subtle]: '#6e7781',
    [ColoursNames.fg_on_emphasis]: '#ffffff',
    [ColoursNames.bg_default]: '#f6f8fa',
    [ColoursNames.bg_inset]: '#eff2f5',
    [ColoursNames.border_default]: '#d0d7de',
    [ColoursNames.border_subtle]: 'rgba(27, 31, 36, 0.15)',
    [ColoursNames.shadow]: '#d0d7de',
    [ColoursNames.neutral]: '#e8ecef',
    [ColoursNames.neutral_muted]: '#dae0e7',
    [ColoursNames.neutral_subtle]: '#f3f5f7',
    [ColoursNames.accent]: '#0969da',
    [ColoursNames.accent_muted]: 'rgba(84, 174, 255, 0.4)',
    [ColoursNames.accent_subtle]: '#ddf4ff',
    // State Colours
    [ColoursNames.success]: '#1a7f37',
    [ColoursNames.success_muted]: 'rgba(74, 194, 107, 0.4)',
    [ColoursNames.success_subtle]: '#2da44e',
    [ColoursNames.attention]: '#9a6700',
    [ColoursNames.attention_muted]: 'rgba(212, 167, 44, 0.4)',
    [ColoursNames.attention_subtle]: '#fff8c5',
    [ColoursNames.danger]: '#cf222e',
    [ColoursNames.danger_muted]: 'rgba(255, 129, 130, 0.4)',
    [ColoursNames.danger_subtle]: '#FFEBE9',
    // Instance Colours
    [ColoursNames.class_instance]: '#d3b3ef',
    [ColoursNames.class_instance_contrast]: '#9875b7'
};
const classicColourMap = Object.assign(JSON.parse(JSON.stringify(gscapeColourMap)), {
    [ColoursNames.bg_graph]: '#fafafa',
    [ColoursNames.edge]: '#000',
    [ColoursNames.bg_node_light]: '#fcfcfc',
    [ColoursNames.bg_node_dark]: '#000',
    [ColoursNames.border_node]: '#000',
    [ColoursNames.label]: '#000',
    [ColoursNames.label_contrast]: '#fcfcfc',
    [ColoursNames.object_property]: '#fcfcfc',
    [ColoursNames.object_property_contrast]: '#000',
    [ColoursNames.data_property]: '#fcfcfc',
    [ColoursNames.data_property_contrast]: '#000',
    [ColoursNames.class]: '#fcfcfc',
    [ColoursNames.class_contrast]: '#000',
    [ColoursNames.individual]: '#fcfcfc',
    [ColoursNames.individual_contrast]: '#000',
    // Instance Colours
    [ColoursNames.class_instance]: '#fcfcfc',
    [ColoursNames.class_instance_contrast]: '#000'
});
const darkColourMap = {
    // graph colors
    [ColoursNames.bg_graph]: '#0d1117',
    [ColoursNames.edge]: '#a0a0a0',
    [ColoursNames.bg_node_light]: '#a0a0a0',
    [ColoursNames.bg_node_dark]: '#010101',
    [ColoursNames.border_node]: '#a0a0a0',
    [ColoursNames.label]: '#a0a0a0',
    [ColoursNames.label_contrast]: '#000',
    [ColoursNames.object_property]: '#043954',
    [ColoursNames.object_property_contrast]: '#7fb3d2',
    [ColoursNames.data_property_contrast]: '#C7DAAD',
    [ColoursNames.data_property]: '#4B7900',
    [ColoursNames.class_contrast]: '#b28f00',
    [ColoursNames.class]: '#423500',
    [ColoursNames.individual_contrast]: '#9875b7',
    [ColoursNames.individual]: '#422D53',
    // Instance Colours
    [ColoursNames.class_instance]: '#422D53',
    [ColoursNames.class_instance_contrast]: '#9875b7',
    // UI colours
    [ColoursNames.fg_default]: '#c9d1d9',
    [ColoursNames.fg_muted]: '#8b949e',
    [ColoursNames.fg_subtle]: '#6e7681',
    [ColoursNames.fg_on_emphasis]: '#ffffff',
    [ColoursNames.bg_default]: '#21262d',
    [ColoursNames.bg_inset]: '#010409',
    [ColoursNames.border_default]: '#8b949e',
    [ColoursNames.border_subtle]: 'rgba(240,246,252,0.1)',
    [ColoursNames.shadow]: '#010409',
    [ColoursNames.neutral]: '#313b48',
    [ColoursNames.neutral_muted]: '#343941',
    [ColoursNames.neutral_subtle]: '#0c1015',
    [ColoursNames.accent]: '#58a6ff',
    [ColoursNames.accent_muted]: 'rgba(56,139,253,0.4)',
    [ColoursNames.accent_subtle]: 'rgba(56,139,253,0.15)',
};
const DefaultThemes = {
    grapholscape: new GrapholscapeTheme(DefaultThemesEnum.GRAPHOLSCAPE, gscapeColourMap, 'Grapholscape'),
    graphol: new GrapholscapeTheme(DefaultThemesEnum.GRAPHOL, classicColourMap, 'Graphol'),
    dark: new GrapholscapeTheme(DefaultThemesEnum.DARK, darkColourMap, 'Dark'),
};

const CSS_PROPERTY_NAMESPACE = '--gscape-color';

/**
 * @typedef {object} Filter
 * @property {string} Filter.selector Cytoscape selector identifying the elements to filter out
 * [cytoscape selectors](https://js.cytoscape.org/#selectors)
 * @property {boolean} Filter.active whether the filter is currently active or not
 * @property {boolean} Filter.activable whether the filter is currently activable
 * @property {string} Filter.class the class to add to filtered elems to easily retrieve them later on
 * @property {string} Filter.key unique key to identify a filter
 */
class Filter {
    /**
     *
     * @param key Unique identifier
     * @param compareFn Function receiving a GrapholElement and returning true if the element should be filtered, false otherwise
     */
    constructor(key, compareFn) {
        this._compareFn = () => false;
        this.active = false;
        this._locked = false;
        this._key = key;
        this._compareFn = compareFn;
    }
    get key() {
        return this._key;
    }
    get filterTag() {
        return `filter-${this.key}`;
    }
    get locked() { return this._locked; }
    lock() {
        this._locked = true;
    }
    unlock() {
        this._locked = false;
    }
    shouldFilter(grapholElement) {
        return this._compareFn(grapholElement);
    }
}
const dataPropertyFilter = () => {
    return new Filter(RDFGraphConfigFiltersEnum.DATA_PROPERTY, (element) => element.is(TypesEnum.DATA_PROPERTY));
};
const valueDomainFilter = () => {
    return new Filter(RDFGraphConfigFiltersEnum.VALUE_DOMAIN, (element) => element.is(TypesEnum.VALUE_DOMAIN));
};
const individualsFilter = () => {
    return new Filter(RDFGraphConfigFiltersEnum.INDIVIDUAL, (element) => element.is(TypesEnum.INDIVIDUAL));
};
const universalQuantifierFilter = () => new Filter(RDFGraphConfigFiltersEnum.UNIVERSAL_QUANTIFIER, (element) => {
    return (element.is(TypesEnum.DOMAIN_RESTRICTION) || element.is(TypesEnum.RANGE_RESTRICTION)) &&
        element.displayedName === 'forall';
});
const complementFilter = () => new Filter(RDFGraphConfigFiltersEnum.COMPLEMENT, (element) => element.is(TypesEnum.COMPLEMENT));
const hasKeyFilter = () => new Filter(RDFGraphConfigFiltersEnum.HAS_KEY, (element) => element.is(TypesEnum.HAS_KEY));
const getDefaultFilters = () => {
    return {
        DATA_PROPERTY: dataPropertyFilter(),
        VALUE_DOMAIN: valueDomainFilter(),
        INDIVIDUAL: individualsFilter(),
        UNIVERSAL_QUANTIFIER: universalQuantifierFilter(),
        COMPLEMENT: complementFilter(),
        HAS_KEY: hasKeyFilter(),
    };
};

// export enum FunctionalityEnum {
//   functional = 'functional',
//   inverseFunctional = 'inverseFunctional',
//   transitive = 'transitive',
//   symmetric = 'symmetric',
//   asymmetric = 'asymmetric',
//   reflexive = 'reflexive',
//   irreflexive = 'irreflexive'
// }
class GrapholEntity extends AnnotatedElement {
    static newFromSwagger(iri, e) {
        const instance = new GrapholEntity(iri);
        Object.entries(e).forEach(([key, value]) => {
            if (e[key] && key !== 'fullIri') {
                instance[key] = value;
            }
        });
        return instance;
    }
    constructor(iri) {
        super();
        this._occurrences = new Map([[RendererStatesEnum.GRAPHOL, []]]);
        this._isDataPropertyFunctional = false;
        this._functionProperties = [];
        this.iri = iri;
    }
    addOccurrence(newGrapholElement, representationKind = RendererStatesEnum.GRAPHOL) {
        if (!this.occurrences.get(representationKind)) {
            this.occurrences.set(representationKind, []);
        }
        const occurrences = this.occurrences.get(representationKind);
        if (!(occurrences === null || occurrences === void 0 ? void 0 : occurrences.some(occ => occ.equals(newGrapholElement)))) {
            occurrences === null || occurrences === void 0 ? void 0 : occurrences.push(newGrapholElement);
        }
    }
    removeOccurrence(grapholElement, representationKind) {
        const occurrences = this.occurrences.get(representationKind);
        const occurrenceToRemoveIndex = occurrences === null || occurrences === void 0 ? void 0 : occurrences.findIndex(o => o === grapholElement);
        if (occurrenceToRemoveIndex !== undefined && occurrenceToRemoveIndex >= 0) {
            occurrences === null || occurrences === void 0 ? void 0 : occurrences.splice(occurrenceToRemoveIndex, 1);
        }
    }
    /**
     * Get all occurrences of the entity in a given diagram
     * @param diagramId the diagram in which the entity must occurr
     * @param representationKind the diagram representation identifier ({@link RendererStatesEnum})
     * if not set, all representations will be considered
     * @returns A map with the occurrences in the original Graphol representation and other
     * replicated occurrences in other diagram representations
     */
    getOccurrencesByDiagramId(diagramId, representationKind) {
        const result = new Map();
        if (representationKind) {
            const occurrences = this.occurrences.get(representationKind);
            if (occurrences) {
                result.set(representationKind, occurrences.filter(occ => occ.diagramId === diagramId));
            }
        }
        else {
            for (let [representationKind, occurrences] of this.occurrences) {
                result.set(representationKind, occurrences.filter(occ => occ.diagramId === diagramId));
            }
        }
        return result;
    }
    get types() {
        let types = new Set();
        for (let [_, elements] of this.occurrences) {
            elements.forEach(e => types.add(e.type));
        }
        return types;
    }
    /**
     * Check if entity is of a certain type
     * @param type
     */
    is(type) {
        for (let [_, elements] of this.occurrences) {
            if (elements.some(e => e.is(type))) {
                return true;
            }
        }
        return false;
    }
    get occurrences() {
        return this._occurrences;
    }
    set iri(val) {
        this._iri = val;
    }
    get iri() {
        return this._iri;
    }
    get fullIri() {
        return this.iri.fullIri;
    }
    get functionProperties() {
        return this._functionProperties;
    }
    set functionProperties(properties) {
        this._functionProperties = properties;
    }
    get isDataPropertyFunctional() {
        return this._isDataPropertyFunctional;
    }
    set isDataPropertyFunctional(value) {
        this._isDataPropertyFunctional = value;
    }
    get datatype() { return this._datatype; }
    set datatype(datatype) { this._datatype = datatype; }
    getOccurrenceByType(type, rendererState) {
        var _a;
        return (_a = this.occurrences.get(rendererState)) === null || _a === void 0 ? void 0 : _a.find(o => o.type === type);
    }
    getOccurrencesByType(type, rendererState) {
        var _a;
        return (_a = this.occurrences.get(rendererState)) === null || _a === void 0 ? void 0 : _a.filter(o => o.type === type);
    }
    hasFunctionProperty(property) {
        var _a;
        const resVal = ((_a = this._functionProperties) === null || _a === void 0 ? void 0 : _a.includes(property)) || false;
        if (property === FunctionPropertiesEnum.FUNCTIONAL) {
            return this.isDataPropertyFunctional || resVal;
        }
        return resVal;
    }
    hasOccurrenceInDiagram(diagramId, representationKind) {
        var _a;
        if (representationKind) {
            const result = (_a = this.occurrences.get(representationKind)) === null || _a === void 0 ? void 0 : _a.some(occ => occ.diagramId === diagramId);
            return result === true;
        }
        for (let occurrenceInRepresentation of this.occurrences.values()) {
            if (occurrenceInRepresentation.some(occ => occ.diagramId === diagramId)) {
                return true;
            }
        }
        return false;
    }
    getDisplayedName(nameType, currentLanguage) {
        var _a, _b;
        let newDisplayedName;
        switch (nameType) {
            case RDFGraphConfigEntityNameTypeEnum.LABEL:
                newDisplayedName =
                    ((_a = this.getLabels(currentLanguage)[0]) === null || _a === void 0 ? void 0 : _a.lexicalForm) ||
                        ((_b = this.getLabels()[0]) === null || _b === void 0 ? void 0 : _b.lexicalForm) ||
                        this.iri.remainder;
                break;
            case RDFGraphConfigEntityNameTypeEnum.PREFIXED_IRI:
                newDisplayedName = this.iri.prefixed;
                break;
            case RDFGraphConfigEntityNameTypeEnum.FULL_IRI:
                newDisplayedName = this.iri.fullIri;
                break;
        }
        if (this.is(TypesEnum.CLASS) || this.is(TypesEnum.INDIVIDUAL))
            return newDisplayedName.replace(/\r?\n|\r/g, '');
        else
            return newDisplayedName;
    }
    getEntityOriginalNodeId() {
        const grapholRepresentationOccurrences = this.occurrences.get(RendererStatesEnum.GRAPHOL);
        if (grapholRepresentationOccurrences) {
            return grapholRepresentationOccurrences[0].id; // used in UI to show the original nodeID in graphol
        }
    }
    getIdInDiagram(diagramId, type, rendererState) {
        var _a;
        let entityOccurrences = this.getOccurrencesByType(type, rendererState);
        if (!entityOccurrences || entityOccurrences.length === 0)
            entityOccurrences = this.getOccurrencesByType(type, RendererStatesEnum.GRAPHOL);
        if (!entityOccurrences)
            return;
        return (_a = entityOccurrences.find(o => o.diagramId === diagramId)) === null || _a === void 0 ? void 0 : _a.id;
    }
    json() {
        return {
            fullIri: this.fullIri,
            annotations: this.getAnnotations().map(ann => {
                return {
                    property: ann.property,
                    lexicalForm: ann.lexicalForm,
                    language: ann.language,
                    datatype: ann.datatype,
                };
            }),
            datatype: this.datatype,
            functionProperties: this.functionProperties,
            isDataPropertyFunctional: this.isDataPropertyFunctional,
        };
    }
}

/** @internal */
class ClassInstanceEntity extends GrapholEntity {
    constructor(iri, parentClassIris = []) {
        super(iri);
        this._parentClassIris = [];
        this._dataProperties = [];
        this._parentClassIris = parentClassIris;
    }
    /**
     * Set the instance to be instance of a particular Class.
     * If it is already instance of such a class, no changes will be made.
     * @param parentClassIri the IRI of the Class
     */
    addParentClass(parentClassIri) {
        var _a;
        if (!this.hasParentClassIri(parentClassIri)) {
            (_a = this._parentClassIris) === null || _a === void 0 ? void 0 : _a.push(parentClassIri);
        }
    }
    /**
     * Check if the instance is instance of a class with such an IRI
     * @param parentClassIri
     * @returns
     */
    hasParentClassIri(parentClassIri) {
        return this._parentClassIris.find(iri => iri.equals(parentClassIri));
    }
    get isRDFTypeUnknown() { return this._parentClassIris.length === 0; }
    get parentClassIris() { return Array.from(this._parentClassIris); }
    get dataProperties() {
        return this._dataProperties;
    }
    set dataProperties(newProperties) {
        this._dataProperties = newProperties;
    }
}

class BaseFilterManager {
    constructor() {
        this.lockedFilters = [];
    }
    filterActivation(filter) {
        if (filter.active) {
            console.warn(`Filter with key = "${filter.key} is already active`);
            return false;
        }
        if (filter.locked) {
            console.warn(`Filter has been locked and cannot be applied at the moment`);
            return false;
        }
        return true;
    }
    filterDeactivation(filter) {
        if (!filter.active) {
            return false;
        }
        if (filter.locked) {
            console.warn(`Filter has been locked and cannot be deactivated at the moment`);
            return false;
        }
        return true;
    }
    get filters() { return this._filters; }
    set filters(filters) {
        this._filters = filters;
        filters.forEach(filter => {
            if (this.lockedFilters.includes(filter.key))
                filter === null || filter === void 0 ? void 0 : filter.lock();
            else
                filter === null || filter === void 0 ? void 0 : filter.unlock();
        });
    }
}

class BaseRenderer {
    constructor(renderer) {
        this.layoutRunning = false;
        if (renderer)
            this.renderer = renderer;
    }
    centerOnElementById(elementId, zoom, select) {
        const cy = this.renderer.cy;
        if (!cy || (!zoom && zoom !== 0))
            return;
        const cyElement = cy.$id(elementId);
        zoom = zoom > cy.maxZoom() ? cy.maxZoom() : zoom;
        if (cyElement.empty()) {
            console.warn(`Element id (${elementId}) not found. Please check that this is the correct diagram`);
        }
        else {
            cy.animate({
                center: {
                    eles: cyElement
                },
                zoom: zoom,
                queue: false,
            });
            if (select && cy.$(':selected') !== cyElement) {
                this.renderer.unselect();
                cyElement.select();
            }
        }
    }
    set renderer(newRenderer) {
        this._renderer = newRenderer;
        this.filterManager.filters = newRenderer.filters;
    }
    get renderer() {
        return this._renderer;
    }
    filter(elementId, filter) {
        var _a;
        if (this.renderer.diagram)
            (_a = this.renderer.diagram.representations.get(this.id)) === null || _a === void 0 ? void 0 : _a.filter(elementId, filter.filterTag);
    }
    unfilter(elementId, filter) {
        var _a;
        if (this.renderer.diagram)
            (_a = this.renderer.diagram.representations.get(this.id)) === null || _a === void 0 ? void 0 : _a.unfilter(elementId, filter.filterTag);
    }
}

var LifecycleEvent;
(function (LifecycleEvent) {
    LifecycleEvent["DiagramChange"] = "diagramChange";
    LifecycleEvent["RendererChange"] = "rendererChange";
    LifecycleEvent["ThemeChange"] = "themeChange";
    LifecycleEvent["EntitySelection"] = "entitySelection";
    LifecycleEvent["NodeSelection"] = "nodeSelection";
    LifecycleEvent["EdgeSelection"] = "edgeSelection";
    LifecycleEvent["LanguageChange"] = "languageChange";
    LifecycleEvent["EntityNameTypeChange"] = "entityNameTypeChange";
    LifecycleEvent["Filter"] = "filter";
    LifecycleEvent["Unfilter"] = "unfilter";
    LifecycleEvent["FilterRequest"] = "filterRequest";
    LifecycleEvent["UnfilterRequest"] = "unfilterRequest";
    LifecycleEvent["BackgroundClick"] = "backgroundClick";
    LifecycleEvent["ContextClick"] = "contextClick";
    LifecycleEvent["DoubleTap"] = "doubleTap";
    LifecycleEvent["EntityWikiLinkClick"] = "entityWikiLinkClick";
    // Ontology Designer
    LifecycleEvent["EntityAddition"] = "entityAddition";
    LifecycleEvent["EntityRemoval"] = "entityRemoval";
    LifecycleEvent["DiagramAddition"] = "diagramAddition";
    LifecycleEvent["DiagramRemoval"] = "diagramRemoval";
    LifecycleEvent["AnnotationAddition"] = "annotationAddition";
    LifecycleEvent["AnnotationEdit"] = "annotationEdit";
    LifecycleEvent["AnnotationRemoval"] = "annotationRemoval";
})(LifecycleEvent || (LifecycleEvent = {}));
class Lifecycle {
    constructor() {
        this.diagramChange = [];
        this.rendererChange = [];
        this.themeChange = [];
        this.entitySelection = [];
        this.nodeSelection = [];
        this.edgeSelection = [];
        this.languageChange = [];
        this.entityNameTypeChange = [];
        this.filter = [];
        this.unfilter = [];
        this.filterRequest = () => true;
        this.unfilterRequest = () => true;
        this.backgroundClick = [];
        this.contextClick = [];
        this.doubleTap = [];
        this.entityWikiLinkClick = [];
        this.entityAddition = [];
        this.entityRemoval = [];
        this.diagramAddition = [];
        this.diagramRemoval = [];
        this.annotationAddition = [];
        this.annotationEdit = [];
        this.annotationRemoval = [];
        this.on = (event, callback) => {
            if (event === LifecycleEvent.FilterRequest || event === LifecycleEvent.UnfilterRequest) {
                this[event] = callback;
                return;
            }
            this[event].push(callback);
        };
    }
    trigger(event, ...params) {
        if (event === LifecycleEvent.FilterRequest || event === LifecycleEvent.UnfilterRequest) {
            return this[event](params[0]);
        }
        this[event].forEach((callback) => callback(...params));
    }
}

class Breakpoint {
    constructor(x, y) {
        this.intersectionPoint = { x: 0, y: 0 };
        this.breakpointRelativeToSource = { x: 0, y: 0 };
        this.x = x || 0;
        this.y = y || 0;
    }
    /**
     * Date le posizioni di source, target e del breakpoint,
     * la funzione calcola i due parametri peso e distanza del breakpoint
     * @param source posizione del nodo source
     * @param target posizione del nodo target
     */
    setSourceTarget(source, target) {
        // Coordinate del breakpoint traslando l'origine sul source:
        this.breakpointRelativeToSource.x = this.x - source.x;
        this.breakpointRelativeToSource.y = this.y - source.y;
        this.deltaX = target.x - source.x;
        this.deltaY = target.y - source.y;
        // Se deltaX è nullo : source e target sono sulla stessa ascissa
        // la retta che li congiunge è verticale e pertanto non esprimibile come y = mx + q
        // Sappiamo però automaticamente che la retta perpendicolare è del tipo y = c
        // quindi l'intersect point avrà X = 0 e Y = breakpoint['y']
        if (this.deltaX == 0) {
            this.intersectionPoint = { x: 0, y: this.breakpointRelativeToSource.y };
        }
        else if (this.deltaY == 0) {
            this.intersectionPoint = { x: this.breakpointRelativeToSource.x, y: 0 };
            this.angularCoefficient = 0;
        }
        else {
            this.angularCoefficient = this.deltaY / this.deltaX;
            // quindi prendendo il source come origine, la retta che unisce source e target è data da:
            // R: y = angularCoefficient * x
            // La retta che interseca perpendicolarmente R e che passa per point è data da :
            // T: y = - x / angularCoefficient + quote
            // dobbiamo calcolare quote imponendo che point faccia parte della retta T, quindi calcoliamo:
            // quote = breakpoint_y + (breakpoint_x/angularCoefficient)
            const quote = this.breakpointRelativeToSource.y + (this.breakpointRelativeToSource.x / this.angularCoefficient);
            // Adesso mettiamo a sistema le due rette T ed R (che sono perpendicolari) e risolvendo il sistema
            // otteniamo che il punto di intersezione tra le due ha le coordinate:
            // intersectpoint_x = (quote * angularCoefficient) / ((angularCoefficient ^ 2) + 1)
            // intersectpoint_y = intersectpoint_x * angularCoefficient
            this.intersectionPoint.x = (quote * this.angularCoefficient) / (Math.pow(this.angularCoefficient, 2) + 1);
            this.intersectionPoint.y = this.intersectionPoint.x * this.angularCoefficient;
        }
        // Distanza tra source e target
        this.distanceSourceTarget = getDisance(source, target);
        /**
         * Distanza tra intersection point e source
         * Le coordinate di intersect point sono espresse traslando l'origine su source, che quindi diventa l'origine (0,0)
         */
        this.distanceIntersectionSource = getDisance(this.intersectionPoint, { x: 0, y: 0 });
        this.setDistance();
        this.setWeight();
    }
    setWeight() {
        let point_weight = this.distanceIntersectionSource / this.distanceSourceTarget;
        // Dobbiamo stabilire se il peso è positivo o negativo
        // Se la X dell' intersectpoint è compresta tra quella del source e quella del target, allora il peso è positivo
        // se la X del target è maggiore della X del source e la X dell'intersectpoint è minore di quella del source, allora il peso è negativo
        if (this.deltaX > 0 && this.intersectionPoint.x < 0) {
            point_weight = -point_weight;
        }
        if (this.deltaX < 0 && this.intersectionPoint.x > 0) {
            point_weight = -point_weight;
        }
        this.weight = point_weight;
    }
    setDistance() {
        // Calcolo la distanza tra breakpoint e intersectpoint (sono entrambi espressi rispetto a source, ma per la distanza non ci interessa)
        let distanceBreakpointIntersectionPoint = getDisance(this.breakpointRelativeToSource, this.intersectionPoint);
        //var point_distance = Math.sqrt(Math.pow(intersectpoint['x'] - breakpoint['x'], 2) + Math.pow(intersectpoint['y'] - breakpoint['y'], 2))
        // Dobbiamo stabilire se prendere la point_distance positiva o negativa
        // La regola è che, andando dal source al target sulla retta che li
        // congiunge, se il breakpoint si trova alla mia sinistra, la distanza
        // è negativa, se invece è alla mia destra è positiva
        // questo si traduce nel valutare una diseguaglianza (Y ><= M*X ? dove Y e X sono le coordinate del breakpoint) e la scelta dipende dal quadrante in cui si trova il target.
        // [Stiamo considerando le coordinate relative al source]
        // [Quindi delta['x'] e delta['y'] sono proprio le coordinate del target]
        // RICORDA: in cytoscape il verso crescente dell'asse Y è verso il
        // basso, quindi occorre fare attenzione al verso delle diseguaglianze
        // Target con X negativa => il breakpoint si trova a sinitra della
        // retta quando si trova al di sotto della retta
        if (this.deltaX < 0 && this.breakpointRelativeToSource.y > this.angularCoefficient * this.breakpointRelativeToSource.x) {
            distanceBreakpointIntersectionPoint = -distanceBreakpointIntersectionPoint;
        }
        // Target con X positiva => il breakpoint si trova a sinistra dela
        // retta quando si trova al di sopra della retta
        if (this.deltaX > 0 && this.breakpointRelativeToSource.y < this.angularCoefficient * this.breakpointRelativeToSource.x) {
            distanceBreakpointIntersectionPoint = -distanceBreakpointIntersectionPoint;
        }
        // SOURCE CON STESSA X DEL TARGET
        // se il target ha una Y maggiore del source (deltaY>0),
        // allora sto guardando verso il basso, quindi il punto sarà a
        // sinistra quando la sua X sarà positiva
        if (this.deltaX == 0 && this.deltaY > 0 && this.breakpointRelativeToSource.x > 0) {
            distanceBreakpointIntersectionPoint = -distanceBreakpointIntersectionPoint;
        }
        // Se invece guardo verso l'alto (target con Y<0), allora il nodo è a
        // sinistra della retta quando ha la X negativa
        if (this.deltaX == 0 && this.deltaY < 0 && this.breakpointRelativeToSource.x < 0) {
            distanceBreakpointIntersectionPoint = -distanceBreakpointIntersectionPoint;
        }
        this.distance = distanceBreakpointIntersectionPoint;
    }
}
function getDisance(point1, point2) {
    const deltaX = point1.x - point2.x;
    const deltaY = point1.y - point2.y;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
}

class Hierarchy {
    /**
     *
     * @param id
     * @param type
     * @param forcedComplete if the hierarchy is forced to be complete, any superclass edge
     * will have type COMPLETE_UNION / COMPLETE_DISJOINT_UNION, regardless if they are created
     * as complete or not.
     */
    constructor(id, type, forcedComplete = false) {
        this.type = type;
        this.forcedComplete = forcedComplete;
        this._inputs = [];
        this._superclasses = [];
        this.id = id;
    }
    addInput(classEntity) {
        this.inputs.push(classEntity);
    }
    removeInput(classEntity) {
        const index = this.inputs.findIndex(i => i === classEntity);
        this.inputs.splice(index, 1);
    }
    addSuperclass(classEntity, complete = this.forcedComplete) {
        this._superclasses.push({ classEntity: classEntity, complete: complete });
    }
    removeSuperclass(classEntity) {
        const index = this.superclasses.findIndex(i => i.classEntity === classEntity);
        this.superclasses.splice(index, 1);
    }
    get inputs() { return this._inputs; }
    get superclasses() { return this._superclasses; }
    set id(newId) { this._id = newId; }
    get id() { return this._id; }
    getUnionGrapholNode(position) {
        if (!this.isValid()) {
            console.warn('[Grapholscape] Hierarchy not valid, cannot create the union graphol node - check id, inputs and superclasses');
            return;
        }
        const unionNode = new GrapholNode(this._id, TypesEnum.CLASS);
        unionNode.type = this.type;
        unionNode.identity = TypesEnum.CLASS;
        unionNode.shape = Shape$1.ELLIPSE;
        unionNode.hierarchyID = this._id;
        unionNode.hierarchyForcedComplete = this.forcedComplete;
        unionNode.displayedName = !this.isDisjoint() ? 'or' : undefined;
        unionNode.height = unionNode.width = 30;
        unionNode.position = position || { x: 0, y: 0 };
        unionNode.setLabelXposFromXML((position === null || position === void 0 ? void 0 : position.x) || 0);
        unionNode.setLabelYposFromXML((position === null || position === void 0 ? void 0 : position.y) || 0);
        return unionNode;
    }
    getInputGrapholEdges(diagramId, rendererState) {
        if (!this.isValid()) {
            console.warn('[Grapholscape] Hierarchy not valid, cannot create input edges - check id, inputs and superclasses');
            return;
        }
        const res = [];
        let sourceId;
        this.inputs.forEach((inputEntity, i) => {
            const newInputEdge = new GrapholEdge(`${this._id}-e-${i}`, TypesEnum.INPUT);
            sourceId = inputEntity.getIdInDiagram(diagramId, TypesEnum.CLASS, rendererState);
            if (!sourceId)
                return;
            newInputEdge.sourceId = sourceId;
            newInputEdge.targetId = this._id;
            res.push(newInputEdge);
        });
        return res;
    }
    getInclusionEdges(diagramId, rendererState) {
        if (!this.isValid()) {
            console.warn('[Grapholscape] Hierarchy not valid, cannot create inclusions edges - check id, inputs and superclasses');
            return;
        }
        const res = [];
        let targetId;
        this.type;
        this._superclasses.forEach((superclass, i) => {
            if (superclass.complete || this.forcedComplete) {
                if (this.isDisjoint()) {
                    TypesEnum.COMPLETE_DISJOINT_UNION;
                }
                else {
                    TypesEnum.COMPLETE_UNION;
                }
            }
            const newInclusionEdge = new GrapholEdge(`${this._id}-inclusion-${i}`, this.type);
            newInclusionEdge.sourceId = this._id;
            targetId = superclass.classEntity.getIdInDiagram(diagramId, TypesEnum.CLASS, rendererState);
            if (!targetId)
                return;
            newInclusionEdge.targetId = targetId;
            if (superclass.complete || this.forcedComplete) {
                newInclusionEdge.targetLabel = 'C';
            }
            res.push(newInclusionEdge);
        });
        return res;
    }
    isDisjoint() {
        return this.type === TypesEnum.DISJOINT_UNION;
    }
    isValid() {
        return this._id && this.inputs.length > 0 && this._superclasses.length > 0;
    }
}

class BaseGrapholTransformer {
    get newCy() { return this.result.cy; }
    // filter nodes if the criterion function returns true
    // criterion must be a function returning a boolean value for a given a node
    filterByCriterion(criterion) {
        this.newCy.$('*').forEach(node => {
            if (criterion(node)) {
                this.result.filter(node.id(), '');
            }
        });
    }
    deleteFilteredElements() {
        this.deleteElements(this.newCy.elements('.filtered'));
    }
    isRestriction(grapholElement) {
        if (!grapholElement)
            return false;
        return grapholElement.is(TypesEnum.DOMAIN_RESTRICTION) ||
            grapholElement.is(TypesEnum.RANGE_RESTRICTION);
    }
    getGrapholElement(id) {
        return this.result.grapholElements.get(id);
    }
    deleteElements(elements) {
        elements.forEach(elem => {
            this.deleteElement(elem);
        });
    }
    deleteElement(elem) {
        this.newCy.remove(elem);
        this.result.grapholElements.delete(elem.id());
    }
}

class LiteTransformer extends BaseGrapholTransformer {
    constructor() {
        super(...arguments);
        this.isQualifiedRestriction = (node) => {
            const grapholElement = this.getGrapholElement(node.id());
            if (this.isRestriction(grapholElement)) {
                return node.incomers(`edge[type = "${TypesEnum.INPUT}"]`).size() > 1 ? true : false;
            }
            return false;
        };
        this.isCardinalityRestriction = (node) => {
            const grapholElement = this.getGrapholElement(node.id());
            if (this.isRestriction(grapholElement) && grapholElement.displayedName && grapholElement.displayedName.search(/[0-9]/g) >= 0) {
                return true;
            }
            return false;
        };
        this.inputEdgesBetweenRestrictions = (node) => {
            const grapholElement = this.getGrapholElement(node.id());
            let outcome = false;
            if (this.isRestriction(grapholElement)) {
                node.incomers(`edge[type = "${TypesEnum.INPUT}"]`).forEach(edge => {
                    const sourceGrapholElement = this.getGrapholElement(edge.source().id());
                    if (this.isRestriction(sourceGrapholElement)) {
                        outcome = true;
                    }
                });
            }
            return outcome;
        };
    }
    transform(diagram) {
        this.result = new DiagramRepresentation(liteOptions);
        const grapholRepresentation = diagram.representations.get(RendererStatesEnum.GRAPHOL);
        if (!grapholRepresentation) {
            return this.result;
        }
        this.result.grapholElements = new Map(grapholRepresentation.grapholElements);
        this.newCy.add(grapholRepresentation.cy.elements().clone());
        this.newCy.elements().removeClass('filtered'); // make all filtered elements not filtered anymore
        this.filterByCriterion((node) => {
            const grapholNode = this.getGrapholElement(node.id());
            if (!grapholNode)
                return false;
            switch (grapholNode.type) {
                case TypesEnum.COMPLEMENT:
                case TypesEnum.VALUE_DOMAIN:
                case TypesEnum.ROLE_CHAIN:
                case TypesEnum.ENUMERATION:
                case TypesEnum.HAS_KEY:
                    return true;
                case TypesEnum.DOMAIN_RESTRICTION:
                case TypesEnum.RANGE_RESTRICTION:
                    if (grapholNode.displayedName == 'forall')
                        return true;
                    else
                        return false;
                default:
                    return false;
            }
        });
        this.filterByCriterion(this.isQualifiedRestriction);
        this.filterByCriterion(this.isCardinalityRestriction);
        this.filterByCriterion(this.inputEdgesBetweenRestrictions);
        this.deleteFilteredElements();
        this.simplifyDomainAndRange();
        this.simplifyComplexHierarchies();
        this.simplifyUnions();
        this.simplifyIntersections();
        this.simplifyRoleInverse();
        return this.result;
    }
    simplifyDomainAndRange() {
        /**
         * Get all input incomers and pick the one coming from a object/data property
         * @param restriction
         * @returns the input from object/data property to the given restriction
         */
        const getInputEdgeFromPropertyToRestriction = (restriction) => {
            //let edgeResult: EdgeSingular
            // source is any obj/data property node connected to restriction by input edge
            const edgeResult = restriction.incomers('edge')
                .filter(edge => {
                const grapholEdge = this.getGrapholElement(edge.id());
                const grapholSource = this.getGrapholElement(edge.data().source);
                return grapholEdge.is(TypesEnum.INPUT) &&
                    (grapholSource.is(TypesEnum.OBJECT_PROPERTY) || grapholSource.is(TypesEnum.DATA_PROPERTY));
            });
            if (!edgeResult.empty()) {
                return this.getGrapholElement(edgeResult.id());
            }
        };
        /**
         * Given a domain/range restriction, we need each edge on the restriction of type != input
         * to be transformed into a ROLE EDGE going into the object/data property using the
         * input edge from property -> restriction (here we assume it is already been reversed).
         * @param edgeOnRestriction an edge connected to the restriction node, will be transformed into a role edge
         * @param edgeFromProperty the edge from property to restriction (reversed, so it's going from restriction to property)
         * @param restrictionNode the restriction node, must become a breakpoint
         */
        const transformIntoRoleEdge = (edgeOnRestriction, edgeFromProperty, restrictionNode) => {
            // let edges = []
            // let new_edge = null
            let edgeOnRestrictionSourceNode = this.getGrapholElement(edgeOnRestriction.sourceId);
            let edgeOnRestrictionTargetNode = this.getGrapholElement(edgeOnRestriction.targetId);
            const propertyNode = this.getGrapholElement(edgeFromProperty.targetId);
            /**
             * if the edge to restriction is between two existential, remove it and filter the other existential
             */
            if (this.isRestriction(edgeOnRestrictionSourceNode) && this.isRestriction(edgeOnRestrictionTargetNode)) {
                this.newCy.remove(`#${edgeOnRestriction.id}`);
                this.result.grapholElements.delete(edgeOnRestriction.id);
                return;
            }
            if (edgeOnRestriction.targetId !== restrictionNode.id) {
                this.reverseEdge(edgeOnRestriction);
                edgeOnRestrictionSourceNode = this.getGrapholElement(edgeOnRestriction.sourceId);
            }
            edgeOnRestriction.targetId = propertyNode.id;
            // move attribute on restriction node position
            if (propertyNode.is(TypesEnum.DATA_PROPERTY)) {
                edgeOnRestriction.type = TypesEnum.ATTRIBUTE_EDGE;
                propertyNode.x = restrictionNode.position.x;
                propertyNode.y = restrictionNode.position.y;
                this.result.updateElement(propertyNode);
                //new_edge = edges[0]
            }
            if (propertyNode.is(TypesEnum.OBJECT_PROPERTY)) {
                edgeOnRestriction.type = restrictionNode.type;
                // restriction node must become a new breakpoint
                edgeOnRestriction.addBreakPoint(new Breakpoint(restrictionNode.x, restrictionNode.y));
                // each breakpoint from restriction to property must become a breakpoint for the result edge
                edgeFromProperty.breakpoints.forEach(breakpoint => {
                    edgeOnRestriction.addBreakPoint(breakpoint);
                });
            }
            edgeOnRestriction.computeBreakpointsDistancesWeights(edgeOnRestrictionSourceNode.position, propertyNode.position);
            this.result.updateElement(edgeOnRestriction);
        };
        //let eles = cy.$('*')
        let grapholRestrictionNode;
        // select domain and range restrictions
        this.result.cy.nodes().forEach(restriction => {
            grapholRestrictionNode = this.getGrapholElement(restriction.id());
            if (!this.isRestriction(grapholRestrictionNode))
                return;
            const inputGrapholEdge = getInputEdgeFromPropertyToRestriction(restriction);
            if (!inputGrapholEdge)
                return;
            // Final role edge will be concatenated with this one, 
            // so we need to revert it to make it point to the obj/data property
            this.reverseEdge(inputGrapholEdge);
            // create a new role edge concatenating each edge different from inputs
            // to the input edge from object/data property to restriction node
            restriction.connectedEdges().filter(edge => !this.getGrapholElement(edge.id()).is(TypesEnum.INPUT))
                .forEach((edgeToRestriction, i) => {
                const grapholEdgeToRestriction = this.getGrapholElement(edgeToRestriction.id());
                if (!isGrapholEdge(grapholEdgeToRestriction) || !isGrapholNode(grapholRestrictionNode))
                    return;
                transformIntoRoleEdge(grapholEdgeToRestriction, inputGrapholEdge, grapholRestrictionNode);
            });
            this.result.filter(restriction.id(), '');
            this.deleteFilteredElements();
        });
        this.deleteFilteredElements();
    }
    reverseEdge(edge) {
        //let new_edge = edge.json()
        let sourceIdAux = edge.sourceId;
        edge.sourceId = edge.targetId;
        edge.targetId = sourceIdAux;
        let sourceEndpointAux = edge.sourceEndpoint;
        edge.sourceEndpoint = edge.targetEndpoint;
        edge.targetEndpoint = sourceEndpointAux;
        edge.controlpoints = edge.controlpoints.reverse();
        edge.breakpoints.forEach(breakpoint => {
            const source = this.newCy.$id(edge.sourceId);
            const target = this.newCy.$id(edge.targetId);
            // update distances and weights
            breakpoint.setSourceTarget(source.position(), target.position());
        });
        // new_edge.data.breakpoints = edge.data('breakpoints').reverse()
        // if (edge.data('segment_distances')) {
        //   new_edge.data.segment_distances = []
        //   new_edge.data.segment_weights = []
        //   new_edge.data.breakpoints.forEach( breakpoint => {
        //     let aux = getDistanceWeight(edge.source().position(), edge.target().position(), breakpoint)
        //     new_edge.data.segment_distances.push(aux[0])
        //     new_edge.data.segment_weights.push(aux[1])
        //   })
        // }
    }
    simplifyComplexHierarchies() {
        this.newCy.nodes().forEach(node => {
            if (this.isComplexHierarchy(node)) {
                this.replicateAttributes(node);
                this.result.filter(node.id(), '');
            }
        });
        this.deleteFilteredElements();
    }
    isComplexHierarchy(node) {
        const grapholNode = this.getGrapholElement(node.id());
        if (!grapholNode || (!grapholNode.is(TypesEnum.UNION) &&
            !grapholNode.is(TypesEnum.DISJOINT_UNION) &&
            !grapholNode.is(TypesEnum.INTERSECTION)))
            return false;
        // Complex hierarchy if it has something different from a class as input
        const inputNodesNotConcepts = node.incomers(`edge`)
            .filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INPUT))
            .sources()
            .filter(node => !this.getGrapholElement(node.id()).is(TypesEnum.CLASS));
        return !inputNodesNotConcepts.empty();
    }
    replicateAttributes(node) {
        /**
         * Given a hierarchy node, recursively retrieve all input classes nodes
         * @param node the hierearchy node
         * @returns a collection of classes nodes
         */
        const getAllInputClasses = (node) => {
            let allInputClasses = node.cy().collection();
            let inputEdges = node.incomers('edge').filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INPUT));
            allInputClasses = allInputClasses.union(inputEdges.sources().filter(node => this.getGrapholElement(node.id()).is(TypesEnum.CLASS)));
            inputEdges.sources().difference(allInputClasses).forEach(constructor => {
                allInputClasses = allInputClasses.union(getAllInputClasses(constructor));
            });
            return allInputClasses;
        };
        /**
         *
         * @param concept
         * @param attribute
         * @param i
         */
        const addAttribute = (concept, attribute, edgeType, i) => {
            const newAttribute = new GrapholNode(`duplicate-${attribute.id()}-${i}`, TypesEnum.DATA_PROPERTY);
            const newAttributeEdge = new GrapholEdge(`e-${concept.id()}-${attribute.id()}`, edgeType);
            newAttribute.originalId = attribute.id();
            newAttribute.x = concept.position().x;
            newAttribute.y = concept.position().y;
            Object.entries(attribute.data()).forEach(([key, value]) => {
                if (key !== 'id' && key !== 'originalId' && key !== 'type')
                    newAttribute[key] = value;
            });
            newAttributeEdge.sourceId = concept.id();
            newAttributeEdge.targetId = newAttribute.id;
            this.result.addElement(newAttribute);
            this.result.addElement(newAttributeEdge);
            this.newCy.$id(newAttribute.id).addClass('repositioned');
            // recursively add new attributes connected to replicated attributes by inclusions
            if (!attribute.hasClass('repositioned')) {
                attribute.neighborhood('node').filter(node => this.getGrapholElement(node.id()).is(TypesEnum.DATA_PROPERTY)).forEach((inclusion_attribute, j) => {
                    if (allAttributes.contains(inclusion_attribute)) {
                        return;
                    }
                    const edgeBetweenAttributes = attribute.edgesTo(inclusion_attribute)[0];
                    if (edgeBetweenAttributes) {
                        addAttribute(this.newCy.$id(newAttribute.id), inclusion_attribute, edgeBetweenAttributes.data().type, i);
                        inclusion_attribute.addClass('repositioned');
                        allInclusionAttributes = allInclusionAttributes.union(inclusion_attribute);
                    }
                });
            }
        };
        let allClasses = getAllInputClasses(node);
        let allAttributes = node.neighborhood(`node`).filter(node => this.getGrapholElement(node.id()).is(TypesEnum.DATA_PROPERTY));
        let allInclusionAttributes = this.newCy.collection();
        allAttributes.forEach((attribute) => {
            allClasses.forEach((concept, j) => {
                addAttribute(concept, attribute, TypesEnum.ATTRIBUTE_EDGE, j);
            });
            attribute.addClass('repositioned');
            allInclusionAttributes.addClass('repositioned');
        });
        this.deleteElements(allAttributes);
        this.deleteElements(allInclusionAttributes);
    }
    simplifyUnions() {
        this.newCy.nodes().forEach(union => {
            const grapholUnion = this.getGrapholElement(union.id());
            if (!grapholUnion || !isGrapholNode(grapholUnion) ||
                (!grapholUnion.is(TypesEnum.UNION) && !grapholUnion.is(TypesEnum.DISJOINT_UNION)))
                return;
            //grapholUnion.height = grapholUnion.width = 0.1
            //makeDummyPoint(union)
            //union.incomers('edge[type = "input"]').data('type', 'easy_input')
            // delete incoming inclusions
            union.incomers('edge').forEach(edge => {
                const grapholEdge = this.getGrapholElement(edge.id());
                if (grapholEdge.is(TypesEnum.INCLUSION)) {
                    this.deleteElement(edge);
                }
            });
            // process equivalence edges
            union.connectedEdges('edge').forEach(edge => {
                const grapholEdge = this.getGrapholElement(edge.id());
                // if it's equivalence add 'C' and reverse if needed
                if (grapholEdge.is(TypesEnum.EQUIVALENCE)) {
                    grapholEdge.targetLabel = 'C';
                    if (grapholUnion.type === TypesEnum.UNION) {
                        grapholEdge.type = TypesEnum.COMPLETE_UNION;
                    }
                    else if (grapholUnion.type === TypesEnum.DISJOINT_UNION) {
                        grapholEdge.type = TypesEnum.COMPLETE_DISJOINT_UNION;
                    }
                    // the edge must have as source the union node
                    if (grapholEdge.sourceId != grapholUnion.id) {
                        this.reverseEdge(grapholEdge);
                    }
                    this.result.updateElement(grapholEdge);
                    return;
                }
                else if (grapholEdge.sourceId === grapholUnion.id && grapholEdge.is(TypesEnum.INCLUSION)) {
                    // if it's outgoing and of type inclusion
                    grapholEdge.type = grapholUnion.type;
                    this.result.updateElement(grapholEdge);
                }
            });
            // process inclusion edges
            // union.outgoers('edge').forEach(inclusion => {
            //   inclusion.addClass('hierarchy')
            //   if (union.data('type') == TypesEnum.DISJOINT_UNION)
            //     inclusion.addClass('disjoint')
            // })
            // if (union.data('label'))
            //   union.data('label', '')
            //grapholUnion.displayedName = undefined
            this.replicateAttributes(union);
            // replicate role tipization on input classes
            this.replicateRoleTypizations(union);
            this.result.updateElement(grapholUnion);
            const numberEdgesNotInput = union.connectedEdges().filter(edge => !this.getGrapholElement(edge.id()).is(TypesEnum.INPUT)).size();
            if (numberEdgesNotInput <= 0) {
                this.deleteElement(union);
            }
            // if the union has not any connected non-input edges, then remove it
            // if (union.connectedEdges('[type !*= "input"]').size() == 0)
            //   cy.remove(union)
        });
    }
    simplifyIntersections() {
        this.newCy.nodes().forEach(and => {
            const grapholAndNode = this.getGrapholElement(and.id());
            if (!grapholAndNode || !grapholAndNode.is(TypesEnum.INTERSECTION))
                return;
            this.replicateAttributes(and);
            this.replicateRoleTypizations(and);
            // if there are no incoming inclusions or equivalence and no equivalences connected,
            // remove the intersection
            const incomingInclusions = and.incomers('edge').filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INCLUSION));
            const connectedEquivalences = and.connectedEdges().filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.EQUIVALENCE));
            const incomingUnionEdges = and.incomers('edge').filter(edge => {
                const grapholEdge = this.getGrapholElement(edge.id());
                return grapholEdge.is(TypesEnum.UNION) || grapholEdge.is(TypesEnum.DISJOINT_UNION);
            });
            const edgesToBeReplicated = incomingInclusions.union(connectedEquivalences).union(incomingUnionEdges);
            if (edgesToBeReplicated.empty()) {
                this.result.filter(grapholAndNode.id, '');
            }
            else {
                const incomingInputs = and.incomers('edge').filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INPUT));
                // process incoming inclusion && connected equivalences
                edgesToBeReplicated.forEach(edge => {
                    const edgeToBeReplicated = this.getGrapholElement(edge.id());
                    /**
                     * create a new ISA edge for each input class
                     * the new edge will be a concatenation:
                     *  - ISA towards the 'and' node + input edge
                     *
                     * the input edge must be reversed
                     * In case of equivalence edge, we only consider the
                     * isa towards the 'and' node and discard the other direction
                     */
                    incomingInputs.forEach((input, i) => {
                        /**
                         * if the edge is an equivalence, we must consider it as an
                         * incoming edge in any case and ignore the opposite direction.
                         * so if the edge is outgoing from the intersection, we reverse it
                         */
                        if (edgeToBeReplicated.is(TypesEnum.EQUIVALENCE) &&
                            edgeToBeReplicated.sourceId === grapholAndNode.id) {
                            this.reverseEdge(edgeToBeReplicated);
                        }
                        // Edge concatenation: isa/equilvance + reversed input
                        const grapholInputEdge = this.getGrapholElement(input.id());
                        this.reverseEdge(grapholInputEdge);
                        grapholInputEdge.sourceId = edgeToBeReplicated.sourceId;
                        grapholInputEdge.controlpoints.unshift(...edgeToBeReplicated.controlpoints);
                        const source = this.getGrapholElement(grapholInputEdge.sourceId);
                        const target = this.getGrapholElement(grapholInputEdge.targetId);
                        grapholInputEdge.computeBreakpointsDistancesWeights(source.position, target.position);
                        grapholInputEdge.targetLabel = edgeToBeReplicated.targetLabel;
                        grapholInputEdge.type = edgeToBeReplicated.type;
                        this.result.updateElement(grapholInputEdge);
                    });
                });
                this.result.filter(grapholAndNode.id, '');
            }
            this.deleteFilteredElements();
            this.deleteElements(edgesToBeReplicated);
        });
    }
    replicateRoleTypizations(constructorNode) {
        // replicate role tipization on input classes
        const restrictionEdges = constructorNode.connectedEdges().filter(edge => this.isRestriction(this.getGrapholElement(edge.id())));
        const inputEdges = constructorNode.incomers('edge').filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INPUT));
        restrictionEdges.forEach((restrictionEdge, i) => {
            const grapholRestrictionEdge = this.getGrapholElement(restrictionEdge.id());
            inputEdges.forEach((inputEdge) => {
                const grapholInputEdge = this.getGrapholElement(inputEdge.id());
                if (!grapholInputEdge)
                    return;
                const newRestrictionEdge = new GrapholEdge(`${grapholRestrictionEdge.id}-${grapholInputEdge.id}`, grapholRestrictionEdge.type);
                /**
                 * if the connected non input edge is only one (the one we are processing)
                 * then the new edge will be the concatenation of the input edge + role edge
                 */
                if (i === 0) {
                    newRestrictionEdge.controlpoints = grapholInputEdge.controlpoints.concat(grapholRestrictionEdge.controlpoints);
                }
                else {
                    newRestrictionEdge.controlpoints = [...grapholRestrictionEdge.controlpoints];
                }
                newRestrictionEdge.sourceId = grapholInputEdge.sourceId;
                newRestrictionEdge.sourceEndpoint = grapholInputEdge.sourceEndpoint
                    ? { x: grapholInputEdge.sourceEndpoint.x, y: grapholInputEdge.sourceEndpoint.y }
                    : undefined;
                newRestrictionEdge.targetEndpoint = grapholRestrictionEdge.targetEndpoint
                    ? { x: grapholRestrictionEdge.targetEndpoint.x, y: grapholRestrictionEdge.targetEndpoint.y }
                    : undefined;
                newRestrictionEdge.targetId = grapholRestrictionEdge.targetId;
                const sourceNode = this.getGrapholElement(newRestrictionEdge.sourceId);
                const targetNode = this.getGrapholElement(newRestrictionEdge.targetId);
                newRestrictionEdge.computeBreakpointsDistancesWeights(sourceNode.position, targetNode.position);
                this.result.addElement(newRestrictionEdge);
            });
            this.deleteElement(restrictionEdge);
        });
    }
    simplifyRoleInverse() {
        this.newCy.nodes().filter(node => { var _a; return (_a = this.getGrapholElement(node.id())) === null || _a === void 0 ? void 0 : _a.is(TypesEnum.ROLE_INVERSE); }).forEach(roleInverseNode => {
            // the input role is only one
            const inputEdge = roleInverseNode.incomers('edge').filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INPUT));
            const grapholInputEdge = this.getGrapholElement(inputEdge.id());
            // the input edge must always be reversed
            this.reverseEdge(grapholInputEdge);
            const grapholRoleInverseNode = this.getGrapholElement(roleInverseNode.id());
            // for each other edge connected, create a concatenated edge
            // the edge is directed towards the input_role
            roleInverseNode.connectedEdges().filter(edge => !this.getGrapholElement(edge.id()).is(TypesEnum.INPUT))
                .forEach((edge) => {
                const roleInverseEdge = this.getGrapholElement(edge.id());
                roleInverseEdge.type = TypesEnum.ROLE_INVERSE;
                if (roleInverseEdge.sourceId === grapholRoleInverseNode.id) {
                    this.reverseEdge(roleInverseEdge);
                }
                roleInverseEdge.controlpoints = roleInverseEdge.controlpoints.concat(grapholInputEdge.controlpoints);
                roleInverseEdge.targetId = grapholInputEdge.targetId;
                const source = this.getGrapholElement(roleInverseEdge.sourceId);
                const target = this.getGrapholElement(roleInverseEdge.targetId);
                roleInverseEdge.computeBreakpointsDistancesWeights(source.position, target.position);
                roleInverseEdge.displayedName = 'inverse Of';
                this.result.updateElement(roleInverseEdge);
            });
            this.deleteElement(inputEdge);
            this.deleteElement(roleInverseNode);
            // if (new_edges_count > 1) {
            //   cy.remove(inputEdge)
            //   makeDummyPoint(roleInverseNode)
            //   roleInverseNode.data('label', 'inverse Of')
            //   roleInverseNode.data('labelXpos', 0)
            //   roleInverseNode.data('labelYpos', 0)
            //   roleInverseNode.data('text_background', true)
            // } else {
            //   if (inputEdge.source())
            //     inputEdge.source().connectedEdges('edge.inverse-of').data('displayed_name','inverse Of')
            //   cy.remove(roleInverseNode)
            // }
        });
    }
}

class FloatyTransformer extends BaseGrapholTransformer {
    get newCy() { return this.result.cy; }
    transform(diagram) {
        this.result = new DiagramRepresentation(floatyOptions);
        let liteRepresentation = diagram.representations.get(RendererStatesEnum.GRAPHOL_LITE);
        if (!liteRepresentation || liteRepresentation.grapholElements.size === 0) {
            liteRepresentation = new LiteTransformer().transform(diagram);
            diagram.representations.set(RendererStatesEnum.GRAPHOL_LITE, liteRepresentation);
        }
        this.result.grapholElements = new Map(liteRepresentation.grapholElements);
        this.newCy.add(liteRepresentation.cy.elements().clone());
        this.newCy.elements().removeClass('filtered'); // make all filtered elements not filtered anymore
        // remember original positions
        // this.newCy.$('node').forEach( node => {
        //   node.data('original-position', JSON.stringify(node.position()))
        // })
        this.filterByCriterion(node => {
            return this.getGrapholElement(node.id()) === undefined;
        });
        this.makeEdgesStraight();
        this.simplifyRolesFloat();
        this.newCy.elements().unlock();
        return this.result;
    }
    makeEdgesStraight() {
        this.result.cy.$('edge').forEach(edge => {
            const grapholEdge = this.getGrapholElement(edge.id());
            grapholEdge.controlpoints = [];
            grapholEdge.targetEndpoint = undefined;
            grapholEdge.sourceEndpoint = undefined;
            this.result.updateElement(grapholEdge);
        });
    }
    simplifyRolesFloat() {
        let objectProperties = this.newCy.nodes().filter(node => {
            const grapholNode = this.getGrapholElement(node.id());
            return grapholNode && grapholNode.is(TypesEnum.OBJECT_PROPERTY);
        });
        objectProperties.forEach(objectProperty => {
            let domains = this.getDomainsOfObjectProperty(objectProperty);
            let ranges = this.getRangesOfObjectProperty(objectProperty);
            if (domains && ranges)
                this.connectDomainsRanges(domains, ranges, objectProperty);
        });
        //cy.remove(objectProperties)
        this.deleteElements(objectProperties);
    }
    connectDomainsRanges(domains, ranges, objectProperty) {
        let grapholDomainNode, grapholRangeNode, newId;
        domains.forEach((domain) => {
            grapholDomainNode = this.getGrapholElement(domain.id());
            ranges.forEach((range, i) => {
                grapholRangeNode = this.getGrapholElement(range.id());
                newId = `e-${objectProperty.id()}-${grapholDomainNode.id}-${grapholRangeNode.id}-${i}`;
                let newGrapholEdge = new GrapholEdge(newId, TypesEnum.OBJECT_PROPERTY);
                newGrapholEdge.sourceId = grapholDomainNode.id;
                newGrapholEdge.targetId = grapholRangeNode.id;
                Object.entries(objectProperty.data()).forEach(([key, value]) => {
                    switch (key) {
                        case 'id':
                        case 'labelXpos':
                        case 'labelYpos':
                        case 'labelXcentered':
                        case 'labelYcentered':
                        case 'shape':
                            break;
                        default:
                            newGrapholEdge[key] = value;
                    }
                });
                newGrapholEdge.originalId = objectProperty.id().toString();
                this.result.addElement(newGrapholEdge);
                const newAddedCyElement = this.newCy.$id(newGrapholEdge.id);
                newAddedCyElement.data().iri = objectProperty.data().iri;
            });
        });
    }
    getDomainsOfObjectProperty(objectProperty) {
        if (!objectProperty || objectProperty.empty())
            return null;
        let domains = objectProperty.incomers(`edge`).filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.DOMAIN_RESTRICTION)).sources();
        const fathers = this.getFathers(objectProperty);
        let fathersDomains = this.newCy.collection();
        fathers.forEach(father => {
            const newDomains = this.getDomainsOfObjectProperty(father);
            if (newDomains)
                fathersDomains = fathersDomains.union(newDomains);
        });
        return domains.union(fathersDomains);
    }
    getRangesOfObjectProperty(objectProperty) {
        if (!objectProperty || objectProperty.empty())
            return;
        let ranges = objectProperty.incomers(`edge`).filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.RANGE_RESTRICTION)).sources();
        const fathers = this.getFathers(objectProperty);
        let fatherRanges = this.newCy.collection();
        fathers.forEach(father => {
            const newRanges = this.getRangesOfObjectProperty(father);
            if (newRanges)
                fatherRanges = fatherRanges.union(newRanges);
        });
        return ranges.union(fatherRanges);
    }
    getFathers(node) {
        return node.outgoers('edge').filter(edge => this.getGrapholElement(edge.id()).is(TypesEnum.INCLUSION)).targets();
    }
}

function rdfgraphSerializer (grapholscape) {
    const ontology = grapholscape.ontology;
    const result = {
        diagrams: [],
        entities: Array.from(ontology.entities.values()).map(e => e.json()),
        modelType: RDFGraphModelTypeEnum.ONTOLOGY,
        metadata: {
            name: ontology.name,
            version: ontology.version,
            namespaces: ontology.namespaces.map(n => {
                return {
                    value: n.value,
                    prefixes: n.prefixes
                };
            }),
            iri: ontology.iri,
            defaultLanguage: ontology.defaultLanguage,
            languages: ontology.languages
        }
    };
    result.diagrams = ontology.diagrams.map(d => {
        let floaty = d.representations.get(RendererStatesEnum.FLOATY);
        if (!floaty) {
            const floatyTransformer = new FloatyTransformer();
            floaty = floatyTransformer.transform(d);
        }
        let resElem;
        return {
            id: d.id,
            name: d.name,
            lastViewportState: d.id === grapholscape.diagramId ? grapholscape.renderer.viewportState : d.lastViewportState,
            nodes: floaty.cy.nodes().map(n => {
                var _a;
                resElem = (_a = floaty.grapholElements.get(n.id())) === null || _a === void 0 ? void 0 : _a.json();
                if (resElem) {
                    resElem.position = n.position();
                }
                return resElem;
            }).filter(n => n !== undefined),
            edges: floaty.cy.edges().map(e => { var _a; return (_a = floaty.grapholElements.get(e.id())) === null || _a === void 0 ? void 0 : _a.json(); }).filter(e => e !== undefined)
        };
    });
    if (grapholscape.diagramId !== undefined) {
        result.selectedDiagramId = grapholscape.diagramId;
    }
    result.config = {
        themes: grapholscape.themeList.map(t => {
            return {
                id: t.id,
                name: t.name,
                colours: t.colours,
            };
        }),
        selectedTheme: grapholscape.theme.id,
        language: grapholscape.language,
        entityNameType: grapholscape.entityNameType,
        renderers: grapholscape.renderers,
        widgets: {},
    };
    const widgetCurrentStates = {};
    grapholscape.widgets.forEach((widget, key) => {
        switch (key) {
            case WidgetEnum$1.FILTERS:
                result.config.filters = Array.from(widget.filters.values()).map(f => {
                    if (f.active) {
                        return f.key;
                    }
                }).filter(f => f !== undefined);
            case WidgetEnum$1.ENTITY_DETAILS:
            case WidgetEnum$1.FILTERS:
            case WidgetEnum$1.ONTOLOGY_INFO:
            case WidgetEnum$1.DIAGRAM_SELECTOR:
            case WidgetEnum$1.ONTOLOGY_EXPLORER:
            case WidgetEnum$1.OWL_VISUALIZER:
                widgetCurrentStates[key] = widget.enabled !== false;
                break;
        }
    });
    result.config.widgets = widgetCurrentStates;
    return result;
}

/**
 * @internal
 */
class DisplayedNamesManager {
    constructor(grapholscape) {
        this._entityNameType = RDFGraphConfigEntityNameTypeEnum.LABEL;
        this._language = Language.EN;
        this._grapholscape = grapholscape;
    }
    get entityNameType() { return this._entityNameType; }
    get language() { return this._language; }
    setEntityNameType(newEntityNameType) {
        if (newEntityNameType === this._entityNameType)
            return;
        if (!Object.values(RDFGraphConfigEntityNameTypeEnum).includes(newEntityNameType)) {
            console.warn(`"${newEntityNameType}" is not a valid entity name type`);
            return;
        }
        this._entityNameType = newEntityNameType;
        for (let entity of this._grapholscape.ontology.entities.values()) {
            this.setDisplayedNames(entity);
        }
        this._grapholscape.lifecycle.trigger(LifecycleEvent.EntityNameTypeChange, newEntityNameType);
        storeConfigEntry('entityNameType', newEntityNameType);
    }
    setLanguage(language) {
        const languageValue = language;
        if (!this._grapholscape.ontology.languages.includes(language)) {
            console.warn(`Language ${language} is not supported by this ontology`);
            return;
        }
        if (languageValue === this._language) {
            return;
        }
        this._language = languageValue;
        if (this._entityNameType === RDFGraphConfigEntityNameTypeEnum.LABEL) {
            for (let entity of this._grapholscape.ontology.entities.values()) {
                this.setDisplayedNames(entity);
            }
        }
        this._grapholscape.lifecycle.trigger(LifecycleEvent.LanguageChange, languageValue);
        storeConfigEntry('language', language);
    }
    setDisplayedNames(entity) {
        entity.occurrences.forEach((entityOccurrencesInRenderState, renderState) => {
            entityOccurrencesInRenderState.forEach(entityOccurrence => {
                var _a, _b, _c, _d, _e, _f;
                let grapholElement;
                if (renderState === RendererStatesEnum.INCREMENTAL) {
                    // incremental diagram is not in the ontology, must take it from inremental controller
                    grapholElement = (_c = (_b = (_a = this._grapholscape.incremental) === null || _a === void 0 ? void 0 : _a.diagram) === null || _b === void 0 ? void 0 : _b.representation) === null || _c === void 0 ? void 0 : _c.grapholElements.get(entityOccurrence.id);
                }
                else {
                    grapholElement = this._grapholscape.ontology.getGrapholElement(entityOccurrence.id, entityOccurrence.diagramId, renderState);
                }
                if (!grapholElement)
                    return;
                let newDisplayedName = entity.getDisplayedName(this.entityNameType, this.language);
                if (newDisplayedName !== grapholElement.displayedName) {
                    grapholElement.displayedName = newDisplayedName;
                    const diagram = this._grapholscape.ontology.getDiagram(entityOccurrence.diagramId) || ((_d = this._grapholscape.incremental) === null || _d === void 0 ? void 0 : _d.diagram);
                    if (diagram) {
                        /**
                         * Entity Occurrences are not replicated, in entity.occurrences.get('lite') there will
                         * be only replicated/transformed entities. So the occurrences in graphol will be
                         * present also in other representations unless filtered.
                         * So for each occurrence in graphol, we search it in other representations and update them as well
                         */
                        if (renderState === RendererStatesEnum.GRAPHOL) {
                            diagram.representations.forEach(representation => {
                                if (grapholElement)
                                    representation.cy.$id(grapholElement.id).data('displayedName', grapholElement.displayedName);
                            });
                        }
                        else {
                            (_e = diagram.representations.get(renderState)) === null || _e === void 0 ? void 0 : _e.cy.$id(grapholElement.id).data('displayedName', grapholElement.displayedName);
                        }
                    }
                    else {
                        (_f = this._grapholscape.renderer.diagram) === null || _f === void 0 ? void 0 : _f.representations.forEach(representation => representation.updateElement(grapholElement.id));
                    }
                }
            });
        });
    }
}

/**
 * @internal
 */
class EntityNavigator {
    constructor(grapholscape) {
        this._grapholscape = grapholscape;
    }
    centerOnEntity(iri, diagramId, zoom) {
        this._centerSelectEntity(iri, diagramId, false, zoom);
    }
    selectEntity(iri, diagramId, zoom) {
        this._centerSelectEntity(iri, diagramId, true, zoom);
    }
    _centerSelectEntity(iri, diagramId, select = false, zoom) {
        if (diagramId || diagramId === 0) {
            const entityOccurrence = this.getEntityOccurrenceInDiagram(iri, diagramId);
            if (entityOccurrence) {
                this._performCenterSelect(entityOccurrence, select, zoom);
            }
        }
        else {
            for (let diagram of this._grapholscape.ontology.diagrams) {
                const entityOccurrence = this.getEntityOccurrenceInDiagram(iri, diagram.id);
                if (entityOccurrence) {
                    this._performCenterSelect(entityOccurrence, select, zoom);
                    break;
                }
            }
        }
    }
    _performCenterSelect(grapholElement, select, zoom) {
        if (this._grapholscape.diagramId !== grapholElement.diagramId) {
            this._grapholscape.showDiagram(grapholElement.diagramId);
        }
        this._grapholscape.renderer.centerOnElementById(grapholElement.id, zoom, select);
        if (select) {
            if (!grapholElement)
                return;
            if (isGrapholNode(grapholElement)) {
                this._grapholscape.lifecycle.trigger(LifecycleEvent.NodeSelection, grapholElement);
            }
            else if (isGrapholEdge(grapholElement)) {
                this._grapholscape.lifecycle.trigger(LifecycleEvent.EdgeSelection, grapholElement);
            }
        }
    }
    getEntityOccurrenceInDiagram(iri, diagramId) {
        const occurrencesMap = this._grapholscape.ontology.getEntityOccurrences(iri, diagramId);
        if (!occurrencesMap)
            return;
        const grapholOccurrences = occurrencesMap.get(RendererStatesEnum.GRAPHOL);
        // if no graphol occurrence, then cannot appear in any representation
        if (!grapholOccurrences || grapholOccurrences.length <= 0)
            return;
        const diagram = this._grapholscape.ontology.getDiagram(diagramId);
        if (!diagram || !this._grapholscape.renderState)
            return;
        const currentDiagramRepresentation = diagram.representations.get(this._grapholscape.renderState);
        // Search any original graphol occurrence in the current representation
        for (let grapholOccurrence of grapholOccurrences) {
            if ((currentDiagramRepresentation === null || currentDiagramRepresentation === void 0 ? void 0 : currentDiagramRepresentation.grapholElements.get(grapholOccurrence.id)) === grapholOccurrence) {
                return grapholOccurrence;
            }
        }
        // The original graphol occurrence may not be present in a new representation
        // Find first replicated occurrence
        const replicatedOccurrences = occurrencesMap.get(this._grapholscape.renderState);
        if (replicatedOccurrences && replicatedOccurrences.length > 0) {
            return replicatedOccurrences[0];
        }
    }
    updateEntitiesOccurrences() {
        if (this._grapholscape.renderState && this._grapholscape.renderState === RendererStatesEnum.GRAPHOL)
            return;
        this._grapholscape.ontology.diagrams.forEach(diagram => {
            var _a, _b;
            if (!this._grapholscape.renderState)
                return;
            const diagramRepresentation = diagram.representations.get(this._grapholscape.renderState);
            if (diagramRepresentation) {
                const replicatedElements = (_b = (_a = diagram.representations.get(this._grapholscape.renderState)) === null || _a === void 0 ? void 0 : _a.cy) === null || _b === void 0 ? void 0 : _b.$("[originalId]");
                if (replicatedElements && !replicatedElements.empty()) {
                    replicatedElements.forEach(replicatedElement => {
                        const grapholEntity = this._grapholscape.ontology.getEntity(replicatedElement.data('iri'));
                        if (grapholEntity) {
                            //grapholEntity.getOccurrencesByDiagramId(diagram.id, this._grapholscape.renderState)
                            // replicatedElement.data('iri', grapholEntity.iri.fullIri)
                            const grapholElement = diagramRepresentation.grapholElements.get(replicatedElement.id());
                            if (grapholElement) {
                                grapholEntity.addOccurrence(grapholElement, this._grapholscape.renderState);
                            }
                        }
                    });
                }
            }
        });
    }
}

class Renderer {
    constructor(renderState) {
        this.filters = new Map(Object.values(getDefaultFilters()).map(filter => [filter.key, filter]));
        this.FOCUS_ZOOM_LEVEL = 1.5;
        this.renderStateData = {};
        /**
         * Filter elements on the diagram.
         * It will be actually applied only if the user defined callback on the event
         * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
         * allows for the filter to be applied.
         * @param filter Can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
         * or a string representing the unique key of a defined filter
         */
        this.filter = (filter) => {
            var _a;
            let _filter = this.getFilter(filter);
            if (!_filter)
                return;
            if (this._lifecycle.trigger(LifecycleEvent.FilterRequest, _filter) && ((_a = this._renderState) === null || _a === void 0 ? void 0 : _a.filterManager.filterActivation(_filter))) {
                this.performFilter(_filter);
                this._lifecycle.trigger(LifecycleEvent.Filter, _filter);
            }
        };
        /**
         * Unfilter elements on the diagram.
         * It will be actually deactivated only if the user defined callback on the event
         * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
         * allows for the filter to be deactivated.
         * @param filter Can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
         * or a string representing the unique key of a defined filter
         */
        this.unfilter = (filter) => {
            var _a;
            const _filter = this.getFilter(filter);
            if (!_filter)
                return;
            if (this._lifecycle.trigger(LifecycleEvent.UnfilterRequest, _filter) && ((_a = this._renderState) === null || _a === void 0 ? void 0 : _a.filterManager.filterDeactivation(_filter))) {
                this.performFilter(_filter, false);
                this.applyActiveFilters();
                this._lifecycle.trigger(LifecycleEvent.Unfilter, _filter);
            }
        };
        if (renderState)
            this.renderState = renderState;
    }
    set lifecycle(lc) {
        this._lifecycle = lc;
    }
    set renderState(rs) {
        if (this.diagram) {
            /**
             * Stop rendering current diagram before
             * changing renderer state
             */
            this.stopRendering();
        }
        this._renderState = rs;
        if (rs) {
            rs.renderer = this;
            if (this.diagram) {
                rs.render();
                this.performAllFilters();
            }
        }
    }
    get renderState() { return this._renderState; }
    get theme() { return this._theme; }
    render(diagram) {
        var _a;
        if (!this.diagram || this.diagram.id !== diagram.id) {
            this.stopRendering();
            this.diagram = diagram;
            (_a = this._renderState) === null || _a === void 0 ? void 0 : _a.render();
            this.performAllFilters();
            this._lifecycle.trigger(LifecycleEvent.DiagramChange, diagram);
        }
    }
    mount() {
        var _a;
        this.applyTheme();
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.mount(this.container);
    }
    addElement(element) {
        var _a;
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.add(element);
    }
    performFilter(filter, activate = true) {
        if (this.grapholElements && this._renderState) {
            for (let grapholElement of this.grapholElements.values()) {
                if (filter.shouldFilter(grapholElement)) {
                    if (activate)
                        this._renderState.filter(grapholElement.id, filter);
                    else
                        this._renderState.unfilter(grapholElement.id, filter);
                }
            }
        }
        filter.active = activate;
    }
    getFilter(filter) {
        let _filter;
        if (typeof filter === 'string') {
            _filter = this.filters.get(filter);
        }
        else {
            _filter = filter;
        }
        if (!_filter || !this.filters.has(_filter.key)) {
            console.warn(`Can't find any filter "${filter}"`);
            return;
        }
        return _filter;
    }
    applyActiveFilters() {
        this.filters.forEach(filter => {
            if (filter.active) {
                this.performFilter(filter);
            }
        });
    }
    performAllFilters() {
        // first unfiler
        this.filters.forEach(filter => {
            if (!filter.active)
                this.performFilter(filter, filter.active);
        });
        this.filters.forEach(filter => {
            if (filter.active)
                this.performFilter(filter, filter.active);
        });
    }
    stopRendering() {
        var _a, _b;
        this.unselect();
        (_a = this._renderState) === null || _a === void 0 ? void 0 : _a.stopRendering();
        (_b = this.cy) === null || _b === void 0 ? void 0 : _b.unmount();
    }
    /**
     * Select a node or an edge in the current diagram given its unique id
     * @param {string} elementId elem id (node or edge)
     */
    selectElement(elementId) {
        var _a;
        this.unselect();
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.$id(elementId).select();
    }
    /**
     * Unselect every selected element in this diagram
     */
    unselect() {
        var _a;
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.elements(':selected').unselect();
    }
    /**
     * Fit viewport to diagram
     */
    fit() {
        var _a;
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.fit();
    }
    /**
     * Put a set of elements (nodes and/or edges) at the center of the viewport.
     * If just one element then the element will be at the center.
     * @param elementId the element's ID
     * @param zoom the zoom level to apply, if not passed, zoom level won't be changed
     */
    centerOnElementById(elementId, zoom, select) {
        var _a, _b;
        if (zoom === void 0) { zoom = (_a = this.cy) === null || _a === void 0 ? void 0 : _a.zoom(); }
        (_b = this.renderState) === null || _b === void 0 ? void 0 : _b.centerOnElementById(elementId, zoom, select);
    }
    centerOnElement(element, zoom, select) {
        this.centerOnElementById(element.id, zoom, select);
    }
    centerOnModelPosition(xPos, yPos, zoom) {
        if (!this.cy)
            return;
        let offsetX = this.cy.width() / 2;
        let offsetY = this.cy.height() / 2;
        xPos -= offsetX;
        yPos -= offsetY;
        this.cy.pan({
            x: -xPos,
            y: -yPos
        });
        this.cy.zoom({
            level: zoom || this.cy.zoom(),
            renderedPosition: { x: offsetX, y: offsetY }
        });
    }
    centerOnRenderedPosition(xPos, yPos, zoom) {
        var _a;
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.viewport({
            zoom: zoom || this.cy.zoom(),
            pan: { x: xPos, y: yPos }
        });
    }
    zoom(zoomValue) {
        var _a, _b;
        if (zoomValue != ((_a = this.cy) === null || _a === void 0 ? void 0 : _a.zoom()))
            (_b = this.cy) === null || _b === void 0 ? void 0 : _b.animate({
                zoom: zoomValue,
                queue: false
            });
    }
    zoomIn(zoomValue) {
        var _a;
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.animate({
            zoom: {
                level: this.cy.zoom() + zoomValue * this.cy.zoom(),
                renderedPosition: { x: this.cy.width() / 2, y: this.cy.height() / 2 }
            },
            queue: false,
        });
    }
    zoomOut(zoomValue) {
        var _a;
        (_a = this.cy) === null || _a === void 0 ? void 0 : _a.animate({
            zoom: {
                level: this.cy.zoom() - zoomValue * this.cy.zoom(),
                renderedPosition: { x: this.cy.width() / 2, y: this.cy.height() / 2 }
            },
            queue: false,
        });
    }
    setTheme(theme) {
        if (theme !== this._theme) {
            this._theme = theme;
            if (this.cy) {
                this.applyTheme();
            }
        }
    }
    applyTheme() {
        var _a;
        if (this._theme && this.renderState) {
            (_a = this.cy) === null || _a === void 0 ? void 0 : _a.style(this.renderState.getGraphStyle(this._theme));
            if (this.theme.colours["bg-graph"])
                this.container.style.backgroundColor = this.theme.colours["bg-graph"];
        }
    }
    // updateAll() {
    //   for (let grapholElement of this.grapholElements.values()) {
    //     this.updateElement(grapholElement.id)
    //   }
    // }
    updateElement(grapholElement) {
        if (!this.cy)
            return;
        const cyElement = this.cy.$id(grapholElement.id);
        if (isGrapholNode(grapholElement) && grapholElement.position !== cyElement.position()) {
            cyElement.position(grapholElement.position);
        }
        if (isGrapholEdge(grapholElement)) {
            cyElement.move({
                source: grapholElement.sourceId,
                target: grapholElement.targetId
            });
        }
        cyElement.data(grapholElement.getCytoscapeRepr()[0].data);
    }
    get isThemeApplied() {
        var _a;
        return (_a = this.cy) === null || _a === void 0 ? void 0 : _a.style();
    }
    get grapholElements() {
        var _a, _b;
        if (this.renderState)
            return (_b = (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.representations.get(this.renderState.id)) === null || _b === void 0 ? void 0 : _b.grapholElements;
    }
    get selectedElement() {
        var _a, _b;
        if (this.cy)
            return (_a = this.grapholElements) === null || _a === void 0 ? void 0 : _a.get((_b = this.cy.$(':selected')[0]) === null || _b === void 0 ? void 0 : _b.id());
    }
    get viewportState() {
        if (this.cy)
            return {
                zoom: this.cy.zoom(),
                pan: this.cy.pan(),
            };
    }
    set container(container) {
        this._container = document.createElement('div');
        this._container.classList.add('grapholscape-graph');
        this._container.style.width = '100%';
        this._container.style.height = '100%';
        this._container.style.position = 'relative';
        container.appendChild(this.container);
    }
    get container() { return this._container; }
    /**
     * Getter
     */
    get nodes() {
        var _a;
        return (_a = this.cy) === null || _a === void 0 ? void 0 : _a.nodes().jsons();
    }
    /**
     * Getter
     */
    get edges() {
        var _a;
        return (_a = this.cy) === null || _a === void 0 ? void 0 : _a.edges().jsons();
    }
}

class GrapholFilterManager extends BaseFilterManager {
    filterActivation(filter) {
        var _a;
        if (!super.filterActivation(filter))
            return false;
        if (filter.locked) {
            console.warn(`Filter has been locked and cannot be applied at the moment`);
            return false;
        }
        if (filter.key === RDFGraphConfigFiltersEnum.DATA_PROPERTY) {
            // VALUE DOMAIN filter cannot be changed if data-property filter has been activated
            (_a = this.filters.get(RDFGraphConfigFiltersEnum.VALUE_DOMAIN)) === null || _a === void 0 ? void 0 : _a.lock();
        }
        return true;
    }
    filterDeactivation(filter) {
        var _a;
        if (!super.filterDeactivation(filter))
            return false;
        if (filter.key === RDFGraphConfigFiltersEnum.DATA_PROPERTY) {
            // VALUE DOMAIN filter cannot be changed if data-property filter has been activated
            (_a = this.filters.get(RDFGraphConfigFiltersEnum.VALUE_DOMAIN)) === null || _a === void 0 ? void 0 : _a.unlock();
        }
        return true;
    }
    get filters() { return this._filters; }
    set filters(filters) {
        var _a, _b;
        this._filters = filters;
        filters.forEach(filter => {
            filter.unlock();
        });
        if ((_a = filters.get(RDFGraphConfigFiltersEnum.DATA_PROPERTY)) === null || _a === void 0 ? void 0 : _a.active) {
            (_b = filters.get(RDFGraphConfigFiltersEnum.VALUE_DOMAIN)) === null || _b === void 0 ? void 0 : _b.lock();
        }
    }
}

function grapholStyle (theme) {
    return [
        {
            selector: 'node',
            style: {
                'height': (node) => node.data('height') || 40,
                'width': (node) => node.data('width') || 40,
                'background-color': (node) => getColor(node, ColoursNames.bg_node_light),
                'shape': 'data(shape)',
                'border-width': 1,
                'border-color': theme.getColour(ColoursNames.border_node),
                'border-style': 'solid',
                'font-size': 12,
                'color': theme.getColour(ColoursNames.label),
            }
        },
        {
            selector: '[fontSize]',
            style: {
                'font-size': 'data(fontSize)',
            }
        },
        {
            selector: 'node[displayedName]',
            style: {
                'label': 'data(displayedName)',
                'text-margin-x': (n) => n.data('labelXpos') || 0,
                'text-margin-y': (n) => n.data('labelYpos') || 0,
                'text-wrap': 'wrap',
                'min-zoomed-font-size': '5px',
            }
        },
        {
            selector: `node[displayedName][type = "${TypesEnum.CLASS}"], node[displayedName][type = "${TypesEnum.INDIVIDUAL}"]`,
            style: {
                'text-max-width': (n) => n.data('width') || 40,
            }
        },
        {
            selector: 'node[labelXcentered]',
            style: {
                'text-halign': 'center',
            }
        },
        {
            selector: 'node[labelYcentered]',
            style: {
                'text-valign': 'center',
            }
        },
        {
            selector: 'edge',
            style: {
                'width': 2,
                'line-color': theme.getColour(ColoursNames.edge),
                'target-arrow-color': theme.getColour(ColoursNames.edge),
                'source-arrow-color': theme.getColour(ColoursNames.edge),
                'curve-style': 'bezier',
                'arrow-scale': 1.3,
                'color': theme.getColour(ColoursNames.label),
            }
        },
        {
            selector: `edge[type = "${TypesEnum.INCLUSION}"]`,
            style: {
                'line-style': 'solid',
                'target-arrow-shape': 'triangle',
                'target-arrow-fill': 'filled'
            }
        },
        {
            selector: `edge[type = "${TypesEnum.MEMBERSHIP}"]`,
            style: {
                'line-style': 'dashed',
                'line-dash-pattern': [2, 3],
                'target-arrow-shape': 'triangle',
                'target-arrow-fill': 'hollow'
            }
        },
        {
            selector: `edge[type = "${TypesEnum.INPUT}"]`,
            style: {
                'line-style': 'dashed',
                'target-arrow-shape': 'diamond',
                'target-arrow-fill': 'hollow'
            }
        },
        {
            selector: `edge[type = "${TypesEnum.EQUIVALENCE}"]`,
            style: {
                'line-style': 'solid',
                'source-arrow-shape': 'triangle',
                'source-arrow-fill': 'filled',
                'target-arrow-shape': 'triangle',
                'target-arrow-fill': 'filled',
            }
        },
        {
            selector: '[segmentDistances]',
            style: {
                'curve-style': 'segments',
                'segment-distances': 'data(segmentDistances)',
                'segment-weights': 'data(segmentWeights)',
                'edge-distances': 'node-position'
            }
        },
        {
            selector: '[sourceEndpoint]',
            style: {
                'source-endpoint': 'data(sourceEndpoint)'
            }
        },
        {
            selector: '[targetEndpoint]',
            style: {
                'target-endpoint': 'data(targetEndpoint)'
            }
        },
        {
            selector: '[?functional][!inverseFunctional]',
            style: {
                'border-width': 5,
                'border-color': theme.getColour(ColoursNames.border_node),
                'border-style': 'double'
            }
        },
        {
            selector: '[?inverseFunctional][!functional]',
            style: {
                'border-width': 4,
                'border-color': theme.getColour(ColoursNames.border_node),
                'border-style': 'solid'
            }
        },
        {
            selector: 'edge[displayedName]',
            style: {
                'label': 'data(displayedName)',
                'font-size': 10,
                'text-rotation': 'autorotate',
                'text-margin-y': -10,
            }
        },
        {
            selector: '[sourceLabel],[targetLabel]',
            style: {
                'font-size': 15,
                'target-text-offset': 20,
            }
        },
        {
            selector: '[targetLabel]',
            style: {
                'target-label': 'data(targetLabel)',
            }
        },
        {
            selector: '[sourceLabel]',
            style: {
                'source-label': 'data(sourceLabel)',
            }
        },
        {
            selector: 'edge[displayedName],[sourceLabel],[targetLabel],[text_background]',
            style: {
                'text-background-color': theme.getColour(ColoursNames.bg_graph),
                'text-background-opacity': 1,
                'text-background-shape': 'roundrectangle',
                'text-background-padding': 2,
            }
        },
        {
            selector: '[shapePoints]',
            style: {
                'shape-polygon-points': 'data(shapePoints)'
            }
        },
        {
            selector: '.filtered',
            style: {
                'display': 'none'
            }
        },
        {
            selector: `[type = "${TypesEnum.FACET}"][!fake], .fake-bottom-rhomboid`,
            style: {
                'background-opacity': 0
            }
        },
        {
            selector: `.fake-top-rhomboid`,
            style: {
                'background-color': node => getColor(node, ColoursNames.bg_inset),
            }
        },
        {
            selector: `[type = "${TypesEnum.PROPERTY_ASSERTION}"][!fake]`,
            style: {
                'background-opacity': 0,
                'border-width': 0,
            }
        },
        {
            selector: '.hidden',
            style: {
                'visibility': 'hidden'
            }
        },
        {
            selector: '.no_border',
            style: {
                'border-width': 0
            }
        },
        {
            selector: '.no_overlay',
            style: {
                'overlay-opacity': 0,
                'overlay-padding': 0
            }
        },
        {
            selector: `node[type = "${TypesEnum.CLASS}"]`,
            style: {
                'background-color': node => getColor(node, ColoursNames.class),
                'border-color': theme.getColour(ColoursNames.class_contrast),
            }
        },
        {
            selector: `node[type = "${TypesEnum.OBJECT_PROPERTY}"], .fake-triangle`,
            style: {
                'background-color': node => getColor(node, ColoursNames.object_property),
                'border-color': theme.getColour(ColoursNames.object_property_contrast),
            }
        },
        {
            selector: `node[type = "${TypesEnum.DATA_PROPERTY}"]`,
            style: {
                'background-color': node => getColor(node, ColoursNames.data_property),
                'border-color': theme.getColour(ColoursNames.data_property_contrast),
            }
        },
        {
            selector: `node[type = "${TypesEnum.DATA_PROPERTY}"]:selected`,
            style: {
                'text-background-color': theme.getColour(ColoursNames.bg_graph),
                'text-background-opacity': 1,
            }
        },
        {
            selector: `node[type = "${TypesEnum.INDIVIDUAL}"]`,
            style: {
                'background-color': node => getColor(node, ColoursNames.individual),
                'border-color': theme.getColour(ColoursNames.individual_contrast),
            }
        },
        {
            selector: `[type = "${TypesEnum.RANGE_RESTRICTION}"], [type = "${TypesEnum.DISJOINT_UNION}"]`,
            style: {
                'background-color': theme.getColour(ColoursNames.bg_node_dark),
            }
        },
        {
            selector: '.fake-triangle-right',
            style: {
                'background-color': theme.getColour(ColoursNames.object_property_contrast) || 'black',
            }
        },
        {
            selector: `[shape = "${Shape$1.HEXAGON}"],[type = "${TypesEnum.VALUE_DOMAIN}"]`,
            style: {
                'color': theme.getColour(ColoursNames.bg_node_dark),
            }
        },
        {
            selector: ':active',
            style: {
                'underlay-color': theme.getColour(ColoursNames.accent),
                'underlay-opacity': 0.2,
                'overlay-opacity': 0,
                'z-index': '100',
                'underlay-shape': (node) => node.style('shape') === Shape$1.ELLIPSE ? Shape$1.ELLIPSE : Shape$1.ROUND_RECTANGLE
            },
        },
        //-----------------------------------------------------------
        // selected selector always last
        {
            selector: ':selected, :active',
            style: {
                'overlay-color': theme.getColour(ColoursNames.accent),
                'overlay-opacity': 0.2,
                'z-index': '100',
                'overlay-shape': (node) => node.style('shape') === Shape$1.ELLIPSE ? Shape$1.ELLIPSE : Shape$1.ROUND_RECTANGLE
            }
        },
    ];
    function getColor(node, colour) {
        // take color from parsed XML source file
        if (theme.id === DefaultThemesEnum.GRAPHOL) {
            return node.data().fillColor;
        }
        else {
            return theme.getColour(colour) || node.data().fillColor;
        }
    }
}

class GrapholRendererState extends BaseRenderer {
    constructor() {
        super(...arguments);
        this.id = RendererStatesEnum.GRAPHOL;
        this.cyConfig = cytoscapeDefaultConfig;
        this.filterManager = new GrapholFilterManager();
    }
    render() {
        var _a;
        if (!this.renderer.diagram)
            return;
        const grapholRepresentation = this.renderer.diagram.representations.get(this.id);
        if (!grapholRepresentation)
            return;
        this.renderer.cy = grapholRepresentation.cy;
        this.renderer.mount();
        if (!grapholRepresentation.hasEverBeenRendered) {
            this.renderer.fit();
        }
        if (this.renderer.diagram.lastViewportState) {
            (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.viewport(this.renderer.diagram.lastViewportState);
        }
        grapholRepresentation.hasEverBeenRendered = true;
    }
    stopRendering() {
        if (this.renderer.viewportState && this.renderer.diagram) {
            this.renderer.diagram.lastViewportState = this.renderer.viewportState;
        }
    }
    runLayout() {
        throw new Error("Method not implemented.");
    }
    stopLayout() {
        throw new Error("Method not implemented.");
    }
    getGraphStyle(theme) {
        return grapholStyle(theme);
    }
    transformOntology(ontology) { }
}

class LiteFilterManager extends BaseFilterManager {
    constructor() {
        super(...arguments);
        this.lockedFilters = [
            RDFGraphConfigFiltersEnum.VALUE_DOMAIN,
            RDFGraphConfigFiltersEnum.UNIVERSAL_QUANTIFIER,
            RDFGraphConfigFiltersEnum.COMPLEMENT,
            RDFGraphConfigFiltersEnum.HAS_KEY,
        ];
    }
}

function liteStyle (theme) {
    const baseStyle = grapholStyle(theme);
    const liteStyle = [
        {
            selector: `edge[type = "${TypesEnum.INPUT}"]`,
            style: {
                'line-style': 'solid',
                'target-arrow-shape': 'none',
            }
        },
        {
            selector: `node[type = "${TypesEnum.UNION}"], node[type = "${TypesEnum.DISJOINT_UNION}"]`,
            style: {
                'label': '',
                'width': 0.1,
                'height': 0.1,
            }
        },
        {
            selector: `edge[type = "${TypesEnum.UNION}"], edge[type = "${TypesEnum.DISJOINT_UNION}"], edge[type = "${TypesEnum.COMPLETE_UNION}"], edge[type = "${TypesEnum.COMPLETE_DISJOINT_UNION}"]`,
            style: {
                'width': 6,
                'line-style': 'solid',
                'target-arrow-shape': 'triangle',
            }
        },
        {
            selector: `edge[type = "${TypesEnum.UNION}"]`,
            style: {
                'target-arrow-fill': 'hollow',
            }
        },
        {
            selector: `edge[type = "${TypesEnum.DISJOINT_UNION}"]`,
            style: {
                'target-arrow-fill': 'filled',
            }
        },
        {
            selector: `[type = "${TypesEnum.DOMAIN_RESTRICTION}"], [type = "${TypesEnum.RANGE_RESTRICTION}"]`,
            style: {
                'line-color': theme.getColour(ColoursNames.object_property_contrast),
                'source-arrow-color': theme.getColour(ColoursNames.object_property_contrast),
                'target-arrow-color': theme.getColour(ColoursNames.object_property_contrast),
                'target-arrow-shape': 'triangle',
                'target-arrow-fill': 'filled',
                'source-arrow-shape': 'square',
                'source-arrow-fill': 'hollow',
            }
        },
        {
            selector: `[type = "${TypesEnum.RANGE_RESTRICTION}"]`,
            style: {
                'target-arrow-shape': 'square',
                'target-arrow-fill': 'filled',
                'source-arrow-shape': 'none',
            }
        },
        {
            selector: `[type = "${TypesEnum.DOMAIN_RESTRICTION}"]`,
            style: {
                'target-arrow-shape': 'square',
                'target-arrow-fill': 'hollow',
                'source-arrow-shape': 'none',
            }
        },
        {
            selector: `edge[type = "${TypesEnum.DATA_PROPERTY}"]`,
            style: {
                'line-color': theme.getColour(ColoursNames.data_property_contrast),
                'source-arrow-shape': 'none',
                'target-arrow-shape': 'none',
            }
        },
        {
            selector: `edge[type = "${TypesEnum.ROLE_INVERSE}"]`,
            style: {
                'target-arrow-shape': 'triangle',
                'target-arrow-fill': 'filled',
                'text-rotation': 'autorotate',
            }
        },
    ];
    return baseStyle.concat(liteStyle);
}

class LiteRendererState extends BaseRenderer {
    constructor() {
        super(...arguments);
        this.id = RendererStatesEnum.GRAPHOL_LITE;
        this.filterManager = new LiteFilterManager();
        this.cyConfig = cytoscapeDefaultConfig;
    }
    runLayout() {
        var _a;
        if (!this.renderer.cy)
            return;
        (_a = this._layout) === null || _a === void 0 ? void 0 : _a.stop();
        this.renderer.cy.nodes().lock();
        this._layout = this.renderer.cy.$('.repositioned').closedNeighborhood().closedNeighborhood().layout({
            name: 'cola',
            centerGraph: false,
            refresh: 3,
            maxSimulationTime: 8000,
            convergenceThreshold: 0.0000001,
            fit: false,
        });
        this.renderer.cy.$('.repositioned').unlock();
        this._layout.run();
    }
    render() {
        var _a;
        if (!this.renderer.diagram)
            return;
        let liteRepresentation = this.renderer.diagram.representations.get(this.id);
        if (!liteRepresentation)
            return;
        this.renderer.cy = liteRepresentation.cy;
        this.renderer.mount();
        if (!liteRepresentation.hasEverBeenRendered) {
            this.renderer.fit();
            this.runLayout();
        }
        if (this.renderer.diagram.lastViewportState) {
            (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.viewport(this.renderer.diagram.lastViewportState);
        }
        liteRepresentation.hasEverBeenRendered = true;
    }
    stopRendering() {
        if (this.renderer.viewportState && this.renderer.diagram) {
            this.renderer.diagram.lastViewportState = this.renderer.viewportState;
        }
    }
    stopLayout() { }
    getGraphStyle(theme) {
        return liteStyle(theme);
    }
    transformOntology(ontology) {
        ontology.diagrams.forEach(diagram => {
            const liteTransformer = new LiteTransformer();
            diagram.representations.set(this.id, liteTransformer.transform(diagram));
        });
    }
    get layout() { return this._layout; }
    set layout(newLayout) { this._layout = newLayout; }
}

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1=window,e$2=t$1.ShadowRoot&&(void 0===t$1.ShadyCSS||t$1.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),n$3=new WeakMap;class o$3{constructor(t,e,n){if(this._$cssResult$=!0,n!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$2&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=n$3.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&n$3.set(s,t));}return t}toString(){return this.cssText}}const r$2=t=>new o$3("string"==typeof t?t:t+"",void 0,s$3),i$1=(t,...e)=>{const n=1===t.length?t[0]:e.reduce(((e,s,n)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[n+1]),t[0]);return new o$3(n,t,s$3)},S$1=(s,n)=>{e$2?s.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((e=>{const n=document.createElement("style"),o=t$1.litNonce;void 0!==o&&n.setAttribute("nonce",o),n.textContent=e.cssText,s.appendChild(n);}));},c$1=e$2?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$2(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$2;const e$1=window,r$1=e$1.trustedTypes,h$1=r$1?r$1.emptyScript:"",o$2=e$1.reactiveElementPolyfillSupport,n$2={toAttribute(t,i){switch(i){case Boolean:t=t?h$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},a$1=(t,i)=>i!==t&&(i==i||t==t),l$2={attribute:!0,type:String,converter:n$2,reflect:!1,hasChanged:a$1},d$1="finalized";class u$1 extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this.u();}static addInitializer(t){var i;this.finalize(),(null!==(i=this.h)&&void 0!==i?i:this.h=[]).push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Ep(s,i);void 0!==e&&(this._$Ev.set(e,s),t.push(e));})),t}static createProperty(t,i=l$2){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$2}static finalize(){if(this.hasOwnProperty(d$1))return !1;this[d$1]=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),void 0!==t.h&&(this.h=[...t.h]),this.elementProperties=new Map(t.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(c$1(i));}else void 0!==i&&s.push(c$1(i));return s}static _$Ep(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}u(){var t;this._$E_=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Eg(),this.requestUpdate(),null===(t=this.constructor.h)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$ES)&&void 0!==i?i:this._$ES=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$ES)||void 0===i||i.splice(this._$ES.indexOf(t)>>>0,1);}_$Eg(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Ei.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return S$1(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$EO(t,i,s=l$2){var e;const r=this.constructor._$Ep(t,s);if(void 0!==r&&!0===s.reflect){const h=(void 0!==(null===(e=s.converter)||void 0===e?void 0:e.toAttribute)?s.converter:n$2).toAttribute(i,s.type);this._$El=t,null==h?this.removeAttribute(r):this.setAttribute(r,h),this._$El=null;}}_$AK(t,i){var s;const e=this.constructor,r=e._$Ev.get(t);if(void 0!==r&&this._$El!==r){const t=e.getPropertyOptions(r),h="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==(null===(s=t.converter)||void 0===s?void 0:s.fromAttribute)?t.converter:n$2;this._$El=r,this[r]=h.fromAttribute(i,t.type),this._$El=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||a$1)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$El!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$E_=this._$Ej());}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach(((t,i)=>this[i]=t)),this._$Ei=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$Ek();}catch(t){throw i=!1,this._$Ek(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$ES)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$EO(i,this[i],t))),this._$EC=void 0),this._$Ek();}updated(t){}firstUpdated(t){}}u$1[d$1]=!0,u$1.elementProperties=new Map,u$1.elementStyles=[],u$1.shadowRootOptions={mode:"open"},null==o$2||o$2({ReactiveElement:u$1}),(null!==(s$2=e$1.reactiveElementVersions)&&void 0!==s$2?s$2:e$1.reactiveElementVersions=[]).push("1.6.2");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t;const i=window,s$1=i.trustedTypes,e=s$1?s$1.createPolicy("lit-html",{createHTML:t=>t}):void 0,o$1="$lit$",n$1=`lit$${(Math.random()+"").slice(9)}$`,l$1="?"+n$1,h=`<${l$1}>`,r=document,d=()=>r.createComment(""),u=t=>null===t||"object"!=typeof t&&"function"!=typeof t,c=Array.isArray,v=t=>c(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]),a="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_=/-->/g,m=/>/g,p=RegExp(`>|${a}(?:([^\\s"'>=/]+)(${a}*=${a}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),g=/'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=w(1),b=w(2),T=Symbol.for("lit-noChange"),A=Symbol.for("lit-nothing"),E=new WeakMap,C=r.createTreeWalker(r,129,null,!1),P=(t,i)=>{const s=t.length-1,l=[];let r,d=2===i?"<svg>":"",u=f;for(let i=0;i<s;i++){const s=t[i];let e,c,v=-1,a=0;for(;a<s.length&&(u.lastIndex=a,c=u.exec(s),null!==c);)a=u.lastIndex,u===f?"!--"===c[1]?u=_:void 0!==c[1]?u=m:void 0!==c[2]?(y.test(c[2])&&(r=RegExp("</"+c[2],"g")),u=p):void 0!==c[3]&&(u=p):u===p?">"===c[0]?(u=null!=r?r:f,v=-1):void 0===c[1]?v=-2:(v=u.lastIndex-c[2].length,e=c[1],u=void 0===c[3]?p:'"'===c[3]?$:g):u===$||u===g?u=p:u===_||u===m?u=f:(u=p,r=void 0);const w=u===p&&t[i+1].startsWith("/>")?" ":"";d+=u===f?s+h:v>=0?(l.push(e),s.slice(0,v)+o$1+s.slice(v)+n$1+w):s+n$1+(-2===v?(l.push(void 0),i):w);}const c=d+(t[s]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==e?e.createHTML(c):c,l]};class V{constructor({strings:t,_$litType$:i},e){let h;this.parts=[];let r=0,u=0;const c=t.length-1,v=this.parts,[a,f]=P(t,i);if(this.el=V.createElement(a,e),C.currentNode=this.el.content,2===i){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(h=C.nextNode())&&v.length<c;){if(1===h.nodeType){if(h.hasAttributes()){const t=[];for(const i of h.getAttributeNames())if(i.endsWith(o$1)||i.startsWith(n$1)){const s=f[u++];if(t.push(i),void 0!==s){const t=h.getAttribute(s.toLowerCase()+o$1).split(n$1),i=/([.?@])?(.*)/.exec(s);v.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?k:"?"===i[1]?I:"@"===i[1]?L:R});}else v.push({type:6,index:r});}for(const i of t)h.removeAttribute(i);}if(y.test(h.tagName)){const t=h.textContent.split(n$1),i=t.length-1;if(i>0){h.textContent=s$1?s$1.emptyScript:"";for(let s=0;s<i;s++)h.append(t[s],d()),C.nextNode(),v.push({type:2,index:++r});h.append(t[i],d());}}}else if(8===h.nodeType)if(h.data===l$1)v.push({type:2,index:r});else {let t=-1;for(;-1!==(t=h.data.indexOf(n$1,t+1));)v.push({type:7,index:r}),t+=n$1.length-1;}r++;}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){var o,n,l,h;if(i===T)return i;let r=void 0!==e?null===(o=s._$Co)||void 0===o?void 0:o[e]:s._$Cl;const d=u(i)?void 0:i._$litDirective$;return (null==r?void 0:r.constructor)!==d&&(null===(n=null==r?void 0:r._$AO)||void 0===n||n.call(r,!1),void 0===d?r=void 0:(r=new d(t),r._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Co)&&void 0!==l?l:h._$Co=[])[e]=r:s._$Cl=r),void 0!==r&&(i=N(t,r._$AS(t,i.values),r,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:r).importNode(s,!0);C.currentNode=o;let n=C.nextNode(),l=0,h=0,d=e[0];for(;void 0!==d;){if(l===d.index){let i;2===d.type?i=new M(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new z(n,this,t)),this._$AV.push(i),d=e[++h];}l!==(null==d?void 0:d.index)&&(n=C.nextNode(),l++);}return C.currentNode=r,o}v(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class M{constructor(t,i,s,e){var o;this.type=2,this._$AH=A,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cp=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cp}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===(null==t?void 0:t.nodeType)&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),u(t)?t===A||null==t||""===t?(this._$AH!==A&&this._$AR(),this._$AH=A):t!==this._$AH&&t!==T&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):v(t)?this.T(t):this._(t);}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t));}_(t){this._$AH!==A&&u(this._$AH)?this._$AA.nextSibling.data=t:this.$(r.createTextNode(t)),this._$AH=t;}g(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=V.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.v(s);else {const t=new S(o,this),i=t.u(this.options);t.v(s),this.$(i),this._$AH=t;}}_$AC(t){let i=E.get(t.strings);return void 0===i&&E.set(t.strings,i=new V(t)),i}T(t){c(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new M(this.k(d()),this.k(d()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cp=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class R{constructor(t,i,s,e,o){this.type=1,this._$AH=A,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=A;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=N(this,t,i,0),n=!u(t)||t!==this._$AH&&t!==T,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=N(this,e[s+l],i,l),h===T&&(h=this._$AH[l]),n||(n=!u(h)||h!==this._$AH[l]),h===A?t=A:t!==A&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.j(t);}j(t){t===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class k extends R{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===A?void 0:t;}}const H=s$1?s$1.emptyScript:"";class I extends R{constructor(){super(...arguments),this.type=4;}j(t){t&&t!==A?this.element.setAttribute(this.name,H):this.element.removeAttribute(this.name);}}class L extends R{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=N(this,t,i,0))&&void 0!==s?s:A)===T)return;const e=this._$AH,o=t===A&&e!==A||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==A&&(e===A||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t);}}const j=i.litHtmlPolyfillSupport;null==j||j(V,M),(null!==(t=i.litHtmlVersions)&&void 0!==t?t:i.litHtmlVersions=[]).push("2.7.4");const B=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new M(i.insertBefore(d(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l,o;class s extends u$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=B(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!1);}render(){return T}}s.finalized=!0,s._$litElement$=!0,null===(l=globalThis.litElementHydrateSupport)||void 0===l||l.call(globalThis,{LitElement:s});const n=globalThis.litElementPolyfillSupport;null==n||n({LitElement:s});(null!==(o=globalThis.litElementVersions)&&void 0!==o?o:globalThis.litElementVersions=[]).push("3.3.2");

var classIcon = b `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="18"
   height="18"
   version="1.1"
   id="svg4"
   sodipodi:docname="class.svg"
   inkscape:version="0.92.4 (f8dce91, 2019-08-02)">
  <metadata
     id="metadata10">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs8" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="1853"
     inkscape:window-height="1025"
     id="namedview6"
     showgrid="false"
     inkscape:zoom="13.111111"
     inkscape:cx="0.11440678"
     inkscape:cy="9"
     inkscape:window-x="67"
     inkscape:window-y="27"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg4" />
  <rect
     x="3"
     y="6"
     width="12"
     height="7"
     rx="0"
     ry="0"
     id="rect2"
     style="fill:none;stroke: var(--gscape-color-class-contrast);stroke-width:3" />
</svg>
`;

var classInstanceIcon = b `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18">
<circle cx="9" cy="9" r="5" stroke="var(--gscape-color-class-instance-contrast)" stroke-width="3.5" fill="none"/>
</svg>
`;

var dataPropertyIcon = b `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18">
<circle cx="9" cy="9" r="5" stroke="var(--gscape-color-data-property-contrast)" stroke-width="3.5" fill="none"/>
</svg>
`;

var individualIcon = b `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:osb="http://www.openswatchbook.org/uri/2009/osb"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   inkscape:version="1.0 (6e3e5246a0, 2020-05-07)"
   sodipodi:docname="individual.svg"
   id="svg4"
   version="1.1"
   height="18"
   width="18">
  <metadata
     id="metadata10">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs8">
    <linearGradient
       osb:paint="solid"
       id="linearGradient880">
      <stop
         id="stop878"
         offset="0"
         style="stop-color:#000000;stop-opacity:1;" />
    </linearGradient>
  </defs>
  <sodipodi:namedview
     inkscape:document-rotation="0"
     fit-margin-bottom="0"
     fit-margin-right="0"
     fit-margin-left="0"
     fit-margin-top="0"
     inkscape:current-layer="svg4"
     inkscape:window-maximized="0"
     inkscape:window-y="27"
     inkscape:window-x="993"
     inkscape:cy="9.677215"
     inkscape:cx="9.0082925"
     inkscape:zoom="22.702061"
     showgrid="false"
     id="namedview6"
     inkscape:window-height="1025"
     inkscape:window-width="927"
     inkscape:pageshadow="2"
     inkscape:pageopacity="0"
     guidetolerance="10"
     gridtolerance="10"
     objecttolerance="10"
     borderopacity="1"
     bordercolor="#666666"
     pagecolor="#ffffff" />
  <g
     id="g27">
    <g
       id="g21">
      <g
         id="g16">
        <g
           id="g12" />
      </g>
    </g>
  </g>
  <path
     transform="matrix(0.9072154,0,0,0.92465409,0.92347539,1.0342853)"
     d="m 15.868025,11.669896 -4.068749,4.075966 -5.7591839,0.0051 -4.0759657,-4.06875 -0.0051,-5.7591835 4.0687497,-4.0759657 5.7591833,-0.0051 4.075966,4.0687497 z"
     inkscape:randomized="0"
     inkscape:rounded="0"
     inkscape:flatsided="true"
     sodipodi:arg2="0.78451219"
     sodipodi:arg1="0.39181311"
     sodipodi:r2="6.9185686"
     sodipodi:r1="7.5247387"
     sodipodi:cy="8.796464"
     sodipodi:cx="8.9135246"
     sodipodi:sides="8"
     id="path51"
     style="fill:none;fill-rule:evenodd;stroke:var(--gscape-color-individual-contrast);stroke-width:4;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
     sodipodi:type="star" />
</svg>`;

var objectPropertyIcon = b `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="18"
   height="18"
   version="1.1"
   id="svg4"
   sodipodi:docname="role.svg"
   inkscape:version="0.92.4 (f8dce91, 2019-08-02)">
  <metadata
     id="metadata10">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs8" />
  <sodipodi:namedview
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1"
     objecttolerance="10"
     gridtolerance="10"
     guidetolerance="10"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:window-width="927"
     inkscape:window-height="1025"
     id="namedview6"
     showgrid="false"
     inkscape:zoom="13.111111"
     inkscape:cx="7.2336581"
     inkscape:cy="6.7167247"
     inkscape:window-x="993"
     inkscape:window-y="27"
     inkscape:window-maximized="0"
     inkscape:current-layer="svg4"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <polygon
     points="125,86.909 146.992,125 125,163.092 103.008,125 "
     transform="matrix(0.27862408,0,0,0.13179941,-25.774205,-7.2921404)"
     id="polygon2"
     style="fill:none;stroke:var(--gscape-color-object-property-contrast);stroke-width:12.02451324;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none" />
</svg>
`;

const diagrams = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M6.333 5.438Q5.875 5.438 5.552 5.76Q5.229 6.083 5.229 6.542Q5.229 7 5.552 7.302Q5.875 7.604 6.333 7.604Q6.792 7.604 7.094 7.302Q7.396 7 7.396 6.542Q7.396 6.083 7.094 5.76Q6.792 5.438 6.333 5.438ZM6.333 13.208Q5.875 13.208 5.552 13.51Q5.229 13.812 5.229 14.271Q5.229 14.729 5.552 15.052Q5.875 15.375 6.333 15.375Q6.792 15.375 7.094 15.052Q7.396 14.729 7.396 14.271Q7.396 13.812 7.094 13.51Q6.792 13.208 6.333 13.208ZM3.667 3.167H16.354Q16.667 3.167 16.875 3.375Q17.083 3.583 17.083 3.896V9.104Q17.083 9.458 16.875 9.677Q16.667 9.896 16.354 9.896H3.667Q3.354 9.896 3.135 9.677Q2.917 9.458 2.917 9.104V3.896Q2.917 3.583 3.135 3.375Q3.354 3.167 3.667 3.167ZM4.25 4.5V8.562H15.75V4.5ZM3.667 10.938H16.333Q16.667 10.938 16.875 11.156Q17.083 11.375 17.083 11.708V16.875Q17.083 17.229 16.875 17.448Q16.667 17.667 16.333 17.667H3.688Q3.354 17.667 3.135 17.448Q2.917 17.229 2.917 16.875V11.708Q2.917 11.375 3.125 11.156Q3.333 10.938 3.667 10.938ZM4.25 12.271V16.333H15.75V12.271ZM4.25 4.5V8.562ZM4.25 12.271V16.333Z"/></svg>`;
const triangle_up = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M7 14l5-5 5 5H7z"/></svg>`;
const triangle_down = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M7 10l5 5 5-5H7z"/></svg>`;
const arrow_right = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>`;
const arrowDown = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="M480 723 240 483l51-51 189 189 189-189 51 51-240 240Z"/></svg>`;
const explore = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="m5.75 14.25 6.021-2.479L14.25 5.75 8.229 8.229Zm3.542-3.542Q9 10.417 9 10t.292-.708Q9.583 9 10 9t.708.292Q11 9.583 11 10t-.292.708Q10.417 11 10 11t-.708-.292ZM10 18q-1.646 0-3.104-.625-1.458-.625-2.552-1.719t-1.719-2.552Q2 11.646 2 10q0-1.667.625-3.115.625-1.447 1.719-2.541Q5.438 3.25 6.896 2.625T10 2q1.667 0 3.115.625 1.447.625 2.541 1.719 1.094 1.094 1.719 2.541Q18 8.333 18 10q0 1.646-.625 3.104-.625 1.458-1.719 2.552t-2.541 1.719Q11.667 18 10 18Zm0-1.5q2.708 0 4.604-1.896T16.5 10q0-2.708-1.896-4.604T10 3.5q-2.708 0-4.604 1.896T3.5 10q0 2.708 1.896 4.604T10 16.5Zm0-6.5Z"/></svg>`;
const info_outline = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M9.25 14H10.75V9H9.25ZM10 7.5Q10.312 7.5 10.531 7.281Q10.75 7.062 10.75 6.75Q10.75 6.438 10.531 6.219Q10.312 6 10 6Q9.688 6 9.469 6.219Q9.25 6.438 9.25 6.75Q9.25 7.062 9.469 7.281Q9.688 7.5 10 7.5ZM10 16.5Q11.354 16.5 12.531 15.99Q13.708 15.479 14.594 14.594Q15.479 13.708 15.99 12.521Q16.5 11.333 16.5 10Q16.5 8.646 15.99 7.469Q15.479 6.292 14.594 5.406Q13.708 4.521 12.531 4.01Q11.354 3.5 10 3.5Q8.667 3.5 7.479 4.01Q6.292 4.521 5.406 5.406Q4.521 6.292 4.01 7.469Q3.5 8.646 3.5 10Q3.5 11.333 4.01 12.521Q4.521 13.708 5.406 14.594Q6.292 15.479 7.479 15.99Q8.667 16.5 10 16.5ZM10 18Q6.667 18 4.333 15.667Q2 13.333 2 10Q2 6.667 4.333 4.333Q6.667 2 10 2Q13.333 2 15.667 4.333Q18 6.667 18 10Q18 13.333 15.667 15.667Q13.333 18 10 18ZM10 10Q10 10 10 10Q10 10 10 10Q10 10 10 10Q10 10 10 10Q10 10 10 10Q10 10 10 10Q10 10 10 10Q10 10 10 10Z"/></svg>`;
const enterFullscreen = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="1 1 18 18"><path d="M4.167 15.833V11.646H5.5V14.5H8.354V15.833ZM4.167 8.354V4.167H8.354V5.5H5.5V8.354ZM11.646 15.833V14.5H14.5V11.646H15.833V15.833ZM14.5 8.354V5.5H11.646V4.167H15.833V8.354Z"/></svg>`;
const exitFullscreen = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="1 1 18 18"><path d="M7.021 15.833V12.979H4.167V11.646H8.354V15.833ZM4.167 8.354V7.021H7.021V4.167H8.354V8.354ZM11.646 15.833V11.646H15.833V12.979H12.979V15.833ZM11.646 8.354V4.167H12.979V7.021H15.833V8.354Z"/></svg>`;
const centerDiagram = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M10 12.167Q9.104 12.167 8.469 11.531Q7.833 10.896 7.833 10Q7.833 9.104 8.469 8.469Q9.104 7.833 10 7.833Q10.896 7.833 11.531 8.469Q12.167 9.104 12.167 10Q12.167 10.896 11.531 11.531Q10.896 12.167 10 12.167ZM2.917 7.542V4.5Q2.917 3.833 3.375 3.375Q3.833 2.917 4.5 2.917H7.542V4.25H4.5Q4.417 4.25 4.333 4.333Q4.25 4.417 4.25 4.5V7.542ZM7.542 17.083H4.5Q3.833 17.083 3.375 16.625Q2.917 16.167 2.917 15.5V12.458H4.25V15.5Q4.25 15.583 4.333 15.667Q4.417 15.75 4.5 15.75H7.542ZM12.458 17.083V15.75H15.5Q15.583 15.75 15.667 15.667Q15.75 15.583 15.75 15.5V12.458H17.083V15.5Q17.083 16.167 16.625 16.625Q16.167 17.083 15.5 17.083ZM15.75 7.542V4.5Q15.75 4.417 15.667 4.333Q15.583 4.25 15.5 4.25H12.458V2.917H15.5Q16.167 2.917 16.625 3.375Q17.083 3.833 17.083 4.5V7.542ZM10 10.833Q10.354 10.833 10.594 10.594Q10.833 10.354 10.833 10Q10.833 9.646 10.594 9.406Q10.354 9.167 10 9.167Q9.646 9.167 9.406 9.406Q9.167 9.646 9.167 10Q9.167 10.354 9.406 10.594Q9.646 10.833 10 10.833Z"/></svg>`;
const filter = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M8.062 13.979V12.583H11.938V13.979ZM5.104 10.5V9.104H14.875V10.5ZM3.146 7V5.604H16.854V7Z"/></svg>`;
const bubbles = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M6.021 14.667Q4.75 14.667 3.865 13.781Q2.979 12.896 2.979 11.625Q2.979 10.354 3.865 9.469Q4.75 8.583 6.021 8.583Q7.271 8.583 8.156 9.469Q9.042 10.354 9.042 11.625Q9.042 12.896 8.156 13.781Q7.271 14.667 6.021 14.667ZM13.542 11.458Q11.792 11.458 10.583 10.24Q9.375 9.021 9.375 7.271Q9.375 5.5 10.583 4.292Q11.792 3.083 13.542 3.083Q15.292 3.083 16.521 4.292Q17.75 5.5 17.75 7.271Q17.75 9.021 16.521 10.24Q15.292 11.458 13.542 11.458ZM11.958 16.938Q11.042 16.938 10.396 16.292Q9.75 15.646 9.75 14.708Q9.75 13.792 10.396 13.146Q11.042 12.5 11.958 12.5Q12.896 12.5 13.542 13.146Q14.188 13.792 14.188 14.708Q14.188 15.646 13.542 16.292Q12.896 16.938 11.958 16.938Z"/></svg>`;
const lite = b `<svg fill="currentColor" style="padding: 2px; box-sizing: border-box;" width="20" height="20" version="1.1" viewBox="0 0 752 752" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com"><path d="M 375.714 0.009 C 371.042 0.066 366.482 1.447 362.593 3.994 L 156.603 127.708 C 153.518 129.737 150.954 132.436 149.099 135.596 L 12.104 135.596 C 5.422 135.596 0 140.911 0 147.462 L 0 599.375 L 0 599.369 C 0 605.92 5.422 611.236 12.104 611.236 L 139.149 611.236 L 139.149 728.278 L 139.149 728.272 C 139.149 734.568 141.694 740.599 146.235 745.052 C 150.77 749.498 156.93 752 163.343 752 L 588.652 752 C 595.064 752 601.218 749.498 605.76 745.052 C 610.292 740.599 612.846 734.568 612.846 728.272 L 612.846 611.236 L 739.903 611.236 C 746.584 611.236 752 605.92 752 599.369 L 752 147.456 C 752 140.905 746.584 135.59 739.903 135.59 L 602.94 135.59 C 601.08 132.428 598.496 129.73 595.403 127.702 L 389.431 3.988 C 385.371 1.333 380.59 -0.056 375.709 0.001 L 375.714 0.009 Z M 376.014 98.108 L 491.584 157.275 L 376.014 216.436 L 260.427 157.275 L 376.014 98.108 Z M 37.566 178.974 L 149.089 178.974 C 150.949 182.128 153.519 184.821 156.606 186.844 L 362.579 310.545 L 362.584 310.545 C 366.556 313.142 371.23 314.529 376.006 314.529 C 380.781 314.529 385.455 313.142 389.427 310.545 L 595.383 186.844 C 598.463 184.815 601.026 182.122 602.88 178.974 L 714.428 178.974 L 714.428 574.405 L 612.83 574.405 L 612.83 463.926 C 612.83 457.631 610.28 451.599 605.744 447.153 C 601.202 442.701 595.051 440.201 588.631 440.201 L 163.339 440.201 C 156.926 440.201 150.767 442.701 146.232 447.153 C 141.69 451.599 139.146 457.631 139.146 463.926 L 139.146 574.405 L 37.561 574.405 L 37.566 178.974 Z M 242.668 541.701 L 509.325 541.701 L 510.994 652.145 L 240.998 652.145 L 242.668 541.701 Z" fill-rule="evenodd" style=""></path></svg>`;
const settings_icon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="m8.021 17.917-.313-2.5q-.27-.125-.625-.334-.354-.208-.625-.395l-2.312.979-1.979-3.438 1.979-1.5q-.021-.167-.031-.364-.011-.198-.011-.365 0-.146.011-.344.01-.198.031-.385l-1.979-1.5 1.979-3.417 2.312.958q.271-.187.615-.385t.635-.344l.313-2.5h3.958l.313 2.5q.312.167.625.344.312.177.604.385l2.333-.958 1.979 3.417-1.979 1.521q.021.187.021.364V10q0 .146-.01.333-.011.188-.011.396l1.958 1.5-1.979 3.438-2.312-.979q-.292.208-.615.395-.323.188-.614.334l-.313 2.5Zm1.937-5.355q1.063 0 1.813-.75t.75-1.812q0-1.062-.75-1.812t-1.813-.75q-1.041 0-1.802.75-.76.75-.76 1.812t.76 1.812q.761.75 1.802.75Zm0-1.333q-.5 0-.864-.364-.365-.365-.365-.865t.365-.865q.364-.364.864-.364t.865.364q.365.365.365.865t-.365.865q-.365.364-.865.364ZM10.021 10Zm-.854 6.583h1.666l.25-2.187q.605-.167 1.136-.49.531-.323 1.031-.802l2.021.875.854-1.375-1.792-1.354q.105-.333.136-.635.031-.303.031-.615 0-.292-.031-.573-.031-.281-.115-.635l1.792-1.396-.834-1.375-2.062.875q-.438-.438-1.021-.781-.583-.344-1.125-.49l-.271-2.208H9.167l-.271 2.208q-.584.146-1.125.458-.542.313-1.042.792l-2.021-.854-.833 1.375 1.75 1.354q-.083.333-.125.646-.042.312-.042.604t.042.594q.042.302.125.635l-1.75 1.375.833 1.375 2.021-.854q.479.458 1.021.771.542.312 1.146.479Z"/></svg>`;
const infoFilled = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M10 14.167Q10.354 14.167 10.615 13.906Q10.875 13.646 10.875 13.292V10.021Q10.875 9.667 10.615 9.417Q10.354 9.167 10 9.167Q9.646 9.167 9.385 9.427Q9.125 9.688 9.125 10.042V13.312Q9.125 13.667 9.385 13.917Q9.646 14.167 10 14.167ZM10 7.479Q10.354 7.479 10.615 7.219Q10.875 6.958 10.875 6.604Q10.875 6.25 10.615 5.99Q10.354 5.729 10 5.729Q9.646 5.729 9.385 5.99Q9.125 6.25 9.125 6.604Q9.125 6.958 9.385 7.219Q9.646 7.479 10 7.479ZM10 18.333Q8.271 18.333 6.75 17.677Q5.229 17.021 4.104 15.896Q2.979 14.771 2.323 13.25Q1.667 11.729 1.667 10Q1.667 8.271 2.323 6.75Q2.979 5.229 4.104 4.104Q5.229 2.979 6.75 2.323Q8.271 1.667 10 1.667Q11.729 1.667 13.25 2.323Q14.771 2.979 15.896 4.104Q17.021 5.229 17.677 6.75Q18.333 8.271 18.333 10Q18.333 11.729 17.677 13.25Q17.021 14.771 15.896 15.896Q14.771 17.021 13.25 17.677Q11.729 18.333 10 18.333Z"/></svg>`;
const plus = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M9.188 15.083V10.792H4.896V9.167H9.188V4.875H10.812V9.167H15.104V10.792H10.812V15.083Z"/></svg>`;
const minus = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M4.875 10.792V9.167H15.125V10.792Z"/></svg>`;
const save = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M17.083 6v9.5q0 .667-.458 1.125-.458.458-1.125.458h-11q-.667 0-1.125-.458-.458-.458-.458-1.125v-11q0-.667.458-1.125.458-.458 1.125-.458H14Zm-1.333.604L13.396 4.25H4.5q-.104 0-.177.073T4.25 4.5v11q0 .104.073.177t.177.073h11q.104 0 .177-.073t.073-.177ZM10 14.312q.896 0 1.531-.645.636-.646.636-1.521 0-.896-.636-1.531-.635-.636-1.531-.636-.896 0-1.531.636-.636.635-.636 1.531 0 .875.636 1.521.635.645 1.531.645Zm-4.667-6.02h6.855V5.333H5.333ZM4.25 6.604v9.146-11.5Z"/></svg>`;
const lock_open = '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px" fill="currentColor"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"/></svg>';
const close = b `<svg fillColor="currentColor" style="width:20px;height:20px" viewBox="0 0 24 24"><path fill="currentColor" d="M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" /></svg>`;
const blankSlateDiagrams = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M14.104 8.521Q13.875 8.312 13.875 8.052Q13.875 7.792 14.083 7.583L15.875 5.792Q16.062 5.604 16.333 5.615Q16.604 5.625 16.792 5.812Q17 6.021 17 6.281Q17 6.542 16.792 6.75L15 8.542Q14.812 8.729 14.552 8.719Q14.292 8.708 14.104 8.521ZM10 6.729Q9.729 6.729 9.531 6.531Q9.333 6.333 9.333 6.062V3.604Q9.333 3.333 9.531 3.135Q9.729 2.938 10 2.938Q10.271 2.938 10.469 3.135Q10.667 3.333 10.667 3.604V6.062Q10.667 6.333 10.469 6.531Q10.271 6.729 10 6.729ZM5 8.521 3.208 6.75Q3 6.562 3.01 6.281Q3.021 6 3.229 5.792Q3.417 5.604 3.688 5.604Q3.958 5.604 4.167 5.792L5.938 7.583Q6.125 7.792 6.125 8.052Q6.125 8.312 5.938 8.521Q5.729 8.708 5.458 8.708Q5.188 8.708 5 8.521ZM3.667 15.75H16.333Q16.417 15.75 16.5 15.667Q16.583 15.583 16.583 15.5V11.896Q16.583 11.812 16.5 11.729Q16.417 11.646 16.333 11.646H13.875Q13.375 12.771 12.302 13.469Q11.229 14.167 10 14.167Q8.771 14.167 7.708 13.469Q6.646 12.771 6.125 11.646H3.667Q3.583 11.646 3.5 11.729Q3.417 11.812 3.417 11.896V15.5Q3.417 15.583 3.5 15.667Q3.583 15.75 3.667 15.75ZM3.667 17.083Q3 17.083 2.542 16.625Q2.083 16.167 2.083 15.5V11.896Q2.083 11.229 2.542 10.771Q3 10.312 3.667 10.312H6.625Q7 10.312 7.083 10.385Q7.167 10.458 7.229 10.708Q7.417 11.5 8.135 12.167Q8.854 12.833 10 12.833Q11.146 12.833 11.865 12.156Q12.583 11.479 12.771 10.708Q12.833 10.458 12.917 10.385Q13 10.312 13.375 10.312H16.333Q17 10.312 17.458 10.771Q17.917 11.229 17.917 11.896V15.5Q17.917 16.167 17.458 16.625Q17 17.083 16.333 17.083ZM3.667 15.75Q3.583 15.75 3.5 15.75Q3.417 15.75 3.417 15.75Q3.417 15.75 3.5 15.75Q3.583 15.75 3.667 15.75H6.125Q6.646 15.75 7.708 15.75Q8.771 15.75 10 15.75Q11.229 15.75 12.302 15.75Q13.375 15.75 13.875 15.75H16.333Q16.417 15.75 16.5 15.75Q16.583 15.75 16.583 15.75Q16.583 15.75 16.5 15.75Q16.417 15.75 16.333 15.75Z"/></svg>`;
const check = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M8.229 13.771 5.021 10.542 5.75 9.792 8.229 12.25 14.25 6.25 14.979 7.021Z"/></svg>`;
const searchOff = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M6 16.417q-1.5 0-2.542-1.042-1.041-1.042-1.041-2.542 0-1.5 1.052-2.541Q4.521 9.25 6 9.25q1.5 0 2.542 1.052 1.041 1.052 1.041 2.552 0 1.479-1.052 2.521Q7.479 16.417 6 16.417Zm10.875-.771-5.083-5.084q-.104.105-.261.188-.156.083-.302.146l-.291-.375q-.146-.188-.313-.354.875-.438 1.427-1.261T12.604 7q0-1.5-1.052-2.552T9 3.396q-1.5 0-2.552 1.052T5.396 7q0 .208.042.406.041.198.083.386-.313.02-.563.073-.25.052-.52.135-.042-.229-.084-.479-.042-.25-.042-.521 0-1.938 1.376-3.312Q7.062 2.312 9 2.312q1.938 0 3.312 1.365Q13.688 5.042 13.688 7q0 .833-.282 1.583-.281.75-.739 1.334l4.979 4.958ZM4.812 14.521l1.167-1.167 1.167 1.167.542-.542-1.167-1.167 1.167-1.145-.542-.542-1.167 1.146-1.167-1.146-.541.542 1.167 1.145-1.167 1.167Z"/></svg>`;
/**
 * Author: Simran
 * Source: https://github.com/Templarian/MaterialDesign/blob/master/svg/checkbox-multiple-blank-circle.svg
 */
const move_bubbles = b `<svg style="width:20px;height:20px" viewBox="0 0 24 24"><path fill="currentColor" d="M14,2A8,8 0 0,0 6,10A8,8 0 0,0 14,18A8,8 0 0,0 22,10A8,8 0 0,0 14,2M4.93,5.82C3.08,7.34 2,9.61 2,12A8,8 0 0,0 10,20C10.64,20 11.27,19.92 11.88,19.77C10.12,19.38 8.5,18.5 7.17,17.29C5.22,16.25 4,14.21 4,12C4,11.7 4.03,11.41 4.07,11.11C4.03,10.74 4,10.37 4,10C4,8.56 4.32,7.13 4.93,5.82Z" /></svg>`;
/**
 * Author: Simran
 * Source: https://github.com/Templarian/MaterialDesign/blob/master/svg/owl.svg
 */
const owl_icon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="height: 20px; width: auto" aria-hidden="true" focusable="false" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M12 16c.56.84 1.31 1.53 2.2 2L12 20.2L9.8 18c.89-.47 1.65-1.16 2.2-2m5-4.8a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2a2 2 0 0 0-2-2m-10 0a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2a2 2 0 0 0-2-2m10-2.5a4 4 0 0 1 4 4a4 4 0 0 1-4 4a4 4 0 0 1-4-4a4 4 0 0 1 4-4m-10 0a4 4 0 0 1 4 4a4 4 0 0 1-4 4a4 4 0 0 1-4-4a4 4 0 0 1 4-4M2.24 1c1.76 3.7.49 6.46-.69 9.2c-.36.8-.55 1.63-.55 2.5a6 6 0 0 0 6 6c.21-.01.42-.02.63-.05l2.96 2.96L12 23l1.41-1.39l2.96-2.96c.21.03.42.04.63.05a6 6 0 0 0 6-6c0-.87-.19-1.7-.55-2.5C21.27 7.46 20 4.7 21.76 1c-2.64 2.06-6.4 3.69-9.76 3.7C8.64 4.69 4.88 3.06 2.24 1z"/></svg>`;
const graphol_icon = b `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 12 12" fill="currentColor" xml:space="preserve" style="height: 20px; width: 20px; box-sizing: border-box; padding: 2px;"><path id="path847" d="M5.4,11.9c-1.4-0.1-2.7-0.8-3.8-1.8c-0.8-0.8-1.3-1.8-1.6-3C0.1,6.8,0.1,6.7,0.1,6c0-0.7,0-0.8,0.1-1.1 c0.3-1.2,0.8-2.3,1.7-3.1C2.3,1.3,2.7,1,3.3,0.7c1.7-0.9,3.8-0.9,5.5,0c2.4,1.3,3.6,3.9,3.1,6.5c-0.6,2.6-2.8,4.5-5.5,4.7 C5.8,12,5.8,12,5.4,11.9L5.4,11.9z M6.5,10.5c0.2-0.1,0.3-0.1,0.8-0.7c0.3-0.3,1.2-1.2,2-1.9c1.1-1.1,1.3-1.4,1.4-1.5 c0.2-0.4,0.2-0.7,0-1.1c-0.1-0.2-0.2-0.3-1-1.1c-1-1-1.1-1-1.6-1c-0.5,0-0.5,0-1.9,1.4C5.5,5.2,5,5.8,5,5.8c0,0,0.2,0.3,0.5,0.6 L6,6.9l1-1l1-1l0.5,0.5l0.5,0.5L7.6,7.4L6,8.9L4.5,7.4L2.9,5.8L5,3.7c1.1-1.1,2.1-2.1,2.1-2.1c0-0.1-1-1-1-1c0,0-1,1-2.3,2.2 c-2,2-2.3,2.3-2.3,2.4C1.3,5.5,1.3,5.7,1.3,6c0.1,0.4,0,0.4,2.1,2.4c1.1,1.1,1.9,1.9,2,2C5.7,10.6,6.1,10.6,6.5,10.5z"/></svg>`;
const tune = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M3.375 15.625Q3.104 15.625 2.906 15.427Q2.708 15.229 2.708 14.958Q2.708 14.688 2.906 14.49Q3.104 14.292 3.375 14.292H6.792Q7.062 14.292 7.26 14.49Q7.458 14.688 7.458 14.958Q7.458 15.229 7.26 15.427Q7.062 15.625 6.792 15.625ZM3.375 5.708Q3.104 5.708 2.906 5.51Q2.708 5.312 2.708 5.042Q2.708 4.771 2.906 4.573Q3.104 4.375 3.375 4.375H9.896Q10.167 4.375 10.365 4.573Q10.562 4.771 10.562 5.042Q10.562 5.312 10.365 5.51Q10.167 5.708 9.896 5.708ZM10.083 17.292Q9.812 17.292 9.615 17.094Q9.417 16.896 9.417 16.625V13.312Q9.417 13.042 9.615 12.844Q9.812 12.646 10.083 12.646Q10.354 12.646 10.552 12.844Q10.75 13.042 10.75 13.312V14.292H16.625Q16.896 14.292 17.094 14.49Q17.292 14.688 17.292 14.958Q17.292 15.229 17.094 15.427Q16.896 15.625 16.625 15.625H10.75V16.625Q10.75 16.896 10.552 17.094Q10.354 17.292 10.083 17.292ZM6.792 12.333Q6.521 12.333 6.323 12.135Q6.125 11.938 6.125 11.667V10.667H3.375Q3.104 10.667 2.906 10.469Q2.708 10.271 2.708 10Q2.708 9.729 2.906 9.531Q3.104 9.333 3.375 9.333H6.125V8.354Q6.125 8.083 6.323 7.885Q6.521 7.688 6.792 7.688Q7.062 7.688 7.26 7.885Q7.458 8.083 7.458 8.354V11.667Q7.458 11.938 7.26 12.135Q7.062 12.333 6.792 12.333ZM10.083 10.667Q9.812 10.667 9.615 10.469Q9.417 10.271 9.417 10Q9.417 9.729 9.615 9.531Q9.812 9.333 10.083 9.333H16.625Q16.896 9.333 17.094 9.531Q17.292 9.729 17.292 10Q17.292 10.271 17.094 10.469Q16.896 10.667 16.625 10.667ZM13.208 7.354Q12.938 7.354 12.74 7.156Q12.542 6.958 12.542 6.688V3.375Q12.542 3.104 12.74 2.906Q12.938 2.708 13.208 2.708Q13.479 2.708 13.677 2.906Q13.875 3.104 13.875 3.375V4.375H16.625Q16.896 4.375 17.094 4.573Q17.292 4.771 17.292 5.042Q17.292 5.312 17.094 5.51Q16.896 5.708 16.625 5.708H13.875V6.688Q13.875 6.958 13.677 7.156Q13.479 7.354 13.208 7.354Z"/></svg>`;
const settings_play = b `<svg style="width:20px;height:20px" viewBox="0 0 24 24"><path fill="currentColor" d="M13.54 22H10C9.75 22 9.54 21.82 9.5 21.58L9.13 18.93C8.5 18.68 7.96 18.34 7.44 17.94L4.95 18.95C4.73 19.03 4.46 18.95 4.34 18.73L2.34 15.27C2.21 15.05 2.27 14.78 2.46 14.63L4.57 12.97L4.5 12L4.57 11L2.46 9.37C2.27 9.22 2.21 8.95 2.34 8.73L4.34 5.27C4.46 5.05 4.73 4.96 4.95 5.05L7.44 6.05C7.96 5.66 8.5 5.32 9.13 5.07L9.5 2.42C9.54 2.18 9.75 2 10 2H14C14.25 2 14.46 2.18 14.5 2.42L14.87 5.07C15.5 5.32 16.04 5.66 16.56 6.05L19.05 5.05C19.27 4.96 19.54 5.05 19.66 5.27L21.66 8.73C21.79 8.95 21.73 9.22 21.54 9.37L19.43 11L19.5 12V12.19C19 12.07 18.5 12 18 12C17.83 12 17.66 12 17.5 12.03C17.5 11.41 17.4 10.79 17.2 10.2L19.31 8.65L18.56 7.35L16.15 8.39C15.38 7.5 14.32 6.86 13.12 6.62L12.75 4H11.25L10.88 6.61C9.68 6.86 8.62 7.5 7.85 8.39L5.44 7.35L4.69 8.65L6.8 10.2C6.4 11.37 6.4 12.64 6.8 13.8L4.68 15.36L5.43 16.66L7.86 15.62C8.63 16.5 9.68 17.14 10.87 17.38L11.24 20H12.35C12.61 20.75 13 21.42 13.54 22M15.96 12.36C16 12.24 16 12.12 16 12C16 9.79 14.21 8 12 8S8 9.79 8 12 9.79 16 12 16C12.12 16 12.24 16 12.36 15.96C12.97 14.29 14.29 12.97 15.96 12.36M12 14C10.9 14 10 13.11 10 12S10.9 10 12 10 14 10.9 14 12 13.11 14 12 14M16 15V21L21 18L16 15Z" /></svg>`;
const filterOff = b `<svg xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="M16.021 16.5 2.438 2.917l.77-.771 13.584 13.583ZM3.208 5.417V4.333h1.73v1.084Zm2 3.895V8.229h3.646v1.083Zm3.396-3.895L7.521 4.333h9.271v1.084Zm-.396 7.812v-1.083h3.584v1.083ZM12.5 9.312l-1.083-1.083h3.375v1.083Z"/></svg>`;
const incremental = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 20 20"><path d="m10 13.458-1.083-2.416L6.5 9.958l2.417-1.083L10 6.458l1.083 2.417L13.5 9.958l-2.417 1.084Zm0 5.084q-2.354 0-4.323-1.188-1.969-1.187-3.177-3.271v2.709H1.417v-4.5h4.479v1.083H3.375q1.021 1.896 2.771 2.99 1.75 1.093 3.854 1.093 2.458 0 4.406-1.458 1.948-1.458 2.74-3.771l1.042.229q-.813 2.73-3.073 4.407-2.261 1.677-5.115 1.677ZM1.458 9.208q.125-1.354.604-2.52.48-1.167 1.355-2.209l.791.75q-.687.875-1.104 1.834-.416.958-.562 2.145ZM5.25 4.167l-.75-.771q1.021-.875 2.24-1.365 1.218-.489 2.51-.593v1.083q-1.083.125-2.104.552Q6.125 3.5 5.25 4.167Zm9.479 0q-.812-.667-1.864-1.105-1.053-.437-2.115-.541V1.438q1.312.083 2.521.583 1.208.5 2.229 1.375Zm2.709 5.041q-.146-1.146-.563-2.146-.417-1-1.104-1.833l.791-.771q.855 1 1.365 2.209.511 1.208.615 2.541Z"/></svg>`;
const refresh = b `<svg fill="currentColor" viewBox="0 0 24 24" height="20px" width="20px"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" /></svg>`;
const instancesIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="padding: 1px;box-sizing: border-box;" height="18" width="18" viewBox="0 0 20 20" ><path d="M10 9q-3.062 0-5.031-.844Q3 7.312 3 6q0-1.229 2.062-2.115Q7.125 3 10 3q2.875 0 4.938.885Q17 4.771 17 6q0 1.312-1.969 2.156Q13.062 9 10 9Zm0 4q-2.979 0-4.99-.865Q3 11.271 3 10V8.042q0 .604.562 1.135.563.531 1.521.938.959.406 2.229.645Q8.583 11 10 11q1.417 0 2.688-.24 1.27-.239 2.229-.645.958-.407 1.521-.938Q17 8.646 17 8.042V10q0 1.271-2.01 2.135Q12.979 13 10 13Zm0 4q-2.917 0-4.958-.906Q3 15.188 3 13.896v-1.958q0 .604.573 1.156.573.552 1.542.979.968.427 2.239.677Q8.625 15 10 15t2.646-.25q1.271-.25 2.239-.677.969-.427 1.542-.979.573-.552.573-1.156v1.958q0 1.292-2.042 2.198Q12.917 17 10 17Z"/></svg>`;
const superHierarchies = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 -1 21 20"><path d="M10 16q-1.667 0-2.833-1.167Q6 13.667 6 12q0-1.479.927-2.573.927-1.094 2.323-1.365V4.875L8.062 6.062 7 5l3-3 3 3-1.062 1.062-1.188-1.187v3.187q1.396.271 2.323 1.365Q14 10.521 14 12q0 1.667-1.167 2.833Q11.667 16 10 16Zm0-1.5q1.042 0 1.771-.729.729-.729.729-1.771 0-1.042-.729-1.771Q11.042 9.5 10 9.5q-1.042 0-1.771.729Q7.5 10.958 7.5 12q0 1.042.729 1.771.729.729 1.771.729Zm0-2.5Z"/></svg>`;
const subHierarchies = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 21 20"><path d="m10 18-3-3 1.062-1.062 1.188 1.187v-3.187q-1.396-.271-2.323-1.365Q6 9.479 6 8q0-1.667 1.167-2.833Q8.333 4 10 4q1.667 0 2.833 1.167Q14 6.333 14 8q0 1.479-.927 2.573-.927 1.094-2.323 1.365v3.187l1.188-1.187L13 15Zm0-7.5q1.042 0 1.771-.729Q12.5 9.042 12.5 8q0-1.042-.729-1.771Q11.042 5.5 10 5.5q-1.042 0-1.771.729Q7.5 6.958 7.5 8q0 1.042.729 1.771.729.729 1.771.729ZM10 8Z"/></svg>`;
const rubbishBin = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20"><path d="M6.5 17q-.625 0-1.062-.438Q5 16.125 5 15.5v-10H4V4h4V3h4v1h4v1.5h-1v10q0 .625-.438 1.062Q14.125 17 13.5 17Zm7-11.5h-7v10h7ZM8 14h1.5V7H8Zm2.5 0H12V7h-1.5Zm-4-8.5v10Z"/></svg>`;
const mastroEndpointIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20"><path d="M3.542 9.25q-.563 0-.948-.396-.386-.396-.386-.937V5.542q0-.542.396-.938.396-.396.938-.396H11V9.25Zm0-1.083h6.375V5.292H3.542q-.104 0-.177.073t-.073.177v2.375q0 .104.073.177t.177.073Zm0 7.625q-.542 0-.938-.396-.396-.396-.396-.938v-2.375q0-.541.396-.937t.938-.396H12.5v5.042Zm0-1.084h7.875v-2.875H3.542q-.104 0-.177.073t-.073.177v2.375q0 .104.073.177t.177.073ZM14 15.792V9.25h-1.5V4.208h5.188L16.25 7.854h1.438Zm-9.896-2.021h1v-1h-1Zm0-6.542h1v-1h-1Zm-.812.938V5.292v2.875Zm0 6.541v-2.875 2.875Z"/></svg>`;
const stopCircle = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20"><path d="M7.208 12.792h5.584V7.208H7.208ZM10 17.583q-1.562 0-2.948-.593-1.385-.594-2.417-1.625-1.031-1.032-1.625-2.417-.593-1.386-.593-2.948 0-1.583.593-2.958.594-1.375 1.625-2.407Q5.667 3.604 7.052 3.01 8.438 2.417 10 2.417q1.583 0 2.958.593 1.375.594 2.407 1.625 1.031 1.032 1.625 2.417.593 1.386.593 2.948t-.593 2.948q-.594 1.385-1.625 2.417-1.032 1.031-2.417 1.625-1.386.593-2.948.593Zm0-1.083q2.708 0 4.604-1.896T16.5 10q0-2.708-1.896-4.604T10 3.5q-2.708 0-4.604 1.896T3.5 10q0 2.708 1.896 4.604T10 16.5Zm0-6.5Z"/></svg>`;
const equivalentClasses = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20"><path d="m10 17-3-3 1.062-1.062 1.188 1.187v-8.25L8.062 7.062 7 6l3-3 3 3-1.062 1.062-1.188-1.187v8.25l1.188-1.187L13 14Z"/></svg>`;
const search$1 = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="M765 912 526 673q-30 22-65.792 34.5T384.035 720Q284 720 214 650t-70-170q0-100 70-170t170-70q100 0 170 70t70 170.035q0 40.381-12.5 76.173T577 622l239 239-51 51ZM384 648q70 0 119-49t49-119q0-70-49-119t-119-49q-70 0-119 49t-49 119q0 70 49 119t119 49Z"/></svg>`;
const insertInGraph = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" width="20"><path d="M4.5 17.083q-.667 0-1.125-.458-.458-.458-.458-1.125V7.833q0-.666.458-1.125.458-.458 1.125-.458h2.896v1.333H4.5q-.083 0-.167.084-.083.083-.083.166V15.5q0 .083.083.167.084.083.167.083h11q.083 0 .167-.083.083-.084.083-.167V7.833q0-.083-.083-.166-.084-.084-.167-.084h-2.896V6.25H15.5q.667 0 1.125.458.458.459.458 1.125V15.5q0 .667-.458 1.125-.458.458-1.125.458Zm5.5-4.041L6.938 9.979l.937-.937L9.333 10.5V.625h1.334V10.5l1.458-1.458.937.937Z"/></svg>`;
const cross = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="m291 816-51-51 189-189-189-189 51-51 189 189 189-189 51 51-189 189 189 189-51 51-189-189-189 189Z"/></svg>`;
// https://materialdesignicons.com/icon/counter
const counter = b `<svg fill="currentColor" viewBox="0 0 24 24" height="20px" width="20px"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H11V6H4M20,18V6H18.76C19,6.54 18.95,7.07 18.95,7.13C18.88,7.8 18.41,8.5 18.24,8.75L15.91,11.3L19.23,11.28L19.24,12.5L14.04,12.47L14,11.47C14,11.47 17.05,8.24 17.2,7.95C17.34,7.67 17.91,6 16.5,6C15.27,6.05 15.41,7.3 15.41,7.3L13.87,7.31C13.87,7.31 13.88,6.65 14.25,6H13V18H15.58L15.57,17.14L16.54,17.13C16.54,17.13 17.45,16.97 17.46,16.08C17.5,15.08 16.65,15.08 16.5,15.08C16.37,15.08 15.43,15.13 15.43,15.95H13.91C13.91,15.95 13.95,13.89 16.5,13.89C19.1,13.89 18.96,15.91 18.96,15.91C18.96,15.91 19,17.16 17.85,17.63L18.37,18H20M8.92,16H7.42V10.2L5.62,10.76V9.53L8.76,8.41H8.92V16Z" /></svg>`;
const labelIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="m806.5 576-165 205q-10.833 13-25.205 20-14.371 7-30.795 7h-317q-27.637 0-47.319-19.681Q201.5 768.638 201.5 741V411q0-27.638 19.681-47.319Q240.863 344 268.5 344h317q16.727 0 30.983 7t25.017 20l165 205Zm-86 0L587.596 411H268.5v330h319l133-165Zm-452 0v165-330 165Z"/></svg>`;
const commentIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20" style="padding: 2px; box-sizing: border-box;"><path d="M246 650h468v-79H246v79Zm0-116h468v-79H246v79Zm0-116h468v-79H246v79Zm624 543L716 807H169q-32.587 0-55.794-23.206Q90 760.588 90 728V264q0-32.588 23.206-55.794Q136.413 185 169 185h622q32.588 0 55.794 23.206Q870 231.412 870 264v697ZM169 264v464h580l42 42V264H169Zm0 0v506-506Z"/></svg>`;
const authorIcon = b `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><rect x="0" y="0" width="24" height="24" fill="rgba(255, 255, 255, 0)" /><path fill="currentColor" d="M2 17v3h8v-1.89H3.9V17c0-.64 3.13-2.1 6.1-2.1c.96.01 1.91.14 2.83.38l1.52-1.52c-1.4-.47-2.85-.73-4.35-.76c-2.67 0-8 1.33-8 4m8-13C7.79 4 6 5.79 6 8s1.79 4 4 4s4-1.79 4-4s-1.79-4-4-4m0 6c-1.1 0-2-.89-2-2s.9-2 2-2s2 .9 2 2s-.89 2-2 2m11.7 3.35l-1 1l-2.05-2l1-1a.55.55 0 0 1 .77 0l1.28 1.28c.21.21.21.56 0 .77M12 18.94l6.06-6.06l2.05 2l-6 6.07H12v-2.01"/></svg>`;
const addDiagramIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="M746.5 801.5v-132h-132v-67h132v-132h67v132h132v67h-132v132h-67Zm-600-132v-379h667v113h-67v-46h-533v245h334v67h-401Zm67-134v-178 245-67Z"/></svg>`;
const addEntityIcon = b `<svg fill="var(--gscape-color-class-contrast)" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="M480.207 953q-78.083 0-146.895-29.75-68.812-29.75-120.838-81.522-52.027-51.772-81.75-120.954Q101 651.593 101 573.883q0-148.383 98.783-255.444Q298.567 211.378 444 197v87q-109 14.5-182.5 96.729T188 574.536q0 120.964 85.171 206.214Q358.343 866 480 866q72.5 0 132.25-31.5T712 750l77 43q-53 73.5-133.176 116.75Q575.649 953 480.207 953ZM447 737V607H317v-67h130V410h67v130h130v67H514v130h-67Zm378-6-77-43q11-26 17.5-55t6.5-59q0-111.864-73.75-193.932Q624.5 298 516 284v-87q144.933 14.397 243.967 121.604Q859 425.812 859 573.793q0 42.194-8.765 81.511Q841.471 694.621 825 731Z"/></svg>`;
const addDataPropertyIcon = b `<svg fill="var(--gscape-color-data-property-contrast)" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="M480.207 953q-78.083 0-146.895-29.75-68.812-29.75-120.838-81.522-52.027-51.772-81.75-120.954Q101 651.593 101 573.883q0-148.383 98.783-255.444Q298.567 211.378 444 197v87q-109 14.5-182.5 96.729T188 574.536q0 120.964 85.171 206.214Q358.343 866 480 866q72.5 0 132.25-31.5T712 750l77 43q-53 73.5-133.176 116.75Q575.649 953 480.207 953ZM447 737V607H317v-67h130V410h67v130h130v67H514v130h-67Zm378-6-77-43q11-26 17.5-55t6.5-59q0-111.864-73.75-193.932Q624.5 298 516 284v-87q144.933 14.397 243.967 121.604Q859 425.812 859 573.793q0 42.194-8.765 81.511Q841.471 694.621 825 731Z"/></svg>`;
const addClassInstanceIcon = b `<svg fill="var(--gscape-color-class-instance-contrast)" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="M480.207 953q-78.083 0-146.895-29.75-68.812-29.75-120.838-81.522-52.027-51.772-81.75-120.954Q101 651.593 101 573.883q0-148.383 98.783-255.444Q298.567 211.378 444 197v87q-109 14.5-182.5 96.729T188 574.536q0 120.964 85.171 206.214Q358.343 866 480 866q72.5 0 132.25-31.5T712 750l77 43q-53 73.5-133.176 116.75Q575.649 953 480.207 953ZM447 737V607H317v-67h130V410h67v130h130v67H514v130h-67Zm378-6-77-43q11-26 17.5-55t6.5-59q0-111.864-73.75-193.932Q624.5 298 516 284v-87q144.933 14.397 243.967 121.604Q859 425.812 859 573.793q0 42.194-8.765 81.511Q841.471 694.621 825 731Z"/></svg>`;
const addObjectPropertyIcon = b `<svg fill="var(--gscape-color-object-property-contrast)" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="m575 762-47-47.5 105-105H199v-67h434l-105-105 47-47.5 186 186-186 186Z"/></svg>`;
const addISAIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 96 960 960" width="20"><path d="m575 762-47-47.5 105-105H199v-67h434l-105-105 47-47.5 186 186-186 186Z"/></svg>`;
const addParentClassIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M479.747-194.5q-78.747 0-133.997-55.471-55.25-55.471-55.25-134.173 0-69.733 44.5-121.795Q379.5-558 446.5-570.562V-732.5l-58 58.5-47.5-47.5 139-139 139 139-47.5 47-58-58v161.938q67 12.411 111.5 64.475 44.5 52.063 44.5 121.798 0 79.289-55.503 134.539-55.502 55.25-134.25 55.25Zm.224-67q51.029 0 86.779-35.721 35.75-35.72 35.75-86.75 0-51.029-35.721-86.779-35.72-35.75-86.75-35.75-51.029 0-86.779 35.721-35.75 35.72-35.75 86.75 0 51.029 35.721 86.779 35.72 35.75 86.75 35.75ZM480-384Z"/></svg>`;
const addChildClassIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="m480-99.5-139-139 47.5-47 58 58v-161.938q-67-12.411-111.5-64.475-44.5-52.063-44.5-121.798 0-79.289 55.503-134.539 55.502-55.25 134.25-55.25 78.747 0 133.997 55.471 55.25 55.471 55.25 134.173 0 69.733-44.5 121.795Q580.5-402 513.5-389.438V-227.5l58-58.5 47.5 47.5-139 139Zm-.029-354q51.029 0 86.779-35.721 35.75-35.72 35.75-86.75 0-51.029-35.721-86.779-35.72-35.75-86.75-35.75-51.029 0-86.779 35.721-35.75 35.72-35.75 86.75 0 51.029 35.721 86.779 35.72 35.75 86.75 35.75ZM480-576Z"/></svg>`;
const addSubhierarchyIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M251.788-410q-29.288 0-49.538-20.462Q182-450.925 182-480.212q0-29.288 20.462-49.538Q222.925-550 252.212-550q29.288 0 49.538 20.462Q322-509.075 322-479.788q0 29.288-20.462 49.538Q281.075-410 251.788-410Zm228 0q-29.288 0-49.538-20.462Q410-450.925 410-480.212q0-29.288 20.462-49.538Q450.925-550 480.212-550q29.288 0 49.538 20.462Q550-509.075 550-479.788q0 29.288-20.462 49.538Q509.075-410 479.788-410Zm228 0q-29.288 0-49.538-20.462Q638-450.925 638-480.212q0-29.288 20.462-49.538Q678.925-550 708.212-550q29.288 0 49.538 20.462Q778-509.075 778-479.788q0 29.288-20.462 49.538Q737.075-410 707.788-410Z"/></svg>`;
const addInputIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M767.867-386.5q-29.127 0-52.617-17-23.489-17-33.806-43H98.5v-67H681q10.35-26 33.874-43t52.693-17q38.933 0 66.433 27.275 27.5 27.274 27.5 66 0 38.725-27.378 66.225-27.379 27.5-66.255 27.5Z"/></svg>`;
const renameIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M445-152v-67h71v67h-71Zm0-588v-67h71v67h-71Zm148 588v-67h71v67h-71Zm0-588v-67h71v67h-71Zm148 588v-67h67v67h-67Zm0-144v-71h67v71h-67Zm0-148v-71h67v71h-67Zm0-148v-71h67v71h-67Zm0-148v-67h67v67h-67ZM153-152v-67h83v-521h-83v-67h233v67h-83v521h83v67H153Z"/></svg>`;
const editIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M210-210.5h55l338-338-55-55-338 338v55ZM770-602 602-771l46-46q24-24 56.25-23.75T760-816.5l56.5 56.5q22.5 22.5 22 56.25t-23 56.25L770-602Zm-54.5 54L299-131.5H131v-168L547.5-716l168 168ZM576-575.5l-28-28 55 55-27-27Z"/></svg>`;
const sankey = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" style="padding: 1px; box-sizing: border-box;"><path d="M20 4V6H4V4H2V12H4V10C8.16 10 9.92 12.11 11.77 14.34S15.65 19 20 19V21H22V15H20V17C16.59 17 15.07 15.17 13.31 13.06C11.34 10.69 9.1 8 4 8H20V10H22V4Z" /></svg>`;
const pathIcon = b `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M744-144q-41 0-72-24t-42-60H396q-55 0-93.5-38.5T264-360q0-55 38.5-93.5T396-492h120q34.65 0 59.325-24.748Q600-541.496 600-576.248 600-611 575.325-635.5T516-660H330q-11 36-42 60t-72 24q-50 0-85-35t-35-85q0-50 35-85t85-35q41 0 72 24t42 60h186q65 0 110.5 45.5T672-576q0 65-45.5 110.5T516-420H396q-24.75 0-42.375 17.677T336-359.823Q336-335 353.625-317.5T396-300h234q11-36 42-60t72-24q50 0 85 35t35 85q0 50-35 85t-85 35ZM216-648q20.4 0 34.2-13.8Q264-675.6 264-696q0-20.4-13.8-34.2Q236.4-744 216-744q-20.4 0-34.2 13.8Q168-716.4 168-696q0 20.4 13.8 34.2Q195.6-648 216-648Z"/></svg>`;
const entityIcons = {
    [TypesEnum.CLASS]: classIcon,
    [TypesEnum.OBJECT_PROPERTY]: objectPropertyIcon,
    [TypesEnum.DATA_PROPERTY]: dataPropertyIcon,
    [TypesEnum.INDIVIDUAL]: individualIcon,
    [TypesEnum.CLASS_INSTANCE]: classInstanceIcon,
};
const annotationIcons = {
    label: labelIcon,
    comment: commentIcon,
    author: authorIcon,
    deprecated: undefined,
    isDefinedBy: undefined,
    versionInfo: undefined,
    priorVersion: undefined,
    incompatibleWith: undefined,
    backwardCompatible: undefined,
    backwardCompatibleWith: undefined,
};

class FloatyFilterManager extends BaseFilterManager {
    constructor() {
        super(...arguments);
        this.lockedFilters = [
            RDFGraphConfigFiltersEnum.VALUE_DOMAIN,
            RDFGraphConfigFiltersEnum.UNIVERSAL_QUANTIFIER,
            RDFGraphConfigFiltersEnum.COMPLEMENT,
            RDFGraphConfigFiltersEnum.HAS_KEY,
        ];
    }
}

function floatyStyle (theme) {
    const baseStyle = grapholStyle(theme);
    const floatyStyle = [
        {
            selector: 'node',
            style: {
                'shape': 'ellipse',
            }
        },
        {
            selector: `[type = "${TypesEnum.CLASS}"]`,
            style: {
                'text-margin-x': 0,
                'text-margin-y': 0,
                'text-valign': 'center',
                'text-halign': 'center',
                'height': (node) => node.data('width') || 100,
                'width': (node) => node.data('width') || 100
            }
        },
        {
            selector: `node[type = "${TypesEnum.DATA_PROPERTY}"]`,
            style: {
                'height': (node) => node.data('width') || 20,
                'width': (node) => node.data('width') || 20
            }
        },
        {
            selector: `node[type = "${TypesEnum.CLASS_INSTANCE}"]`,
            style: {
                backgroundColor: theme.getColour(ColoursNames.class_instance),
                "border-color": theme.getColour(ColoursNames.class_instance_contrast),
            }
        },
        {
            selector: `edge[type = "${TypesEnum.INSTANCE_OF}"]`,
            style: {
                "target-arrow-shape": 'triangle',
                'target-arrow-fill': 'filled',
                'line-color': theme.getColour(ColoursNames.class_instance_contrast),
                'target-arrow-color': theme.getColour(ColoursNames.class_instance_contrast),
                'line-opacity': 0.4,
            }
        },
        {
            selector: `edge[type = "${TypesEnum.INPUT}"]`,
            style: {
                'line-style': 'solid',
                'target-arrow-shape': 'none',
            }
        },
        {
            selector: `[displayedName][type = "${TypesEnum.OBJECT_PROPERTY}"]`,
            style: {
                'label': (elem) => elem.data().displayedName.replace(/\r?\n|\r/g, '')
            }
        },
        {
            selector: `[type = "${TypesEnum.OBJECT_PROPERTY}"]`,
            style: {
                'line-color': theme.getColour(ColoursNames.object_property_contrast),
                'source-arrow-color': theme.getColour(ColoursNames.object_property_contrast),
                'target-arrow-color': theme.getColour(ColoursNames.object_property_contrast),
                'target-arrow-shape': 'triangle',
                'target-arrow-fill': 'filled',
                'source-arrow-shape': 'square',
                'source-arrow-fill': 'hollow',
                'width': 4,
            }
        },
        {
            selector: `node[type = "${TypesEnum.UNION}"], node[type = "${TypesEnum.DISJOINT_UNION}"]`,
            style: {
                'width': 35,
                'height': 35,
            }
        },
        {
            selector: `edge[type = "${TypesEnum.UNION}"], edge[type = "${TypesEnum.DISJOINT_UNION}"], edge[type = "${TypesEnum.COMPLETE_UNION}"], edge[type = "${TypesEnum.COMPLETE_DISJOINT_UNION}"]`,
            style: {
                'width': 6,
                'line-style': 'solid',
                'target-arrow-shape': 'triangle',
            }
        },
        {
            selector: `edge[type = "${TypesEnum.UNION}"], edge[type = "${TypesEnum.COMPLETE_UNION}"]`,
            style: {
                'target-arrow-fill': 'hollow'
            }
        },
        {
            selector: `edge[type = "${TypesEnum.DISJOINT_UNION}"], edge[type = "${TypesEnum.COMPLETE_DISJOINT_UNION}"]`,
            style: {
                'target-arrow-fill': 'filled',
            }
        },
        {
            selector: ':loop',
            style: {
                'control-point-step-size': 80,
                'control-point-weight': 0.5,
            }
        },
        {
            selector: '[?pinned]',
            style: {
                'border-width': 4,
            }
        },
    ];
    return baseStyle.concat(floatyStyle);
}

function computeHierarchies(ontology) {
    var _a;
    const unionNodeSelector = `node[type = "${TypesEnum.UNION}"], node[type = "${TypesEnum.DISJOINT_UNION}"]`;
    const unionEdgeSelector = `edge[type = "${TypesEnum.UNION}"], edge[type = "${TypesEnum.DISJOINT_UNION}"]`;
    for (const diagram of ontology.diagrams) {
        (_a = diagram.representations.get(RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.cy.$(unionNodeSelector).forEach(unionNode => {
            var _a;
            const hierarchy = new Hierarchy(`${unionNode.id()}-${diagram.id}`, unionNode.data().type);
            unionNode.data('hierarchyID', hierarchy.id);
            const grapholUnionNode = (_a = diagram.representations.get(RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.grapholElements.get(unionNode.id());
            if (grapholUnionNode && isGrapholNode(grapholUnionNode)) {
                grapholUnionNode.hierarchyID = hierarchy.id;
            }
            let entity;
            unionNode.connectedEdges(`[type = "${TypesEnum.INPUT}"]`).sources().forEach(inputNode => {
                var _a;
                if (inputNode.data().iri) {
                    if (!ontology.hierarchiesBySubclassMap.get(inputNode.data().iri)) {
                        ontology.hierarchiesBySubclassMap.set(inputNode.data().iri, []);
                    }
                    entity = ontology.getEntity(inputNode.data().iri);
                    if (entity) {
                        hierarchy.addInput(entity);
                    }
                    (_a = ontology.hierarchiesBySubclassMap.get(inputNode.data().iri)) === null || _a === void 0 ? void 0 : _a.push(hierarchy);
                }
            });
            unionNode.outgoers(unionEdgeSelector).forEach(inclusionEdge => {
                var _a;
                const superClass = inclusionEdge.target();
                if (superClass.data().iri) {
                    if (!ontology.hierarchiesBySuperclassMap.get(superClass.data().iri)) {
                        ontology.hierarchiesBySuperclassMap.set(superClass.data().iri, []);
                    }
                    entity = ontology.getEntity(superClass.data().iri);
                    if (entity) {
                        hierarchy.addSuperclass(entity, inclusionEdge.data().targetLabel === 'C');
                    }
                    (_a = ontology.hierarchiesBySuperclassMap.get(superClass.data().iri)) === null || _a === void 0 ? void 0 : _a.push(hierarchy);
                }
            });
        });
    }
}

cytoscape.use(automove);
class FloatyRendererState extends BaseRenderer {
    constructor() {
        super(...arguments);
        this.id = RendererStatesEnum.FLOATY;
        this.filterManager = new FloatyFilterManager();
        this.grabHandler = (e) => {
            if (this.dragAndPin)
                e.target.data('old_pos', JSON.stringify(e.target.position()));
        };
        this.freeHandler = (e) => {
            if (this.dragAndPin) {
                let current_pos = JSON.stringify(e.target.position());
                if (e.target.data('old_pos') !== current_pos) {
                    this.pinNode(e.target);
                }
                e.target.removeData('old_pos');
            }
        };
        this.automoveOptions = {
            nodesMatching: (node) => { var _a; return (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.$(':grabbed').neighborhood(`[type = "${TypesEnum.DATA_PROPERTY}"]`).has(node); },
            reposition: 'drag',
            dragWith: `[type ="${TypesEnum.CLASS}"][iri]`
        };
    }
    set renderer(newRenderer) {
        super.renderer = newRenderer;
        if (!newRenderer.renderStateData[this.id]) {
            newRenderer.renderStateData[this.id] = {};
            newRenderer.renderStateData[this.id].popperContainers = new Map();
            this.floatyLayoutOptions = this.defaultLayoutOptions;
        }
    }
    get renderer() { return super.renderer; }
    transformOntology(ontology) {
        ontology.diagrams.forEach(diagram => {
            const floatyTransformer = new FloatyTransformer();
            diagram.representations.set(this.id, floatyTransformer.transform(diagram));
        });
        computeHierarchies(ontology);
    }
    runLayout() {
        var _a;
        if (!this.renderer.cy)
            return;
        (_a = this._layout) === null || _a === void 0 ? void 0 : _a.stop();
        this._layout = this.renderer.cy.elements().layout(this.floatyLayoutOptions);
        this._layout.one('layoutstop', (e) => {
            if (e.layout === this._layout) // only if layout has not changed
                this.layoutRunning = false;
        });
        this._layout.run();
        this.layoutRunning = true;
    }
    render() {
        var _a, _b;
        if (!this.renderer.diagram)
            return;
        let floatyRepresentation = this.renderer.diagram.representations.get(this.id);
        if (!floatyRepresentation) {
            const floatyTransformer = new FloatyTransformer();
            floatyRepresentation = floatyTransformer.transform(this.renderer.diagram);
            this.renderer.diagram.representations.set(this.id, floatyRepresentation);
        }
        this.renderer.cy = floatyRepresentation.cy;
        this.renderer.mount();
        if (!floatyRepresentation.hasEverBeenRendered) {
            this.floatyLayoutOptions.fit = true;
            this.runLayout();
            if (this.isLayoutInfinite) {
                setTimeout(() => this.renderer.fit(), 1000);
            }
            this.popperContainers.set(this.renderer.diagram.id, document.createElement('div'));
            this.setDragAndPinEventHandlers();
            this.renderer.cy.automove(this.automoveOptions);
        }
        else {
            if (!this.isLayoutInfinite) {
                if (floatyRepresentation.lastViewportState) {
                    (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.viewport(floatyRepresentation.lastViewportState);
                }
            }
        }
        if (this.popperContainer)
            (_b = this.renderer.cy.container()) === null || _b === void 0 ? void 0 : _b.appendChild(this.popperContainer);
        if (!this.dragAndPin)
            this.unpinAll();
        if (this.isLayoutInfinite) {
            this.floatyLayoutOptions.fit = false;
            this.runLayout();
        }
        floatyRepresentation.hasEverBeenRendered = true;
    }
    stopRendering() {
        var _a;
        (_a = this._layout) === null || _a === void 0 ? void 0 : _a.stop();
        if (this.renderer.diagram) {
            const floaty = this.renderer.diagram.representations.get(this.id);
            if (floaty) {
                floaty.lastViewportState = this.renderer.viewportState;
            }
        }
    }
    getGraphStyle(theme) {
        return floatyStyle(theme);
    }
    stopLayout() {
        var _a;
        (_a = this._layout) === null || _a === void 0 ? void 0 : _a.stop();
        this.floatyLayoutOptions.infinite = false;
    }
    runLayoutInfinitely() {
        this.floatyLayoutOptions.infinite = true;
        this.floatyLayoutOptions.fit = false;
        this.runLayout();
    }
    pinNode(nodeOrId) {
        if (!nodeOrId || !this.renderer.cy)
            return;
        let node;
        if (typeof (nodeOrId) === 'string') {
            node = this.renderer.cy.$id(nodeOrId);
        }
        else {
            node = nodeOrId;
        }
        if (node.data().pinner)
            return;
        node.lock();
        node.data("pinned", true);
        let n = node;
        n.unlockButton = node.popper({
            content: () => {
                var _a;
                if (!this.renderer.cy)
                    return;
                let dimension = node.data('width') / 9 * this.renderer.cy.zoom();
                let div = document.createElement('div');
                div.style.background = node.style('border-color');
                div.style.borderRadius = '100%';
                div.style.padding = '5px';
                div.style.cursor = 'pointer';
                div.style.boxSizing = 'content-box';
                div.setAttribute('title', 'Unlock Node');
                div.innerHTML = `<span class="popper-icon">${lock_open}</span>`;
                this.setPopperStyle(dimension, div);
                div.onclick = () => this.unpinNode(node);
                (_a = this.popperContainer) === null || _a === void 0 ? void 0 : _a.appendChild(div);
                return div;
            },
        });
        node.on('position', () => this.updatePopper(node));
        this.renderer.cy.on('pan zoom resize', () => this.updatePopper(node));
    }
    unpinAll() {
        var _a;
        (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.$('[?pinned]').each(node => this.unpinNode(node));
    }
    setPopperStyle(dim, popper) {
        let icon = popper.querySelector('.popper-icon > svg');
        icon.style.display = 'inherit';
        icon.style.color = 'var(--gscape-color-fg-on-emphasis)';
        if (dim > 2) {
            popper.style.width = dim + 'px';
            popper.style.height = dim + 'px';
            popper.style.display = 'flex';
            if (dim > 8) {
                icon.setAttribute('width', dim + 'px');
                icon.setAttribute('height', dim + 'px');
            }
            else if (dim - 10 > 0) {
                icon.setAttribute('width', (dim - 10) + 'px');
                icon.setAttribute('height', (dim - 10) + 'px');
            }
            else {
                icon.style.display = 'none';
            }
        }
        else {
            icon.style.display = 'none';
            popper.style.display = 'none';
        }
    }
    updatePopper(node) {
        if (!node.unlockButton || !this.renderer.cy)
            return;
        let unlockButton = node.unlockButton;
        let dimension = node.data('width') / 9 * this.renderer.cy.zoom();
        this.setPopperStyle(dimension, unlockButton.state.elements.popper);
        unlockButton.update();
    }
    unpinNode(nodeOrId) {
        if (!nodeOrId || !this.renderer.cy)
            return;
        let node;
        if (typeof (nodeOrId) === 'string') {
            node = this.renderer.cy.$id(nodeOrId);
        }
        else {
            node = nodeOrId;
        }
        this.removeUnlockButton(node);
        node.unlock();
        node.data("pinned", false);
    }
    removeUnlockButton(node) {
        if (node.unlockButton) {
            node.unlockButton.state.elements.popper.remove();
            node.unlockButton.destroy();
            node.unlockButton = null;
        }
    }
    setDragAndPinEventHandlers() {
        var _a, _b;
        (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.on('grab', this.grabHandler);
        (_b = this.renderer.cy) === null || _b === void 0 ? void 0 : _b.on('free', this.freeHandler);
        // this.renderer.cy.$('[?pinned]').each(n => {
        //   //n.on('position', () => this.updatePopper(n))
        //   this.renderer.cy.on('pan zoom resize', () => this.updatePopper(n))
        // })
    }
    get defaultLayoutOptions() {
        return {
            name: 'cola',
            avoidOverlap: false,
            edgeLength: function (edge) {
                let crowdnessFactor = edge.target().neighborhood(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`).length +
                    edge.source().neighborhood(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`).length;
                crowdnessFactor = crowdnessFactor > 5 ? crowdnessFactor * 10 : 0;
                if (edge.hasClass('role')) {
                    return 250 + edge.data('displayedName').length * 4 + crowdnessFactor;
                }
                else if (edge.target().data('type') == TypesEnum.DATA_PROPERTY ||
                    edge.source().data('type') == TypesEnum.DATA_PROPERTY)
                    return 150;
                else {
                    return 200 + crowdnessFactor;
                }
            },
            fit: true,
            maxSimulationTime: 4000,
            infinite: false,
            handleDisconnected: true,
            centerGraph: false,
        };
    }
    centerOnElementById(elementId, zoom, select) {
        const cy = this.renderer.cy;
        if (!cy || (!zoom && zoom !== 0))
            return;
        const cyElement = cy.$id(elementId).first();
        zoom = zoom > cy.maxZoom() ? cy.maxZoom() : zoom;
        if (cyElement.empty()) {
            console.warn(`Element id (${elementId}) not found. Please check that this is the correct diagram`);
        }
        else {
            const previousFitValue = this.defaultLayoutOptions.fit;
            if (this.layoutRunning) {
                // run layout not fitting it, avoid conflict with fitting view on element
                this.floatyLayoutOptions.fit = false;
                this.runLayout();
                // keep element centered while layout runs
                cyElement.isNode() ? cyElement.lock() : cyElement.connectedNodes().lock();
                if (this.isLayoutInfinite) {
                    // if layout is infinite, do not wait for it to stop
                    // just wait 5 seconds and restore previous conditions
                    setTimeout(() => {
                        cyElement.isNode() ? cyElement.unlock() : cyElement.connectedNodes().unlock();
                        if (this.floatyLayoutOptions.fit !== previousFitValue && this.layoutRunning) {
                            this.floatyLayoutOptions.fit = previousFitValue;
                            this.runLayout();
                        }
                    }, 5000);
                }
                else {
                    // if layout is finite, wait for it to stop and restore previous conditions
                    this.layout.one('layoutstop', (layoutEvent) => {
                        if (layoutEvent.layout === this.layout) {
                            cyElement.isNode() ? cyElement.unlock() : cyElement.connectedNodes().unlock();
                            this.floatyLayoutOptions.fit = previousFitValue;
                        }
                        else {
                            this.centerOnElementById(elementId, zoom, select);
                        }
                    });
                }
            }
            cy.animate({
                center: {
                    eles: cyElement
                },
                zoom: zoom,
                queue: false,
            });
            if (select && cy.$(':selected') !== cyElement) {
                this.renderer.unselect();
                cyElement.select();
            }
        }
    }
    get floatyLayoutOptions() {
        return this.renderer.renderStateData[this.id].layoutOptions;
    }
    set floatyLayoutOptions(newOptions) {
        this.renderer.renderStateData[this.id].layoutOptions = newOptions;
    }
    get isLayoutInfinite() {
        return this.floatyLayoutOptions.infinite ? true : false;
    }
    get dragAndPin() { return this.renderer.renderStateData[this.id].dragAndPing; }
    set dragAndPin(isActive) {
        this.renderer.renderStateData[this.id].dragAndPing = isActive;
        if (!isActive)
            this.unpinAll();
    }
    get popperContainer() {
        if (this.renderer.diagram)
            return this.popperContainers.get(this.renderer.diagram.id);
    }
    get popperContainers() {
        return this.renderer.renderStateData[this.id].popperContainers;
    }
    get layout() {
        return this._layout;
    }
}

/**
 * Incremental should not allow any filter and widgtet should not even be visible
 */
class IncrementalFilterManager extends BaseFilterManager {
    constructor() {
        super(...arguments);
        this.lockedFilters = Object.keys(RDFGraphConfigFiltersEnum).map(k => RDFGraphConfigFiltersEnum[k]);
    }
}

function incrementalStyle (theme) {
    const baseStyle = floatyStyle(theme);
    const incrementalStyle = [
        {
            selector: '.incremental-expanded-class',
            style: {
                'border-width': 4,
                'background-blacken': 0.1,
            }
        },
        {
            selector: `node[type = "${TypesEnum.CLASS_INSTANCE}"]`,
            style: {
                backgroundColor: theme.getColour(ColoursNames.class_instance),
                "border-color": theme.getColour(ColoursNames.class_instance_contrast),
            }
        },
        {
            selector: `node[type = "${TypesEnum.CLASS_INSTANCE}"]:selected`,
            style: {
                'text-background-color': theme.getColour(ColoursNames.bg_graph),
                'text-background-opacity': 1,
            }
        },
        {
            selector: `edge[type = "${TypesEnum.INSTANCE_OF}"]`,
            style: {
                "target-arrow-shape": 'triangle',
                'target-arrow-fill': 'filled',
                'line-color': theme.getColour(ColoursNames.class_instance_contrast),
                'target-arrow-color': theme.getColour(ColoursNames.class_instance_contrast),
                'line-opacity': 0.4,
            }
        },
        {
            selector: `.unknown-parent-class`,
            style: {
                backgroundColor: theme.getColour(ColoursNames.neutral)
            }
        },
        {
            selector: '.path',
            style: {
                'underlay-opacity': 0.5,
                'underlay-color': theme.getColour(ColoursNames.success_subtle),
                'underlay-shape': 'ellipse'
            }
        },
        {
            selector: '.loading-edge',
            style: {
                width: 4,
                "line-color": theme.getColour(ColoursNames.neutral),
                "transition-property": "line-color target-arrow-color",
                "transition-duration": '0.5s',
                'text-rotation': 'autorotate',
                'target-arrow-color': theme.getColour(ColoursNames.neutral),
                'font-size': 12,
                'text-background-color': theme.getColour(ColoursNames.bg_graph),
                label: 'Loading...',
            }
        },
        {
            selector: '.loading-edge[?on]',
            style: {
                "line-color": theme.getColour(ColoursNames.accent),
                "target-arrow-color": theme.getColour(ColoursNames.accent)
            }
        },
        {
            selector: '.eh-ghost-edge, edge.eh-preview',
            style: {
                'width': 4,
                'label': 'Find path to...',
                'line-color': theme.getColour(ColoursNames.accent),
                'target-arrow-color': theme.getColour(ColoursNames.accent),
                'target-arrow-shape': 'triangle',
                'opacity': 0.8,
                'text-rotation': 'autorotate',
            }
        },
        {
            selector: '.eh-ghost-edge.eh-preview-active',
            style: {
                'opacity': 0,
            }
        },
        {
            selector: '.eh-target, .eh-source',
            style: {
                'border-width': 4,
                'border-color': theme.getColour(ColoursNames.accent),
            }
        },
        {
            selector: '.eh-presumptive-target',
            style: {
                'opacity': 1,
            }
        },
        {
            selector: '.eh-not-target',
            style: {
                'opacity': 0.4,
            }
        },
    ];
    return baseStyle.concat(incrementalStyle);
}

/**
 * The incremental renderer state is a kind of floaty renderer state in which
 * ontology's diagrams are used only to compute what to show.
 * There is only a single empty diagram and any render() call just render the same diagram
 * no matter what was the input diagram.
 *
 * This renderer state is logic agnostic, meaning that it does not control what to show and when.
 * You can decide what to show/hide outside, based on lifecycle and/or other custom developed widgets.
 */
class IncrementalRendererState extends FloatyRendererState {
    constructor() {
        super(...arguments);
        this.id = RendererStatesEnum.INCREMENTAL;
        this.filterManager = new IncrementalFilterManager();
    }
    render() {
        var _a, _b, _c, _d;
        if (this.renderer.diagram && ((_a = this.renderer.diagram) === null || _a === void 0 ? void 0 : _a.id) !== IncrementalDiagram.ID) {
            this.previousDiagram = this.renderer.diagram;
        }
        if (!this.renderer.diagram)
            return;
        const incrementalRepresentation = this.renderer.diagram.representations.get(this.id);
        if (!incrementalRepresentation)
            return;
        this.renderer.cy = incrementalRepresentation.cy;
        this.renderer.mount();
        if (this.renderer.diagram.lastViewportState) {
            (_b = this.renderer.cy) === null || _b === void 0 ? void 0 : _b.viewport(this.renderer.diagram.lastViewportState);
        }
        if (!incrementalRepresentation.hasEverBeenRendered) {
            if (this.popperContainer) {
                (_d = (_c = this.renderer.cy) === null || _c === void 0 ? void 0 : _c.container()) === null || _d === void 0 ? void 0 : _d.appendChild(this.popperContainer);
            }
        }
        incrementalRepresentation.hasEverBeenRendered = true;
    }
    runLayout() {
        super.runLayout();
        if (this.isLayoutInfinite) {
            this.unFreezeGraph();
        }
        else {
            this.layout.one('layoutstop', (e) => {
                var _a, _b;
                if (((_b = (_a = this.renderer.diagram) === null || _a === void 0 ? void 0 : _a.representations.get(this.id)) === null || _b === void 0 ? void 0 : _b.grapholElements.size) === 1)
                    this.renderer.fit();
                if (e.layout === this._layout)
                    this.unFreezeGraph();
            });
        }
    }
    runCustomLayout(cyLayoutOptions) {
        Object.assign(this.floatyLayoutOptions, cyLayoutOptions);
        this.runLayout();
        this.floatyLayoutOptions = this.defaultLayoutOptions;
    }
    /** lock all nodes */
    freezeGraph() {
        var _a;
        if (!this.layoutRunning)
            (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.nodes().lock();
    }
    /** unlock all nodes that are not pinned (pinned can be unlocked only with unpin) */
    unFreezeGraph() {
        var _a;
        (_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.$("[!pinned]:locked").unlock();
    }
    stopRendering() {
        super.stopRendering();
        this.renderer.diagram = this.previousDiagram;
    }
    transformOntology(ontology) {
        var _a;
        // Perform floaty transformation if it has not been done yet
        if (!((_a = ontology.diagrams[0]) === null || _a === void 0 ? void 0 : _a.representations.get(RendererStatesEnum.FLOATY))) {
            ontology.diagrams.forEach(diagram => {
                const floatyTransformer = new FloatyTransformer();
                diagram.representations.set(RendererStatesEnum.FLOATY, floatyTransformer.transform(diagram));
            });
            computeHierarchies(ontology);
        }
    }
    getGraphStyle(theme) {
        return incrementalStyle(theme);
    }
    reset() {
        var _a, _b;
        if ((_a = this.renderer.diagram) === null || _a === void 0 ? void 0 : _a.id) {
            (_b = this.popperContainers.get(this.renderer.diagram.id)) === null || _b === void 0 ? void 0 : _b.childNodes.forEach(c => c.remove());
        }
        this.render();
    }
    set renderer(newRenderer) {
        super.renderer = newRenderer;
        if (!newRenderer.renderStateData[this.id]) {
            newRenderer.renderStateData[this.id] = {};
        }
        // this.floatyLayoutOptions = this.defaultLayoutOptions
        // this.floatyLayoutOptions.fit = false
        // this.floatyLayoutOptions.maxSimulationTime = 1000
        // this.floatyLayoutOptions.edgeLength = function (edge: EdgeSingular) {
        //   let crowdnessFactor =
        //     edge.target().neighborhood(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`).length +
        //     edge.source().neighborhood(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`).length
        //   crowdnessFactor = crowdnessFactor > 5 ? crowdnessFactor * 2 : 0
        //   const nameLength = edge.data('displayedName')?.length * 5 || 0
        //   return 140 + crowdnessFactor + nameLength
        // }
        // this.floatyLayoutOptions.avoidOverlap = true
        // this.floatyLayoutOptions.randomize = true
        // this.floatyLayoutOptions.centerGraph = true
        // this.floatyLayoutOptions.boundingBox = {
        //   x1: 0,
        //   y1: 0,
        //   w: 500,
        //   h: 500
        // }
        // this.floatyLayoutOptions.flow = { axis: 'x', minSeparation: 100 }
    }
    get renderer() {
        return super.renderer;
    }
    get defaultLayoutOptions() {
        return {
            name: 'cola',
            avoidOverlap: true,
            edgeLength: function (edge) {
                var _a;
                let crowdnessFactor = edge.target().neighborhood(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`).length +
                    edge.source().neighborhood(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`).length;
                crowdnessFactor = crowdnessFactor > 5 ? crowdnessFactor * 2 : 0;
                const nameLength = ((_a = edge.data('displayedName')) === null || _a === void 0 ? void 0 : _a.length) * 5 || 0;
                return 140 + crowdnessFactor + nameLength;
            },
            fit: false,
            maxSimulationTime: 1000,
            infinite: false,
            handleDisconnected: true,
            centerGraph: false,
        };
    }
}

function setGraphEventHandlers(diagram, lifecycle, ontology) {
    diagram.representations.forEach(diagramRepresentation => {
        const cy = diagramRepresentation.cy;
        if (cy.scratch('_gscape-graph-handlers-set'))
            return;
        cy.on('select', e => {
            const grapholElement = diagramRepresentation.grapholElements.get(e.target.id());
            if (grapholElement) {
                if (grapholElement.isEntity() && !grapholElement.is(TypesEnum.CLASS_INSTANCE)) {
                    const grapholEntity = ontology.getEntity(e.target.data().iri);
                    if (grapholEntity) {
                        lifecycle.trigger(LifecycleEvent.EntitySelection, grapholEntity, grapholElement);
                    }
                }
                if (isGrapholNode(grapholElement)) {
                    lifecycle.trigger(LifecycleEvent.NodeSelection, grapholElement);
                }
                if (isGrapholEdge(grapholElement)) {
                    lifecycle.trigger(LifecycleEvent.EdgeSelection, grapholElement);
                }
            }
        });
        cy.on('tap', evt => {
            if (evt.target === cy) {
                lifecycle.trigger(LifecycleEvent.BackgroundClick);
            }
        });
        cy.on('cxttap', evt => lifecycle.trigger(LifecycleEvent.ContextClick, evt));
        cy.on('dbltap', evt => lifecycle.trigger(LifecycleEvent.DoubleTap, evt));
        cy.on('mouseover', '*', e => {
            const container = cy.container();
            if (container) {
                container.style.cursor = 'pointer';
            }
        });
        cy.on('mouseout', '*', e => {
            const container = cy.container();
            if (container) {
                container.style.cursor = 'inherit';
            }
        });
        cy.scratch('_gscape-graph-handlers-set', true);
    });
}

/**
 * @internal
 */
class ThemeManager {
    constructor(grapholscape) {
        this.themes = Object.values(DefaultThemes);
        this._grapholscape = grapholscape;
    }
    setTheme(newThemeId) {
        const newTheme = this.themes.find(t => t.id === newThemeId);
        if (newTheme) {
            this.setMissingColours(newTheme);
            this.theme = newTheme;
            Object.entries(newTheme.colours).forEach(([colourName, colour]) => {
                this._grapholscape.container.style.setProperty(`${CSS_PROPERTY_NAMESPACE}-${colourName}`, colour);
            });
            this._grapholscape.renderer.setTheme(newTheme);
            this._grapholscape.lifecycle.trigger(LifecycleEvent.ThemeChange, newTheme);
            storeConfigEntry('selectedTheme', newThemeId);
        }
    }
    addTheme(newTheme) {
        this.themes.push(newTheme);
    }
    removeThemes() {
        this.themes = [];
    }
    setMissingColours(theme) {
        // Set default theme colours for missing colours
        Object.entries(gscapeColourMap).forEach(([colourName, colourValue]) => {
            const _colourName = colourName;
            if (!theme.getColour(_colourName))
                theme.setColour(_colourName, colourValue);
        });
    }
}

class Grapholscape {
    constructor(ontology, container, config) {
        this.renderer = new Renderer();
        this.availableRenderers = [
            RendererStatesEnum.GRAPHOL,
            RendererStatesEnum.GRAPHOL_LITE,
            RendererStatesEnum.FLOATY,
            RendererStatesEnum.INCREMENTAL
        ];
        this.lifecycle = new Lifecycle();
        this.entityNavigator = new EntityNavigator(this);
        this.displayedNamesManager = new DisplayedNamesManager(this);
        this.themesManager = new ThemeManager(this);
        this.widgets = new Map();
        // ----------------------------- LIFECYCLE ----------------------------- //
        /**
         * Register a callback for a given event.
         * @remarks
         * Check {@link !model.LifecycleEvent} and {@link !model.IonEvent} for the
         * full list of events/callbacks types
         * @param event The event for which register a callback.
         * @param callback Function to call when the specified event occurs
         *
         * @example reacting to a node selection
         * ```js
         *  import { LifecycleEvent } from 'grapholscape'
         *
         *  // ...init grapholscape
         *
         * grapholscape.on(LifecycleEvent.NodeSelection, (selectedNode) => {
         *  // here you can do whatever you want with selectedNode, like printing its shape
         *  console.log(selectedNode.shape)
         * })
         * ```
         */
        this.on = this.lifecycle.on;
        this.ontology = ontology;
        this.container = container;
        this.renderer.container = container;
        this.renderer.lifecycle = this.lifecycle;
        //this.renderer.renderState = new GrapholRendererState()
        if (!(config === null || config === void 0 ? void 0 : config.selectedTheme)) {
            this.themesManager.setTheme(DefaultThemesEnum.GRAPHOLSCAPE);
        }
        if (config) {
            this.setConfig(config);
        }
    }
    // ----------------------------- RENDERER ----------------------------- //
    /**
     * Show a certain diagram by its ID
     * @param diagramId the diagram's id to display
     * @param viewportState set a custom {@link !model.ViewportState}, if not set, last one available will be used
     */
    showDiagram(diagramId, viewportState) {
        var _a, _b;
        const diagram = this.ontology.getDiagram(diagramId);
        if (!diagram) {
            console.warn(`Can't find any diagram with id="${diagramId}"`);
            return;
        }
        if (this.renderState && !((_b = (_a = diagram.representations) === null || _a === void 0 ? void 0 : _a.get(this.renderState)) === null || _b === void 0 ? void 0 : _b.hasEverBeenRendered))
            setGraphEventHandlers(diagram, this.lifecycle, this.ontology);
        if (viewportState)
            diagram.lastViewportState = viewportState;
        this.renderer.render(diagram);
    }
    /**
     * Change the current renderer (Graphol - Lite - Floaty).
     *
     * @remarks
     * A RendererState is an implementation for the {@link !model.iRenderState} interface
     * that changes the way the {@link Renderer} performs the main operations on a
     * {@link !model.Diagram} such as rendering it and filtering elements in it.
     * The renderer states included in Grapholscape are: {@link GrapholRendererState},
     * {@link LiteRendererState} and {@link FloatyRendererState}.
     *
     * @param newRenderState the renderer state instance to set, if you want to reuse
     * these instances it's totally up to you.
     *
     *
     * @example
     * ```ts
     * // Setting the floaty renderer state
     * import { FloatyRendererState } from 'grapholscape'
     *
     * grapholscape.setRenderer(new FloatyRendererState())
     * ```
     */
    setRenderer(newRenderState) {
        var _a, _b, _c, _d;
        const shouldUpdateEntities = (this.diagramId !== 0 && !this.diagramId) || !((_a = this.ontology.getDiagram(this.diagramId)) === null || _a === void 0 ? void 0 : _a.representations.get(newRenderState.id)) ? true : false;
        if (!((_b = this.ontology.diagrams[0]) === null || _b === void 0 ? void 0 : _b.representations.get(newRenderState.id))) {
            newRenderState.transformOntology(this.ontology);
        }
        if (this.renderer.diagram && !((_d = (_c = this.renderer.diagram) === null || _c === void 0 ? void 0 : _c.representations.get(newRenderState.id)) === null || _d === void 0 ? void 0 : _d.hasEverBeenRendered))
            setGraphEventHandlers(this.renderer.diagram, this.lifecycle, this.ontology);
        this.renderer.renderState = newRenderState;
        if (shouldUpdateEntities)
            this.entityNavigator.updateEntitiesOccurrences();
        this.lifecycle.trigger(LifecycleEvent.RendererChange, newRenderState.id);
    }
    /**
     * Center the viewport on a single element.
     * @remarks
     * If you specify a different diagram from the current one, it will be displayed
     * @param elementId the element's id (can be a node or an edge)
     * @param diagramId the diagram's id (**default**: the current one)
     * @param zoom the level zoom to apply, do not pass it if you don't want zoom to change
     */
    centerOnElement(elementId, diagramId, zoom) {
        if ((diagramId || diagramId === 0) && this.diagramId !== diagramId)
            this.showDiagram(diagramId);
        this.renderer.centerOnElementById(elementId, zoom);
    }
    /**
     * Select an element in a diagram.
     * @remarks
     * If you specify a different diagram from the current one, it will be displayed
     * @param elementId the element's id (can be a node or an edge)
     * @param diagramId the diagram's id (**default**: the current one)
     */
    selectElement(elementId, diagramId) {
        if ((diagramId || diagramId === 0) && this.diagramId !== diagramId)
            this.showDiagram(diagramId);
        this.renderer.selectElement(elementId);
    }
    /** Unselect any selected element in the current diagram */
    unselect() { this.renderer.unselect(); }
    /** Fit viewport to diagram */
    fit() { this.renderer.fit(); }
    /**
     * Apply a certain level of zoom
     * @param value level of zoom to set
     */
    zoom(value) { this.renderer.zoom(value); }
    /**
     * Increase the zooom level by a certain amount
     * @param amount the amount of zoom to add
     */
    zoomIn(amount) { this.renderer.zoomIn(amount); }
    /**
     * Decrease the zooom level by a certain amount
     * @param amount the amount of zoom to remove
     */
    zoomOut(amount) { this.renderer.zoomOut(amount); }
    /**
     * Filter elements on the diagram.
     * @remarks
     * It will be currently applied only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be applied.
     * @param filter the filter to apply, can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    filter(filter) { this.renderer.filter(filter); }
    /**
     * Unfilter elements on the diagram.
     * @remarks
     * It will be currently deactivated only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be deactivated.
     * @param filter the filter to disable, can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    unfilter(filter) { this.renderer.unfilter(filter); }
    /** The current diagram's id */
    get diagramId() {
        var _a;
        return (_a = this.renderer.diagram) === null || _a === void 0 ? void 0 : _a.id;
    }
    /** The current renderer state */
    get renderState() {
        var _a;
        return (_a = this.renderer.renderState) === null || _a === void 0 ? void 0 : _a.id;
    }
    /** The current selected Entity */
    get selectedEntity() {
        var _a;
        const selectedElement = this.renderer.selectedElement;
        if (selectedElement === null || selectedElement === void 0 ? void 0 : selectedElement.isEntity())
            return this.ontology.getEntity((_a = this.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(selectedElement.id).data().iri);
    }
    /** An array of available renderer's state for this Grapholscape instance */
    get renderers() { return this.availableRenderers; }
    // ------------------------- ENTITY NAVIGATOR ------------------------- //
    /**
     * Center viewport on a single entity occurrence given its IRI
     * @param iri the iri of the entity to find and center on
     * @param diagramId the diagram containing the entity.
     * If not specified, the first entity occurrence in any diagram will be used.
     * @param zoom the level of zoom to apply.
     * If not specified, zoom level won't be changed.
     */
    centerOnEntity(iri, diagramId, zoom) {
        this.entityNavigator.centerOnEntity(iri, diagramId, zoom);
    }
    /**
     * Center viewport on a single entity occurrence and selects it given its IRI
     * @param iri the iri of the entity to find and center on
     * @param diagramId the diagram containing the entity.
     * If not specified, the first entity occurrence in any diagram will be used.
     * @param zoom the level of zoom to apply.
     * If not specified, zoom level won't be changed.
     */
    selectEntity(iri, diagramId, zoom) {
        this.entityNavigator.selectEntity(iri, diagramId, zoom);
    }
    // ---------------------- DISPLAYED NAMES MANAGER ---------------------- //
    /**
     * Change the displayed entity's names.
     * @param newEntityNametype the entity name type to set
     */
    setEntityNameType(newEntityNametype) {
        this.displayedNamesManager.setEntityNameType(newEntityNametype);
    }
    /**
     * Change the language used for the labels and comments
     * @remarks The language must be supported by the ontology or the first available
     * language for a given label/comment wil be used as fallback
     * @param newLanguage the language to set {@link !config.Language}
     */
    setLanguage(newLanguage) {
        this.displayedNamesManager.setLanguage(newLanguage);
    }
    /** The current selected language */
    get language() { return this.displayedNamesManager.language; }
    /** The current selected entity name type (label, full iri or prefixed iri) */
    get entityNameType() { return this.displayedNamesManager.entityNameType; }
    // -------------------------- THEMES MANAGER -------------------------- //
    /**
     * Apply a given theme
     * @param themeId the theme's ID
     */
    setTheme(themeId) {
        this.themesManager.setTheme(themeId);
    }
    /**
     * @ignore
     * // TODO: make this method update settings widget before publishing in docs
     * Add a new theme in the list of available themes
     * @param newTheme the new theme
     * @experimental
     */
    addTheme(newTheme) {
        this.themesManager.addTheme(newTheme);
    }
    /** The current theme used by Grapholscape */
    get theme() { return this.themesManager.theme; }
    /** The available themes for this Grapholscape instance */
    get themeList() { return this.themesManager.themes; }
    // -------------------------------- UI -------------------------------- //
    /**
     * The container in which Grapholscape places the UI components.
     * You can use this container to add new widgets or dialogs if you want to.
     */
    get uiContainer() { return this.container.querySelector('.gscape-ui'); }
    /**
     * The container in which the bottom-right buttons are placed.
     * You can use this container to add your own Buttons if you want to.
     */
    get buttonsTray() { var _a; return (_a = this.uiContainer) === null || _a === void 0 ? void 0 : _a.querySelector('.gscape-ui-buttons-tray'); }
    // ------------------------------ CONFIG ------------------------------ //
    /**
     * @ignore
     * @privateRemarks // TODO: Be sure this method reflects on UI before publishing it in to the docs
     * Apply a new custom configuration
     * @param newConfig the config object to apply
     * @experimental
     */
    setConfig(newConfig) {
        if (newConfig.language) {
            this.displayedNamesManager.setLanguage(newConfig.language);
        }
        if (newConfig.entityNameType) {
            this.displayedNamesManager.setEntityNameType(newConfig.entityNameType);
        }
        if (newConfig.renderers) {
            this.availableRenderers = newConfig.renderers;
        }
        let rendererStateToSet = undefined;
        /**
         * If only one renderer defined, just use it
         */
        if (this.availableRenderers.length <= 1) {
            rendererStateToSet = this.availableRenderers[0];
        }
        /**
         * If selected renderer is included in the list of renderers, use it.
         * The other ones will be managed by renderer-selector widget
         * or manually by the app importing grapholscape.
         */
        else if (newConfig.selectedRenderer && this.availableRenderers.includes(newConfig.selectedRenderer)) {
            rendererStateToSet = newConfig.selectedRenderer;
        }
        if (rendererStateToSet) {
            switch (rendererStateToSet) {
                case RendererStatesEnum.GRAPHOL: {
                    this.setRenderer(new GrapholRendererState());
                    break;
                }
                case RendererStatesEnum.GRAPHOL_LITE: {
                    this.setRenderer(new LiteRendererState());
                    break;
                }
                case RendererStatesEnum.FLOATY: {
                    this.setRenderer(new FloatyRendererState());
                    break;
                }
                case RendererStatesEnum.INCREMENTAL: {
                    this.setRenderer(new IncrementalRendererState());
                    break;
                }
            }
        }
        if (newConfig.themes) {
            this.themesManager.removeThemes();
            newConfig.themes.forEach(newTheme => {
                const _castedNewTheme = newTheme;
                // It's a default theme id
                if (DefaultThemes[newTheme]) {
                    this.themesManager.addTheme(DefaultThemes[newTheme]);
                }
                // It's a custom theme
                else if (_castedNewTheme.id) {
                    this.themesManager.addTheme(new GrapholscapeTheme(_castedNewTheme.id, _castedNewTheme.colours, _castedNewTheme.name));
                }
            });
        }
        if (newConfig.selectedTheme && this.themeList.map(theme => theme.id).includes(newConfig.selectedTheme)) {
            this.themesManager.setTheme(newConfig.selectedTheme);
        }
        else if (!this.themeList.includes(this.theme)) {
            this.themesManager.setTheme(this.themeList[0].id);
        }
        if (newConfig.widgets) {
            this.widgetsInitialStates = newConfig.widgets;
        }
    }
    // ---------------------------- EXPORTING ---------------------------- //
    /**
     * Export current diagram and download it as a PNG image.
     * @param fileName custom file name. Defaults to {@link exportFileName}
     */
    exportToPng(fileName = this.exportFileName) {
        fileName += '.png';
        toPNG(fileName, this.renderer.cy, this.theme.getColour(ColoursNames.bg_graph));
    }
    /**
     * Export current diagram and download it as an SVG.
     * @param fileName custom file name. Defaults to {@link exportFileName}
     */
    exportToSvg(fileName = this.exportFileName) {
        fileName += '.svg';
        toSVG(fileName, this.renderer.cy, this.theme.getColour(ColoursNames.bg_graph));
    }
    exportToRdfGraph() {
        const rdfGraph = rdfgraphSerializer(this);
        console.log(rdfGraph);
        return rdfGraph;
    }
    /**
     * Filename for exports.
     * String in the form: "[ontology name]-[diagram name]-v[ontology version]"
     */
    get exportFileName() {
        var _a;
        return `${this.ontology.name}-${(_a = this.renderer.diagram) === null || _a === void 0 ? void 0 : _a.name}-v${this.ontology.version}`;
    }
}

var grapholscapeLogo = x `<?xml version="1.0" encoding="utf-8"?>
<svg version="1.1" id="Livello_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 1024 792.6" style="enable-background:new 0 0 1024 792.6;" xml:space="preserve">
<style type="text/css">
	.st0{fill:url(#SVGID_1_);}
	.st1{fill:#FFFFFF;}
	.st2{enable-background:new    ;}
	.st3{fill:url(#SVGID_2_);}
</style>
<g>
	<g id="Logo">

			<radialGradient id="SVGID_1_" cx="502.1" cy="894.61" r="662.91" gradientTransform="matrix(1 0 0 1 12.76 -283.3)" gradientUnits="userSpaceOnUse">
			<stop  offset="0" style="stop-color:#5B86E5"/>
			<stop  offset="0.34" style="stop-color:#509CE2"/>
			<stop  offset="1" style="stop-color:#36D1DC"/>
		</radialGradient>
		<path class="st0" d="M512,506c-138.1,0-250-111.9-250-250c0-66.3,26.3-129.9,73.2-176.8c97.6-97.6,256-97.6,353.6,0
			s97.6,256,0,353.6C642,479.8,578.3,506.2,512,506z"/>
		<path class="st1" d="M512,11.9c134.8,0,244.1,109.3,244.1,244.2c0,98.1-58.7,186.6-149.1,224.8c-124.2,52.5-267.4-5.7-319.9-129.9
			S292.8,83.6,417,31.1C447.1,18.4,479.4,11.9,512,11.9 M512,0C370.6,0,256,114.6,256,256s114.6,256,256,256s256-114.6,256-256
			S653.4,0,512,0z"/>
		<path class="st1" d="M513.6,432c-12.4,0-24.4-4.9-33.1-13.7L344.1,282c-18.3-18.3-18.3-48,0-66.3L513.6,46.2l40.3,40.3
			L391.6,248.8l122,122l122-122L594.7,208l-81.2,81.1l-40.3-40.3l88.3-88.3c18.3-18.3,48-18.3,66.3,0l55.2,55.2
			c18.3,18.3,18.3,48,0,66.3L546.7,418.3C537.9,427.1,526,432,513.6,432z"/>
		<g class="st2">
			<path d="M83,594.8c5.3,0,10.2,0.3,14.7,0.8s8.9,1.3,13.1,2.2c4.2,1,8.2,2.1,12.1,3.5s7.9,2.9,11.9,4.5v12.6
				c-3.2-2-6.5-3.9-10.1-5.7s-7.4-3.3-11.6-4.7c-4.1-1.3-8.6-2.4-13.3-3.2c-4.7-0.8-9.8-1.2-15.3-1.2c-11.1,0-20.8,1.2-29.1,3.5
				s-15.2,5.7-20.6,10c-5.5,4.3-9.6,9.6-12.4,15.8c-2.7,6.2-4.1,13.2-4.1,21c0,7.3,1.3,14,4,20.1s6.8,11.4,12.2,15.8
				c5.5,4.4,12.3,7.9,20.5,10.4s17.8,3.7,28.9,3.7c4.3,0,8.6-0.2,12.9-0.5c4.2-0.3,8.3-0.8,12-1.3c3.8-0.5,7.2-1.1,10.3-1.7
				c3.1-0.6,5.7-1.3,7.9-2V664H80.7v-9.7h56.9v50.3c-4.1,1.4-8.3,2.7-12.4,3.8c-4.2,1.1-8.5,2-13,2.8c-4.5,0.7-9.1,1.3-13.9,1.7
				s-9.8,0.6-15.1,0.6c-10.8,0-20.7-1.2-30-3.6c-9.2-2.4-17.2-6.1-23.9-11s-12-11.1-15.9-18.5c-3.8-7.4-5.7-16.2-5.7-26.2
				c0-6.7,0.9-12.8,2.7-18.3s4.3-10.5,7.5-14.9s7.2-8.3,11.7-11.5c4.6-3.3,9.7-6,15.2-8.1c5.6-2.1,11.6-3.7,18-4.8
				C69.3,595.3,76,594.8,83,594.8z"/>
			<path d="M181.2,662.2v48.9h-10.4V596.8h56.9c8.7,0,16.2,0.7,22.4,2c6.2,1.4,11.3,3.4,15.3,6.2c4,2.7,6.9,6.2,8.7,10.3
				c1.8,4.1,2.7,8.9,2.7,14.4c0,8.5-2.2,15.4-6.7,20.5s-11.7,8.6-21.7,10.5l39,50.4h-13.1l-36.9-49.3c-1.6,0.1-3.1,0.2-4.7,0.2
				c-1.6,0.1-3.3,0.1-5,0.1L181.2,662.2L181.2,662.2z M266.1,629.7c0-4.9-0.9-8.8-2.6-11.9c-1.7-3-4.5-5.4-8.4-7s-9-2.8-15.3-3.4
				c-6.3-0.6-14-0.9-23.2-0.9h-35.5v45.9h35.1c9.2,0,16.9-0.3,23.2-0.8s11.5-1.6,15.4-3.2c3.9-1.6,6.8-3.9,8.5-6.9
				C265.3,638.6,266.1,634.6,266.1,629.7z"/>
			<path d="M417.4,711.2L401.7,681h-77.6l-15.7,30.2H297l59.8-114.3H369l59.8,114.3H417.4z M362.9,606.9l-33.8,64.6h67.5
				L362.9,606.9z"/>
			<path d="M562.8,632c0,5.7-0.9,10.8-2.8,15.1c-1.9,4.4-4.8,8.1-8.8,11.1s-9.1,5.3-15.4,6.8c-6.3,1.5-13.9,2.3-22.8,2.3h-51.3v43.9
				h-10.4V596.8H513c8.9,0,16.5,0.8,22.8,2.3s11.4,3.8,15.4,6.7s6.9,6.6,8.8,11C561.8,621.2,562.8,626.2,562.8,632z M552.1,632
				c0-5.4-0.9-9.8-2.7-13.1s-4.6-5.9-8.3-7.7s-8.5-3-14.2-3.6s-12.6-0.9-20.4-0.9h-44.7v50.9h44.7c3.1,0,6.3,0,9.8,0
				s6.9-0.1,10.3-0.5c3.4-0.4,6.6-1,9.7-1.9s5.8-2.3,8.2-4.2s4.2-4.4,5.7-7.4C551.4,640.5,552.1,636.6,552.1,632z"/>
			<path d="M703.6,711.2v-55.6H601.2v55.6h-10.4V596.8h10.4v49.3h102.4v-49.3H714v114.3h-10.4V711.2z"/>
			<path d="M889.7,654.1c0,10.3-1.9,19.1-5.6,26.6c-3.7,7.5-8.8,13.6-15.3,18.5s-14.1,8.4-23,10.8s-18.3,3.5-28.5,3.5
				c-10.3,0-19.8-1.2-28.7-3.5s-16.6-5.9-23.1-10.8c-6.5-4.9-11.7-11-15.4-18.5s-5.6-16.3-5.6-26.6c0-6.8,0.9-13,2.6-18.6
				c1.7-5.6,4.1-10.6,7.2-15c3.1-4.4,6.9-8.2,11.3-11.4c4.4-3.2,9.3-5.9,14.7-8s11.2-3.7,17.4-4.7s12.7-1.5,19.5-1.5
				c10.2,0,19.7,1.2,28.5,3.5s16.5,5.9,23,10.8c6.5,4.9,11.6,11,15.3,18.5C887.8,635,889.7,643.8,889.7,654.1z M879,654.1
				c0-8.1-1.3-15.3-4-21.5c-2.6-6.2-6.5-11.4-11.7-15.7c-5.2-4.2-11.6-7.5-19.3-9.7s-16.6-3.3-26.8-3.3s-19.1,1.1-26.9,3.3
				c-7.7,2.2-14.2,5.5-19.4,9.7s-9.2,9.5-11.8,15.7s-4,13.4-4,21.3c0,8.1,1.3,15.3,4,21.5s6.6,11.4,11.8,15.7
				c5.2,4.2,11.7,7.5,19.4,9.7s16.7,3.3,26.9,3.3s19.1-1.1,26.8-3.3s14.1-5.4,19.3-9.7c5.2-4.2,9.1-9.5,11.7-15.7
				C877.7,669.3,879,662.2,879,654.1z"/>
			<path d="M920.2,711.2V596.8h10.4v104.6h83.5v9.7h-93.9V711.2z"/>
		</g>

			<radialGradient id="SVGID_2_" cx="513.05" cy="1101.48" r="466.86" gradientTransform="matrix(1 0 0 1 0 -286)" gradientUnits="userSpaceOnUse">
			<stop  offset="0" style="stop-color:#5B86E5"/>
			<stop  offset="0.34" style="stop-color:#509CE2"/>
			<stop  offset="1" style="stop-color:#36D1DC"/>
		</radialGradient>
		<path class="st3" d="M389.9,700.8h244.3c16.8,0,30.4,13.6,30.4,30.4v27.4c0,16.8-13.6,30.4-30.4,30.4H389.9
			c-16.8,0-30.4-13.6-30.4-30.4v-27.4C359.4,714.4,373,700.8,389.9,700.8L389.9,700.8L389.9,700.8z"/>
		<path class="st1" d="M634.2,704.3c14.8,0,26.8,12,26.8,26.9v27.4c0,14.8-12,26.9-26.9,26.9l0,0H389.9c-14.8,0-26.9-12-26.9-26.9
			v-27.4c0-14.8,12-26.9,26.9-26.9l0,0H634.2 M634.2,697.2H389.9c-18.8,0-34,15.2-34,34v27.4c0,18.8,15.2,34,34,34h244.3
			c18.8,0,34-15.2,34-34v-27.4C668.2,712.4,652.9,697.2,634.2,697.2L634.2,697.2z"/>
		<g class="st2">
			<path class="st1" d="M385,764.8c-3.7-0.9-6.6-2-8.6-3.3l3-4c2.1,1.2,4.7,2.2,7.8,3c3.1,0.8,6.4,1.2,9.8,1.2
				c4.5,0,7.9-0.5,10.1-1.6c2.2-1.1,3.3-2.6,3.3-4.5c0-1.4-0.6-2.4-1.8-3.2c-1.2-0.8-2.7-1.4-4.5-1.8c-1.8-0.4-4.2-0.8-7.3-1.2
				c-4-0.6-7.3-1.1-9.7-1.7c-2.5-0.6-4.5-1.6-6.3-3c-1.7-1.4-2.6-3.4-2.6-5.9c0-3.1,1.7-5.7,5.2-7.7c3.5-2,8.3-3,14.4-3
				c3.2,0,6.4,0.3,9.6,1c3.2,0.6,5.9,1.5,7.9,2.5l-2.9,4c-4.1-2.1-9-3.2-14.6-3.2c-4.3,0-7.5,0.6-9.7,1.7c-2.2,1.1-3.3,2.6-3.3,4.5
				c0,1.4,0.6,2.6,1.8,3.4c1.2,0.9,2.8,1.5,4.6,1.9c1.8,0.4,4.3,0.8,7.6,1.2c4,0.6,7.1,1.1,9.5,1.7c2.4,0.6,4.4,1.5,6.1,2.9
				s2.5,3.3,2.5,5.7c0,3.3-1.8,5.9-5.4,7.8c-3.6,1.9-8.6,2.9-15.1,2.9C392.6,766.1,388.7,765.7,385,764.8z"/>
			<path class="st1" d="M436.9,763.7c-3.9-1.6-6.9-3.9-9.1-6.8c-2.2-2.9-3.3-6.2-3.3-9.8c0-3.6,1.1-6.9,3.3-9.8
				c2.2-2.9,5.2-5.1,9.1-6.7c3.9-1.6,8.3-2.4,13.2-2.4c4.3,0,8.1,0.6,11.5,1.9c3.4,1.3,6,3.1,8,5.5l-5,2.6c-1.6-1.8-3.7-3.2-6.2-4.2
				c-2.5-0.9-5.3-1.4-8.2-1.4c-3.6,0-6.8,0.6-9.7,1.8c-2.9,1.2-5.1,2.9-6.7,5.1s-2.4,4.8-2.4,7.6c0,2.9,0.8,5.4,2.4,7.6
				c1.6,2.2,3.8,3.9,6.7,5.1c2.9,1.2,6.1,1.8,9.7,1.8c3,0,5.7-0.4,8.2-1.3c2.5-0.9,4.6-2.3,6.2-4.1l5,2.6c-2,2.4-4.6,4.2-8,5.5
				c-3.4,1.3-7.2,1.9-11.4,1.9C445.1,766.1,440.7,765.3,436.9,763.7z"/>
			<path class="st1" d="M514.9,731.8c3.5,2.4,5.2,6,5.2,10.8v23.1h-6.4v-5.8c-1.5,1.9-3.7,3.5-6.7,4.5c-2.9,1.1-6.4,1.6-10.4,1.6
				c-5.5,0-9.9-1-13.2-3c-3.3-2-4.9-4.6-4.9-7.9c0-3.2,1.5-5.7,4.6-7.7c3.1-1.9,7.9-2.9,14.6-2.9h15.8v-2.3c0-3.2-1.2-5.7-3.6-7.3
				c-2.4-1.7-5.9-2.5-10.5-2.5c-3.1,0-6.2,0.4-9.1,1.2c-2.9,0.8-5.4,1.9-7.5,3.2l-3-3.8c2.5-1.6,5.5-2.9,9.1-3.7
				c3.5-0.9,7.2-1.3,11.1-1.3C506.5,728.1,511.5,729.3,514.9,731.8z M507.4,760.2c2.7-1.3,4.7-3.2,6-5.6v-6.1h-15.6
				c-8.5,0-12.7,2.2-12.7,6.7c0,2.2,1.1,3.9,3.3,5.1c2.2,1.3,5.3,1.9,9.3,1.9C501.4,762.1,504.7,761.5,507.4,760.2z"/>
			<path class="st1" d="M576.6,730.5c3.8,1.6,6.7,3.8,8.9,6.7c2.1,2.9,3.2,6.2,3.2,9.9c0,3.7-1.1,7.1-3.2,9.9
				c-2.1,2.9-5.1,5.1-8.8,6.7c-3.7,1.6-8,2.4-12.7,2.4c-4,0-7.7-0.6-10.9-1.9c-3.2-1.3-5.9-3.1-8-5.5v20.8h-6.7v-51.1h6.4v7.4
				c2-2.5,4.7-4.4,8-5.7s7-2,11.2-2C568.6,728.1,572.8,728.9,576.6,730.5z M572.9,759.8c2.8-1.2,5.1-2.9,6.7-5.1
				c1.6-2.2,2.4-4.8,2.4-7.6s-0.8-5.4-2.4-7.6c-1.6-2.2-3.8-3.9-6.7-5.1c-2.8-1.2-6-1.8-9.4-1.8c-3.5,0-6.7,0.6-9.5,1.8
				c-2.8,1.2-5,2.9-6.6,5.1s-2.4,4.7-2.4,7.6s0.8,5.4,2.4,7.6c1.6,2.2,3.8,3.9,6.6,5.1s6,1.8,9.5,1.8
				C566.9,761.6,570.1,761,572.9,759.8z"/>
			<path class="st1" d="M645.6,748.6h-41.5c0.4,3.9,2.4,7,5.9,9.4c3.6,2.4,8.1,3.6,13.6,3.6c3.1,0,5.9-0.4,8.5-1.2
				c2.6-0.8,4.8-2,6.7-3.7l3.8,3.3c-2.2,2-5,3.5-8.3,4.5c-3.3,1-6.9,1.6-10.9,1.6c-5.1,0-9.6-0.8-13.6-2.5c-3.9-1.6-7-3.9-9.2-6.8
				c-2.2-2.9-3.3-6.2-3.3-9.8c0-3.6,1.1-6.9,3.2-9.8c2.1-2.9,5-5.1,8.7-6.7c3.7-1.6,7.8-2.4,12.4-2.4c4.6,0,8.7,0.8,12.4,2.4
				c3.7,1.6,6.5,3.8,8.6,6.7c2.1,2.9,3.1,6.1,3.1,9.8L645.6,748.6z M609.6,735.9c-3.2,2.3-5.1,5.3-5.5,9h35.2
				c-0.4-3.7-2.3-6.7-5.5-9c-3.2-2.3-7.3-3.4-12.1-3.4C616.8,732.5,612.8,733.6,609.6,735.9z"/>
		</g>
	</g>
</g>
</svg>`;

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    classIcon: classIcon,
    objectPropertyIcon: objectPropertyIcon,
    dataPropertyIcon: dataPropertyIcon,
    individualIcon: individualIcon,
    classInstanceIcon: classInstanceIcon,
    grapholscapeLogo: grapholscapeLogo,
    diagrams: diagrams,
    triangle_up: triangle_up,
    triangle_down: triangle_down,
    arrow_right: arrow_right,
    arrowDown: arrowDown,
    explore: explore,
    info_outline: info_outline,
    enterFullscreen: enterFullscreen,
    exitFullscreen: exitFullscreen,
    centerDiagram: centerDiagram,
    filter: filter,
    bubbles: bubbles,
    lite: lite,
    settings_icon: settings_icon,
    infoFilled: infoFilled,
    plus: plus,
    minus: minus,
    save: save,
    lock_open: lock_open,
    close: close,
    blankSlateDiagrams: blankSlateDiagrams,
    check: check,
    searchOff: searchOff,
    move_bubbles: move_bubbles,
    owl_icon: owl_icon,
    graphol_icon: graphol_icon,
    tune: tune,
    settings_play: settings_play,
    filterOff: filterOff,
    incremental: incremental,
    refresh: refresh,
    instancesIcon: instancesIcon,
    superHierarchies: superHierarchies,
    subHierarchies: subHierarchies,
    rubbishBin: rubbishBin,
    mastroEndpointIcon: mastroEndpointIcon,
    stopCircle: stopCircle,
    equivalentClasses: equivalentClasses,
    search: search$1,
    insertInGraph: insertInGraph,
    cross: cross,
    counter: counter,
    labelIcon: labelIcon,
    commentIcon: commentIcon,
    authorIcon: authorIcon,
    addDiagramIcon: addDiagramIcon,
    addEntityIcon: addEntityIcon,
    addDataPropertyIcon: addDataPropertyIcon,
    addClassInstanceIcon: addClassInstanceIcon,
    addObjectPropertyIcon: addObjectPropertyIcon,
    addISAIcon: addISAIcon,
    addParentClassIcon: addParentClassIcon,
    addChildClassIcon: addChildClassIcon,
    addSubhierarchyIcon: addSubhierarchyIcon,
    addInputIcon: addInputIcon,
    renameIcon: renameIcon,
    editIcon: editIcon,
    sankey: sankey,
    pathIcon: pathIcon,
    entityIcons: entityIcons,
    annotationIcons: annotationIcons
});

const animationDuration = i$1 `200ms`;
const BOTTOM_RIGHT_WIDGET = i$1 `bottom-right-widget`;
var baseStyle$3 = i$1 `
*, :host {
  line-height: initial;
  scrollbar-width: thin;
  pointer-events: auto;
}

:host(.${BOTTOM_RIGHT_WIDGET}) {
  border-radius: var(--gscape-border-radius-btn);
  border: 1px solid var(--gscape-color-border-subtle);
  background-color: var(--gscape-color-bg-default);
}

:host(.${BOTTOM_RIGHT_WIDGET}:hover) {
  border-color: var(--gscape-color-border-default);
}

.background-propagation, .background-propagation * {
  background: inherit;
}

.gscape-panel {
  font-size: 12px;
  background-color: var(--gscape-color-bg-default);
  box-shadow: 0 2px 10px 0 var(--gscape-color-shadow);
  border-radius: var(--gscape-border-radius);
  border: solid 1px var(--gscape-color-border-subtle);
  width: fit-content;
  min-width: 130px;
  max-width: 350px;
  max-height: 350px;
  overflow: auto;
  padding: 8px;
  position: relative;
}

::-webkit-scrollbar {
  width: 2px;
  height: 2px;
}

::-webkit-scrollbar:hover {
  width: 4px;
  height: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--gscape-color-fg-muted);
  -webkit-border-radius: 1ex;
}

.gscape-panel-in-tray {
  position: absolute;
  right: 100%;
  bottom: 0;
  margin-right: 4px;
  white-space: nowrap;
  animation-name: drop-left;
  animation-duration: ${animationDuration};
  overflow: hidden;
  text-overflow: ellipsis;
  padding-right: 0;
  padding-left: 0;
}

.gscape-panel-in-tray.hanging {
  bottom: initial;
  transform: translate(0, calc(-50% - 17px));
}

.gscape-panel-in-tray > .content-wrapper {
  overflow: hidden auto;
  scrollbar-width: inherit;
  max-height: 320px;
  padding: 0px 8px;
  position: relative;
}

.slotted-icon, [slot = "icon"], [slot = "alt-icon"], [slot = "trailing-icon"] {
  line-height: 0;
}

.actionable {
  border-radius: var(--gscape-border-radius-btn);
  padding: 6px 8px;
  cursor: pointer;
}

.actionable:hover, .actionable:focus, .actionable:focus-visible {
  background-color: var(--gscape-color-neutral);
}

.actionable:active {
  filter: brightness(90%);
}

.selected-item::before {
  content: '.';
  position: static;
  background-color: var(--gscape-color-accent);
  color: var(--gscape-color-accent);
  border-radius: var(--gscape-border-radius);
  margin: 4px 0;
}

.selected-item > .actionable {
  background-color: var(--gscape-color-neutral);
  font-weight: 600;
}

.primary {
  color: var(--gscape-color-accent);
}

.hide {
  display: none !important;
}

.drop-down {
  position:absolute;
  margin-top: 4px;
  top: 100%;
  animation-name: drop-down;
  animation-duration: ${animationDuration};
  z-index: 999;
}

@keyframes drop-down {
  from {opacity: 0; top: -20%;}
  to {opacity: 1; top: 100%;}
}

.drop-left {
  animation-name: drop-left;
  animation-duration: ${animationDuration};
}

@keyframes drop-left {
  from {opacity: 0; position: absolute; right: -10px;}
  to {opacity: 1; right: 100%;}
}

.drop-right {
  animation-name: drop-right;
  animation-duration: ${animationDuration};
}

@keyframes drop-right {
  from {opacity: 0; position: absolute; left: -10px;}
  to {opacity: 1;  left: 100%;}
}

.blank-slate {
  display:flex;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  text-align: center;
}

.blank-slate > svg {
  height: 36px;
  width: 36px;
  margin-bottom: 12px;
}

.blank-slate > .header {
  font-weight: 600;
}

.blank-slate > .description {
  font-size: 12px;
  color: var(--gscape-color-fg-subtle);
}

.hr {
  height:1px;
  width:90%;
  margin: 0 auto;
  background-color: var(--gscape-color-border-subtle)
}

.header {
  font-weight: 600;
  margin: 8px 16px;
}

.gscape-panel-in-tray > .header {
  margin-top: 0;
  text-align: center;
}

.muted-text {
  color: var(--gscape-color-fg-muted);
}

.ellipsed, .ellipsed * {
  overflow-x: hidden;
  text-overflow: ellipsis ellipsis;
}

.rtl {
  direction: rtl;
  text-align: left;
}

.bold-text {
  font-weight: 600;
}

select {
  background: var(--gscape-color-neutral-subtle);
  border: solid 1px var(--gscape-color-border-subtle);
  color: inherit;
  padding: 8px 12px;
  font-size: inherit;
  border-radius: var(--gscape-border-radius);
  cursor: pointer;
}

select:focus, input:focus {
  border-color: var(--gscape-color-accent);
  box-shadow: var(--gscape-color-accent) 0px 0px 0px 1px inset;
  outline: currentcolor none 0px;
}

input {
  line-height: inherit;
  border: solid 1px var(--gscape-color-border-subtle);
  padding: 6px 12px;
  border-radius: var(--gscape-border-radius);
  background: var(--gscape-color-bg-inset);
  color: inherit;
  display: inline-block;
  box-sizing: border-box;
}

.link {
  text-decoration: underline;
  cursor: pointer;
  color: var(--gscape-color-accent);
}

.section-body {
  padding: 0px 8px;
}

.section-header {
  margin-bottom: 4px;
}

.chip, .chip-neutral {
  display: inline-flex;
  border: 1px solid var(--gscape-color-accent);
  color: var(--gscape-color-accent);
  border-radius: 16px;
  padding: 2px 6px;
  background: var(--gscape-color-accent-subtle);
  margin: 1px 2px;
}

.chip-neutral {
  border: 1px solid var(--gscape-color-neutral-muted);
  color: var(--gscape-color-fg-muted);
  background: var(--gscape-color-neutral);
}

.area {
  background: var(--gscape-color-bg-inset);
  border-radius: calc(var(--gscape-border-radius) - 2px);
  padding: 4px 4px 4px 6px;
  border: solid 1px var(--gscape-color-border-subtle);
  margin-bottom: 18px;
}

.tip {
  font-size: 90%;
  border-bottom: dotted 2px;
  cursor: help;
}

.tip: hover {
  color:inherit;
}
`;

var GscapeButtonStyle = i$1 `
:host {
  display: inline-block;
}

.btn {
  border-radius: var(--gscape-border-radius-btn);
  border: 1px solid var(--gscape-color-border-subtle);
  font-family: inherit;
  white-space: nowrap;
  cursor: pointer;
  user-select: none;
  text-decoration: none;
  text-align: center;
  background-color: var(--gscape-color-bg-default);
  line-height: 20px;
  display: inline-flex;
  align-items: center;
  position: relative;
  color: inherit;
  width: inherit;
  max-width: inherit;
  min-width: inherit;
}

.btn[label] {
  gap: 8px;
  justify-content: space-between;
}

.btn:hover {
  background-color: var(--gscape-color-neutral);
  border-color: var(--gscape-color-border-default);
}

.btn:active {
  background-color: var(--gscape-color-neutral-muted);
}

.btn[active] {
  color: var(--gscape-color-accent);
}

.btn[disabled] {
  opacity: 50%;
  cursor: initial;
  pointer-events: none;
}

.btn-s {
  font-size: 12px;
  padding: 3px 4px;
}

.btn-s[label] {
  padding-left: 8px;
  padding-right: 8px;
}


.btn-m {
  font-size: 14px;
  padding: 5px 6px;
}

.btn-m[label] {
  padding-left: 16px;
  padding-right: 16px;
}

.btn-l {
  font-size: 16px;
  padding: 7px 8px;
}

.btn-l[label] {
  padding-left: 32px;
  padding-right: 32px;
}

.btn.primary, .primary-box {
  background-color: var(--gscape-color-accent);
  color: var(--gscape-color-fg-on-emphasis);
}

.btn.subtle, .subtle-box {
  background-color: transparent;
  border: none;
  box-shadow: none;
}

.btn.subtle:hover {
  background-color: var(--gscape-color-neutral);
}

.btn.subtle:active {
  background-color: var(--gscape-color-neutral-muted);
}

.btn.subtle:hover > .btn-label {
  color: var(--gscape-color-accent);
}

.btn-label {
  font-weight: 600;
  line-height: 20px;
  flex-shrink: 1;
}
`;

var SizeEnum$1;
(function (SizeEnum) {
    SizeEnum["S"] = "s";
    SizeEnum["M"] = "m";
    SizeEnum["L"] = "l";
})(SizeEnum$1 || (SizeEnum$1 = {}));
class GscapeButton$1 extends s {
    // static get styles() {
    //   let super_styles = super.styles
    //   let colors = super_styles[1]
    //   return [
    //     super_styles[0],
    //     css`
    //       :host {
    //         box-shadow: 0 0 4px 0 var(--theme-gscape-shadows, ${colors.shadows});
    //         padding: calc(var(--gscape-icon-size) * 0.2 );
    //         cursor: pointer;
    //       }
    //       :host(:hover){
    //         box-shadow: 0 0 8px 0 var(--theme-gscape-shadows, ${colors.shadows});
    //         color: var(--theme-gscape-secondary, ${colors.secondary});
    //       }
    //       .btn {
    //         display: flex;
    //         align-items: center;
    //       }
    //       .btn-label {
    //         font-weight: var(--gscape-button-font-weight, 600);
    //         padding: 0 5px 0 8px;
    //       }
    //       .btn[active] {
    //         color: var(--theme-gscape-secondary, ${colors.secondary});
    //       }
    //       .btn[disabled] {
    //         opacity: 20%;
    //         cursor: initial;
    //         pointer-events: none;
    //       }
    //       svg {
    //         height: inherit;
    //         width: inherit;
    //       }
    //     `
    //   ]
    // }
    constructor() {
        super();
        this.size = SizeEnum$1.M;
        this.toggled = false;
        this.asSwitch = false;
        this.active = false;
        this.disabled = false;
        this.label = '';
    }
    render() {
        return x `
      <button
        class="btn btn-${this.size} ${this.type}"
        ?label="${this.label}"
        ?disabled = "${this.disabled}"
        ?active = "${this.active}"
        @click = "${this.clickHandler}"
      >

      ${this.toggled && this.altIcon
            ? x `<slot name="alt-icon" class="slotted-icon"></slot>`
            : x `<slot name="icon" class="slotted-icon"></slot>`}

      ${this.label ? x `<span class="btn-label ellipsed">${this.label}<span>` : ``}

      <slot name="trailing-icon" class="slotted-icon"></slot>
      </button>
    `;
    }
    clickHandler() {
        this.toggled = !this.toggled;
        if (!this.disabled && this.asSwitch)
            this.active = !this.active;
    }
    get altIcon() {
        return this.querySelector('[slot = "alt-icon"]');
    }
}
GscapeButton$1.properties = {
    active: { type: Boolean, reflect: true },
    label: { type: String, reflect: true },
    title: { type: String, reflect: true },
    disabled: { type: Boolean, reflect: true },
    asSwitch: { type: Boolean, attribute: 'as-switch', reflect: true },
    size: { type: String, reflect: true },
    type: { type: String, reflect: true },
    fullWidth: { type: String, attribute: 'full-width', reflect: true },
    toggled: { type: Boolean, state: true }
};
GscapeButton$1.styles = [baseStyle$3, GscapeButtonStyle];
customElements.define('gscape-button', GscapeButton$1);

function getIconSlot$1 (slotName, icon) {
    const span = document.createElement('span');
    span.innerHTML = icon.strings[0];
    span.setAttribute('slot', slotName);
    return span;
}

const BaseMixin$3 = (superClass) => {
    class BaseMixinClass extends superClass {
        constructor() {
            super(...arguments);
            this.enabled = true;
            this.display = this.style.display;
            this.onStateChange = () => { };
        }
        hide() {
            if (this.enabled && this.style.display !== 'none') {
                this.display = this.style.display;
                this.style.display = 'none';
            }
        }
        show() {
            if (this.enabled && this.style.display === 'none')
                this.style.display = this.display;
        }
        showInPosition(position) {
            if (this.style.position !== 'absolute') {
                console.warn('Grapholscape: showInPosition() has no effect with position different from absolute or relative');
            }
            this.show();
            if (position) {
                this.style.top = position.y + "px";
                this.style.left = position.x + "px";
            }
        }
        enable() {
            this.enabled = true;
            this.show();
            this.onStateChange();
        }
        disable() {
            this.hide();
            this.enabled = false;
            this.onStateChange();
        }
        get isVisible() { return this.enabled && this.style.display !== 'none'; }
    }
    // Cast return type to your mixin's interface intersected with the superClass type
    return BaseMixinClass;
};

// Define the interface for the mixin
const DropPanelMixin = (superClass) => {
    class DropPanelMixinClass extends superClass {
        constructor() {
            super(...arguments);
            this.isDefaultClosed = true;
            this.onblur = (ev) => {
                ev.stopPropagation();
                ev.preventDefault();
                const target = ev.relatedTarget;
                if (target && !this.contains(target)) {
                    this.blur();
                }
            };
            this.onTogglePanel = () => { };
        }
        get panel() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#drop-panel'); }
        togglePanel() {
            this.isPanelClosed() ? this.openPanel() : this.closePanel();
            this.onTogglePanel();
        }
        openPanel() {
            var _a;
            (_a = this.panel) === null || _a === void 0 ? void 0 : _a.classList.remove('hide');
            this.requestUpdate();
            // Blur other widgets in bottom-right-buttons-tray, keep only one panel open at time
            const container = this.parentElement;
            if (container && container.classList.contains('gscape-ui-buttons-tray')) {
                for (const siblingElement of container.children) {
                    if (siblingElement !== this)
                        siblingElement.blur();
                }
            }
        }
        closePanel() {
            var _a;
            if (!this.isPanelClosed()) {
                (_a = this.panel) === null || _a === void 0 ? void 0 : _a.classList.add('hide');
                this.requestUpdate();
            }
        }
        blur() {
            super.blur();
            this.closePanel();
        }
        isPanelClosed() {
            if (this.panel) {
                return this.panel.classList.contains('hide');
            }
            else {
                return this.isDefaultClosed;
            }
        }
    }
    // Cast return type to your mixin's interface intersected with the superClass type
    return DropPanelMixinClass;
};
function hasDropPanel(element) {
    return element.togglePanel ? true : false;
}

const ModalMixin$3 = (superClass) => {
    class ModalMixinClass extends superClass {
        constructor(..._) {
            super();
            this.modalBackground = document.createElement('div');
            this.style.cssText = `
        z-index: 100;
        position: relative;
        height: 100%;
        width: 100%;
        display: block;
      `;
            this.modalBackground.style.cssText = `
        position: absolute;
        top: 0;
        width: 100%;
        height: 100%;
        background: var(--gscape-color-bg-default);
        opacity: 0.6;
        display: none;
      `;
            this.hide();
        }
        show() {
            super.show();
            // (this as unknown as HTMLElement).style.zIndex = '2';
            this.showModalBackground();
        }
        hide() {
            super.hide();
            this.style.zIndex = '';
            this.hideModalBackground();
        }
        showModalBackground() {
            var _a, _b;
            this.modalBackground.style.display = 'initial';
            const thisElem = this;
            (_a = thisElem.shadowRoot) === null || _a === void 0 ? void 0 : _a.insertBefore(this.modalBackground, (_b = thisElem.shadowRoot) === null || _b === void 0 ? void 0 : _b.firstElementChild);
        }
        hideModalBackground() {
            this.modalBackground.style.display = 'none';
        }
    }
    // Cast return type to your mixin's interface intersected with the superClass type
    return ModalMixinClass;
};

const ContextualWidgetMixin = (superClass) => {
    class ContextualWidgetMixinClass extends superClass {
        constructor() {
            super(...arguments);
            this.tippyWidget = tippy(document.createElement('div'));
            this.cxtWidgetProps = {
                trigger: 'manual',
                allowHTML: true,
                interactive: true,
                placement: "bottom",
                appendTo: ((ref) => {
                    return document.querySelector('.gscape-ui') || ref;
                }) || undefined,
                // content prop can be used when the target is a single element https://atomiks.github.io/tippyjs/v6/constructor/#prop
                content: this,
                offset: [0, 0],
            };
            this.oncontextmenu = (e) => e.preventDefault();
        }
        attachTo(element) {
            this._attachTo(element);
            this.tippyWidget.show();
        }
        attachToSilently(element) {
            this._attachTo(element);
        }
        _attachTo(element) {
            this.tippyWidget.setProps(this.cxtWidgetProps);
            this.tippyWidget.setProps({ getReferenceClientRect: () => element.getBoundingClientRect() });
        }
        hide() {
            this.tippyWidget.hide();
        }
    }
    // Cast return type to your mixin's interface intersected with the superClass type
    return ContextualWidgetMixinClass;
};

const textSpinner = () => x `<div title="Loading" class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>`;
const textSpinnerStyle = i$1 `
  .lds-ellipsis {
    display: inline-block;
    position: relative;
    width: 20px;
    height: 1em;
  }
  .lds-ellipsis div {
    position: absolute;
    top: calc(1em / 2);
    width: 3px;
    height: 3px;
    border-radius: 50%;
    background: var(--gscape-color-fg-subtle);
    animation-timing-function: cubic-bezier(0, 1, 1, 0);
  }
  .lds-ellipsis div:nth-child(1) {
    left: 2px;
    animation: lds-ellipsis1 0.6s infinite;
  }
  .lds-ellipsis div:nth-child(2) {
    left: 2px;
    animation: lds-ellipsis2 0.6s infinite;
  }
  .lds-ellipsis div:nth-child(3) {
    left: 8px;
    animation: lds-ellipsis2 0.6s infinite;
  }
  .lds-ellipsis div:nth-child(4) {
    left: 14px;
    animation: lds-ellipsis3 0.6s infinite;
  }
  @keyframes lds-ellipsis1 {
    0% {
      transform: scale(0);
    }
    100% {
      transform: scale(1);
    }
  }
  @keyframes lds-ellipsis3 {
    0% {
      transform: scale(1);
    }
    100% {
      transform: scale(0);
    }
  }
  @keyframes lds-ellipsis2 {
    0% {
      transform: translate(0, 0);
    }
    100% {
      transform: translate(6px, 0);
    }
  }
`;

function getContentSpinner() {
    return x `<div class="lds-ring" title="Loading"><div></div><div></div><div></div><div></div></div>`;
}
const contentSpinnerStyle = i$1 `
  .lds-ring {
    width: 20px;
    height: 20px;
  }

  .lds-ring div {
    box-sizing: border-box;
    display: block;
    position: absolute;
    width: 16px;
    height: 16px;
    margin: 2px;
    border: 2px solid var(--gscape-color-accent);
    border-radius: 50%;
    animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    border-color: var(--gscape-color-accent) transparent transparent transparent;
  }
  .lds-ring div:nth-child(1) {
    animation-delay: -0.45s;
  }
  .lds-ring div:nth-child(2) {
    animation-delay: -0.3s;
  }
  .lds-ring div:nth-child(3) {
    animation-delay: -0.15s;
  }
  @keyframes lds-ring {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
class ContentSpinner extends s {
    constructor() {
        super(...arguments);
        this.render = getContentSpinner;
    }
    setColor(newColor) {
        this.style.setProperty('--gscape-color-accent', newColor);
    }
}
ContentSpinner.styles = [
    contentSpinnerStyle,
    i$1 `
      :host {
        display: inline-block;
        position: relative;
        top: 50%;
        transform: translate(-50%, -50%);
        left: 50%;
      }
    `
];
ContentSpinner.properties = {
    color: { type: String }
};
customElements.define('gscape-content-spinner', ContentSpinner);

class NodeButton extends ContextualWidgetMixin(BaseMixin$3(s)) {
    constructor(content, contentType = 'icon') {
        super();
        this.content = content;
        this.contentType = contentType;
        this.cxtWidgetProps = {
            trigger: 'manual',
            allowHTML: true,
            interactive: true,
            placement: "right",
            appendTo: ((ref) => {
                return document.querySelector('.gscape-ui') || ref;
            }) || undefined,
            // content prop can be used when the target is a single element https://atomiks.github.io/tippyjs/v6/constructor/#prop
            content: this,
            offset: [0, 0],
            hideOnClick: false,
            sticky: true,
        };
    }
    render() {
        return x `
      <div
        class="gscape-panel btn ${this.highlighted ? 'primary' : ''}"
        style="${this.contentType === 'icon' ? 'border-radius: 50%;' : ''}"
      >
      ${this.contentType === 'icon'
            ? getIconSlot$1('icon', this.content)
            : this.content}
      </div>
    `;
    }
}
NodeButton.properties = {
    content: { type: Object },
    contentType: { type: String, reflect: true },
    highlighted: { type: Boolean, reflect: true },
};
NodeButton.styles = [
    baseStyle$3,
    textSpinnerStyle,
    contentSpinnerStyle,
    GscapeButtonStyle,
    i$1 `
      .gscape-panel {
        padding: 4px;
        min-width: 20px;
        justify-content: center;
      }

      .highlighted {
        border-color: var(--gscape-color-accent);
      }
    `
];
customElements.define('gscape-node-button', NodeButton);

class GscapeContextMenu$1 extends ContextualWidgetMixin(BaseMixin$3(s)) {
    constructor() {
        super(...arguments);
        this.commands = [];
        this.customElements = [];
        this.showFirst = 'elements';
        this.onCommandRun = () => { };
    }
    render() {
        return x `
    <div class="gscape-panel">
      ${this.title ? x `<div>${this.title}</div>` : null}
      ${this.showFirst === 'elements' ? this.customElementsTemplate : null}
      
      ${this.showFirst === 'elements' && this.customElements.length > 0 && this.commands.length > 0
            ? x `<div class="hr"></div>` : null}

      ${this.commandsTemplate}

      ${this.showFirst === 'commands' && this.customElements.length > 0 && this.commands.length > 0
            ? x `<div class="hr"></div>` : null}


      ${this.showFirst === 'commands' ? this.customElementsTemplate : null}
    </div>
    `;
    }
    // Attach context menu to a given html element
    attachTo(element, commands, elements) {
        super.attachTo(element);
        this.commands = commands || [];
        this.customElements = elements || [];
    }
    // Attach menu to nothing, show it in arbitrary position
    attachToPosition(position, container, commands, elements) {
        const dummyDiv = document.createElement('div');
        dummyDiv.style.position = 'absolute';
        dummyDiv.style.top = position.y + "px";
        dummyDiv.style.left = position.x + "px";
        container.appendChild(dummyDiv);
        super.attachTo(dummyDiv);
        this.commands = commands || [];
        this.customElements = elements || [];
        const oldOnHide = this.cxtWidgetProps.onHide;
        this.cxtWidgetProps.onHide = (instance) => {
            dummyDiv.remove();
            this.cxtWidgetProps.onHide = undefined;
            if (oldOnHide) {
                oldOnHide(instance);
                //restore oldOnHide
                this.cxtWidgetProps.onHide = oldOnHide;
            }
        };
    }
    handleCommandClick(e) {
        const command = this.commands[e.currentTarget.getAttribute('command-id')];
        if (command.select) {
            command.select();
            this.onCommandRun();
            this.hide();
        }
    }
    get commandsTemplate() {
        if (this.commands.length > 0)
            return x `
        <div class="commands">
          ${this.commands.map((command, id) => {
                return x `
              <div class="command-entry actionable" command-id="${id}" @click=${this.handleCommandClick}>
                ${command.icon ? x `<span class="command-icon slotted-icon">${command.icon}</span>` : null}
                <span class="command-text">${command.content}</span>
              <div>
            `;
            })}
        </div>
      `;
    }
    get customElementsTemplate() {
        if (this.customElements.length > 0)
            return x `
        <div class="custom-elements">
          ${this.customElements.map(c => x `<div class="custom-element-wrapper">${c}</div>`)}
        </div>    
      `;
    }
}
GscapeContextMenu$1.properties = {
    commands: { type: Object, attribute: false },
    customElements: { type: Object, attribute: false },
    showFirst: { type: String },
};
GscapeContextMenu$1.styles = [
    baseStyle$3,
    i$1 `
      :host {
        display: flex;
        flex-direction: column;
        padding: 5px 0;
      }

      .command-entry {
        white-space: nowrap;
        cursor: pointer;
        padding: 5px 10px;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .command-text {
        line-height: 20px;
      }

      .gscape-panel, .custom-elements {
        overflow: unset;
        display: flex;
        flex-direction: column;
        gap: 8px;
        justify-content: center;
        align-items: stretch;
      }
    `
];
customElements.define('gscape-context-menu', GscapeContextMenu$1);

var actionItemStyle = i$1 `
  .list-item {
    display: flex;
    gap: 8px;
    width: 100%;
  }

  .list-item.selected-item::before {
    margin-right: -4px;
  }

  .list-item-label {
    align-self: center;
  }

  .list-item.actionable {
    padding-right: 18px;
  }

  .list-item[disabled] {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

class GscapeActionListItem extends s {
    constructor() {
        super();
        this.expanded = false;
        this.disabled = false;
        this.tabIndex = 0;
    }
    render() {
        return x `
      <li class="list-item ${this.selected && !this.subtle ? 'selected-item' : null} ellipsed" @click=${this.clickHandler} ?disabled=${this.disabled}>
        <div class="list-item actionable" @click=${this.clickHandler}>
          <slot name="icon" class="slotted-icon" ></slot>
          <span class="list-item-label" title=${this.label}>${this.label}</span>
          <slot name="trailing-icon" class="slotted-icon" ></slot>

          ${this.expanded
            ? x `<slot name="hidden-content" class="slotted-icon" ></slot>`
            : null}
        </div>
      </li>
    `;
    }
    clickHandler() {
        if (this.hiddenContent) {
            this.expanded = !this.expanded;
        }
    }
    get hiddenContent() { return this.querySelector('[slot = "hidden-content"]'); }
}
GscapeActionListItem.properties = {
    label: { type: String, reflect: true },
    subtle: { type: Boolean },
    selected: { type: Boolean },
    expanded: { state: true },
    disabled: { type: Boolean }
};
GscapeActionListItem.styles = [baseStyle$3, actionItemStyle];
customElements.define('gscape-action-list-item', GscapeActionListItem);

var entityListItemStyle = i$1 `
  div.entity-list-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 8px;
    flex-wrap: var(--custom-wrap, initial);
    min-height: var(--custom-min-height, unset);
  }

  .entity-list-item {
    white-space: nowrap;
  }

  .entity-list-item:hover, .entity-list-item:focus {
    background: var(--gscape-color-neutral-subtle);
    border-radius: var(--gscape-border-radius-btn);
  }

  div.entity-list-item > .slotted-icon, summary > .slotted-icon {
    flex-shrink: 0;
  }

  details.entity-list-item > summary {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .entity-list-item .entity-name {
    flex-grow: 2;
  }

  details.entity-list-item > .summary-body {
    background-color: var(--gscape-color-bg-inset);
    white-space: normal;
    padding: 4px 8px;
  }

  details.entity-list-item > summary {
    padding: 6px 8px 6px 4px;
  }

  details.entity-list-item[open] {
    border: solid 1px var(--gscape-color-border-subtle);
    border-radius: var(--gscape-border-radius);
    margin-bottom: 8px;
  }

  slot[name="accordion-body"]::slotted(*) {
    background-color: var(--gscape-color-bg-inset);
    padding: 4px 8px;
  }

  slot {
    white-space: normal;
  }

  .entity-list-item[disabled] {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

class GscapeIconList extends s {
    constructor() {
        super(...arguments);
        this.icons = [];
    }
    render() {
        return x `
      <div class="icons background-propagation">
        ${this.icons.map(i => {
            return x `
            <div class="icon-item">
              <div class="icon-img slotted-icon">${i}
            </div>
          `;
        })}
      </div>
    `;
    }
}
GscapeIconList.properties = {
    icons: { type: Array }
};
GscapeIconList.styles = [
    baseStyle$3,
    i$1 `
    :host {
      display: inline-block;
    }

    .icons {
      display: flex;
    }

    .icon-item:first-of-type {
      margin-left: 0;
      padding-left: 0;
    }
    
    .icon-item {
      /* Nagative margin make icons overlap to previous one */
      margin-left: -0.5rem;
      border-radius: 9999px;
      background: inherit;
      padding-left: 2px;
    }
    
    .icon-img {
      justify-content: center;
      align-items: center;
      display: flex;
      background: inherit;
    }
    `
];
customElements.define('gscape-icon-list', GscapeIconList);

class GscapeEntityListItem extends s {
    constructor() {
        super(...arguments);
        this._types = new Set();
        this.displayedName = '';
        this.iri = '';
        this.actionable = false;
        this.asAccordion = false;
        this.disabled = false;
        this.isAccordionOpen = false;
    }
    render() {
        return this.asAccordion
            ? x `
        <details title=${this.displayedName} class="ellipsed entity-list-item" ?open=${this.isAccordionOpen || false} ?disabled=${this.disabled}>
          <summary class="actionable" @click=${this.handleDetailsClick}>
            ${this.iconNameSlotTemplate()}
          </summary>
          <!-- body defined by consumer as slot element -->
          <slot name="accordion-body" class="summary-body"></slot>
        </details>
      `
            : x `
        <div title=${this.displayedName} class="ellipsed background-propagation entity-list-item ${this.actionable ? 'actionable' : null}" ?disabled=${this.disabled}>
          ${this.iconNameSlotTemplate()}
        </div>
      `;
    }
    iconNameSlotTemplate() {
        return x `
      ${this.asAccordion
            ? x `
          <span class="slotted-icon">
            ${this.isAccordionOpen
                ? x `${arrowDown}`
                : x `${arrow_right}`}
          </span>
        `
            : null}      
      <span class="entity-icon slotted-icon">
        <gscape-icon-list .icons=${Array.from(this._types).map(t => entityIcons[t])}></gscape-icon-list>
      </span>
      <div style="display: flex; flex-direction: column; flex-grow: 2; gap: 4px">
        <span class="entity-name rtl"><bdo dir="ltr">${this.displayedName}</bdo></span>
        <slot name="subrow-item"></slot>
      </div>
      <slot name="trailing-element"></slot>
    `;
    }
    handleDetailsClick(e) {
        e.preventDefault();
        this.isAccordionOpen = !this.isAccordionOpen;
        this.requestUpdate();
    }
    openAccordion() {
        if (this.asAccordion)
            this.isAccordionOpen = true;
    }
    closeAccordion() {
        if (this.asAccordion)
            this.isAccordionOpen = false;
    }
    set types(newTypes) {
        this._types = newTypes || new Set();
    }
    get types() {
        return this._types;
    }
}
GscapeEntityListItem.properties = {
    types: { type: Object, reflect: true },
    displayedName: { type: String, reflect: true },
    actionable: { type: Boolean },
    asAccordion: { type: Boolean },
    disabled: { type: Boolean },
    isAccordionOpen: { type: Boolean, attribute: false },
    iri: { type: String, reflect: true },
};
GscapeEntityListItem.styles = [
    entityListItemStyle,
    baseStyle$3,
    i$1 `
      :host {
        display: block;
      }
    `
];
customElements.define('gscape-entity-list-item', GscapeEntityListItem);

class GscapeTextSearch extends s {
    constructor() {
        super(...arguments);
        this._onSearchCallback = () => { };
    }
    render() {
        return x `
      
    `;
    }
    onSearch(callback) {
        this._onSearchCallback = callback;
    }
}
GscapeTextSearch.properties = {
    value: { type: String, reflect: true },
    placeholder: { type: String, reflect: true }
};
GscapeTextSearch.styles = [baseStyle$3, GscapeButtonStyle];
customElements.define('gscape-text-search', GscapeTextSearch);

class GscapeEntitySearch extends DropPanelMixin(s) {
    constructor() {
        super(...arguments);
        this.areAllFiltersDisabled = true;
        this.isSearchTextEmpty = true;
    }
    render() {
        var _a, _b, _c, _d, _e;
        return x `
      <div class="search-box">
        <div id="input-wrapper" style="position:relative">
          <span class="slotted-icon muted-text">${search$1}</span>
          <input @keyup=${this.handleKeyPress} type="text" placeholder="Search IRI, labels...">
          ${!this.isSearchTextEmpty
            ? x `
              <gscape-button id="clear-btn" size="s" type="subtle" title="Clear search" @click=${this.clearSearch}>
                ${getIconSlot$1('icon', cross)}
              </gscape-button>
            `
            : A}
        </div>
        
        ${this.atLeastTwoFilters
            ? x `
              <gscape-button size="m" title="Show/Hide filters" @click=${this.togglePanel}>
                ${getIconSlot$1('icon', filter)}
              </gscape-button>
            `
            : null}
      </div>
      <div id="drop-panel" class="hide">
        <gscape-entity-type-filter
          class=${(_a = this[TypesEnum.CLASS]) !== null && _a !== void 0 ? _a : A}
          object-property=${(_b = this[TypesEnum.OBJECT_PROPERTY]) !== null && _b !== void 0 ? _b : A}
          data-property=${(_c = this[TypesEnum.DATA_PROPERTY]) !== null && _c !== void 0 ? _c : A}
          individual=${(_d = this[TypesEnum.INDIVIDUAL]) !== null && _d !== void 0 ? _d : A}
          class-instance=${(_e = this[TypesEnum.CLASS_INSTANCE]) !== null && _e !== void 0 ? _e : A}
        ></gscape-entity-type-filter>
      </div>
      
    `;
    }
    handleKeyPress(e) {
        const inputElement = e.currentTarget;
        if (!inputElement)
            return;
        if (e.key === 'Escape') {
            inputElement.blur();
            inputElement.value = '';
            this.handleSearch('');
            return;
        }
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            this.handleSearch(inputElement.value);
        }, 500);
    }
    handleSearch(searchText) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateComplete;
            this.dispatchEvent(new CustomEvent('onsearch', {
                bubbles: true,
                composed: true,
                detail: { searchText: searchText }
            }));
            this.isSearchTextEmpty = searchText.length <= 0;
        });
    }
    clearSearch() {
        if (this.input) {
            this.input.value = '';
            this.dispatchEvent(new CustomEvent('onsearch', {
                bubbles: true,
                composed: true,
                detail: { searchText: '' }
            }));
            this.isSearchTextEmpty = true;
        }
    }
    get atLeastTwoFilters() {
        let count = 0;
        if (this[TypesEnum.CLASS] !== undefined)
            count++;
        if (this[TypesEnum.OBJECT_PROPERTY] !== undefined)
            count++;
        if (this[TypesEnum.DATA_PROPERTY] !== undefined)
            count++;
        if (this[TypesEnum.INDIVIDUAL] !== undefined)
            count++;
        return count >= 2;
    }
    get input() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input'); }
}
TypesEnum.CLASS, TypesEnum.DATA_PROPERTY, TypesEnum.OBJECT_PROPERTY, TypesEnum.INDIVIDUAL, TypesEnum.CLASS_INSTANCE;
GscapeEntitySearch.properties = {
    [TypesEnum.CLASS]: { type: Number, reflect: true },
    [TypesEnum.DATA_PROPERTY]: { type: Number, reflect: true },
    [TypesEnum.OBJECT_PROPERTY]: { type: Number, reflect: true },
    [TypesEnum.INDIVIDUAL]: { type: Number, reflect: true },
    [TypesEnum.CLASS_INSTANCE]: { type: Number, reflect: true },
    isSearchTextEmpty: { type: Boolean, state: true },
};
GscapeEntitySearch.styles = [
    baseStyle$3,
    GscapeButtonStyle,
    i$1 `
      :host {
        display: block;
        padding: 8px;
      }

      .search-box {
        display: flex;
        align-items: stretch;
        gap: 8px;
      }

      #input-wrapper > .slotted-icon {
        position: absolute;
        left: 6px;
        top: 6px;
      }

      #input-wrapper {
        position: relative;
        flex-grow: 2;
      }

      input {
        width: 100%;
        height: 100%;
        padding-left: 32px;
      }

      #clear-btn {
        position: absolute;
        top: 3px;
        right: 4px;
      }
    `
];
customElements.define('gscape-entity-search', GscapeEntitySearch);

function capitalizeFirstChar (text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}

class GscapeEntityTypeFilters extends BaseMixin$3(s) {
    render() {
        return x `
      <div class="chips-filters">
        ${this[TypesEnum.CLASS] !== undefined
            ? this.getChipTemplate(TypesEnum.CLASS)
            : null}

        ${this[TypesEnum.DATA_PROPERTY] !== undefined
            ? this.getChipTemplate(TypesEnum.DATA_PROPERTY)
            : null}

        ${this[TypesEnum.OBJECT_PROPERTY] !== undefined
            ? this.getChipTemplate(TypesEnum.OBJECT_PROPERTY)
            : null}

        ${this[TypesEnum.INDIVIDUAL] !== undefined
            ? this.getChipTemplate(TypesEnum.INDIVIDUAL)
            : null}

        ${this[TypesEnum.CLASS_INSTANCE] !== undefined
            ? this.getChipTemplate(TypesEnum.CLASS_INSTANCE)
            : null}
      </div>
    `;
    }
    getChipTemplate(type) {
        const labels = type.split('-');
        labels.forEach(l => capitalizeFirstChar(l));
        const label = labels.join(' ');
        return x `
      <span 
        class="chip actionable ${this[type] && !this.areAllFiltersDisabled ? null : 'disabled'}"
        entity-type=${type}
        @click=${this._handleFilterStateChange}
      >
        ${entityIcons[type]} ${label}
      </span>
    `;
    }
    _handleFilterStateChange(e) {
        return __awaiter(this, void 0, void 0, function* () {
            const entityType = e.currentTarget.getAttribute('entity-type');
            if (this[entityType] !== undefined) {
                this[entityType] = !this[entityType];
                yield this.updateComplete;
                this.dispatchEvent(new CustomEvent('onentityfilterchange', {
                    bubbles: true,
                    composed: true,
                    detail: {
                        [TypesEnum.CLASS]: this[TypesEnum.CLASS],
                        [TypesEnum.DATA_PROPERTY]: this[TypesEnum.DATA_PROPERTY],
                        [TypesEnum.OBJECT_PROPERTY]: this[TypesEnum.OBJECT_PROPERTY],
                        [TypesEnum.INDIVIDUAL]: this[TypesEnum.INDIVIDUAL],
                        [TypesEnum.CLASS_INSTANCE]: this[TypesEnum.CLASS_INSTANCE],
                        areAllFiltersDisabled: this.areAllFiltersDisabled
                    }
                }));
            }
        });
    }
    get areAllFiltersDisabled() {
        let result = true;
        if (this[TypesEnum.CLASS] !== undefined) {
            result = result && !this[TypesEnum.CLASS];
        }
        if (this[TypesEnum.OBJECT_PROPERTY] !== undefined) {
            result = result && !this[TypesEnum.OBJECT_PROPERTY];
        }
        if (this[TypesEnum.DATA_PROPERTY] !== undefined) {
            result = result && !this[TypesEnum.DATA_PROPERTY];
        }
        if (this[TypesEnum.INDIVIDUAL] !== undefined) {
            result = result && !this[TypesEnum.INDIVIDUAL];
        }
        if (this[TypesEnum.CLASS_INSTANCE] !== undefined) {
            result = result && !this[TypesEnum.CLASS_INSTANCE];
        }
        return result;
    }
    set [TypesEnum.CLASS](v) {
        this._class = v;
        this.requestUpdate();
    }
    get [TypesEnum.CLASS]() { return this._class; }
    set [TypesEnum.DATA_PROPERTY](v) {
        this._dataproperty = v;
        this.requestUpdate();
    }
    get [TypesEnum.DATA_PROPERTY]() { return this._dataproperty; }
    set [TypesEnum.OBJECT_PROPERTY](v) {
        this._objectproperty = v;
        this.requestUpdate();
    }
    get [TypesEnum.OBJECT_PROPERTY]() { return this._objectproperty; }
    set [TypesEnum.INDIVIDUAL](v) {
        this._individual = v;
        this.requestUpdate();
    }
    get [TypesEnum.INDIVIDUAL]() { return this._individual; }
    set [TypesEnum.CLASS_INSTANCE](v) {
        this._classInstance = v;
        this.requestUpdate();
    }
    get [TypesEnum.CLASS_INSTANCE]() { return this._classInstance; }
}
GscapeEntityTypeFilters.properties = {
    [TypesEnum.CLASS]: { type: Number, reflect: true },
    [TypesEnum.DATA_PROPERTY]: { type: Number, reflect: true },
    [TypesEnum.OBJECT_PROPERTY]: { type: Number, reflect: true },
    [TypesEnum.INDIVIDUAL]: { type: Number, reflect: true },
    [TypesEnum.CLASS_INSTANCE]: { type: Number, reflect: true },
    onFilterToggle: { type: Function, reflect: true }
};
GscapeEntityTypeFilters.styles = [
    baseStyle$3,
    GscapeButtonStyle,
    i$1 `
      .chips-filters {
        margin-top: 4px;
        white-space: normal;
      }

      .chip[entity-type = "class"] {
        color: var(--gscape-color-class-contrast);
        border-color: var(--gscape-color-class-contrast);
      }

      .chip[entity-type = "data-property"] {
        color: var(--gscape-color-data-property-contrast);
        border-color: var(--gscape-color-data-property-contrast);
      }

      .chip[entity-type = "object-property"] {
        color: var(--gscape-color-object-property-contrast);
        border-color: var(--gscape-color-object-property-contrast);
      }

      .chip[entity-type = "individual"] {
        color: var(--gscape-color-individual-contrast);
        border-color: var(--gscape-color-individual-contrast);
      }

      .chip[entity-type = "class-instance"] {
        color: var(--gscape-color-class-instance-contrast);
        border-color: var(--gscape-color-class-instance-contrast);
      }

      .chip {
        line-height: 0;
        gap: 4px;
        align-items: center;
        background: inherit;
      }

      .chip.disabled {
        opacity: 0.4;
      }

      .chip:hover {
        opacity: 1;
      }

      .chip.disabled:hover {
        opacity: 0.4;
      }
    `
];
customElements.define('gscape-entity-type-filter', GscapeEntityTypeFilters);

var ToggleLabelPosition;
(function (ToggleLabelPosition) {
    ToggleLabelPosition["LEFT"] = "left";
    ToggleLabelPosition["RIGHT"] = "right";
})(ToggleLabelPosition || (ToggleLabelPosition = {}));
class GscapeToggle extends s {
    constructor() {
        super(...arguments);
        this.labelPosition = ToggleLabelPosition.RIGHT;
    }
    static get properties() {
        return {
            disabled: { type: Boolean, reflect: true },
            label: { type: String, reflect: true },
            labelPosition: { type: String, reflect: true, attribute: 'label-position' },
            key: { type: String, reflect: true },
            checked: { type: Boolean, reflect: true },
        };
    }
    render() {
        return x `
    <label class="toggle-container">
      <span class="toggle-label">${this.label}</span>
      <span class="toggle-wrap">
        <input id="${this.key}" type="checkbox"
          ?checked="${this.checked}"
          ?disabled="${this.disabled}"
        />
        <span class="toggle"></span>
      </span>
    </label>
    `;
    }
}
GscapeToggle.ToggleLabelPosition = ToggleLabelPosition;
GscapeToggle.styles = [
    baseStyle$3,
    i$1 `
      :host {
        display: block;
        cursor: pointer;
      }

      :host([disabled]) {
        cursor: not-allowed;
      }

      .toggle-container {
        white-space: nowrap;
        display: flex;
        align-items: center;
        cursor: inherit;
        gap: 15px;
        justify-content: space-between;
      }

      :host([label-position = "right"]) > .toggle-container {
        flex-direction: row-reverse;
      }

      .toggle-wrap {
        width: 36px;
        height: 18px;
        display: inline-block;
        position: relative;
      }

      .toggle {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 18px;
        background-color: var(--gscape-color-neutral-muted);
        border: 1px solid var(--gscape-color-border-subtle);
        transition: all 0.2s ease 0s;
      }

      .toggle::before {
        content: "";
        transition: all 0.1s ease 0s;
        position: absolute;
        width: 10px;
        height: 10px;
        background-color: var(--gscape-color-bg-default);
        border: solid 1px var(--gscape-color-border-subtle);
        border-radius: 9px;
        bottom: 2px;
        left: 2px;
      }

      .toggle-wrap input {
        display:none;
      }

      .toggle-wrap input:checked + .toggle {
        background-color: var(--gscape-color-accent-muted);
        border-color: var(--gscape-color-accent);
        filter: brightness(100%);
      }

      .toggle-wrap input:checked + .toggle::before {
        -webkit-transform: translateX(18px);
        -ms-transform: translateX(18px);
        transform: translateX(18px);
        background-color: var(--gscape-color-accent);
      }

      .toggle-wrap input:disabled + .toggle {
        opacity:0.5;
      }

      .toggle-label {
        flex-grow: 2;
      }
    `
];
customElements.define('gscape-toggle', GscapeToggle);

class GscapeConfirmDialog extends ModalMixin$3(BaseMixin$3(s)) {
    constructor(message, dialogTitle = 'Confirm') {
        super();
        this.message = message;
        this.dialogTitle = dialogTitle;
    }
    render() {
        return x `
      <div class="gscape-panel">
        <div class="header">
          ${this.dialogTitle}
        </div>
        <div class="dialog-message area">
          ${this.message}
        </div>

        <div class="buttons">
          ${this._onConfirm || this._onCancel
            ? x `
              <gscape-button label="Cancel" type="subtle" @click=${this.handleCancel}></gscape-button>
            `
            : null}
          <gscape-button label="Ok" @click=${this.handleConfirm}></gscape-button>
        </div>
      </div>
    `;
    }
    handleConfirm() {
        if (this._onConfirm)
            this._onConfirm();
        this.remove();
    }
    handleCancel() {
        if (this._onCancel)
            this._onCancel();
        this.remove();
    }
    onConfirm(callback) {
        this._onConfirm = callback;
        this.requestUpdate();
        return this;
    }
    onCancel(callback) {
        this._onCancel = callback;
        this.requestUpdate();
        return this;
    }
}
GscapeConfirmDialog.properties = {
    message: { type: String }
};
GscapeConfirmDialog.styles = [
    baseStyle$3,
    i$1 `
      .gscape-panel {
        position: absolute;
        top: 100px;
        left: 50%;
        transform: translate(-50%);
        max-width: 400px;
        min-width: 300px;
      }

      .header, .dialog-message {
        margin: 8px;
      }

      .dialog-message {
        padding: 8px;
        margin-bottom: 16px;
      }

      .buttons {
        display: flex;
        align-items: center;
        justify-content: right;
        gap: 8px;
      }
    `
];
customElements.define('gscape-confirm-dialog', GscapeConfirmDialog);
function showMessage(message, title, container) {
    const dialog = new GscapeConfirmDialog(message, title);
    container.appendChild(dialog);
    dialog.show();
    return dialog;
}

function a11yClick(event) {
    if (event.type === 'click' || event.type === 'mousedown') {
        return true;
    }
    else if (event.type === 'keypress') {
        var code = event.charCode || event.keyCode;
        if ((code === 32) || (code === 13)) {
            return true;
        }
    }
    else {
        return false;
    }
}

class GscapeSelect extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super(...arguments);
        this.PLACEHOLDER_ID = '!PLACEHOLDER!';
        this.selectedOptionsId = new Set();
        this.options = [];
        this.size = SizeEnum$1.S;
        this.clearable = false;
        this.multipleSelection = false;
        this._placeholder = {
            id: this.PLACEHOLDER_ID,
            text: 'Select'
        };
        this.onSelection = () => { };
    }
    render() {
        return x `
      ${this.getButton()}

      <div class="gscape-panel hide drop-down" id="drop-panel">

        <slot name="custom-element"></slot>

        ${this.options.length > 0
            ? this.options.map(option => {
                const selected = this.isIdSelected(option.id);
                return x `
              <div class="option-wrapper">
                <gscape-action-list-item
                  @click=${this.handleSelection}
                  @keypress=${this.handleSelection}
                  label="${option.text}"
                  title="${option.text}"
                  id="${option.id}"
                  ?selected=${selected || (this.isSelectionEmpty() && this.defaultOptionId === option.id)}
                  ?disabled=${option.disabled !== undefined && option.disabled}
                >
                  ${option.leadingIcon ? getIconSlot$1('icon', option.leadingIcon) : null}
                </gscape-action-list-item>
              </div>
            `;
            })
            : x `
            <div class="blank-slate">
              ${blankSlateDiagrams}
              <div class="description">No Options</div>
            </div>
          `}
      </div>
    `;
    }
    handleSelection(e) {
        if (a11yClick(e)) {
            const targetItem = e.currentTarget;
            if (targetItem && !targetItem.disabled) {
                if (targetItem.selected) {
                    // UNSELECT
                    if (this.clearable) {
                        this.selectedOptionsId.delete(targetItem.id);
                        this.requestUpdate();
                        this.updateComplete.then(() => this.dispatchEvent(new Event('change')));
                    }
                }
                else {
                    // SELECT
                    if (!this.multipleSelection) {
                        this.closePanel();
                        this.selectedOptionsId.clear();
                    }
                    this.selectedOptionsId.add(targetItem.id);
                    this.requestUpdate();
                    this.updateComplete.then(() => this.dispatchEvent(new Event('change')));
                }
            }
        }
    }
    getButton() {
        var _a;
        const options = this.selectedOptions.length > 0 ? this.selectedOptions : [this.defaultOption];
        const icon = (_a = options.find(o => o.leadingIcon !== undefined)) === null || _a === void 0 ? void 0 : _a.leadingIcon;
        const label = options.map(o => o.text).join(' - ');
        return x `
      <gscape-button id="select-btn" @click="${this.togglePanel}" label=${label} title=${label} size="${this.size}">
        <!-- Only set icons if selected options have all the same icon -->
        ${icon && options.every(o => !o.leadingIcon || o.leadingIcon === icon) ? getIconSlot$1('icon', icon) : null}
        ${getIconSlot$1('trailing-icon', triangle_down)}
      </gscape-button>
    `;
    }
    clear() {
        this.selectedOptionsId.clear();
        this.closePanel();
        this.requestUpdate();
        this.updateComplete.then(() => this.dispatchEvent(new Event('change')));
    }
    isSelectionEmpty() {
        return this.selectedOptionsId.size === 0;
    }
    isIdSelected(id) {
        return this.selectedOptionsId.has(id);
    }
    get selectedOptions() {
        return this.options.filter(o => this.isIdSelected(o.id));
    }
    get defaultOption() {
        return this.options.find(o => o.id === this.defaultOptionId) || this.placeholder;
    }
    get placeholder() { return this._placeholder; }
    set placeholder(placeHolder) {
        this._placeholder = placeHolder;
        this._placeholder.id = this.PLACEHOLDER_ID;
    }
}
GscapeSelect.properties = {
    options: { type: Object },
    selectedOptionId: { type: String, attribute: 'selected-option', reflect: true },
    defaultOptionId: { type: String, attribute: 'default-option' },
    placeHolder: { type: Object, attribute: 'placeholder' },
    onSelection: { type: Object, attribute: 'onselection' },
    size: { type: String },
    clearable: { type: Boolean },
    multipleSelection: { type: Boolean, attribute: 'multiple-selection' },
};
GscapeSelect.styles = [
    baseStyle$3,
    GscapeButtonStyle,
    i$1 `
      :host {
        position: relative;
      }

      gscape-button {
        max-width: inherit;
      }

      .option-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .option-wrapper > gscape-action-list-item {
        flex-grow: 1;
      }
    `
];
customElements.define('gscape-select', GscapeSelect);

function grapholEntityToEntityViewData(grapholEntity, grapholscape) {
    return {
        displayedName: grapholEntity.getDisplayedName(grapholscape.entityNameType, grapholscape.language),
        value: grapholEntity
    };
}
function getEntityViewDataUnfolding(entity, grapholscape, hasUnfoldings) {
    let hasAnyUnfolding = true;
    if (hasUnfoldings) {
        entity.types.forEach(type => {
            hasAnyUnfolding = hasAnyUnfolding && hasUnfoldings(entity.iri.fullIri, type);
        });
    }
    else {
        hasAnyUnfolding = false;
    }
    return {
        entityViewData: grapholEntityToEntityViewData(entity, grapholscape),
        hasUnfolding: hasAnyUnfolding
    };
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    capitalizeFirstChar: capitalizeFirstChar,
    grapholEntityToEntityViewData: grapholEntityToEntityViewData,
    getEntityViewDataUnfolding: getEntityViewDataUnfolding
});

function getEntityViewOccurrences (grapholEntity, grapholscape) {
    var _a, _b;
    const result = new Map();
    (_a = grapholEntity.occurrences.get(RendererStatesEnum.GRAPHOL)) === null || _a === void 0 ? void 0 : _a.forEach(occurrence => {
        addOccurrenceViewData(occurrence);
    });
    if (grapholscape.renderState && grapholscape.renderState !== RendererStatesEnum.GRAPHOL) {
        (_b = grapholEntity.occurrences.get(grapholscape.renderState)) === null || _b === void 0 ? void 0 : _b.forEach((occurrence) => {
            addOccurrenceViewData(occurrence);
        });
    }
    return result;
    function addOccurrenceViewData(occurrence) {
        var _a;
        if (!grapholscape.renderState)
            return;
        const diagram = grapholscape.ontology.getDiagram(occurrence.diagramId) || grapholscape.renderer.diagram;
        // const cyElement = diagram?.representations.get(grapholscape.renderState)?.cy?.$id(occurrence.elementId)
        if (diagram) {
            /**
             * In case of repositioned or transformed elements, show the original id
             */
            const occurrenceIdViewData = {
                realId: occurrence.id,
                originalId: occurrence.originalId || occurrence.id,
            };
            const d = Array.from(result).find(([diagramViewData, _]) => diagramViewData.id === diagram.id);
            let diagramViewData;
            if (!d) {
                diagramViewData = { id: diagram.id, name: diagram.name };
                result.set(diagramViewData, []);
            }
            else {
                diagramViewData = d[0];
            }
            (_a = result.get(diagramViewData)) === null || _a === void 0 ? void 0 : _a.push(occurrenceIdViewData);
            // for (let [diagramViewData, occurrencesIdViewData] of result.entries()) {
            //   if (diagramViewData.id === diagram.id) {
            //     occurrencesIdViewData.push(occurrenceIdViewData)
            //     break
            //   }
            // }
        }
    }
}
function getEntityOccurrencesTemplate(occurrences, onNodeNavigation) {
    function nodeNavigationHandler(e) {
        var _a;
        const target = e.target;
        const diagramId = (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute('diagram-id');
        const elementId = target.getAttribute('real-id');
        if (!diagramId || !elementId)
            return;
        onNodeNavigation(elementId, parseInt(diagramId));
    }
    return x `
  ${Array.from(occurrences).map(([diagram, occurrencesIds]) => {
        return x `
      <div diagram-id="${diagram.id}" style="display: flex; align-items: center; gap: 2px; flex-wrap: wrap;">
        <span class="diagram-name">${diagram.name}</span>
        ${occurrencesIds.map(occurrenceId => x `
          <gscape-button
            label="${occurrenceId.originalId || occurrenceId.realId}"
            real-id="${occurrenceId.realId}"
            type="subtle"
            size="s"
            @click=${nodeNavigationHandler}
          ></gscape-button>
        `)}
      </div>
    `;
    })}
  `;
}

function createEntitiesList(grapholscape, entityFilters) {
    var _a;
    const result = [];
    grapholscape.ontology.entities.forEach(entity => {
        if (!shouldFilterEntity(entity, entityFilters)) {
            result.push({
                displayedName: entity.getDisplayedName(grapholscape.entityNameType, grapholscape.language),
                value: entity,
                viewOccurrences: getEntityViewOccurrences(entity, grapholscape)
            });
        }
    });
    if (grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
        (_a = grapholscape.incremental) === null || _a === void 0 ? void 0 : _a.classInstanceEntities.forEach(classInstanceEntity => {
            var _a, _b;
            if (grapholscape.renderer.diagram && !shouldFilterEntity(classInstanceEntity, entityFilters)) {
                const viewClassInstanceEntity = grapholEntityToEntityViewData(classInstanceEntity, grapholscape);
                viewClassInstanceEntity.viewOccurrences = new Map();
                viewClassInstanceEntity.viewOccurrences.set({
                    id: (_a = grapholscape.renderer.diagram) === null || _a === void 0 ? void 0 : _a.id,
                    name: (_b = grapholscape.renderer.diagram) === null || _b === void 0 ? void 0 : _b.name
                }, [
                    {
                        originalId: viewClassInstanceEntity.value.iri.prefixed,
                        realId: viewClassInstanceEntity.value.iri.fullIri
                    }
                ]);
                result.push(viewClassInstanceEntity);
            }
        });
    }
    return result.sort((a, b) => a.displayedName.localeCompare(b.displayedName));
}
function shouldFilterEntity(entity, entityFilters) {
    if (!entityFilters)
        return false;
    let typeFilterEnabled = true;
    entity.types.forEach(type => {
        typeFilterEnabled = typeFilterEnabled && entityFilters[type] !== 1 && entityFilters[type] !== true;
    });
    return !entityFilters.areAllFiltersDisabled && typeFilterEnabled;
}
function search(searchValue, entities) {
    const searchWords = searchValue.split(' ');
    return new Promise((resolve) => {
        const result = entities.filter(entity => {
            let isAmatch = true;
            let isCurrentAMatch = false;
            for (const word of searchWords) {
                if (word.length <= 2)
                    continue;
                isCurrentAMatch = matchInIRI(entity.value.iri, word) || matchInAnnotations(entity.value.getAnnotations(), word);
                isAmatch = isAmatch && isCurrentAMatch;
            }
            return isAmatch;
        });
        resolve(result);
    });
    function matchInIRI(iri, searchValue) {
        return isMatch(iri.fullIri, searchValue) || isMatch(iri.prefixed, searchValue);
    }
    function matchInAnnotations(annotations, searchValue) {
        // search in labels defined in annotations (only for Graphol v3)
        for (const annotation of annotations) {
            if (isMatch(annotation.lexicalForm, searchValue))
                return true;
        }
        return false; // only if no language has a match
    }
    function isMatch(value1, value2) { return value1.toLowerCase().includes(value2.toLowerCase()); }
}

var emptySearchBlankState = x `
  <div class="blank-slate">
    ${searchOff}
    <div class="header">Can't find any entity</div>
    <div class="description">Please try again with another search text.</div>
  </div>
`;

class GscapeEntitySelector extends DropPanelMixin(BaseMixin$3(s)) {
    static get properties() {
        return {
            entityList: { type: Object, attribute: false },
            isSearchTextEmpty: { type: Boolean, state: true },
            loading: { type: Boolean, state: true },
            onClassSelection: { type: Object },
        };
    }
    constructor() {
        super();
        this.title = 'Class Selector';
        this.fullEntityList = [];
        this._entityList = [];
        this.isSearchTextEmpty = true;
        this.loading = false;
    }
    render() {
        return x `
      <div class="gscape-panel widget-body">
        <div id="input-wrapper">
          <span class="slotted-icon muted-text">${search$1}</span>
          <input @keyup=${this.handleSearch} type="text" placeholder="Search a class by IRI, labels...">
          ${!this.isSearchTextEmpty
            ? x `
              <gscape-button id="clear-btn" size="s" type="subtle" title="Clear search" @click=${this.clearSearch}>
                ${getIconSlot$1('icon', cross)}
              </gscape-button>
            `
            : null}
        </div>
        
        <gscape-button 
          type="secondary"
          @click=${this.togglePanel}
          title="Toggle complete list"
          size=${SizeEnum$1.S}>
          ${getIconSlot$1('icon', arrowDown)}
        </gscape-button>
      </div>
          
      <div id="drop-panel" class="gscape-panel hide drop-down">
        ${this.loading
            ? x `<div style="margin: 16px auto; display: table;">${getContentSpinner()}</div>`
            : !this.isPanelClosed()
                ? x `
              <lit-virtualizer
                scroller
                class="background-propagation"
                style="min-height: 100%;"
                .items=${this.entityList}
                .renderItem=${(entityItem) => x `
                  <gscape-entity-list-item
                    style="width:100%"
                    .types=${entityItem.value.types}
                    displayedName=${entityItem.displayedName}
                    title=${entityItem.displayedName}
                    iri=${entityItem.value.iri.fullIri}
                    tabindex="0"
                    @keypress=${this.handleKeyPressOnEntry.bind(this)}
                  >
                    <div slot="trailing-element" class="hover-btn">
                      <gscape-button
                        size="s"
                        type="subtle"
                        title="Insert in graph"
                        @click=${this.handleEntitySelection.bind(this)}
                      >
                        ${getIconSlot$1('icon', insertInGraph)}
                      </gscape-button>
                    </div>
                  </gscape-entity-list-item>
                `}
              >
              </lit-virtualizer>

              ${this.entityList.length === 0
                    ? emptySearchBlankState
                    : null} 
            `
                : null}
      </div>
    `;
    }
    // override blur to avoid collapsing when clicking on cytoscape's canvas
    blur() { }
    focusInputSearch() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateComplete;
            (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input')) === null || _b === void 0 ? void 0 : _b.focus();
        });
    }
    handleEntitySelection(evt) {
        var _a, _b;
        const iri = (_b = (_a = evt.currentTarget.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.getAttribute('iri');
        if (iri)
            this.onClassSelectionCallback(iri);
    }
    handleKeyPressOnEntry(evt) {
        if (a11yClick(evt)) {
            this.onClassSelectionCallback(evt.currentTarget.iri);
        }
    }
    handleSearch(e) {
        var _a;
        const inputElement = e.currentTarget;
        if (!inputElement)
            return;
        // on ESC key press
        if (e.key === 'Escape') {
            inputElement.blur();
            inputElement.value = '';
            this.entityList = this.fullEntityList;
            this.isSearchTextEmpty = true;
            this.closePanel();
            return;
        }
        this.isSearchTextEmpty = inputElement.value.length <= 0;
        if (((_a = inputElement.value) === null || _a === void 0 ? void 0 : _a.length) > 2) {
            this.loading = true;
            search(inputElement.value, this.fullEntityList).then(entities => {
                this.loading = false;
                this.entityList = entities;
            });
            this.openPanel();
        }
        else {
            this.entityList = this.fullEntityList;
        }
    }
    clearSearch() {
        if (this.input) {
            this.input.value = '';
            this.entityList = this.fullEntityList;
            this.isSearchTextEmpty = true;
        }
    }
    // onClassSelection(callback: (iri: string) => void) {
    //   this.onClassSelectionCallback = callback
    // }
    get onClassSelection() {
        return this.onClassSelectionCallback;
    }
    set onClassSelection(callback) {
        this.onClassSelectionCallback = callback;
        this.requestUpdate();
    }
    set entityList(newEntityList) {
        if (!this.fullEntityList || this.fullEntityList.length === 0) {
            this.fullEntityList = newEntityList;
        }
        this._entityList = newEntityList;
        this.requestUpdate();
    }
    get entityList() {
        return this._entityList;
    }
    get input() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('input'); }
}
GscapeEntitySelector.styles = [
    baseStyle$3,
    GscapeButtonStyle,
    contentSpinnerStyle,
    i$1 `

      .gscape-panel {
        width: 100%;
        max-width: unset;
        box-sizing: border-box;
      }

      .widget-body {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-shrink: 0;
        z-index: 1;
      }

      #drop-panel {
        position: relative;
        top: 0;
        max-height: unset;
        min-height: 60vh;
        height: 1px;
        overflow: hidden;
      }

      gscape-entity-list-item {
        --custom-min-height: 26.5px;
      }

      .hover-btn {
        display: none;
      }
      
      gscape-entity-list-item:hover > .hover-btn {
        display: initial;
      }

      gscape-entity-search {
        flex-shrink: 0;
      }

      #input-wrapper {
        position: relative;
        flex-grow: 2;
      }

      #input-wrapper > .slotted-icon {
        position: absolute;
        left: 8px;
        top: 11px;
      }

      input {
        width: 100%;
        height: 100%;
        padding: 12px 24px;
        padding-left: 38px;
      }

      #clear-btn {
        position: absolute;
        top: 8px;
        right: 8px;
      }

      @keyframes drop-down {
        from {opacity: 0; top: -20%;}
        to {opacity: 1; top: 0;}
      }
    `
];
customElements.define('gscape-entity-selector', GscapeEntitySelector);

const rendererStates = {
    [RendererStatesEnum.GRAPHOL]: {
        name: 'Graphol',
        id: RendererStatesEnum.GRAPHOL,
        icon: graphol_icon,
        // description: 'Full ontology representation'
    },
    [RendererStatesEnum.GRAPHOL_LITE]: {
        name: 'Entity Diagram',
        id: RendererStatesEnum.GRAPHOL_LITE,
        icon: lite,
        // description: 'E/R like simplified representation'
    },
    [RendererStatesEnum.FLOATY]: {
        name: 'Floaty',
        id: RendererStatesEnum.FLOATY,
        icon: bubbles,
        // description: 'Further simplified representation. Only classes and properties'
    },
    [RendererStatesEnum.INCREMENTAL]: {
        name: 'Path',
        id: RendererStatesEnum.INCREMENTAL,
        icon: incremental,
        // description: 'Choose a class and explore adding other classe\' information on demand'
    }
};

function init$9 (rendererSelector, grapholscape) {
    rendererSelector.rendererStates = grapholscape.renderers.map(rendererStateKey => rendererStates[rendererStateKey]);
    if (grapholscape.renderState) {
        rendererSelector.currentRendererStateKey = grapholscape.renderState;
    }
    rendererSelector.onRendererStateSelection = (rendererState) => {
        rendererStateSelectionCallback(rendererState, grapholscape);
    };
    rendererSelector.onIncrementalReset = () => { var _a; return (_a = grapholscape.incremental) === null || _a === void 0 ? void 0 : _a.reset(); };
    grapholscape.on(LifecycleEvent.RendererChange, (newRendererState) => {
        rendererSelector.currentRendererStateKey = newRendererState;
        if (newRendererState === RendererStatesEnum.FLOATY)
            rendererSelector.layoutSettingsComponent.openPanel();
    });
}
function rendererStateSelectionCallback(rendererState, grapholscape) {
    var _a;
    if (rendererState !== grapholscape.renderState) {
        let isRenderValid = false;
        switch (rendererState) {
            case RendererStatesEnum.GRAPHOL:
                grapholscape.setRenderer(new GrapholRendererState());
                isRenderValid = true;
                break;
            case RendererStatesEnum.GRAPHOL_LITE:
                grapholscape.setRenderer(new LiteRendererState());
                isRenderValid = true;
                break;
            case RendererStatesEnum.FLOATY:
                grapholscape.setRenderer(new FloatyRendererState());
                isRenderValid = true;
                break;
            case RendererStatesEnum.INCREMENTAL:
                grapholscape.setRenderer(new IncrementalRendererState());
                (_a = grapholscape.incremental) === null || _a === void 0 ? void 0 : _a.showDiagram();
                isRenderValid = true;
                break;
        }
        if (isRenderValid)
            storeConfigEntry('selectedRenderer', rendererState);
    }
}

function init$8 (welcomeRendererSelector, grapholscape) {
    welcomeRendererSelector.options = grapholscape.renderers.map(rendererStateId => rendererStates[rendererStateId]);
    welcomeRendererSelector.onOptionSelection = (optionId) => rendererStateSelectionCallback(optionId, grapholscape);
}

class GscapeFullPageSelector extends BaseMixin$3(s) {
    constructor() {
        super(...arguments);
        this._title = 'Select a rendering mode:';
    }
    render() {
        return x `
      <div class="title bold-text">${this._title}</div>
      <div class="options">
        ${this.options.map(option => {
            if (option)
                return x `
              <div class="card" renderer-state=${option.id} @click=${this.handleRendererSelection}>
                <div class="icon">${option.icon}</div>
                <div class="title bold-text">${option.name}</div>
                <div class="description muted-text">${option.description}</div>
              </div>
            `;
        })}
      </div>
    `;
    }
    handleRendererSelection(evt) {
        const targetElement = evt.currentTarget;
        this.onOptionSelection(targetElement.getAttribute('renderer-state'));
        this.hide();
    }
}
GscapeFullPageSelector.properties = {
    rendererStates: { type: Object, attribute: false },
    title: { type: String, reflect: true },
};
GscapeFullPageSelector.styles = [
    baseStyle$3,
    i$1 `
      :host {
        z-index: 100;
        top: 0;
        height: 100%;
        width: 100%;
        position: absolute;
        background: var(--gscape-color-bg-default);
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 50px;
      }

      .title {
        font-size: 150%;
        text-align: center;
      }

      .options {
        display: flex;
        justify-content: center;
        align-items: stretch;
        gap: 24px;
      }

      .card {
        box-shadow: 0 2px 10px 0 var(--gscape-color-shadow);
        border: solid 1px var(--gscape-color-border-default);
        border-radius: var(--gscape-border-radius);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 24px;
        width: 15%;
      }

      .card > .icon {
        margin-bottom: 16px;
      }

      .card > .icon > svg {
        height: 40px !important;
        width: auto !important;
      }

      .card > .title {
        font-size: 120%;
      }

      .card > .description {
        text-align: center;
      }

      .card:hover {
        border-color: var(--gscape-color-accent);
        cursor: pointer;
        background-color: var(--gscape-color-neutral);
      }
    `
];
customElements.define('gscape-welcome-renderer-selector', GscapeFullPageSelector);

function initInitialRendererSelector(grapholscape) {
    if (grapholscape.renderers.length > 1 && !grapholscape.renderState) {
        const rendererSelectorComponent = new GscapeFullPageSelector();
        init$8(rendererSelectorComponent, grapholscape);
        grapholscape.widgets.set(WidgetEnum$1.INITIAL_RENDERER_SELECTOR, rendererSelectorComponent);
    }
}

class GscapeDiagramSelector extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super(...arguments);
        this.title = 'Diagram Selector';
        this.onDiagramSelection = () => { };
    }
    render() {
        var _a;
        return x `
      <gscape-button @click="${this.togglePanel}" label="${((_a = this.currentDiagram) === null || _a === void 0 ? void 0 : _a.name) || 'Select a diagram'}">
        ${getIconSlot$1('icon', diagrams)}
        ${getIconSlot$1('trailing-icon', arrowDown)}
      </gscape-button>

      <div class="gscape-panel drop-down hide" id="drop-panel">
        ${this.diagrams.length === 1 && this.currentDiagramId === 0
            ? x `
            <div class="blank-slate">
              ${blankSlateDiagrams}
              <div class="header">No more diagrams</div>
              <div class="description">The ontology contains only one diagram, the one displayed.</div>
            </div>
          `
            : this.diagrams
                .sort(function (a, b) {
                var x = a.name.toLowerCase();
                var y = b.name.toLowerCase();
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                return 0;
            })
                .map(diagram => x `
              <gscape-action-list-item
                @click="${this.diagramSelectionHandler}"
                label="${diagram.name}"
                diagram-id="${diagram.id}"
                ?selected = "${this.currentDiagramId === diagram.id}"
              ></gscape-action-list-item>
            `)}
        
      </div>
    `;
    }
    diagramSelectionHandler(e) {
        const selectedDiagramId = parseInt(e.target.getAttribute('diagram-id') || '');
        this.onDiagramSelection(selectedDiagramId);
    }
    get currentDiagram() {
        return this.diagrams.find(diagram => diagram.id === this.currentDiagramId);
    }
}
GscapeDiagramSelector.properties = {
    currentDiagramId: { type: Number }
};
GscapeDiagramSelector.styles = [
    baseStyle$3,
    i$1 `
    :host {
      position: absolute;
      top: 10px;
      left: 10px;
    }
    `
];
customElements.define('gscape-diagram-selector', GscapeDiagramSelector);

/**
 *
 * @param {import('./index').default} diagramSelectorComponent
 * @param {import('../../grapholscape').default} grapholscape
 */
function init$7 (diagramSelectorComponent, grapholscape) {
    // const diagramsViewData = grapholscape.ontology.diagrams
    diagramSelectorComponent.diagrams = grapholscape.ontology.diagrams;
    if (grapholscape.diagramId || grapholscape.diagramId === 0) {
        diagramSelectorComponent.currentDiagramId = grapholscape.diagramId;
    }
    diagramSelectorComponent.onDiagramSelection = (diagram) => grapholscape.showDiagram(diagram);
    grapholscape.on(LifecycleEvent.DiagramChange, diagram => {
        if (diagramSelectorComponent.diagrams.includes(diagram))
            diagramSelectorComponent.currentDiagramId = diagram.id;
    });
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initDiagramSelector(grapholscape) {
    const diagramSelectorComponent = new GscapeDiagramSelector();
    init$7(diagramSelectorComponent, grapholscape);
    grapholscape.widgets.set(WidgetEnum$1.DIAGRAM_SELECTOR, diagramSelectorComponent);
}

function itemWithIriTemplate(item, onWikiLinkClick) {
    function wikiClickHandler() {
        if (onWikiLinkClick)
            onWikiLinkClick(item.iri);
    }
    return x `
    <div class="item-with-iri-info ellipsed">
      <div 
        class="name ${onWikiLinkClick ? 'link' : null}" 
        title="${item.name}"
        @click=${onWikiLinkClick ? wikiClickHandler : null}
      >
        ${item.name}
      </div>
      <div class="rtl"><div class="muted-text" style="text-align: center" title="iri: ${item.iri}"><bdo dir="ltr">${item.iri}</bdo></div></div>
      <div class="muted-text type-or-version">
        ${Array.from(item.typeOrVersion).map(text => {
        if (Object.values(TypesEnum).includes(text)) {
            return x `
              <div class="type-or-version">
                ${entityIcons[text]}
                ${text || '-'}
              </div>
            `;
        }
        else {
            return text || '-';
        }
    })}
      </div>
    </div>
  `;
}
const itemWithIriTemplateStyle = i$1 `
  .item-with-iri-info {
    text-align:center;
    background-color: var(--gscape-color-bg-inset);
    white-space: nowrap;
  }

  .item-with-iri-info .type-or-version {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
  }

  .item-with-iri-info .name {
    font-size: 14px;
    font-weight: 600;
  }
`;
function annotationsTemplate(annotations) {
    if (!annotations || annotations.length === 0)
        return null;
    let propertiesAlreadyInserted = [];
    return x `
    <div class="annotations">
      ${annotations.map(annotation => {
        var _a;
        const property = annotation.property;
        if (AnnotationProperty.comment.equals(annotation.property) || propertiesAlreadyInserted.includes(property))
            return null;
        propertiesAlreadyInserted.push(property);
        return x `
          <div class="annotation">
            <div class="bold-text annotation-property">
              <span class="slotted-icon">${(_a = annotationIcons[annotation.kind]) !== null && _a !== void 0 ? _a : A}</span>
              <span>${annotation.kind.charAt(0).toUpperCase() + annotation.kind.slice(1)}</span>
            </div>
            ${annotations.filter(a => a.property === property).map(annotation => {
            return x `
                <div class="annotation-row">
                  <span class="language muted-text bold-text">@${annotation.language}</span>
                  <span title="${annotation.lexicalForm}">${annotation.lexicalForm}</span>
                </div>
              `;
        })}
          </div>
        `;
    })}
    </div>
  `;
}
const annotationsStyle = i$1 `
  .annotations {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .annotation-property {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .annotations .language {
    margin-right: 6px
  }

  .annotation-row {
    padding: 4px 8px;
  }
`;

class GscapeEntityDetails extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super(...arguments);
        this.title = 'Entity Details';
        this.showOccurrences = true;
        this.onNodeNavigation = () => { };
        this.isDefaultClosed = false;
    }
    static get properties() {
        return {
            grapholEntity: { type: Object, attribute: false },
            occurrences: { type: Object, attribute: false },
            showOccurrences: { type: Boolean },
            language: { type: String, attribute: false },
            _isPanelClosed: { type: Boolean, attribute: false },
            incrementalSection: { type: Object, attribute: false }
        };
    }
    render() {
        if (!this.grapholEntity)
            return;
        return x `
      <div class="gscape-panel ellipsed" id="drop-panel">
        ${this.currentOccurrenceType !== TypesEnum.CLASS_INSTANCE
            ? itemWithIriTemplate(this.entityForTemplate, this.onWikiLinkClick)
            : itemWithIriTemplate(this.entityForTemplate)}

        <div class="content-wrapper">
          ${this.grapholEntity.datatype
            ? x `
              <div style="text-align: center" class="chips-wrapper section">
                <span class="chip datatype-chip">${this.grapholEntity.datatype}</span>
              </div>
            `
            : null}

          ${this.grapholEntity.functionProperties.length > 0 || this.grapholEntity.isDataPropertyFunctional
            ? x `
                <div class="chips-wrapper section">
                ${this.grapholEntity.isDataPropertyFunctional
                ? x `<span class="chip">&#10003; functional</span>`
                : null}
                ${this.grapholEntity.functionProperties.map(functionality => {
                if (this.grapholEntity.isDataPropertyFunctional)
                    return null;
                else
                    return x `<span class="chip">&#10003; ${functionality.toString()}</span>`;
            })}
                </div>
              `
            : null}

          ${this.incrementalSection}

          ${annotationsTemplate(this.grapholEntity.getAnnotations())}
          
          ${this.showOccurrences && this.occurrences.size > 0 ? this.occurrencesTemplate() : null}

          ${this.grapholEntity.getComments().length > 0
            ? x `
                <div class="section">
                  <div id="description-header" class="section-header">
                    <span class="slotted-icon">${commentIcon}</span>
                    <span class="bold-text">
                      Description
                    </span>
                    <select id="language-select" class="btn btn-s" @change=${this.languageSelectionHandler}>
                      ${this.commentsLanguages.map(language => {
                return x `
                          <option value="${language}" ?selected=${this.language === language}>
                            @${language}
                          </option>
                        `;
            })}
                    </select>
                  </div>
                  <div class="section-body">
                    ${this.grapholEntity.getComments(this.language).map(comment => x `<span class="comment">${comment.lexicalForm}</span>`)}
                  </div>
                </div>
              `
            : null}
        </div>
      </div>

      <div class="top-bar">
        <gscape-button style="z-index: 1"
          id="toggle-panel-button"
          size="${this.isPanelClosed() ? 'm' : 's'}" 
          type="${this.isPanelClosed() ? '' : 'subtle'}"
          @click=${this.togglePanel}
          label = "${this.isPanelClosed() ? 'Entity Details' : ''}"
        > 
          ${this.isPanelClosed()
            ? x `
                <span slot="icon">${infoFilled}</span>
                <span slot="trailing-icon">${plus}</span>
              `
            : x `<span slot="icon">${minus}</span>`}
        </gscape-button>
      </div>
    `;
    }
    occurrencesTemplate() {
        return x `
      <div class="section">
        <div class="bold-text section-header">Occurrences</div>
        <div class="section-body">
          ${getEntityOccurrencesTemplate(this.occurrences, this.onNodeNavigation)}
        </div>
      </div>
    `;
    }
    // override blur to avoid collapsing when clicking on cytoscape's canvas
    blur() { }
    setGrapholEntity(entity, instance) { }
    languageSelectionHandler(e) {
        this.language = e.target.value;
    }
    get entityForTemplate() {
        const result = {
            name: this.grapholEntity.iri.remainder,
            typeOrVersion: this.currentOccurrenceType ? new Set([this.currentOccurrenceType]) : this.grapholEntity.types,
            iri: this.grapholEntity.iri.fullIri,
        };
        return result;
    }
    get commentsLanguages() {
        return Array.from(new Set(this.grapholEntity.getComments().map(comment => comment.language)));
    }
    updated() {
        var _a;
        // let description = this.entity?.annotations?.comment
        const allComments = (_a = this.grapholEntity) === null || _a === void 0 ? void 0 : _a.getComments();
        if (!allComments || allComments.length === 0)
            return;
        const commentsInCurrentLanguage = this.grapholEntity.getComments(this.language);
        // if current language is not available, select the first available
        if (commentsInCurrentLanguage.length === 0) {
            this.language = allComments[0].language;
        }
    }
}
GscapeEntityDetails.styles = [
    baseStyle$3,
    itemWithIriTemplateStyle,
    annotationsStyle,
    GscapeButtonStyle,
    i$1 `
      :host {
        position: absolute;
        top:10px;
        right:62px;
        max-height: 50%;
        min-height: 200px;
        min-width: 300px;
        max-width: 20%;
        display: flex;
        flex-direction: column;
        pointer-events: none;
      }

      .gscape-panel {
        padding:0;
        max-height: inherit;
        display: flex;
        flex-direction: column;
        width: inherit;
        max-width: unset;
        min-width: unset;
      }

      .gscape-panel > * {
        padding: 8px;
      }

      .datatype-chip {
        color: inherit;
        background-color: var(--gscape-color-neutral-muted);
        border-color: var(--gscape-color-border-subtle);
        padding-top: 1px;
      }

      [diagram-id] > gscape-button {
        color: var(--gscape-color-accent);
      }

      #language-select: {
        margin: 10px auto;
        display: block;
      }

      .comment {
        margin: 8px 0;
        display: block;
      }

      .top-bar {
        display: flex;
        flex-direction: row-reverse;
        line-height: 1;
        position: absolute;
        top: 0;
        right: 0;
      }

      .item-with-iri-info {
        padding-top: 12px;
        flex-shrink: 0;
      }

      .content-wrapper {
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow: auto;
      }

      .content-wrapper > * {
        flex-shrink: 0;
      }

      .section-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 0;
      }
    `
];
customElements.define('gscape-entity-details', GscapeEntityDetails);

function init$6 (entityDetailsComponent, grapholscape) {
    // entityDetailsComponent.onWikiClick = (iri) => grapholscape.wikiRedirectTo(iri)
    entityDetailsComponent.onNodeNavigation = (elementId, diagramId) => {
        grapholscape.centerOnElement(elementId, diagramId, 1.2);
        grapholscape.selectElement(elementId);
    };
    entityDetailsComponent.language = grapholscape.language;
    entityDetailsComponent.setGrapholEntity = setGrapholEntity;
    grapholscape.on(LifecycleEvent.EntitySelection, setGrapholEntity);
    grapholscape.on(LifecycleEvent.NodeSelection, node => {
        if (!node.isEntity())
            entityDetailsComponent.hide();
    });
    grapholscape.on(LifecycleEvent.EdgeSelection, edge => {
        if (!edge.isEntity())
            entityDetailsComponent.hide();
    });
    grapholscape.on(LifecycleEvent.LanguageChange, language => {
        entityDetailsComponent.language = language;
    });
    grapholscape.on(LifecycleEvent.RendererChange, _ => {
        if (entityDetailsComponent.grapholEntity && grapholscape.renderState !== RendererStatesEnum.INCREMENTAL)
            entityDetailsComponent.occurrences = getEntityViewOccurrences(entityDetailsComponent.grapholEntity, grapholscape);
        entityDetailsComponent.showOccurrences = grapholscape.renderState !== RendererStatesEnum.INCREMENTAL;
    });
    function setGrapholEntity(entity, instance) {
        entityDetailsComponent.grapholEntity = entity;
        if (instance) {
            entityDetailsComponent.currentOccurrenceType = instance.type;
        }
        entityDetailsComponent.occurrences = getEntityViewOccurrences(entity, grapholscape);
        entityDetailsComponent.language = grapholscape.language;
        entityDetailsComponent.show();
        if (grapholscape.lifecycle.entityWikiLinkClick.length > 0 && !entityDetailsComponent.onWikiLinkClick) {
            entityDetailsComponent.onWikiLinkClick = (iri) => {
                grapholscape.lifecycle.trigger(LifecycleEvent.EntityWikiLinkClick, iri);
            };
        }
    }
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initEntityDetails(grapholscape) {
    const entityDetailsComponent = new GscapeEntityDetails();
    init$6(entityDetailsComponent, grapholscape);
    grapholscape.widgets.set(WidgetEnum$1.ENTITY_DETAILS, entityDetailsComponent);
}

class GscapeFilters extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.title = "Filters";
        this.filterAll = new Filter('all', () => false);
        this.onFilterOn = () => { };
        this.onFilterOff = () => { };
        this.onFilterAll = () => { };
        this.onUnfilterAll = () => { };
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
    }
    render() {
        return x `
      <gscape-button type="subtle" @click=${this.togglePanel}>
        ${getIconSlot$1('icon', filter)}
      </gscape-button>

      <div class="gscape-panel gscape-panel-in-tray hide" id="drop-panel">
        <div class="header">${this.title}</div>

        <div class="content-wrapper">
          ${this.filterToggleTemplate(this.filterAll, false)}
          <div class="hr"></div>
          ${Array.from(this.filters).map(([_, filter]) => this.filterToggleTemplate(filter))}
        </div>
      </div>
    `;
    }
    filterToggleTemplate(filter, reverseState = true) {
        return x `
      <gscape-toggle
        class="${!filter.locked ? 'actionable' : null}"
        @click = ${!filter.locked ? this.toggleFilter : null}
        key = ${filter.key}
        label = ${this.getFilterLabel(filter.key)}
        ?disabled = ${filter.locked}
        ?checked = ${reverseState ? !filter.active : filter.active}
      ></gscape-toggle>
    `;
    }
    getFilterLabel(filterKey) {
        var _a;
        let result = (_a = Object.keys(RDFGraphConfigFiltersEnum)
            .find(key => RDFGraphConfigFiltersEnum[key] === filterKey)) === null || _a === void 0 ? void 0 : _a.toLowerCase().replace('_', ' ');
        if (!result)
            return '';
        result = (result === null || result === void 0 ? void 0 : result.charAt(0).toUpperCase()) + (result === null || result === void 0 ? void 0 : result.substring(1));
        return result;
    }
    toggleFilter(e) {
        var _a;
        e.preventDefault();
        const toggle = e.target;
        const filter = this.filters.get(toggle.key);
        if (!filter) {
            if (toggle.key === this.filterAll.key) {
                this.filterAll.active ? this.onUnfilterAll() : this.onFilterAll();
            }
            return;
        }
        ((_a = this.filters.get(toggle.key)) === null || _a === void 0 ? void 0 : _a.active) ? this.onFilterOff(filter) : this.onFilterOn(filter);
    }
}
GscapeFilters.properties = {
    filters: { type: Object, attribute: false }
};
GscapeFilters.styles = [
    baseStyle$3,
    i$1 `
      :host {
        order: 3;
        display:inline-block;
        position: initial;
        margin-top:10px;
      }

      gscape-toggle {
        padding: 8px;
      }

      gscape-toggle[key ="all"] {
        margin: 0 auto;
      }

      .content-wrapper {
        display: flex;
        flex-direction: column;
      }

      .hr {
        margin-top: 4px;
        margin-bottom: 4px;
      }
    `,
];
customElements.define('gscape-filters', GscapeFilters);

/**
 * @param {import('./index').default} filterComponent
 * @param {import('../../grapholscape').default} grapholscape
 */
function init$5 (filterComponent, grapholscape) {
    filterComponent.filters = grapholscape.renderer.filters;
    filterComponent.onFilterOff = (filter) => grapholscape.unfilter(filter);
    filterComponent.onFilterOn = (filter) => grapholscape.filter(filter);
    filterComponent.onFilterAll = () => {
        grapholscape.renderer.filters.forEach(filter => {
            grapholscape.filter(filter);
            filter.active = true;
        });
        filterComponent.filterAll.active = true;
        filterComponent.requestUpdate();
    };
    filterComponent.onUnfilterAll = () => {
        grapholscape.renderer.filters.forEach(filter => {
            grapholscape.unfilter(filter);
        });
        filterComponent.filterAll.active = false;
        filterComponent.requestUpdate();
    };
    grapholscape.on(LifecycleEvent.Filter, () => filterComponent.requestUpdate());
    grapholscape.on(LifecycleEvent.Unfilter, () => {
        filterComponent.filterAll.active = false;
        filterComponent.requestUpdate();
    });
    grapholscape.on(LifecycleEvent.RendererChange, () => filterComponent.requestUpdate());
    // filterComponent.onFilterOn = (filterType) => {
    //   filterComponent.filterList[filterType].active = true
    //   onFilterToggle(filterType)
    // }
    // filterComponent.onFilterOff = (filterType) => {
    //   filterComponent.filterList[filterType].active = false
    //   onFilterToggle(filterType)
    // }
    // grapholscape.onFilter(_ => filterComponent.updateTogglesState())
    // grapholscape.onUnfilter(_ => filterComponent.updateTogglesState())
    // grapholscape.onRendererChange(() => filterComponent.requestUpdate())
    // function onFilterToggle(type) {
    //   if (type == 'attributes' && !grapholscape.renderer.disabledFilters.includes('value_domain')) {
    //     filterComponent.filterList.value_domain.disabled = filterComponent.filterList.attributes.active
    //   }
    //   // if 'all' is toggled, it affect all other filters
    //   if (type == 'all') {
    //     Object.keys(filterComponent.filterList).map(key => {
    //       if (key != 'all' && !filterComponent.filterList[key].disbaled) {
    //         filterComponent.filterList[key].active = filterComponent.filterList.all.active
    //         /**
    //          * if the actual filter is value-domain it means it's not disabled (see previous if condition)
    //          * but when filter all is active, filter value-domain must be disabled, let's disable it.
    //          * Basically value-domain filter disabled state must be equal to the active state of the 
    //          * 'all' filter.
    //          */
    //         if (key == 'value_domain' && !grapholscape.renderer.disabledFilters.includes('value_domain'))
    //           filterComponent.filterList[key].disabled = filterComponent.filterList['all'].active
    //         executeFilter(key)
    //       }
    //     })
    //   } else if (!filterComponent.filterList[type].active && filterComponent.filterList.all.active) {
    //     // if one filter get deactivated while the 'all' filter is active
    //     // then make the 'all' toggle deactivated
    //     filterComponent.filterList.all.active = false
    //   }
    //   executeFilter(type)
    //   filterComponent.updateTogglesState()
    // }
    // function executeFilter(type) {
    //   if (filterComponent.filterList[type].active) {
    //     grapholscape.filter(type)
    //   } else {
    //     grapholscape.unfilter(type)
    //     // Re-Apply other active filters to resolve ambiguity
    //     applyActiveFilters()
    //   }
    // }
    // function applyActiveFilters() {
    //   Object.keys(filterComponent.filterList).map(key => {
    //     if (filterComponent.filterList[key].active)
    //       grapholscape.filter(filterComponent.filterList[key])
    //   })
    // }
}

function initFilters(grapholscape) {
    const filterComponent = new GscapeFilters();
    init$5(filterComponent, grapholscape);
    grapholscape.widgets.set(WidgetEnum$1.FILTERS, filterComponent);
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initFitButton(grapholscape) {
    const fitButtonComponent = new GscapeButton$1();
    fitButtonComponent.appendChild(getIconSlot$1('icon', centerDiagram));
    fitButtonComponent.style.order = '2';
    fitButtonComponent.style.marginTop = '10px';
    fitButtonComponent.title = 'Center Diagram';
    //fitButtonComponent.style.position = 'initial'
    fitButtonComponent.onclick = () => grapholscape.fit();
    grapholscape.widgets.set(WidgetEnum$1.FIT_BUTTON, fitButtonComponent);
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initFullscreenButton(grapholscape) {
    const fullscreenComponent = new GscapeButton$1();
    //fullscreenComponent.container = grapholscape.container
    const icon = getIconSlot$1('icon', enterFullscreen);
    const alternativeIcon = getIconSlot$1('alt-icon', exitFullscreen);
    fullscreenComponent.appendChild(icon);
    fullscreenComponent.appendChild(alternativeIcon);
    fullscreenComponent.style.top = '10px';
    fullscreenComponent.style.right = '10px';
    fullscreenComponent.style.position = 'absolute';
    fullscreenComponent.onclick = toggleFullscreen;
    fullscreenComponent.title = 'Fullscreen';
    const doc = document; // avoid typechecking
    doc.cancelFullscreen =
        doc.exitFullscreen ||
            doc.cancelFullscreen ||
            doc.mozCancelFullScreen ||
            doc.webkitCancelFullScreen ||
            doc.msExitFullscreen;
    grapholscape.widgets.set(WidgetEnum$1.FULLSCREEN_BUTTON, fullscreenComponent);
    const container = grapholscape.container;
    function toggleFullscreen() {
        setFullScreenRequest();
        if (isFullscreen()) {
            doc.cancelFullscreen();
        }
        else {
            container === null || container === void 0 ? void 0 : container.requestFullscreen();
        }
    }
    function isFullscreen() {
        return doc.fullScreenElement ||
            doc.mozFullScreenElement || // Mozilla
            doc.webkitFullscreenElement || // Webkit
            doc.msFullscreenElement; // IE
    }
    function setFullScreenRequest() {
        container.requestFullscreen =
            (container === null || container === void 0 ? void 0 : container.requestFullscreen) ||
                (container === null || container === void 0 ? void 0 : container.mozRequestFullscreen) || // Mozilla
                (container === null || container === void 0 ? void 0 : container.mozRequestFullScreen) || // Mozilla older API use uppercase 'S'.
                (container === null || container === void 0 ? void 0 : container.webkitRequestFullscreen) || // Webkit
                (container === null || container === void 0 ? void 0 : container.msRequestFullscreen); // IE
    }
}

class GscapeExplorer extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.title = 'Ontology Explorer';
        this._entities = [];
        this.shownEntities = [];
        this.loading = false;
        // search: (e:any) => void = () => { }
        // filterEntities: (entityFilters: IEntityFilters) => void = () => { }
        this.onNodeNavigation = () => { };
        this.closePanel = () => {
            var _a;
            super.closePanel();
            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.entity-list-item[open]').forEach(item => item.open = false);
        };
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
        this.addEventListener('onsearch', (e) => {
            if (e.detail.searchText.length > 2) {
                this.loading = true;
                search(e.detail.searchText, this.entities).then(entities => {
                    this.loading = false;
                    this.shownEntities = entities;
                });
            }
            else {
                this.shownEntities = this.entities;
            }
        });
        this.closePanel();
    }
    render() {
        return x `
    <gscape-button type="subtle" @click=${this.togglePanel}>
      <span slot="icon">${explore}</span>
    </gscape-button>

    <div class="gscape-panel gscape-panel-in-tray hide" id="drop-panel">
      <div class="header">${this.title}</div>
      <gscape-entity-search
        class=0
        object-property=0
        data-property=0
        individual=0
        class-instance=0
      ></gscape-entity-search>

        ${this.loading
            ? x `<div style="margin: 16px auto; display: table;">${getContentSpinner()}</div>`
            : this.shownEntities.length === 0
                ? emptySearchBlankState
                : !this.isPanelClosed()
                    ? x `
                <div style="padding: 0 8px; height: inherit">
                  <lit-virtualizer
                    scroller
                    class="background-propagation"
                    style="min-height: 100%"
                    .items=${this.shownEntities}
                    .renderItem=${(entity) => x `
                      <gscape-entity-list-item
                        style="width: 100%"
                        ?asaccordion=${true}
                        displayedname=${entity.displayedName}
                        .types=${entity.value.types}
                        iri=${entity.value.iri.fullIri}
                      >
                        <div slot="accordion-body">
                        ${entity.viewOccurrences && entity.viewOccurrences.size > 0
                        ? getEntityOccurrencesTemplate(entity.viewOccurrences, this.onNodeNavigation)
                        : x `
                            <div class="blank-slate">
                              ${blankSlateDiagrams}
                              <div class="header">No Occurrences</div>
                              <div class="description">The entity has no occurrences in this rendering mode.</div>
                            </div>
                          `}
                        </div>
                      </gscape-entity-list-item>
                    `}
                  >
                  </lit-virtualizer>
                </div>
              `
                    : null}
    </div>
    `;
    }
    get entities() { return this._entities; }
    set entities(newEntities) {
        this._entities = this.shownEntities = newEntities;
    }
    get searchEntityComponent() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('gscape-entity-search'); }
}
// onSearch: (e: KeyboardEvent) => void
// onEntityFilterToggle: () => void
GscapeExplorer.properties = {
    entities: { type: Object, attribute: false },
    shownEntities: { type: Object, attribute: false },
    loading: { type: Boolean }
};
GscapeExplorer.styles = [
    baseStyle$3,
    contentSpinnerStyle,
    i$1 `
      :host {
        order: 6;
        margin-top:10px;
      }      

      [diagram-id] > gscape-button {
        color: var(--gscape-color-accent);
      }

      .filter-box {
        padding: 8px;
      }

      .gscape-panel-in-tray {
        height: 50vh;
        max-height: unset;
        min-width: 300px;
        min-height: 200px;
        display: flex;
        flex-direction: column;
      }

      .list-wrapper > .blank-slate {
        white-space: normal;
        transform: translateY(40%);
      }

      .list-wrapper {
        padding: 0px 8px;
        overflow: auto;
        flex-grow: 2;
      }

      .content-wrapper {
        height: 100%;
      }
    `
];
customElements.define('gscape-explorer', GscapeExplorer);

function init$4 (ontologyExplorerComponent, grapholscape) {
    ontologyExplorerComponent.onNodeNavigation = (elementId, diagramId) => {
        grapholscape.centerOnElement(elementId, diagramId, 1.2);
        grapholscape.selectElement(elementId);
    };
    ontologyExplorerComponent.addEventListener('onentityfilterchange', (e) => {
        ontologyExplorerComponent.entities = createEntitiesList(grapholscape, e.detail);
    });
    ontologyExplorerComponent.onTogglePanel = () => {
        if (ontologyExplorerComponent.entities.length === 0) {
            updateEntityList();
        }
    };
    grapholscape.on(LifecycleEvent.RendererChange, () => {
        updateEntityList(ontologyExplorerComponent.searchEntityComponent);
    });
    grapholscape.on(LifecycleEvent.EntityNameTypeChange, () => {
        updateEntityList(ontologyExplorerComponent.searchEntityComponent);
    });
    function updateEntityList(entityFilters) {
        ontologyExplorerComponent.loading = true;
        setTimeout(() => {
            ontologyExplorerComponent.entities = createEntitiesList(grapholscape, entityFilters);
            ontologyExplorerComponent.loading = false;
        }, 0);
    }
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initOntologyExplorer(grapholscape) {
    const ontologyExplorerComponent = new GscapeExplorer();
    init$4(ontologyExplorerComponent, grapholscape);
    grapholscape.widgets.set(WidgetEnum$1.ONTOLOGY_EXPLORER, ontologyExplorerComponent);
}

class GscapeOntologyInfo extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.title = "Ontology Info";
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
    }
    render() {
        return x `
      <gscape-button type="subtle" @click="${this.togglePanel}">
        <span slot="icon">${info_outline}</span>
      </gscape-button>  

      <div class="gscape-panel gscape-panel-in-tray hide" id="drop-panel">
        <div class="header" style="display: none">Ontology Info</div>

        ${itemWithIriTemplate(this.ontology)}
        
        ${annotationsTemplate(this.ontology.annotations)}

        ${this.iriPrefixesTemplate()}
      </div>
    `;
    }
    iriPrefixesTemplate() {
        let numRows;
        return x `
      <table>
        <caption>Namespace prefixes</caption>
        ${this.ontology.namespaces.map(namespace => {
            numRows = namespace.prefixes.length;
            return x `
              ${namespace.prefixes.map((prefix, i) => {
                return x `
                  <tr>
                    <th>${prefix}</th>
                    ${i === 0
                    ? x `<td rowspan="${numRows}">${namespace.toString()}</td>`
                    : null}
                  </tr>
                `;
            })}
          `;
        })}
      </table>
    `;
    }
}
GscapeOntologyInfo.styles = [
    baseStyle$3,
    itemWithIriTemplateStyle,
    annotationsStyle,
    i$1 `
      :host {
        order: 4;
        display:inline-block;
        position: initial;
        margin-top: 10px;
      }

      .gscape-panel {
        padding:0;
        font-size: 12px;
        min-height: 200px;
      }

      .gscape-panel > * {
        padding: 8px 16px;
      }

      table {
        border-spacing: 0;
      }

      th, td {
        padding: 2px;
      }

      td {
        padding-left: 8px;
      }

      th {
        text-align: left;
        border-right: solid 1px var(--gscape-color-border-subtle);
        padding-right: 8px;
      }
      
      table > caption {
        margin-top: 8px;
        font-weight: 600;
      }
    `,
];
customElements.define('gscape-ontology-info', GscapeOntologyInfo);

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initOntologyInfo(grapholscape) {
    const ontologyInfoComponent = new GscapeOntologyInfo();
    ontologyInfoComponent.ontology = ontologyModelToViewData$1(grapholscape.ontology);
    grapholscape.widgets.set(WidgetEnum$1.ONTOLOGY_INFO, ontologyInfoComponent);
}
function ontologyModelToViewData$1(ontologyModelData) {
    let ontologyViewData = {
        name: ontologyModelData.name,
        typeOrVersion: new Set([ontologyModelData.version]),
        iri: ontologyModelData.iri || '',
        namespaces: ontologyModelData.namespaces,
        annotations: ontologyModelData.annotations,
    };
    return ontologyViewData;
}

function entityIriTemplate(iri, entityType) {
    if (entityType === TypesEnum.FACET) {
        if (iri.remainder.search(/"[\w]+"\^\^[\w]+:/) != -1) {
            var value = iri.remainder.split('^^')[0];
            var datatype = iri.remainder.split(':')[1];
            return '<span class="owl_value">' + value + '</span>^^' +
                '<span class="axiom_predicate_prefix">' + iri.prefix + '</span>' +
                '<span class="owl_value-domain">' + datatype + '</span>';
        }
        return;
    }
    return `<span class="axiom_predicate_prefix">${iri.prefix}</span>:<span class="owl_${entityType}">${iri.remainder}</span>`;
}

class GrapholToOwlTranslator {
    constructor(grapholscape) {
        this.malformed = '<span class="owl_error">Malformed Axiom</span>';
        this.missingOperand = '<span class="owl_error">Missing Operand</span>';
        this.owlThing = '<span class="axiom_predicate_prefix">owl:</span><span class="axiom_predefinite_obj">Thing</span>';
        this.rdfsLiteral = '<span class="axiom_predicate_prefix">rdfs:</span><span class="axiom_predefinite_obj">Literal</span>';
        this._grapholscape = grapholscape;
    }
    edgeToOwlString(edge) {
        const grapholEdge = this._grapholscape.ontology.getGrapholEdge(edge.id(), this._grapholscape.diagramId);
        if (!grapholEdge)
            return;
        const source = edge.source();
        const grapholSource = this._grapholscape.ontology.getGrapholNode(source.id(), this._grapholscape.diagramId);
        const target = edge.target();
        const grapholTarget = this._grapholscape.ontology.getGrapholNode(target.id(), this._grapholscape.diagramId);
        if (!grapholSource || !grapholTarget)
            return;
        switch (grapholEdge.type) {
            case TypesEnum.INCLUSION:
                if (grapholSource.identity !== grapholTarget.identity)
                    return;
                switch (grapholSource.identity) {
                    case TypesEnum.CLASS:
                        if (grapholSource.is(TypesEnum.DOMAIN_RESTRICTION) && grapholSource.displayedName != 'self' && grapholTarget.displayedName != 'self') {
                            return this.propertyDomain(edge);
                        }
                        else if (grapholSource.is(TypesEnum.RANGE_RESTRICTION) && grapholSource.displayedName != 'self' && grapholTarget.displayedName != 'self') {
                            return this.propertyRange(edge);
                        }
                        else if (grapholTarget.is(TypesEnum.COMPLEMENT) || grapholSource.is(TypesEnum.COMPLEMENT)) {
                            return this.disjointClassesFromEdge(edge.connectedNodes());
                        }
                        return this.subClassOf(edge);
                    case TypesEnum.OBJECT_PROPERTY:
                        if (grapholTarget.is(TypesEnum.COMPLEMENT))
                            return this.disjointTypeProperties(edge);
                        else
                            return this.subTypePropertyOf(edge);
                    case TypesEnum.VALUE_DOMAIN:
                        return this.propertyRange(edge);
                    case TypesEnum.DATATYPE_RESTRICTION:
                        if (grapholTarget.is(TypesEnum.COMPLEMENT))
                            return this.disjointTypeProperties(edge);
                        else
                            return this.subTypePropertyOf(edge);
                    default: return this.malformed;
                }
            case TypesEnum.EQUIVALENCE:
                if (grapholSource.identity !== grapholTarget.identity)
                    return;
                switch (grapholSource.identity) {
                    case TypesEnum.CLASS:
                        return this.equivalentClasses(edge);
                    case TypesEnum.OBJECT_PROPERTY:
                        if (grapholSource.is(TypesEnum.ROLE_INVERSE) || grapholTarget.is(TypesEnum.ROLE_INVERSE)) {
                            return this.inverseObjectProperties(edge);
                        }
                        else {
                            return this.equivalentTypeProperties(edge);
                        }
                    case TypesEnum.DATA_PROPERTY:
                        return this.equivalentTypeProperties(edge);
                    default:
                        return this.malformed;
                }
            case TypesEnum.MEMBERSHIP:
                if (grapholTarget.identity == TypesEnum.CLASS)
                    return this.classAssertion(edge);
                else
                    return this.propertyAssertion(edge);
        }
    }
    subClassOf(inclusionEdge) {
        return `SubClassOf(${this.nodeToOwlString(inclusionEdge.source())} ${this.nodeToOwlString(inclusionEdge.target())})`;
    }
    propertyDomain(edgeOutFromDomain) {
        const nodes = edgeOutFromDomain.source().incomers(`[type = "${TypesEnum.INPUT}"]`).sources();
        if (nodes.size() > 1)
            return this.subClassOf(edgeOutFromDomain);
        const sourceNode = nodes[0];
        const sourceGrapholNode = this._grapholscape.ontology.getGrapholNode(sourceNode.id(), this._grapholscape.diagramId);
        if (!sourceGrapholNode)
            return;
        let axiomType = this.getAxiomPropertyType(sourceGrapholNode);
        return `${axiomType}PropertyDomain(${this.nodeToOwlString(sourceNode)} ${this.nodeToOwlString(edgeOutFromDomain.target())})`;
    }
    propertyRange(edge) {
        var nodeSources = edge.source().incomers(`[type = "${TypesEnum.INPUT}"]`).sources();
        if (nodeSources.size() > 1) {
            return this.subClassOf(edge);
        }
        const sourceNode = nodeSources[0];
        const sourceGrapholNode = this._grapholscape.ontology.getGrapholNode(sourceNode.id(), this._grapholscape.diagramId);
        if (!sourceGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(sourceGrapholNode);
        return `${axiomType}PropertyRange(${this.nodeToOwlString(sourceNode)} ${this.nodeToOwlString(edge.target())})`;
    }
    propertyAssertion(edge) {
        const targetGrapholNode = this._grapholscape.ontology.getGrapholNode(edge.target().id(), this._grapholscape.diagramId);
        const sourceGrapholNode = this._grapholscape.ontology.getGrapholNode(edge.source().id(), this._grapholscape.diagramId);
        if (!targetGrapholNode || !sourceGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(targetGrapholNode);
        let owlString = axiomType + 'PropertyAssertion(' + this.nodeToOwlString(edge.target()) + ' ';
        if (sourceGrapholNode.type == TypesEnum.PROPERTY_ASSERTION) {
            var property_node = edge.source();
            property_node.incomers(`[type = "${TypesEnum.INPUT}"]`).sources().forEach(input => {
                owlString += this.nodeToOwlString(input) + ' ';
            });
            owlString = owlString.slice(0, owlString.length - 1);
        }
        else {
            owlString += this.nodeToOwlString(edge.source());
        }
        return owlString + ')';
    }
    classAssertion(edge) {
        return `ClassAssertion(${this.nodeToOwlString(edge.source())} ${this.nodeToOwlString(edge.target())})`;
    }
    inverseObjectProperties(edge) {
        let complementInput, input;
        if (edge.source().data('type') == TypesEnum.ROLE_INVERSE) {
            input = edge.target();
            complementInput = edge.source().incomers(`[type = "${TypesEnum.INPUT}"]`).sources()[0];
        }
        else {
            input = edge.source();
            complementInput = edge.target().incomers(`[type = "${TypesEnum.INPUT}"]`).sources()[0];
        }
        if (complementInput.empty()) {
            return this.missingOperand;
        }
        return `InverseObjectProperties(${this.nodeToOwlString(input)} ${this.nodeToOwlString(complementInput)})`;
    }
    equivalentClasses(edge) {
        return `EquivalentClasses(${this.nodeToOwlString(edge.source())} ${this.nodeToOwlString(edge.target())})`;
    }
    equivalentTypeProperties(edge) {
        const sourceGrapholNode = this._grapholscape.ontology.getGrapholNode(edge.source().id(), this._grapholscape.diagramId);
        if (!sourceGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(sourceGrapholNode);
        return `Equivalent${axiomType}Properties(${this.nodeToOwlString(edge.source())} ${this.nodeToOwlString(edge.target())})`;
    }
    subTypePropertyOf(edge) {
        const targetGrapholNode = this._grapholscape.ontology.getGrapholNode(edge.target().id(), this._grapholscape.diagramId);
        if (!targetGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(targetGrapholNode);
        return `Sub${axiomType}PropertyOf(${this.nodeToOwlString(edge.source())} ${this.nodeToOwlString(edge.target())})`;
    }
    disjointClassesFromEdge(inputs) {
        var owlString = 'DisjointClasses(';
        inputs.forEach((input) => {
            if (input.data('type') == TypesEnum.COMPLEMENT) {
                input = input.incomers(`[type = "${TypesEnum.INPUT}"]`).source();
            }
            owlString += this.nodeToOwlString(input) + ' ';
        });
        owlString = owlString.slice(0, owlString.length - 1);
        owlString += ')';
        return owlString;
    }
    disjointTypeProperties(edge) {
        const firstInputGrapholNode = this._grapholscape.ontology.getGrapholNode(edge.target().id(), this._grapholscape.diagramId);
        if (!firstInputGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(firstInputGrapholNode);
        let owlString = `Disjoint${axiomType}Properties(`;
        edge.connectedNodes().forEach((node) => {
            if (node.data('type') == TypesEnum.COMPLEMENT) {
                node = node.incomers(`[type = "${TypesEnum.INPUT}"]`).source();
            }
            owlString += this.nodeToOwlString(node) + ' ';
        });
        owlString = owlString.slice(0, owlString.length - 1);
        return owlString + ')';
    }
    // ============================== NODE ==============================
    nodeToOwlString(node, startingFromNode = false) {
        const grapholNode = this._grapholscape.ontology.getGrapholNode(node.id(), this._grapholscape.diagramId);
        if (!grapholNode)
            return;
        let owl_string;
        if (grapholNode.isEntity() || grapholNode.is(TypesEnum.VALUE_DOMAIN)) {
            let nodeIri;
            const grapholNodeEntity = this._grapholscape.ontology.getEntity(node.data().iri);
            if (grapholNodeEntity === null || grapholNodeEntity === void 0 ? void 0 : grapholNodeEntity.iri) {
                nodeIri = grapholNodeEntity.iri;
            }
            else if (grapholNode.is(TypesEnum.VALUE_DOMAIN) && grapholNode.displayedName) {
                nodeIri = {
                    prefix: grapholNode.displayedName.split(':')[0] || '',
                    remainder: grapholNode.displayedName.split(':')[1] || grapholNode.displayedName,
                };
            }
            else
                return;
            const iriSpan = entityIriTemplate(nodeIri, grapholNode.type);
            // if startingFromNode, return iri declaration
            if (startingFromNode) {
                owl_string = '';
                const entitiesOwlNames = {};
                entitiesOwlNames[TypesEnum.CLASS] = 'Class';
                entitiesOwlNames[TypesEnum.OBJECT_PROPERTY] = 'ObjectProperty';
                entitiesOwlNames[TypesEnum.DATA_PROPERTY] = 'DataProperty';
                entitiesOwlNames[TypesEnum.INDIVIDUAL] = 'NamedIndividual';
                entitiesOwlNames[TypesEnum.VALUE_DOMAIN] = 'Datatype';
                if (grapholNode.is(TypesEnum.OBJECT_PROPERTY) || grapholNode.is(TypesEnum.DATA_PROPERTY)) {
                    grapholNodeEntity === null || grapholNodeEntity === void 0 ? void 0 : grapholNodeEntity.functionProperties.forEach(functionality => {
                        owl_string += `<br/>${capitalizeFirstChar(functionality)}${entitiesOwlNames[grapholNode.type]}(${iriSpan})`;
                    });
                }
                return `Declaration(${entitiesOwlNames[grapholNode.type]}(${iriSpan}))` + owl_string;
            }
            else {
                return iriSpan;
            }
        }
        // node is a constructor
        else {
            let inputs;
            switch (grapholNode.type) {
                case TypesEnum.FACET:
                    var remainder = grapholNode.displayedName.replace(/\n/g, '^').split('^^');
                    remainder[0] = remainder[0].slice(4);
                    return '<span class="axiom_predicate_prefix">xsd:</span><span class="owl_value-domain">' + remainder[0] + '</span><span class="owl_value">' + remainder[1] + '</span>';
                case TypesEnum.DOMAIN_RESTRICTION:
                case TypesEnum.RANGE_RESTRICTION:
                    var input_edges = node.connectedEdges(`edge[target = "${node.id()}"][type = "${TypesEnum.INPUT}"]`);
                    var input_first;
                    var input_other;
                    if (!input_edges.length) {
                        return this.missingOperand;
                    }
                    input_edges.forEach((e) => {
                        if (e.source().data('type') == TypesEnum.OBJECT_PROPERTY || e.source().data('type') == TypesEnum.DATA_PROPERTY) {
                            input_first = e.source();
                        }
                        if (e.source().data('type') != TypesEnum.OBJECT_PROPERTY && e.source().data('type') != TypesEnum.DATA_PROPERTY) {
                            input_other = e.source();
                        }
                    });
                    if (input_first) {
                        if (input_first.data('type') == TypesEnum.DATA_PROPERTY && grapholNode.type == TypesEnum.RANGE_RESTRICTION)
                            return;
                        switch (grapholNode.displayedName) {
                            case 'exists':
                                return this.valuesFrom(input_first, input_other, grapholNode.type, 'Some');
                            case 'forall':
                                return this.valuesFrom(input_first, input_other, grapholNode.type, 'All');
                            case 'self':
                                return this.hasSelf(input_first, grapholNode.type);
                            default:
                                if (node.data('displayedName').search(/\(([-]|[\d]+),([-]|[\d]+)\)/) != -1) {
                                    var cardinality = grapholNode.displayedName.replace(/\(|\)/g, '').split(/,/);
                                    return this.minMaxExactCardinality(input_first, input_other, cardinality, grapholNode.type);
                                }
                                return this.missingOperand;
                        }
                    }
                    return;
                case TypesEnum.ROLE_INVERSE:
                    inputs = node.incomers(`[type = "${TypesEnum.INPUT}"]`).sources();
                    if (inputs.length <= 0)
                        return this.missingOperand;
                    return this.objectInverseOf(inputs[0]);
                case TypesEnum.ROLE_CHAIN:
                    if (!node.data('inputs'))
                        return this.missingOperand;
                    return this.objectPropertyChain(node.incomers(`[type = "${TypesEnum.INPUT}"]`).sources());
                case TypesEnum.UNION:
                case TypesEnum.INTERSECTION:
                case TypesEnum.COMPLEMENT:
                case TypesEnum.ENUMERATION:
                case TypesEnum.DISJOINT_UNION:
                    inputs = node.incomers(`[type = "${TypesEnum.INPUT}"]`).sources();
                    if (inputs.length <= 0)
                        return this.missingOperand;
                    const axiomType = this.getAxiomPropertyType(grapholNode);
                    if (node.data('type') == TypesEnum.DISJOINT_UNION) {
                        if (!startingFromNode) {
                            return this.logicalConstructors(inputs, TypesEnum.UNION, axiomType);
                        }
                        else {
                            return this.logicalConstructors(inputs, TypesEnum.UNION, axiomType) + '<br />' + this.disjointClassesFromNode(inputs);
                        }
                    }
                    return this.logicalConstructors(inputs, node.data('type'), axiomType);
                case TypesEnum.DATATYPE_RESTRICTION:
                    inputs = node.incomers(`[type = "${TypesEnum.INPUT}"]`).sources();
                    if (inputs.length <= 0) {
                        return this.missingOperand;
                    }
                    return this.datatypeRestriction(inputs);
                case TypesEnum.PROPERTY_ASSERTION:
                    return;
                case TypesEnum.HAS_KEY:
                    inputs = node.incomers(`[type = "${TypesEnum.INPUT}"]`).sources();
                    if (inputs.length <= 0)
                        return this.missingOperand;
                    return this.hasKey(inputs);
            }
        }
    }
    valuesFrom(first, other, restrictionType, cardinality) {
        let owlString;
        const firstInputGrapholNode = this._grapholscape.ontology.getGrapholNode(first.id(), this._grapholscape.diagramId);
        if (!firstInputGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(firstInputGrapholNode);
        owlString = `${axiomType}${cardinality}ValuesFrom(`;
        // if the node is a range-restriction, put the inverse of the role
        if (restrictionType == TypesEnum.RANGE_RESTRICTION) {
            owlString += this.objectInverseOf(first);
        }
        else {
            owlString += this.nodeToOwlString(first);
        }
        if (!other && axiomType == 'Object') {
            return owlString += ` ${this.owlThing})`;
        }
        if (!other && axiomType == 'Data') {
            return owlString += ` ${this.rdfsLiteral})`;
        }
        return owlString += ` ${this.nodeToOwlString(other)})`;
    }
    minMaxExactCardinality(first, other, cardinality, restrictionType) {
        const getCardinalityString = (cardinality, cardinalityType) => {
            if (restrictionType == TypesEnum.RANGE_RESTRICTION) {
                if (!other)
                    return `${axiomType}${cardinalityType}Cardinality(${cardinality} ${this.objectInverseOf(first)})`;
                else
                    return `${axiomType}${cardinalityType}Cardinality(${cardinality} ${this.objectInverseOf(first)} ${this.nodeToOwlString(other)})`;
            }
            else {
                if (!other)
                    return `${axiomType}${cardinalityType}Cardinality(${cardinality} ${this.nodeToOwlString(first)})`;
                else
                    return `${axiomType}${cardinalityType}Cardinality(${cardinality} ${this.nodeToOwlString(first)} ${this.nodeToOwlString(other)})`;
            }
        };
        const firstInputGrapholNode = this._grapholscape.ontology.getGrapholNode(first.id(), this._grapholscape.diagramId);
        if (!firstInputGrapholNode)
            return;
        const axiomType = this.getAxiomPropertyType(firstInputGrapholNode);
        if (cardinality[0] == '-') {
            return getCardinalityString(cardinality[1], 'Max');
        }
        if (cardinality[1] == '-') {
            return getCardinalityString(cardinality[0], 'Min');
        }
        if (cardinality[0] != '-' && cardinality[1] != '-') {
            var min = [];
            var max = [];
            min.push(cardinality[0]);
            min.push('-');
            max.push('-');
            max.push(cardinality[1]);
            return `${axiomType} IntersectionOf(${this.minMaxExactCardinality(first, other, min, restrictionType)} ${this.minMaxExactCardinality(first, other, max, restrictionType)})`;
        }
    }
    objectInverseOf(node) {
        return `ObjectInverseOf(${this.nodeToOwlString(node)})`;
    }
    objectPropertyChain(inputs) {
        let owlString = 'ObjectPropertyChain(';
        inputs.forEach(input => {
            owlString += this.nodeToOwlString(input) + ' ';
        });
        owlString = owlString.slice(0, owlString.length - 1);
        owlString += ')';
        return owlString;
    }
    hasKey(inputs) {
        let classNode = inputs.filter(`[identity = "${TypesEnum.CLASS}}"]`);
        let owlString = `HasKey(${this.nodeToOwlString(classNode)} `;
        inputs.forEach(input => {
            if (input.id() != classNode.id()) {
                owlString += this.nodeToOwlString(input) + ' ';
            }
        });
        owlString = owlString.slice(0, owlString.length - 1) + ')';
        return owlString;
    }
    logicalConstructors(inputs, constructorName, axiomType) {
        let owlString;
        if (constructorName == TypesEnum.ENUMERATION) {
            constructorName = 'One';
        }
        else // Capitalize first char
         {
            constructorName = constructorName.charAt(0).toUpperCase() + constructorName.slice(1);
        }
        owlString = axiomType + constructorName + 'Of(';
        inputs.forEach((input) => {
            owlString += this.nodeToOwlString(input) + ' ';
        });
        owlString = owlString.slice(0, owlString.length - 1);
        owlString += ')';
        return owlString;
    }
    disjointClassesFromNode(inputs) {
        let owlString = 'DisjointClasses(';
        inputs.forEach((input) => {
            owlString += this.nodeToOwlString(input) + ' ';
        });
        owlString = owlString.slice(0, owlString.length - 1);
        owlString += ')';
        return owlString;
    }
    datatypeRestriction(inputs) {
        let owlString = 'DatatypeRestriction(';
        let valueDomain = inputs.filter(`[type = "${TypesEnum.VALUE_DOMAIN}"]`)[0];
        owlString += this.nodeToOwlString(valueDomain) + ' ';
        inputs.forEach((input) => {
            if (input.data('type') == TypesEnum.FACET) {
                owlString += this.nodeToOwlString(input) + '^^';
                owlString += this.nodeToOwlString(valueDomain) + ' ';
            }
        });
        owlString = owlString.slice(0, owlString.length - 1);
        owlString += ')';
        return owlString;
    }
    hasSelf(input, restrictionType) {
        // if the restriction is on the range, put the inverse of node
        if (restrictionType == TypesEnum.RANGE_RESTRICTION)
            return `ObjectHasSelf(${this.objectInverseOf(input)})`;
        return `ObjectHasSelf(${this.nodeToOwlString(input)})`;
    }
    getAxiomPropertyType(node) {
        if (node.is(TypesEnum.DATA_PROPERTY))
            return 'Data';
        else if (node.is(TypesEnum.OBJECT_PROPERTY))
            return 'Object';
        if (isGrapholNode(node)) {
            if (node.identity === TypesEnum.DATA_PROPERTY)
                return 'Data';
            else if (node.identity === TypesEnum.OBJECT_PROPERTY)
                return 'Object';
        }
        return '';
    }
}

function init$3 (owlVisualizerComponent, grapholscape) {
    grapholscape.on(LifecycleEvent.NodeSelection, node => {
        var _a;
        showOwlTranslation((_a = grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(node.id));
    });
    grapholscape.on(LifecycleEvent.EdgeSelection, edge => {
        var _a;
        showOwlTranslation((_a = grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(edge.id));
    });
    // grapholscape.onNodeSelection( node => showOwlTranslation(node))
    // grapholscape.onEdgeSelection( edge => showOwlTranslation(edge))
    grapholscape.on(LifecycleEvent.RendererChange, rendererKey => {
        if (rendererKey !== RendererStatesEnum.GRAPHOL)
            owlVisualizerComponent.hide();
    });
    function showOwlTranslation(elem) {
        if (!elem)
            return;
        if (grapholscape.renderState === RendererStatesEnum.GRAPHOL) {
            const owlTranslator = new GrapholToOwlTranslator(grapholscape);
            if (elem.isNode())
                owlVisualizerComponent.owlText = owlTranslator.nodeToOwlString(elem, true) || '';
            else
                owlVisualizerComponent.owlText = owlTranslator.edgeToOwlString(elem) || '';
            owlVisualizerComponent.show();
        }
    }
}

class GscapeOwlVisualizer extends BaseMixin$3(DropPanelMixin(s)) {
    constructor() {
        super(...arguments);
        this.title = "OWL 2 Translation";
        this.owlText = '';
        this.isDefaultClosed = false;
    }
    render() {
        if (!this.owlText)
            return;
        return x `
      <div class="top-bar ${this.isPanelClosed() ? null : 'traslated-down'}">
        <gscape-button style="z-index: 1"
          id="toggle-panel-button"
          size="${this.isPanelClosed() ? 'm' : 's'}" 
          type="${this.isPanelClosed() ? '' : 'subtle'}"
          @click=${this.togglePanel}
          label = "${this.isPanelClosed() ? this.title : ''}"
        > 
          ${this.isPanelClosed()
            ? x `
                <span slot="icon">${owl_icon}</span>
                <span slot="trailing-icon">${plus}</span>
              `
            : x `<span slot="icon">${minus}</span>`}
        </gscape-button>
      </div>

      <div class="gscape-panel" id="drop-panel">
        <div class="owl-text"></div>
      </div>
    `;
    }
    // override blur to avoid collapsing when clicking on cytoscape's canvas
    blur() { }
    updated() {
        var _a;
        const owlTextDiv = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.owl-text');
        if (owlTextDiv)
            owlTextDiv.innerHTML = this.owlText;
    }
}
GscapeOwlVisualizer.properties = {
    owlText: { type: String, attribute: false }
};
GscapeOwlVisualizer.styles = [
    baseStyle$3,
    i$1 `
      :host {
        bottom: 10px;
        position: absolute;
        max-width: calc(90% - 64px);
        left: 50%;
        transform: translate(-50%);
      }

      .gscape-panel {
        max-width: unset;
        width: 100%;
        box-sizing: border-box;
      }

      .owl-text {
        padding: 15px 10px;
        font-family: "Lucida Console", Monaco, monospace;
        overflow: auto;
        white-space: nowrap;
        text-overflow: ellipsis;
      }

      .owl_class{
        color: #b58900;
      }

      .owl_object-property{
        color: #268bd2;
      }

      .owl_data-property{
        color: #859900;
      }

      .owl_value-domain{
        color: #2aa198;
      }

      .owl_individual{
        color: #6c71c4;
      }

      .owl_value {
        color: #d33682;
      }

      .axiom_predicate_prefix{
        color:#cb4b16;
      }

      .owl_error {
        color: var(--theme-gscape-error);
      }

      .axiom_predefinite_obj {
        color: #00c0a0;
      }
      
      .top-bar {
        display: flex;
        flex-direction: row-reverse;
        line-height: 1;
      }

      .traslated-down {
        position: absolute;
        right: 0;
      }

    `,
];
customElements.define('gscape-owl-visualizer', GscapeOwlVisualizer);

function initOwlVisualizer(grapholscape) {
    const owlVisualizerComponent = new GscapeOwlVisualizer();
    init$3(owlVisualizerComponent, grapholscape);
    grapholscape.widgets.set(WidgetEnum$1.OWL_VISUALIZER, owlVisualizerComponent);
}

class GscapeRenderSelector extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.title = 'Renderer Selector';
        this.onRendererStateSelection = () => { };
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
    }
    render() {
        var _a;
        return x `
      ${this.currentRendererStateKey === RendererStatesEnum.FLOATY ||
            this.currentRendererStateKey === RendererStatesEnum.INCREMENTAL
            ? x `
          ${this.currentRendererStateKey === RendererStatesEnum.INCREMENTAL && this.onIncrementalReset
                ? x `
              <gscape-button @click=${this.onIncrementalReset} type="subtle" title="Restart Incremental Exploration">
                <span slot="icon">${refresh}</span>
              </gscape-button>
              <div class="hr"></div>
            `
                : null}
          ${this.layoutSettingsComponent}
          <div class="hr"></div>
        `
            : null}

      <gscape-button @click="${this.togglePanel}" type="subtle">
        <span slot="icon">${(_a = this.currentRendererState) === null || _a === void 0 ? void 0 : _a.icon}</span>
      </gscape-button>

      <div class="gscape-panel gscape-panel-in-tray hanging hide" id="drop-panel">
        <div class="header">${this.title}</div>
        <div class="content-wrapper">
      ${this.rendererStates.map(rendererState => {
            if (rendererState) {
                return x `
                <gscape-action-list-item
                  @click=${this.rendererSelectionHandler}
                  label="${rendererState.name}"
                  renderer-state="${rendererState.id}"
                  ?selected = "${this.currentRendererState === rendererState}"
                >
                  <span slot="icon">${rendererState.icon}</span>
                </gscape-action-list-item>
              `;
            }
        })}
        </div>
      </div>
    `;
    }
    rendererSelectionHandler(e) {
        this.togglePanel();
        const rendererState = e.target.getAttribute('renderer-state');
        this.onRendererStateSelection(rendererState);
    }
    get currentRendererState() { return this.rendererStates.find(r => (r === null || r === void 0 ? void 0 : r.id) === this.currentRendererStateKey); }
}
GscapeRenderSelector.properties = {
    currentRendererStateKey: { type: String, attribute: false },
    rendererStates: { type: Object, attribute: false },
    onIncrementalRefresh: { type: Object, attribute: false }
};
GscapeRenderSelector.styles = [
    baseStyle$3,
    i$1 `
      :host {
        order: 7;
        margin-top:10px;
      }
    `
];
customElements.define('gscape-render-selector', GscapeRenderSelector);

class GscapeLayoutSettings extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.layoutRun = false;
        this.dragAndPin = false;
        this.originalPositions = false;
        this.onLayoutRunToggle = () => { };
        this.onDragAndPinToggle = () => { };
        this.onUseOriginalPositions = () => { };
    }
    render() {
        return x `
      <gscape-button type="subtle" @click="${this.togglePanel}">
        <span slot="icon">${settings_play}</span>
      </gscape-button>

      <div id="drop-panel" class="hide gscape-panel gscape-panel-in-tray hanging">
        <div class="header">Layout Settings</div>
        <div class="toggles-wrapper">

          <gscape-toggle
            class="actionable"
            @click = ${this.layoutRunToggleHandler}
            key = "layout-run"
            label = "Layout run"
            ?checked = ${this.layoutRun}
          ></gscape-toggle>

          <gscape-toggle
            class="actionable"
            @click = ${this.dragAndPinToggleHandler}
            key = "drag-and-pin"
            label = "Drag and pin"
            ?checked = ${this.dragAndPin}
          ></gscape-toggle>

        </div>
      </div>
    `;
    }
    layoutRunToggleHandler(e) {
        e.preventDefault();
        this.onLayoutRunToggle();
    }
    dragAndPinToggleHandler(e) {
        e.preventDefault();
        this.onDragAndPinToggle();
    }
}
GscapeLayoutSettings.properties = {
    layoutRun: { type: Boolean, attribute: false },
    dragAndPin: { type: Boolean, attribute: false },
    originalPositions: { type: Boolean, attribute: false },
};
GscapeLayoutSettings.styles = [
    baseStyle$3,
    i$1 `
      :host {
        box-shadow: initial;
        position: initial;
      }

      gscape-toggle {
        padding: 8px;
      }

      .toggles-wrapper {
        display: flex;
        flex-direction: column;
      }
    `,
];
customElements.define('gscape-layout-settings', GscapeLayoutSettings);

/**
 *
 * @param {import('./layout-settings').default} layoutSettingsComponent
 * @param {import('../../../grapholscape').default} grapholscape
 */
function init$2 (layoutSettingsComponent, grapholscape) {
    if (grapholscape.renderState)
        updateToggles(grapholscape.renderState);
    layoutSettingsComponent.onLayoutRunToggle = () => {
        if (grapholscape.renderState !== RendererStatesEnum.FLOATY &&
            grapholscape.renderState !== RendererStatesEnum.INCREMENTAL)
            return;
        const renderer = grapholscape.renderer.renderState;
        // if (!grapholscape.renderer.layoutStopped) {
        //   layoutSettingsComponent.useOriginalPositionsToggle.state = false
        //   grapholscape.renderer.useOriginalPositions = false
        // }
        if (renderer.isLayoutInfinite) {
            renderer.stopLayout();
        }
        else {
            renderer.runLayoutInfinitely();
        }
        updateToggles(renderer.id);
    };
    layoutSettingsComponent.onDragAndPinToggle = () => {
        if (grapholscape.renderState !== RendererStatesEnum.FLOATY &&
            grapholscape.renderState !== RendererStatesEnum.INCREMENTAL)
            return;
        const renderer = grapholscape.renderer.renderState;
        renderer.dragAndPin = !renderer.dragAndPin;
        updateToggles(renderer.id);
    };
    grapholscape.on(LifecycleEvent.RendererChange, (rendererState) => {
        updateToggles(rendererState);
    });
    function updateToggles(renderState) {
        if (renderState === RendererStatesEnum.FLOATY ||
            grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
            const renderer = grapholscape.renderer.renderState;
            layoutSettingsComponent.layoutRun = renderer.isLayoutInfinite;
            layoutSettingsComponent.dragAndPin = renderer.dragAndPin;
        }
    }
    // layoutSettingsComponent.onUseOriginalPositions = () => {
    //   if (!grapholscape.renderer.useOriginalPositions) {
    //     layoutSettingsComponent.layoutRunToggle.state = false
    //     grapholscape.renderer.layoutStopped = true
    //   }
    //   grapholscape.renderer.useOriginalPositions = !grapholscape.renderer.useOriginalPositions
    // }
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initLayoutSettings(grapholscape) {
    const layoutSettingsComponent = new GscapeLayoutSettings();
    init$2(layoutSettingsComponent, grapholscape);
    return layoutSettingsComponent;
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initRendererSelector(grapholscape) {
    const rendererSelectorComponent = new GscapeRenderSelector();
    init$9(rendererSelectorComponent, grapholscape);
    rendererSelectorComponent.layoutSettingsComponent = initLayoutSettings(grapholscape);
    rendererSelectorComponent.requestUpdate();
    grapholscape.widgets.set(WidgetEnum$1.RENDERER_SELECTOR, rendererSelectorComponent);
    grapholscape.widgets.set(WidgetEnum$1.LAYOUT_SETTINGS, rendererSelectorComponent.layoutSettingsComponent);
}

var settingsStyle = i$1 `
  .settings-wrapper {
    overflow-y: auto;
    scrollbar-width: inherit;
    max-height: 320px;
    overflow-x: hidden;
    padding: 0 8px;
  }

  .area:last-of-type {
    margin-bottom: 0;
  }

  .setting {
    padding: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .setting-label {
    font-size: 10px;
  }

  .title-wrap {
    white-space: normal;
    width: 220px;
  }
`;

class GscapeSettings extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.title = 'Settings';
        this.widgetStates = {};
        this.onEntityNameTypeChange = () => { };
        this.onLanguageChange = () => { };
        this.onThemeChange = () => { };
        this.onWidgetEnabled = () => { };
        this.onWidgetDisabled = () => { };
        this.onPngExport = () => { };
        this.onSvgExport = () => { };
        this.onJSONExport = () => { };
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
    }
    render() {
        return x `
      <gscape-button type="subtle" @click=${this.togglePanel}>
        <span slot="icon">${settings_icon}</span>
      </gscape-button>

      <div class="gscape-panel gscape-panel-in-tray hide" id="drop-panel">
        <div class="header">${this.title}</div>

        <div class="settings-wrapper">

        <div class="area">
            <div class="bold-text">Preferences</div>
            ${this.getListSettingEntryTemplate(Object.values(RDFGraphConfigEntityNameTypeEnum).map(ent => {
            return { value: ent, label: capitalizeFirstChar(ent) };
        }), this.selectedEntityNameType, 'Entities Name', 'Select the type of name to display on entities')}

            ${this.getListSettingEntryTemplate(this.languages.map(l => {
            return { value: l, label: l };
        }), this.selectedLanguage, 'Language', 'Select the preferred language')}
        </div>

        <div class="area">
            <div class="bold-text">Appearance</div>
            ${this.getListSettingEntryTemplate(this.themes.map(theme => {
            return { value: theme.id, label: theme.name };
        }), this.selectedTheme, 'Theme', 'Select a theme')}
        </div>

        <div class="area">
            <div class="bold-text" style="padding-bottom: 2px">Widgets</div>
            ${Object.entries(this.widgetStates).map(([widgetName, widgetState]) => {
            if (widgetState !== undefined && widgetState !== null) {
                return this.getToggleSettingEntryTemplate(widgetState, widgetName);
            }
        })}
        </div>

        <div class="area">
          <div class="bold-text">Export Ontology Image</div>
          <div class="setting">
            ${this.getSettingTitleTemplate('Image', 'Save a PNG image of the current diagram on your disk')}
            
            <div class="setting-obj">
              <gscape-button label="PNG" size="s" @click=${this.onPngExport}>
                <span slot="icon">${save}</span>
              </gscape-button>
            </div>
          </div>

          <div class="setting">
            ${this.getSettingTitleTemplate('Vectorial', 'Save an SVG of the current diagram on your disk')}
            <div class="setting-obj">
              <gscape-button label="SVG" size="s" @click=${this.onSvgExport}>
                <span slot="icon">${save}</span>
              </gscape-button>
            </div>
          </div>
        </div>

        <div class="area">
          <div class="setting">
            <gscape-button label="Export JSON" size="s" @click=${this.onJSONExport}>
            </gscape-button>
          </div>
        </div>

        <div class="area">
          <div class="bold-text">About</div>
          <div id="logo">
            ${grapholscapeLogo}
          </div>

          <div id="version" class="muted-text">
            <span>Version: </span>
            <span>${"4.0.1-snap.0"}</span>
          </div>
        </div>
      </div>
    `;
    }
    getSettingTitleTemplate(title, label) {
        return x `
    <div class="title-wrap">
      <div class="setting-title">${title}</div>
      <div class="muted-text setting-label">${label}</div>
    </div>
    `;
    }
    getListSettingEntryTemplate(options, selectedOption, title, label) {
        if (options.length <= 0)
            return null;
        return x `
      <div class="setting">
        ${this.getSettingTitleTemplate(title, label)}
        <div class="setting-obj">
          <select id="${title}" @change=${this.listChangeHandler}>
            ${options.map(option => {
            let selected = option.value == selectedOption;
            return x `<option value="${option.value}" ?selected=${selected}>${option.label}</option>`;
        })}
          </select>
        </div>
      </div>
    `;
    }
    getToggleSettingEntryTemplate(currentState, title) {
        let labelPieces = title.split('-');
        const label = labelPieces.map(text => capitalizeFirstChar(text)).join(' ');
        return x `
      <div class="toggle-setting-obj">
        <gscape-toggle
          @click=${this.widgetToggleChangeHandler}
          label=${label}
          label-position="left"
          class="actionable"
          key = ${title}
          ?checked = ${currentState}
        ></gscape-toggle>
      </div>
    `;
    }
    listChangeHandler(e) {
        const selectId = e.target.id;
        const newValue = e.target.value;
        switch (selectId) {
            case 'Entities Name':
                if (newValue !== this.selectedEntityNameType) {
                    this.onEntityNameTypeChange(newValue);
                }
                break;
            case 'Language':
                if (newValue !== this.selectedLanguage) {
                    this.onLanguageChange(newValue);
                }
                break;
            case 'Theme':
                if (newValue !== this.selectedTheme) {
                    this.onThemeChange(newValue);
                }
                break;
        }
    }
    widgetToggleChangeHandler(e) {
        e.preventDefault();
        let toggle = e.target;
        toggle.checked ?
            this.onWidgetDisabled(toggle.key) :
            this.onWidgetEnabled(toggle.key);
    }
}
GscapeSettings.properties = {
    languages: { type: Object, attribute: false, },
    themes: { type: Object, attribute: false, },
    widgetStates: { type: Object, attribute: false, },
    selectedLanguage: { type: String, attribute: false, },
    selectedTheme: { type: String, attribute: false, },
};
GscapeSettings.styles = [
    baseStyle$3,
    GscapeButtonStyle,
    settingsStyle,
    i$1 `
      :host {
        order: 5;
        display:inline-block;
        position: initial;
        margin-top:10px;
      }

      .gscape-panel {
        overflow: hidden;
        text-overflow: ellipsis;
        padding-right: 0;
        padding-left: 0;
      }

      #logo {
        text-align:center;
      }

      #logo svg {
        width: 40%;
        height: auto;
        margin: 20px 0;
      }

      #version {
        text-align: center;
      }

      .toggle-setting-obj {
        width: 100%;
      }

      gscape-toggle {
        margin: 2px 0;
      }
    `,
];
customElements.define('gscape-settings', GscapeSettings);

function init$1 (settingsComponent, grapholscape) {
    settingsComponent.languages = grapholscape.ontology.languages;
    settingsComponent.selectedLanguage = grapholscape.language;
    settingsComponent.selectedEntityNameType = grapholscape.entityNameType;
    settingsComponent.themes = grapholscape.themeList;
    settingsComponent.selectedTheme = grapholscape.theme.id;
    for (let [widgetName, widget] of grapholscape.widgets) {
        settingsComponent.widgetStates[widgetName] = widget.enabled;
    }
    settingsComponent.requestUpdate();
    settingsComponent.onEntityNameTypeChange = (entityNameType) => {
        grapholscape.setEntityNameType(entityNameType);
    };
    settingsComponent.onLanguageChange = (language) => grapholscape.setLanguage(language);
    settingsComponent.onThemeChange = (themeKey) => {
        grapholscape.setTheme(themeKey);
    };
    settingsComponent.onPngExport = () => grapholscape.exportToPng();
    settingsComponent.onSvgExport = () => grapholscape.exportToSvg();
    settingsComponent.onJSONExport = () => grapholscape.exportToRdfGraph();
    // let gui_container = grapholscape.container.querySelector('#gscape-ui')
    settingsComponent.onWidgetEnabled = (widgetKey) => {
        const widget = grapholscape.widgets.get(widgetKey);
        widget.enable();
        storeConfigEntry(widgetKey, true);
        settingsComponent.widgetStates[widgetKey] = true;
        settingsComponent.requestUpdate();
    };
    settingsComponent.onWidgetDisabled = (widgetKey) => {
        const widget = grapholscape.widgets.get(widgetKey);
        widget.disable();
        storeConfigEntry(widgetKey, false);
        settingsComponent.widgetStates[widgetKey] = false;
        settingsComponent.requestUpdate();
    };
    grapholscape.on(LifecycleEvent.LanguageChange, language => settingsComponent.selectedLanguage = language);
    grapholscape.on(LifecycleEvent.EntityNameTypeChange, entityNameType => settingsComponent.selectedEntityNameType = entityNameType);
    grapholscape.on(LifecycleEvent.ThemeChange, newTheme => settingsComponent.selectedTheme = newTheme.id);
    // function updateOnChange(settingID, newValue) {
    //   let select = settingsComponent.shadowRoot.querySelector(`#${settingID}`)
    //   let option = Array.from(select.options)?.find( o => o.value === newValue)
    //   if (option) {
    //     option.selected = true
    //     let languageSelect = settingsComponent.shadowRoot.querySelector('#language')
    //     if (select.id == 'entity_name') 
    //       languageSelect.disabled = (select.value !== 'label')
    //   }
    // }
}

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initSettings(grapholscape) {
    const settingsComponent = new GscapeSettings();
    init$1(settingsComponent, grapholscape);
    grapholscape.widgets.set(WidgetEnum$1.SETTINGS, settingsComponent);
}

var bottomRightContainer = () => {
    let div = document.createElement('div');
    div.style.setProperty('position', 'absolute');
    div.style.setProperty('bottom', '0');
    div.style.setProperty('right', '0');
    div.style.setProperty('margin', '10px');
    div.style.setProperty('display', 'flex');
    div.style.setProperty('align-items', 'center');
    div.style.setProperty('flex-direction', 'column-reverse');
    return div;
};

class GscapeZoomTools extends s {
    constructor() {
        super();
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
    }
    render() {
        return x `
      <gscape-button title="Zoom In" type="subtle" @click=${this._onZoomIn}><span slot="icon">${plus}</span></gscape-button>
      <div class="hr"></div>
      <gscape-button title="Zoom Out" type="subtle" @click=${this._onZoomOut}><span slot="icon">${minus}</span></gscape-button>
    `;
    }
    set onZoomIn(f) {
        this._onZoomIn = f;
    }
    set onZoomOut(f) {
        this._onZoomOut = f;
    }
}
GscapeZoomTools.styles = [
    baseStyle$3,
    i$1 `
      :host {
        order: 1;
        margin-top:10px;
        position: initial;
      }
    `
];
customElements.define('gscape-zoom-tools', GscapeZoomTools);

/**
 * @param {import('../../grapholscape').default} grapholscape
 */
function initZoomTools(grapholscape) {
    const zoomToolsComponent = new GscapeZoomTools();
    zoomToolsComponent.onZoomIn = () => grapholscape.zoomIn(0.4);
    zoomToolsComponent.onZoomOut = () => grapholscape.zoomOut(0.4);
    grapholscape.widgets.set(WidgetEnum$1.ZOOM_TOOLS, zoomToolsComponent);
}

/**
 * Initialize the UI
 */
function init (grapholscape) {
    const guiContainer = document.createElement('div');
    guiContainer.classList.add('gscape-ui');
    guiContainer.style.height = '100%';
    guiContainer.style.width = '100%';
    guiContainer.style.position = 'absolute';
    guiContainer.style.top = '0';
    guiContainer.style.pointerEvents = 'none';
    grapholscape.container.appendChild(guiContainer);
    const buttonsTray = bottomRightContainer();
    buttonsTray.classList.add('gscape-ui-buttons-tray');
    guiContainer.appendChild(buttonsTray);
    initDiagramSelector(grapholscape);
    initFullscreenButton(grapholscape);
    initFitButton(grapholscape);
    initZoomTools(grapholscape);
    initFilters(grapholscape);
    initOntologyInfo(grapholscape);
    initEntityDetails(grapholscape);
    initOntologyExplorer(grapholscape);
    initOwlVisualizer(grapholscape);
    initSettings(grapholscape);
    // initEntitySelector(grapholscape)
    initRendererSelector(grapholscape);
    initInitialRendererSelector(grapholscape);
    const settingsComponent = grapholscape.widgets.get(WidgetEnum$1.SETTINGS);
    grapholscape.widgets.forEach((widget, key) => {
        switch (key) {
            default:
                buttonsTray.appendChild(widget);
                break;
            case WidgetEnum$1.FULLSCREEN_BUTTON:
            case WidgetEnum$1.DIAGRAM_SELECTOR:
            case WidgetEnum$1.ENTITY_DETAILS:
            case WidgetEnum$1.OWL_VISUALIZER:
            case WidgetEnum$1.ENTITY_SELECTOR:
                guiContainer.appendChild(widget);
                break;
            case WidgetEnum$1.LAYOUT_SETTINGS:
            case WidgetEnum$1.NEW_CLASS:
            case WidgetEnum$1.NEW_DIAGRAM:
            case WidgetEnum$1.NEW_DATAPROPERTY:
            case WidgetEnum$1.NEW_OBJECTPROPERTY:
                break;
            case WidgetEnum$1.INITIAL_RENDERER_SELECTOR:
                grapholscape.container.appendChild(widget);
                break;
        }
        const _widget = widget;
        _widget.onStateChange = () => {
            if (settingsComponent) {
                settingsComponent.widgetStates[key] = _widget.enabled;
                settingsComponent.requestUpdate();
            }
        };
        if (grapholscape.widgetsInitialStates && grapholscape.widgetsInitialStates[key] === false) {
            _widget.disable();
        }
    });
    if (!grapholscape.container.style.getPropertyValue('--gscape-border-radius'))
        grapholscape.container.style.setProperty('--gscape-border-radius', '8px');
    if (!grapholscape.container.style.getPropertyValue('--gscape-border-radius-btn'))
        grapholscape.container.style.setProperty('--gscape-border-radius-btn', '6px');
    if (!grapholscape.container.style.getPropertyValue('--gscape-font-size'))
        grapholscape.container.style.setProperty('--gscape-font-size', '14px');
    grapholscape.container.style.color = `var(${CSS_PROPERTY_NAMESPACE}-fg-default)`;
    grapholscape.container.style.fontSize = `var(--gscape-font-size)`;
    grapholscape.on(LifecycleEvent.BackgroundClick, blurAll);
    function blurAll(widgetsToSkip = []) {
        grapholscape.widgets.forEach((widget, key) => {
            if ((key === WidgetEnum$1.ENTITY_DETAILS || key === WidgetEnum$1.OWL_VISUALIZER)
                && !widgetsToSkip.includes(widget)) {
                widget.hide();
            }
            else if (!widgetsToSkip.includes(widget) && key !== WidgetEnum$1.ENTITY_SELECTOR) {
                widget.blur();
            }
        });
    }
}

/** @module UI */

var UI = /*#__PURE__*/Object.freeze({
    __proto__: null,
    icons: index$1,
    GscapeContextMenu: GscapeContextMenu$1,
    GscapeConfirmDialog: GscapeConfirmDialog,
    showMessage: showMessage,
    GscapeToggle: GscapeToggle,
    GscapeSelect: GscapeSelect,
    GscapeEntitySelector: GscapeEntitySelector,
    initUI: init,
    entityListItemStyle: entityListItemStyle,
    BOTTOM_RIGHT_WIDGET_CLASS: BOTTOM_RIGHT_WIDGET,
    baseStyle: baseStyle$3,
    emptySearchBlankState: emptySearchBlankState,
    getIconSlot: getIconSlot$1,
    get WidgetEnum () { return WidgetEnum$1; },
    GscapeButton: GscapeButton$1,
    NodeButton: NodeButton,
    GscapeButtonStyle: GscapeButtonStyle,
    get SizeEnum () { return SizeEnum$1; },
    GscapeActionListItem: GscapeActionListItem,
    GscapeActionListStyle: actionItemStyle,
    GscapeEntityListItem: GscapeEntityListItem,
    BaseMixin: BaseMixin$3,
    DropPanelMixin: DropPanelMixin,
    hasDropPanel: hasDropPanel,
    ModalMixin: ModalMixin$3,
    ContextualWidgetMixin: ContextualWidgetMixin,
    textSpinner: textSpinner,
    textSpinnerStyle: textSpinnerStyle,
    getContentSpinner: getContentSpinner,
    contentSpinnerStyle: contentSpinnerStyle,
    ContentSpinner: ContentSpinner,
    GscapeTextSearch: GscapeTextSearch,
    GscapeEntitySearch: GscapeEntitySearch,
    GscapeEntityTypeFilters: GscapeEntityTypeFilters,
    get ToggleLabelPosition () { return ToggleLabelPosition; },
    GscapeFullPageSelector: GscapeFullPageSelector,
    initInitialRendererSelector: initInitialRendererSelector,
    getEntityOccurrencesTemplate: getEntityOccurrencesTemplate,
    createEntitiesList: createEntitiesList,
    search: search
});

class DiagramBuilder {
    constructor(diagram, rendererState) {
        this.diagram = diagram;
        this.rendererState = rendererState;
    }
    addClass(classEntity, positionOrNode) {
        var _a, _b;
        if ((_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.containsEntity(classEntity)) {
            const nodeId = classEntity.getIdInDiagram(this.diagram.id, TypesEnum.CLASS, this.rendererState);
            return nodeId
                ? this.diagramRepresentation.grapholElements.get(nodeId)
                : undefined;
        }
        let position, classNode;
        if (positionOrNode && isGrapholNode(positionOrNode)) {
            classNode = positionOrNode;
        }
        else if (positionOrNode) {
            position = positionOrNode;
        }
        if (!classNode) {
            classNode = new GrapholNode(this.getNewId('node'), TypesEnum.CLASS);
            classNode.iri = classEntity.iri.fullIri;
            classNode.displayedName = classEntity.getDisplayedName(RDFGraphConfigEntityNameTypeEnum.LABEL);
            classNode.height = classNode.width = 80;
            classNode.position = position || { x: 0, y: 0 };
            classNode.originalId = classNode.id;
            classNode.diagramId = this.diagram.id;
        }
        classEntity.addOccurrence(classNode, this.rendererState);
        (_b = this.diagramRepresentation) === null || _b === void 0 ? void 0 : _b.addElement(classNode, classEntity);
        return classNode;
    }
    addDataProperty(dataPropertyEntity, ownerEntity) {
        var _a, _b, _c;
        const dataPropertyNode = new GrapholNode(this.getNewId('node'), TypesEnum.DATA_PROPERTY);
        const ownerEntityId = ownerEntity.getIdInDiagram(this.diagram.id, TypesEnum.CLASS, this.rendererState);
        if (!ownerEntityId)
            return;
        let ownerEntityNode = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(ownerEntityId);
        if (!dataPropertyNode || !ownerEntityNode)
            return;
        dataPropertyNode.diagramId = this.diagram.id;
        dataPropertyNode.iri = dataPropertyEntity.iri.fullIri;
        dataPropertyNode.displayedName = dataPropertyEntity.getDisplayedName(RDFGraphConfigEntityNameTypeEnum.LABEL);
        if (isGrapholNode(ownerEntityNode)) {
            dataPropertyNode.position = ownerEntityNode.position;
        }
        dataPropertyNode.originalId = dataPropertyNode.id;
        dataPropertyEntity.addOccurrence(dataPropertyNode, RendererStatesEnum.FLOATY);
        const dataPropertyEdge = new GrapholEdge(this.getNewId('edge'), TypesEnum.DATA_PROPERTY);
        dataPropertyEdge.diagramId = this.diagram.id;
        dataPropertyEdge.sourceId = ownerEntityNode.id;
        dataPropertyEdge.targetId = dataPropertyNode.id;
        (_b = this.diagramRepresentation) === null || _b === void 0 ? void 0 : _b.addElement(dataPropertyNode, dataPropertyEntity);
        (_c = this.diagramRepresentation) === null || _c === void 0 ? void 0 : _c.addElement(dataPropertyEdge);
        return dataPropertyNode;
    }
    /**
     * Add an object property between two entities.
     * If the source and/or target entities are already present in graph, they won't be added again.
     * If there already exists an object property between them with the same IRI, the
     * edge won't be added.
     * @param objectPropertyEntity the object property entity
     * @param sourceEntity the source entity
     * @param targetEntity the target entity
     * @param nodesType the type of source and target, they must have same type
     * @param objectPropertyElement [optional] to use your own GrapholEdge for the object property occurrence.
     * if you don't pass this, a new GrapholEdge will be created from scratch
     * @returns
     */
    addObjectProperty(objectPropertyEntity, sourceEntity, targetEntity, nodesType, objectPropertyElement) {
        var _a;
        // if both object property and range class are already present, do not add them again
        let sourceNode = this.getEntityCyRepr(sourceEntity, nodesType);
        let targetNode = this.getEntityCyRepr(targetEntity, nodesType);
        if (sourceNode.nonempty() && targetNode.nonempty()) {
            /**
             * If the set of edges between reference node and the connected class
             * includes the object property we want to add, then it's already present.
             */
            let edgesAlreadyPresent = sourceNode.edgesWith(targetNode)
                .filter(e => e.data().iri === objectPropertyEntity.iri.fullIri);
            if (edgesAlreadyPresent.nonempty()) {
                return (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(edgesAlreadyPresent.first().id());
            }
        }
        if (sourceNode.empty()) {
            sourceEntity.is(TypesEnum.CLASS_INSTANCE) ? this.addClassInstance(sourceEntity) : this.addClass(sourceEntity);
            sourceNode = this.getEntityCyRepr(sourceEntity, nodesType);
            if (sourceNode.empty()) {
                console.warn(`Unable to find the node that has been automatically added with IRI: ${sourceEntity.iri.fullIri}`);
                return;
            }
        }
        if (targetNode.empty()) {
            targetEntity.is(TypesEnum.CLASS_INSTANCE) ? this.addClassInstance(targetEntity) : this.addClass(targetEntity);
            targetNode = this.getEntityCyRepr(targetEntity, nodesType);
            if (targetNode.empty()) {
                console.warn(`Unable to find the node that has been automatically added with IRI: ${targetEntity.iri.fullIri}`);
                return;
            }
        }
        if (!this.diagramRepresentation ||
            !sourceEntity.is(nodesType) ||
            !targetEntity.is(nodesType)) {
            return;
        }
        let objectPropertyEdge;
        if (!objectPropertyElement) {
            objectPropertyEdge = new GrapholEdge(this.getNewId('edge'), TypesEnum.OBJECT_PROPERTY);
            objectPropertyEdge.displayedName = objectPropertyEntity.getDisplayedName(RDFGraphConfigEntityNameTypeEnum.LABEL);
            objectPropertyEdge.originalId = objectPropertyEdge.id;
            objectPropertyEdge.iri = objectPropertyEntity.iri.fullIri;
        }
        else {
            objectPropertyEdge = objectPropertyElement;
        }
        /**
         * objectPropertyEdge might not have the right source(target)NodeId,
         * can happen loading rdfGraph in VKG having edges between instances
         * that were already present in the diagram.
         * Just set the right IDs anyway, either a custom edge was provided or not.
         */
        objectPropertyEdge.sourceId = sourceNode.id();
        objectPropertyEdge.targetId = targetNode.id();
        objectPropertyEdge.diagramId = this.diagram.id;
        objectPropertyEntity.addOccurrence(objectPropertyEdge, this.rendererState);
        this.diagramRepresentation.addElement(objectPropertyEdge, objectPropertyEntity);
        return objectPropertyEdge;
    }
    addClassInstance(classInstanceEntity, positionOrElem) {
        var _a, _b;
        if ((_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.containsEntity(classInstanceEntity)) {
            const nodeId = classInstanceEntity.getIdInDiagram(this.diagram.id, TypesEnum.CLASS_INSTANCE, this.rendererState);
            if (nodeId)
                return this.diagramRepresentation.grapholElements.get(nodeId);
        }
        let position, instanceNode;
        if (positionOrElem && isGrapholNode(positionOrElem)) {
            instanceNode = positionOrElem;
            position = instanceNode.position;
        }
        else {
            instanceNode = new GrapholNode(this.getNewId('node'), TypesEnum.CLASS_INSTANCE);
            if (positionOrElem) {
                position = positionOrElem;
            }
        }
        if (!position) {
            // check if parent class is present in diagram
            for (let parentClassIri of classInstanceEntity.parentClassIris) {
                if ((_b = this.diagramRepresentation) === null || _b === void 0 ? void 0 : _b.containsEntity(parentClassIri)) {
                    instanceNode.position = this.diagramRepresentation.cy.$id(parentClassIri.fullIri).position() || { x: 0, y: 0 };
                    break;
                }
            }
            if (!instanceNode.position) {
                instanceNode.position = { x: 0, y: 0 };
            }
        }
        else {
            instanceNode.position = position;
        }
        return this._addIndividualOrClassInstance(instanceNode, classInstanceEntity);
    }
    addIndividual(individualEntity, position) {
        var _a;
        if ((_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.containsEntity(individualEntity)) {
            const nodeId = individualEntity.getIdInDiagram(this.diagram.id, TypesEnum.INDIVIDUAL, this.rendererState);
            if (nodeId)
                return this.diagramRepresentation.grapholElements.get(nodeId);
        }
        const instanceNode = new GrapholNode(this.getNewId('node'), TypesEnum.INDIVIDUAL);
        instanceNode.position = position || { x: 0, y: 0 };
        return this._addIndividualOrClassInstance(instanceNode, individualEntity);
    }
    _addIndividualOrClassInstance(grapholNode, grapholEntity) {
        var _a;
        grapholNode.diagramId = this.diagram.id;
        grapholNode.displayedName = grapholEntity.getDisplayedName(RDFGraphConfigEntityNameTypeEnum.LABEL);
        grapholNode.iri = grapholEntity.iri.fullIri;
        grapholNode.height = grapholNode.width = 50;
        grapholNode.shape = Shape$1.ELLIPSE;
        grapholNode.labelXpos = 0;
        grapholNode.labelYpos = 0;
        grapholEntity.addOccurrence(grapholNode, this.rendererState);
        (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.addElement(grapholNode, grapholEntity);
        return grapholNode;
    }
    addHierarchy(hierarchy, position) {
        var _a;
        const unionNode = hierarchy.getUnionGrapholNode(position);
        if (!unionNode)
            return;
        //hierarchy.id = `${unionNode.id}-${this.diagram.id}` 
        // Add inputs
        for (const inputClasses of hierarchy.inputs) {
            this.addClass(inputClasses, position);
        }
        // Add superclasses
        for (const superClass of hierarchy.superclasses) {
            this.addClass(superClass.classEntity, position);
        }
        const inputEdges = hierarchy.getInputGrapholEdges(this.diagram.id, this.rendererState);
        const inclusionEdges = hierarchy.getInclusionEdges(this.diagram.id, this.rendererState);
        if (!inputEdges || !inclusionEdges)
            return;
        (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.addElement(unionNode);
        inputEdges.forEach(inputEdge => { var _a; return (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.addElement(inputEdge); });
        inclusionEdges.forEach(inclusionEdge => { var _a; return (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.addElement(inclusionEdge); });
    }
    addEdge(sourceId, targetId, edgeType) {
        var _a, _b, _c, _d, _e, _f;
        const sourceNode = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(sourceId);
        const targetNode = (_b = this.diagramRepresentation) === null || _b === void 0 ? void 0 : _b.grapholElements.get(targetId);
        const sourceCyNode = (_c = this.diagramRepresentation) === null || _c === void 0 ? void 0 : _c.cy.$id(sourceId);
        const targetCyNode = (_d = this.diagramRepresentation) === null || _d === void 0 ? void 0 : _d.cy.$id(targetId);
        if (sourceCyNode && targetCyNode) {
            const edgesAlreadyPresent = sourceCyNode.edgesTo(targetCyNode).filter(e => e.data().type === edgeType);
            if (edgesAlreadyPresent.nonempty()) {
                return (_e = this.diagramRepresentation) === null || _e === void 0 ? void 0 : _e.grapholElements.get(edgesAlreadyPresent.first().id());
            }
        }
        else {
            return;
        }
        if (sourceNode && targetNode) {
            const instanceEdge = new GrapholEdge(this.getNewId('edge'), edgeType);
            instanceEdge.diagramId = this.diagram.id;
            instanceEdge.sourceId = sourceId;
            instanceEdge.targetId = targetId;
            (_f = this.diagramRepresentation) === null || _f === void 0 ? void 0 : _f.addElement(instanceEdge);
            return instanceEdge;
        }
    }
    get diagramRepresentation() {
        return this.diagram.representations.get(this.rendererState);
    }
    toggleFunctionality(entity, functional) {
        var _a;
        const id = entity.getIdInDiagram(this.diagram.id, TypesEnum.DATA_PROPERTY, this.rendererState);
        if (!id)
            return;
        const node = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$id(id);
        if (!node)
            return;
        node.data('functional', functional);
    }
    toggleUnion(node) {
        const type = node.data('type');
        if (type === TypesEnum.UNION) {
            node.removeClass('union');
            node.data('type', TypesEnum.DISJOINT_UNION);
            node.data('displayedName', undefined);
            node.addClass('disjoint-union');
            // edge
            const edge = node.connectedEdges().find(e => e.data('type') === TypesEnum.UNION);
            edge === null || edge === void 0 ? void 0 : edge.data('type', TypesEnum.DISJOINT_UNION);
        }
        else {
            node.removeClass('disjoint-union');
            node.data('type', TypesEnum.UNION);
            node.data('displayedName', 'or');
            node.data('labelXpos', 0);
            node.data('labelXcentered', true);
            node.data('labelYpos', 0);
            node.data('labelYcentered', true);
            node.addClass('union');
            // edge
            const edge = node.connectedEdges().find(e => e.data('type') === TypesEnum.DISJOINT_UNION);
            edge === null || edge === void 0 ? void 0 : edge.data('type', TypesEnum.UNION);
        }
    }
    toggleComplete(edge) {
        if (edge.data('targetLabel') === 'C') {
            edge.removeClass('equivalence');
            edge.data('targetLabel', '');
            edge.addClass('inclusion');
        }
        else {
            edge.removeClass('inclusion');
            edge.data('targetLabel', 'C');
            edge.addClass('equivalence');
        }
    }
    removeHierarchy(hierarchy) {
        var _a, _b, _c;
        if (hierarchy.id) {
            let unionNode = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$(`node[hierarchyID = "${hierarchy.id}"]`);
            if (!unionNode || unionNode.empty()) {
                return;
            }
            // remove input edges
            (_b = unionNode === null || unionNode === void 0 ? void 0 : unionNode.connectedEdges(`[ type = "${TypesEnum.INPUT}" ]`)) === null || _b === void 0 ? void 0 : _b.forEach(inputEdge => {
                var _a;
                (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.removeElement(inputEdge.id(), this.rendererState);
            });
            // remove inclusion edges
            (_c = unionNode === null || unionNode === void 0 ? void 0 : unionNode.connectedEdges(`[ type = "${hierarchy.type}" ]`)) === null || _c === void 0 ? void 0 : _c.forEach(inclusionEdge => {
                var _a;
                (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.removeElement(inclusionEdge.id(), this.rendererState);
            });
            // remove union node
            this.diagram.removeElement(unionNode.id(), this.rendererState);
        }
    }
    removeHierarchyInputEdge(hierarchy, inputIri) {
        var _a;
        if (hierarchy.id) {
            const unionNode = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$(`node[hierarchyID = "${hierarchy.id}"]`);
            unionNode === null || unionNode === void 0 ? void 0 : unionNode.edgesWith(`[ iri = "${inputIri}" ]`).forEach(inputEdge => {
                var _a;
                if (inputEdge.data().type === TypesEnum.INPUT)
                    (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.removeElement(inputEdge.id(), this.rendererState);
            });
        }
    }
    removeHierarchyInclusionEdge(hierarchy, superclassIri) {
        var _a;
        if (hierarchy.id) {
            const unionNode = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$(`node[hierarchyID = "${hierarchy.id}"]`);
            unionNode === null || unionNode === void 0 ? void 0 : unionNode.edgesTo(`[ iri = "${superclassIri}" ]`).forEach(inclusionEdge => {
                var _a;
                if (inclusionEdge.data().type === hierarchy.type)
                    (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.removeElement(inclusionEdge.id(), this.rendererState);
            });
        }
    }
    removeElement(id) {
        var _a, _b, _c;
        const cyElem = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$id(id);
        const grapholElem = (_b = this.diagramRepresentation) === null || _b === void 0 ? void 0 : _b.grapholElements.get(id);
        if (cyElem === null || cyElem === void 0 ? void 0 : cyElem.nonempty()) {
            if (grapholElem && grapholElem.is(TypesEnum.DATA_PROPERTY)) {
                cyElem.connectedEdges().forEach(e => {
                    var _a;
                    (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.removeElement(e.id());
                });
            }
            (_c = this.diagramRepresentation) === null || _c === void 0 ? void 0 : _c.removeElement(id);
        }
    }
    renameElement(elemId, newIri) {
        var _a, _b;
        const cyElem = (_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$id(elemId);
        cyElem === null || cyElem === void 0 ? void 0 : cyElem.data('iri', newIri.fullIri);
        cyElem === null || cyElem === void 0 ? void 0 : cyElem.data('displayedName', newIri.remainder);
        const grapholElem = (_b = this.diagramRepresentation) === null || _b === void 0 ? void 0 : _b.grapholElements.get(elemId);
        if (!grapholElem)
            return;
        grapholElem.iri = newIri.fullIri;
        grapholElem.displayedName = newIri.remainder;
    }
    /**
     * Get cytoscape representation of an entity given the type needed
     * @param entity
     * @param type
     * @returns
     */
    getEntityCyRepr(entity, type) {
        var _a;
        const occurrenceID = entity.getIdInDiagram(this.diagram.id, type, this.rendererState);
        if (occurrenceID)
            return ((_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.cy.$id(occurrenceID)) || cytoscape().collection();
        else
            return cytoscape().collection();
    }
    getNewId(nodeOrEdge) {
        var _a;
        return ((_a = this.diagramRepresentation) === null || _a === void 0 ? void 0 : _a.getNewId(nodeOrEdge)) || (nodeOrEdge === 'node' ? 'n0' : 'e0');
    }
}

function parseRDFGraph(rdfGraph, container) {
    var _a, _b;
    const rendererState = rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY
        ? RendererStatesEnum.FLOATY
        : RendererStatesEnum.INCREMENTAL;
    const ontology = getOntology(rdfGraph);
    ontology.entities = getEntities(rdfGraph, ontology.namespaces);
    const classInstances = getClassInstances(rdfGraph, ontology.namespaces);
    const parsedDiagrams = getDiagrams(rdfGraph, ontology, classInstances, rendererState);
    if (rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY)
        ontology.diagrams = parsedDiagrams;
    else
        parsedDiagrams[0];
    const grapholscape = new Grapholscape(ontology, container, getConfig(rdfGraph));
    if (grapholscape.incremental)
        grapholscape.incremental.classInstanceEntities = classInstances;
    let grapholEntity;
    parsedDiagrams.forEach(parsedDiagram => {
        parsedDiagram.representations.forEach((representation, rendererState) => {
            representation.grapholElements.forEach(elem => {
                var _a, _b;
                if (elem.iri) {
                    grapholEntity = rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY
                        ? ontology.getEntity(elem.iri)
                        : ((_b = (_a = grapholscape.incremental) === null || _a === void 0 ? void 0 : _a.classInstanceEntities) === null || _b === void 0 ? void 0 : _b.get(elem.iri)) || ontology.getEntity(elem.iri);
                    grapholEntity === null || grapholEntity === void 0 ? void 0 : grapholEntity.addOccurrence(elem, rendererState);
                }
            });
        });
    });
    (_b = (_a = rdfGraph.config) === null || _a === void 0 ? void 0 : _a.filters) === null || _b === void 0 ? void 0 : _b.forEach(f => {
        if (Object.values(RDFGraphConfigFiltersEnum).includes(f)) {
            grapholscape.filter(f);
        }
    });
    return grapholscape;
}
function getOntology(rdfGraph) {
    let ontology;
    ontology = new Ontology(rdfGraph.metadata.name || '', rdfGraph.metadata.version || '', rdfGraph.metadata.iri, rdfGraph.metadata.namespaces.map(n => new Namespace(n.prefixes, n.value)));
    if (rdfGraph.metadata.languages) {
        ontology.languages = rdfGraph.metadata.languages;
    }
    ontology.defaultLanguage = rdfGraph.metadata.defaultLanguage;
    if (rdfGraph.metadata.annotations) {
        ontology.annotations = rdfGraph.metadata.annotations.map(a => {
            return new Annotation(new Iri(a.property, ontology.namespaces), a.lexicalForm, a.language, a.datatype);
        });
    }
    return ontology;
}
function getEntities(rdfGraph, namespaces) {
    let iri;
    const entities = new Map();
    let entity;
    rdfGraph.entities.forEach(e => {
        iri = new Iri(e.fullIri, namespaces);
        entity = GrapholEntity.newFromSwagger(iri, e);
        entity.annotations = getEntityAnnotations$2(e, namespaces);
        console.log(getEntityAnnotations$2(e, namespaces));
        entities.set(iri.fullIri, entity);
    });
    return entities;
}
function getClassInstances(rdfGraph, namespaces) {
    var _a;
    const classInstances = new Map();
    let classInstance;
    (_a = rdfGraph.classInstanceEntities) === null || _a === void 0 ? void 0 : _a.forEach(ci => {
        var _a;
        let iri = new Iri(ci.fullIri, [], ci.shortIri);
        let parentClassesIris = ((_a = ci.parentClasses) === null || _a === void 0 ? void 0 : _a.map(p => new Iri(p, namespaces))) || [];
        classInstance = new ClassInstanceEntity(iri, parentClassesIris);
        classInstance.annotations = getEntityAnnotations$2(ci, namespaces);
        if (ci.dataProperties)
            classInstance.dataProperties = ci.dataProperties;
        classInstances.set(iri.fullIri, classInstance);
    });
    return classInstances;
}
function getEntityAnnotations$2(rdfEntity, namespaces) {
    var _a;
    return ((_a = rdfEntity.annotations) === null || _a === void 0 ? void 0 : _a.map(a => {
        const annotationProperty = Object.values(AnnotationProperty).find(property => {
            return property.equals(a.property);
        }) || new Iri(a.property, namespaces);
        return new Annotation(annotationProperty, a.lexicalForm, a.language, a.datatype);
    })) || [];
}
function getDiagrams(rdfGraph, ontology, classInstances, rendererState = RendererStatesEnum.GRAPHOL) {
    let diagram;
    let diagramRepr;
    let grapholEntity;
    let grapholElement;
    const diagrams = [];
    rdfGraph.diagrams.forEach(d => {
        var _a, _b;
        diagram = rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY ? new Diagram(d.name, d.id) : new IncrementalDiagram();
        diagramRepr = diagram.representations.get(rendererState);
        if (!diagramRepr) {
            diagramRepr = new DiagramRepresentation(floatyOptions);
            diagram.representations.set(rendererState, diagramRepr);
        }
        // Nodes
        (_a = d.nodes) === null || _a === void 0 ? void 0 : _a.forEach(n => {
            grapholElement = GrapholNode.newFromSwagger(n);
            diagramRepr.addElement(grapholElement, grapholEntity);
        });
        // Edges
        (_b = d.edges) === null || _b === void 0 ? void 0 : _b.forEach(e => {
            if (!e.id) {
                e.id = diagramRepr.getNewId('edge');
            }
            grapholElement = GrapholEdge.newFromSwagger(e);
            diagramRepr.addElement(grapholElement);
        });
        if (d.lastViewportState !== undefined) {
            const diagramRepr = diagram.representations.get(rendererState);
            if (diagramRepr) {
                diagramRepr.hasEverBeenRendered = true;
                diagramRepr.lastViewportState = d.lastViewportState;
            }
        }
        diagrams.push(diagram);
    });
    return diagrams;
}
function getConfig(rdfGraph) {
    var _a, _b, _c, _d, _e;
    let themes;
    if ((_a = rdfGraph.config) === null || _a === void 0 ? void 0 : _a.themes) {
        themes = rdfGraph.config.themes.map(t => new GrapholscapeTheme(t.id, t.colours, t.name));
    }
    return {
        themes: themes,
        selectedTheme: (_b = rdfGraph.config) === null || _b === void 0 ? void 0 : _b.selectedTheme,
        selectedRenderer: rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY
            ? RendererStatesEnum.FLOATY
            : RendererStatesEnum.INCREMENTAL,
        language: (_c = rdfGraph.config) === null || _c === void 0 ? void 0 : _c.language,
        entityNameType: (_d = rdfGraph.config) === null || _d === void 0 ? void 0 : _d.entityNameType,
        renderers: (_e = rdfGraph.config) === null || _e === void 0 ? void 0 : _e.renderers,
    };
}

var QueryStatusEnum;
(function (QueryStatusEnum) {
    QueryStatusEnum["FINISHED"] = "FINISHED";
    QueryStatusEnum["UNAVAILABLE"] = "UNAVAILABLE";
    QueryStatusEnum["ERROR"] = "ERROR";
    QueryStatusEnum["RUNNING"] = "RUNNING";
    QueryStatusEnum["READY"] = "READY";
    QueryStatusEnum["STOPPED"] = "STOPPED";
})(QueryStatusEnum || (QueryStatusEnum = {}));
var QuerySemantics;
(function (QuerySemantics) {
    QuerySemantics["CQ"] = "cq";
    QuerySemantics["FULL_SPARQL"] = "eql";
})(QuerySemantics || (QuerySemantics = {}));
var QueryType;
(function (QueryType) {
    QueryType["STANDARD"] = "standard";
    QueryType["COUNT"] = "count";
    QueryType["CONSTRUCT"] = "construct";
})(QueryType || (QueryType = {}));
var HeadTypes;
(function (HeadTypes) {
    HeadTypes["OBJECT"] = "OBJECT";
    HeadTypes["VALUE"] = "VALUE";
})(HeadTypes || (HeadTypes = {}));

/* tslint:disable */
/**
 * @export
 */
const EntityTypeEnum = {
    Class: 'class',
    ObjectProperty: 'objectProperty',
    InverseObjectProperty: 'inverseObjectProperty',
    DataProperty: 'dataProperty',
    Annotation: 'annotation'
};

function handleApiCall(apiCall, onError) {
    return new Promise((resolve, reject) => {
        apiCall
            .then((response) => __awaiter(this, void 0, void 0, function* () {
            if (response.status !== 200) {
                const result = yield (response.json() || response.text());
                onError(result);
                reject(result);
            }
            else {
                resolve(response);
            }
        }))
            .catch(error => {
            if (error.response && error.response.status === 401) {
                const lo = document.getElementById("logout");
                lo === null || lo === void 0 ? void 0 : lo.click();
            }
            else {
                onError(error);
            }
            reject(error);
        });
    });
}

class EndpointApi {
    constructor(requestOptions) {
        this.requestOptions = requestOptions;
    }
    getRunningEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            const runningEndpoints = (yield (yield handleApiCall(fetch(`${this.requestOptions.basePath}/endpoints/running`, {
                method: 'get',
                headers: this.requestOptions.headers,
            }), this.requestOptions.onError)).json()).endpoints;
            return runningEndpoints.filter(endpoint => {
                var _a;
                return ((_a = endpoint.mastroID) === null || _a === void 0 ? void 0 : _a.ontologyID.ontologyName) === this.requestOptions.name &&
                    endpoint.mastroID.ontologyID.ontologyVersion === this.requestOptions.version;
            });
        });
    }
}

var QueryPollerStatus;
(function (QueryPollerStatus) {
    /** Stopped manually */
    QueryPollerStatus[QueryPollerStatus["STOPPED"] = 1] = "STOPPED";
    /** Polling ongoing and waiting for responses */
    QueryPollerStatus[QueryPollerStatus["RUNNING"] = 2] = "RUNNING";
    /** QueryPoller not started yet */
    QueryPollerStatus[QueryPollerStatus["IDLE"] = 3] = "IDLE";
    /** Stopped automatically because stopCondition() === true */
    QueryPollerStatus[QueryPollerStatus["FINISHED"] = 4] = "FINISHED";
    /** Error occurred */
    QueryPollerStatus[QueryPollerStatus["ERROR"] = 5] = "ERROR";
})(QueryPollerStatus || (QueryPollerStatus = {}));
class QueryPoller {
    constructor() {
        this.lastRequestFulfilled = true;
        // Callbacks
        this.onStop = () => { };
        this.onError = () => { };
        this.status = QueryPollerStatus.IDLE;
    }
    poll() {
        this.status = QueryPollerStatus.RUNNING;
        handleApiCall(fetch(this.request), () => { })
            .then((response) => {
            response.json().then((result) => {
                // if (this.hasAnyResults() && this.status === QueryPollerStatus.STOPPED) {
                //   return
                // }
                if (this.isResultError(result)) {
                    this.triggerError(result);
                }
                else {
                    this.lastRequestFulfilled = true;
                    this._result = result;
                    this.onNewResults(result);
                    if (this.stopCondition()) {
                        this.status = QueryPollerStatus.FINISHED;
                        this.stopPolling();
                    }
                }
            });
        })
            .catch(error => this.triggerError(error));
    }
    stopPolling() {
        clearInterval(this.interval);
        this.onStop();
    }
    start() {
        this.interval = setInterval(() => {
            if (this.lastRequestFulfilled) {
                this.lastRequestFulfilled = false;
                this.poll();
            }
        }, QueryPoller.INTERVAL_LENGTH);
    }
    stop() {
        this.status = QueryPollerStatus.STOPPED;
        this.stopPolling();
    }
    triggerError(result) {
        this.status = QueryPollerStatus.ERROR;
        this.stopPolling();
        this.onError(this.getErrrorMessage(result));
    }
    getErrrorMessage(result) {
        return result.toString();
    }
}
QueryPoller.TIMEOUT_LENGTH = 5000;
QueryPoller.INTERVAL_LENGTH = 1000;
class QueryResultsPoller extends QueryPoller {
    constructor(request, limit, executionId) {
        super();
        this.request = request;
        this.limit = limit;
        this.executionId = executionId;
        this.onNewResults = () => { };
        this.numberResultsAvailable = 0;
    }
    hasAnyResults() {
        return this.result && this.result.results.length > 0;
    }
    isResultError(result) {
        return !result || result.results === undefined;
    }
    stopCondition() {
        return this._result.results.length >= this.limit;
    }
    get result() {
        return this._result;
    }
}
class QueryStatusPoller extends QueryPoller {
    constructor(request) {
        super();
        this.request = request;
    }
    hasAnyResults() {
        return this.result !== undefined;
    }
    stopCondition() {
        var _a;
        return ((_a = this.result) === null || _a === void 0 ? void 0 : _a.status) !== QueryStatusEnum.RUNNING;
    }
    isResultError(result) {
        return !result || result.hasError === true || result.status === QueryStatusEnum.UNAVAILABLE || result.status === QueryStatusEnum.ERROR;
    }
    getErrrorMessage(result) {
        return result.errorMessages.map(error => JSON.parse(error));
    }
    get result() {
        return this._result;
    }
}
/**
 * Class to perform polling on a count query,
 * it will stop when the result received is equal
 * to the QUERY_STATUS_FINISHED constant.
 */
class QueryCountStatePoller extends QueryPoller {
    hasAnyResults() {
        return this.result !== undefined;
    }
    constructor(request) {
        super();
        this.request = request;
        /**
         * Callback called in case the count has finished correctly.
         */
        this.onNewResults = () => { };
    }
    isResultError(result) {
        return !result || result === QueryCountStatePoller.QUERY_STATUS_ERROR;
    }
    stopCondition() {
        return this.result === QueryCountStatePoller.QUERY_STATUS_FINISHED;
    }
    get result() {
        return this._result;
    }
}
QueryCountStatePoller.QUERY_STATUS_FINISHED = 3;
QueryCountStatePoller.QUERY_STATUS_ERROR = 4;

class InstanceCheckingPoller extends QueryPoller {
    constructor(request) {
        super();
        this.request = request;
    }
    stopCondition() {
        return this.result.state === QueryStatusEnum.FINISHED || this.result.state === QueryStatusEnum.STOPPED;
    }
    isResultError(result) {
        return result.state === QueryStatusEnum.ERROR;
    }
    hasAnyResults() {
        return this.result.resultClasses ? this.result.resultClasses.length > 0 : false;
    }
    get result() {
        return this._result;
    }
}

class QueryManager {
    constructor(requestOptions, endpoint) {
        this.requestOptions = requestOptions;
        this.endpoint = endpoint;
        this._prefixes = new Promise(() => { });
        this._runningQueryPollerByExecutionId = new Map();
        this._runningCountQueryPollerByExecutionId = new Map();
        this._runningInstanceCheckingPollerByThreadId = new Map();
        this.requestOptions.headers['content-type'] = 'application/json';
        this._prefixes = new Promise((resolve) => {
            handleApiCall(fetch(this.prefixesPath, {
                method: 'get',
                headers: this.requestOptions.headers,
            }), this.onError).then((response) => __awaiter(this, void 0, void 0, function* () {
                const prefixesResponse = yield response.json();
                resolve(prefixesResponse.map((p) => `PREFIX ${p.name} <${p.namespace}>`).join('\n'));
            }));
        });
    }
    /**
     * Start the query using the result route.
     * The QueryResultPoller will poll the query results.
     * @param queryCode
     * @param pageSize the maximum number of results to retrieve
     * @param querySemantics either use conjunctive queries evaluation or full SPARQL. default: **CQ**
     * @param keepAlive keep query running even if stopRunningQueries gets invoked. default: **False**
     * @returns a promise which will be resolved with the query poller, on this
     * object you can set the onNewResults callback to react every time new results
     * are obtained.
     */
    performQuery(queryCode, pageSize, querySemantics = QuerySemantics.CQ, keepAlive = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const executionId = yield this.startQuery(queryCode, querySemantics);
            // return this.getQueryResults(executionId, pageSize, pageNumber)
            const queryResultsPoller = new QueryResultsPoller(this.getQueryResultRequest(executionId, pageSize, 1), pageSize, executionId);
            if (!keepAlive) {
                const pollers = this._runningQueryPollerByExecutionId.get(executionId);
                if (pollers) {
                    pollers.resultPollers.add(queryResultsPoller);
                }
                else {
                    this._runningQueryPollerByExecutionId.set(executionId, {
                        resultPollers: new Set([queryResultsPoller]),
                        statusPollers: new Set(),
                    });
                }
            }
            queryResultsPoller.onError = this.requestOptions.onError;
            const queryStatusPoller = new QueryStatusPoller(this.getQueryStatusRequest(executionId));
            (_a = this._runningQueryPollerByExecutionId.get(executionId)) === null || _a === void 0 ? void 0 : _a.statusPollers.add(queryStatusPoller);
            queryStatusPoller.start();
            queryStatusPoller.onNewResults = (result) => {
                queryResultsPoller.numberResultsAvailable = result.numResults;
                if (result.status !== QueryStatusEnum.RUNNING) {
                    queryResultsPoller.stop();
                    this._runningQueryPollerByExecutionId.delete(executionId);
                    queryStatusPoller.stop();
                }
            };
            queryStatusPoller.onError = (errors) => {
                for (let error of errors)
                    this.requestOptions.onError(error);
                queryResultsPoller.stop();
                this._runningQueryPollerByExecutionId.delete(executionId);
            };
            // queryStatusPoller.onStop = () => {
            //   this._runningQueryStatePollerByExecutionId.delete(executionId)
            // }
            return queryResultsPoller;
        });
    }
    getQueryResults(executionId, pageSize, pageNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryResultsPoller = new QueryResultsPoller(this.getQueryResultRequest(executionId, pageSize, pageNumber), pageSize, executionId);
            const pollers = this._runningQueryPollerByExecutionId.get(executionId);
            if (pollers) {
                pollers.resultPollers.add(queryResultsPoller);
            }
            else {
                this._runningQueryPollerByExecutionId.set(executionId, {
                    resultPollers: new Set([queryResultsPoller]),
                    statusPollers: new Set(),
                });
            }
            queryResultsPoller.onError = this.requestOptions.onError;
            // const queryStatusPoller = new QueryStatusPoller(this.getQueryStatusRequest(executionId))
            // queryStatusPoller.onNewResults = (result) => {
            //   if (result.status !== QueryStatusEnum.RUNNING) {
            //     // queryResultsPoller.stop()
            //     // this._runningQueryPollerByExecutionId.get(executionId)?.delete(queryResultsPoller)
            //     // if (this._runningQueryPollerByExecutionId.get(executionId)?.size === 0) {
            //     //   this._runningQueryPollerByExecutionId.delete(executionId)
            //     // }
            //     queryStatusPoller.stop()
            //   }
            // }
            // queryStatusPoller.onError = (errors) => {
            //   for (let error of errors)
            //     this.requestOptions.onError(error)
            //   queryResultsPoller.stop()
            //   this._runningQueryPollerByExecutionId.delete(executionId)
            // }
            // queryStatusPoller.start()
            return queryResultsPoller;
        });
    }
    /**
     * Start the query using count route, then QueryCountStatePoller
     * will poll for the query state, when it receives the finished state,
     * it yield the result back to the callback onNewResults.
     * In this callback a fetch to the result route will retrieve the
     * actual result and resolve the promise.
     * @param queryCode
     * @returns a promise which will be resolved with the result
     */
    performQueryCount(queryCode, onStopCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const executionId = yield this.startQuery(queryCode, QuerySemantics.CQ, QueryType.COUNT);
            const countStatePoller = new QueryCountStatePoller(this.getQueryCountStatusRequest(executionId));
            this._runningCountQueryPollerByExecutionId.set(executionId, countStatePoller);
            return new Promise((resolve, reject) => {
                countStatePoller.onNewResults = (state) => {
                    if (state === QueryCountStatePoller.QUERY_STATUS_FINISHED && this._runningCountQueryPollerByExecutionId.get(executionId)) {
                        handleApiCall(fetch(`${this.queryCountPath}/${executionId}/result`, {
                            method: 'get',
                            headers: this.requestOptions.headers,
                        }), this.onError).then((response) => __awaiter(this, void 0, void 0, function* () {
                            resolve(yield response.json());
                            // The count query has finished and result has been processed
                            // Now we need to delete the query execution from mastro.
                            this.stopCountQuery(executionId);
                        })).catch(reason => reject(reason));
                    }
                };
                countStatePoller.onError = (error) => {
                    reject(error);
                    handleApiCall(fetch(`${this.queryCountPath}/${executionId}/error`, {
                        method: 'get',
                        headers: this.requestOptions.headers,
                    }), this.onError)
                        .then((errorResponse) => __awaiter(this, void 0, void 0, function* () {
                        this.requestOptions.onError(yield errorResponse.text());
                    }))
                        .finally(() => this.stopCountQuery(executionId));
                };
                if (onStopCallback)
                    countStatePoller.onStop = onStopCallback;
                countStatePoller.start();
            });
        });
    }
    performQueryContrusct(queryCode, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            // return this.getQueryResults(executionId, pageSize, pageNumber)
            // const queryResultsPoller = new QueryConstructResultsPoller(this.getQueryResultRequest(executionId, pageSize, 1, QueryType.CONSTRUCT), pageSize, executionId)
            // if (!keepAlive) {
            //   const pollers = this._runningQueryPollerByExecutionId.get(executionId)
            //   if (pollers) {
            //     pollers.resultPollers.add(queryResultsPoller)
            //   } else {
            //     this._runningQueryPollerByExecutionId.set(executionId, {
            //       resultPollers: new Set([queryResultsPoller]),
            //       statusPollers: new Set(),
            //     })
            //   }
            // }
            // queryResultsPoller.onError = this.requestOptions.onError
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const executionId = yield this.startQuery(queryCode, QuerySemantics.CQ, QueryType.CONSTRUCT);
                const queryStatusPoller = new QueryStatusPoller(this.getQueryStatusRequest(executionId));
                (_a = this._runningQueryPollerByExecutionId.get(executionId)) === null || _a === void 0 ? void 0 : _a.statusPollers.add(queryStatusPoller);
                queryStatusPoller.onNewResults = (statusResult) => {
                    if (statusResult.status !== QueryStatusEnum.RUNNING) {
                        this._runningQueryPollerByExecutionId.delete(executionId);
                        queryStatusPoller.stop();
                    }
                    if (statusResult.status === QueryStatusEnum.FINISHED) {
                        pageSize = pageSize || statusResult.numResults;
                        if (pageSize > 0) {
                            const request = this.getQueryResultRequest(executionId, pageSize || statusResult.numResults, 1, QueryType.CONSTRUCT);
                            handleApiCall(fetch(request), this.onError)
                                .then((response) => __awaiter(this, void 0, void 0, function* () { return resolve(yield response.json()); }));
                        }
                        {
                            resolve(undefined);
                        }
                    }
                };
                queryStatusPoller.onError = (errors) => {
                    for (let error of errors)
                        this.requestOptions.onError(error);
                    // queryResultsPoller.stop()
                    this._runningQueryPollerByExecutionId.delete(executionId);
                };
                queryStatusPoller.start();
            }));
        });
    }
    getQueryStatus(executionID) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                handleApiCall(fetch(this.getQueryStatusRequest(executionID)), this.onError)
                    .then(response => resolve(response.json()))
                    .catch(error => {
                    this.requestOptions.onError(error);
                    reject(error);
                });
            });
        });
    }
    instanceCheck(instanceIri, classesTocheck) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams({ instance: instanceIri });
            const response = yield fetch(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/instanceChecking/start?${params.toString()}`, {
                method: 'post',
                headers: this.requestOptions.headers,
                body: JSON.stringify(classesTocheck)
            });
            const threadId = yield response.json();
            const instanceCheckingPoller = new InstanceCheckingPoller(new Request(`${this.getInstanceCheckingPath(threadId)}/info`, {
                method: 'get',
                headers: this.requestOptions.headers
            }));
            this._runningInstanceCheckingPollerByThreadId.set(threadId, instanceCheckingPoller);
            instanceCheckingPoller.onError((error) => this.requestOptions.onError(error));
            return instanceCheckingPoller;
        });
    }
    stopRunningQueries() {
        this.stopInstancesQueries();
        // this._runningQueryStatePollerByExecutionId.forEach((_, executionId) => this.stopQuery(executionId))
        this.stopCountsQueries();
        // this._runningInstanceCheckingPollerByThreadId.forEach((_, threadId) => this.stopInstanceChecking(threadId))
    }
    stopInstancesQueries() {
        this._runningQueryPollerByExecutionId.forEach((_, executionId) => this.stopQuery(executionId));
    }
    stopCountsQueries() {
        this._runningCountQueryPollerByExecutionId.forEach((_, executionId) => this.stopCountQuery(executionId));
    }
    stopQuery(executionId) {
        // stop polling
        const pollers = this._runningQueryPollerByExecutionId.get(executionId);
        pollers === null || pollers === void 0 ? void 0 : pollers.resultPollers.forEach(poller => poller.stop());
        pollers === null || pollers === void 0 ? void 0 : pollers.statusPollers.forEach(poller => poller.stop());
        this._runningQueryPollerByExecutionId.delete(executionId);
        handleApiCall(fetch(this.getQueryStopPath(executionId), {
            method: 'put',
            headers: this.requestOptions.headers,
        }), this.onError);
    }
    stopCountQuery(executionId) {
        var _a;
        (_a = this._runningCountQueryPollerByExecutionId.get(executionId)) === null || _a === void 0 ? void 0 : _a.stop();
        this._runningCountQueryPollerByExecutionId.delete(executionId);
        handleApiCall(fetch(`${this.queryCountPath}/${executionId}/stop`, {
            method: 'put',
            headers: this.requestOptions.headers,
        }), this.requestOptions.onError);
    }
    stopInstanceChecking(threadId) {
        var _a;
        (_a = this._runningInstanceCheckingPollerByThreadId.get(threadId)) === null || _a === void 0 ? void 0 : _a.stop();
        this._runningInstanceCheckingPollerByThreadId.delete(threadId);
        handleApiCall(fetch(`${this.getInstanceCheckingPath(threadId)}/stop`, {
            method: 'get',
            headers: this.requestOptions.headers,
        }), this.onError);
    }
    shouldQueryUseLabels(executionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryPollers = this._runningQueryPollerByExecutionId.get(executionId);
            return new Promise((resolve) => {
                var _a, _b;
                if (queryPollers) {
                    for (let statusPoller of queryPollers.statusPollers) {
                        if (((_a = statusPoller.result) === null || _a === void 0 ? void 0 : _a.status) == QueryStatusEnum.FINISHED || ((_b = statusPoller.result) === null || _b === void 0 ? void 0 : _b.status) == QueryStatusEnum.RUNNING) {
                            resolve(statusPoller.result.numHighLevelQueries > 0);
                        }
                        else {
                            const oldCallback = statusPoller.onNewResults;
                            // check at every new result without overriding previous callback
                            statusPoller.onNewResults = (result) => {
                                oldCallback(result);
                                if (result.status == QueryStatusEnum.FINISHED || result.status == QueryStatusEnum.RUNNING) {
                                    resolve(result.numHighLevelQueries > 0);
                                }
                            };
                        }
                        break;
                    }
                }
            });
        });
    }
    getPrefixes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._prefixes;
        });
    }
    startQuery(queryCode, querySemantics, queryType = QueryType.STANDARD) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                handleApiCall(fetch(yield this.getNewQueryRequest(queryCode, querySemantics, queryType)), this.onError).then((response) => __awaiter(this, void 0, void 0, function* () {
                    resolve((yield response.json()).executionId);
                }));
            }));
        });
    }
    /**
     * Request for starting a query
     * @param queryCode the code of the query
     * @param querySemantics Conjunctive queries or FULL SPARQL
     * @param customURL URL to use, if not specified this.queryStartPath will be used
     * @returns the request object to send
     */
    getNewQueryRequest(queryCode, querySemantics, queryType, customURL) {
        return __awaiter(this, void 0, void 0, function* () {
            // const url: URL = customURL || this.getQueryStartPath()
            let url;
            let params;
            switch (queryType) {
                case QueryType.STANDARD:
                default:
                    url = this.getQueryStartPath(queryType);
                    params = new URLSearchParams({
                        useReplaceForUrlEncoding: 'false',
                        querySemantics: querySemantics,
                        advanced: 'true',
                        reasoning: 'true',
                        expandSparqlTables: 'true'
                    });
                    break;
                case QueryType.COUNT:
                    url = this.queryCountPath;
                    params = new URLSearchParams({
                        useReplaceForUrlEncoding: 'false',
                        querySemantics: querySemantics,
                        advanced: 'true',
                        reasoning: 'true',
                        expandSparqlTables: 'true'
                    });
                    break;
                case QueryType.CONSTRUCT:
                    url = this.getQueryStartPath(queryType);
            }
            if (params) {
                url = new URL(url.toString().concat(`?${params.toString()}`));
            }
            return new Request(url, {
                method: 'post',
                headers: this.requestOptions.headers,
                body: JSON.stringify({
                    queryCode: `${yield this.getPrefixes()}\n${queryCode}`,
                    queryID: Math.random(),
                    queryDescription: "",
                    mappingParameters: {},
                    construct: queryType === QueryType.CONSTRUCT || undefined,
                }),
            });
        });
    }
    // Requests for polling a query
    getQueryResultRequest(queryExecutionId, pageSize, pagenumber = 1, queryType = QueryType.STANDARD) {
        const params = new URLSearchParams({ pagesize: pageSize.toString(), pagenumber: pagenumber.toString() });
        return new Request(`${this.getQueryResultPath(queryExecutionId, queryType)}?${params.toString()}`, {
            method: 'get',
            headers: this.requestOptions.headers
        });
    }
    getQueryStatusRequest(queryExecutionId, queryType = QueryType.STANDARD) {
        return new Request(`${this.getQueryStatePath(queryExecutionId, queryType)}`, {
            method: 'get',
            headers: this.requestOptions.headers
        });
    }
    getQueryCountStatusRequest(queryExecutionId) {
        return new Request(`${this.queryCountPath}/${queryExecutionId}/state`, {
            method: `get`,
            headers: this.requestOptions.headers,
        });
    }
    getQueryStartPath(queryType = QueryType.STANDARD) {
        let query = 'query';
        if (queryType === QueryType.CONSTRUCT) {
            query = 'cquery';
        }
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/${query}/start`);
    }
    getQueryStopPath(executionId, queryType = QueryType.STANDARD) {
        let query = 'query';
        if (queryType === QueryType.CONSTRUCT) {
            query = 'cquery';
        }
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/${query}/${executionId}/stop`);
    }
    getQueryResultPath(executionId, queryType = QueryType.STANDARD) {
        let endingPath = `query/${executionId}/results`;
        if (queryType === QueryType.CONSTRUCT) {
            endingPath = `cquery/${executionId}/results/rdfGraph`;
        }
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/${endingPath}`);
    }
    getQueryStatePath(executionId, queryType = QueryType.STANDARD) {
        let query = 'query';
        if (queryType === QueryType.CONSTRUCT) {
            query = 'cquery';
        }
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/${query}/${executionId}/status`);
    }
    getInstanceCheckingPath(threadId) {
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/instanceChecking/${threadId}`);
    }
    get onError() {
        return this.requestOptions.onError;
    }
    get prefixesPath() {
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/prefixes`);
    }
    get queryCountPath() {
        return new URL(`${this.requestOptions.basePath}/endpoint/${this.endpoint.name}/query/count`);
    }
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\\\$&"); // $& means the whole matched string
}

const LIMIT = 1000;
const getLimit = (customLimit) => customLimit !== 'unlimited' ? `LIMIT ${customLimit || LIMIT}` : '';
/**
 * 1-2
 * Fetch instances of a given type
 * @param classIRI class type of the instances
 * @param includeLabels retrieve labels or not, default: true
 * @param maxResults if 'unlimited', no limit is set. default: 1000
 * @returns
 */
function getInstances(classIRI, includeLabels = true, maxResults) {
    return `
  SELECT DISTINCT ${includeLabels ? '?x ?lx' : '?x'}
  WHERE {
    ?x a <${classIRI}>;
       ${includeLabels ? `rdfs:label ?lx` : ``}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 3
 *
 * Fetch instances of a given type, filtering by their label
 * @param classIRI class type of the instances
 * @param searchText the text to search in labels
 * @param maxResults if 'unlimited', no limit is set. default: 1000
 * @returns
 */
function getInstancesByLabel(classIRI, searchText, maxResults) {
    return `
  SELECT DISTINCT ?x ?lx
  WHERE {
    ?x a <${classIRI}>;
       rdfs:label ?lx.
    ${getSearchFilters('?lx', searchText)}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 4
 *
 * Fetch instances of a given type, filtering by their IRI
 * @param classIRI class type of the instances
 * @param searchText the text to search in IRIs
 * @param maxResults if 'unlimited', no limit is set. default: 1000
 * @returns
 */
function getInstancesByIRI(classIRI, searchText, maxResults) {
    return `
  SELECT DISTINCT ?x
  WHERE {
    ?x a <${classIRI}>.
    ${getSearchFilters('?x', searchText)}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 5-6
 *
 * Fetch instances of a given type and filter by the value of a given data property.
 * @param classIRI class type of the instances
 * @param dataPropertyIRI the data property on which the filter must be done
 * @param searchText the text to search in the values of the data property
 * @param includeLabels retrieve labels or not, default: true
 * @param maxResults if 'unlimited', no limit is set. default: 1000
 * @returns
 */
function getInstancesByDataProperty(classIRI, dataPropertyIRI, searchText, includeLabels = true, maxResults) {
    return `
  SELECT DISTINCT ${includeLabels ? '?x ?lx ?y' : '?x ?y'}
  WHERE {
    ?x a <${classIRI}>;
       <${dataPropertyIRI}> ?y;
       ${includeLabels ? `rdfs:label ?lx` : ``}
    ${getSearchFilters('?y', searchText)}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 7-8
 *
 * Fetch instances of a given type such that they participate in a object property with
 * another instance whose label contains a given search text.
 *
 * @param classIRI class type of the instances
 * @param objectPropertyIRI the object property on which the filter must be done
 * @param searchText the text to search in the label of the instances participating in the object property
 * @param isDirect whether the object property is direct or inverse default: true (direct)
 * @param includeLabels retrieve labels or not, default: true
 * @param maxResults if 'unlimited', no limit is set. default: 1000
 * @returns
 */
function getInstancesByObjectProperty(classIRI, objectPropertyIRI, searchText, isDirect = true, includeLabels = true, maxResults) {
    return `
  SELECT DISTINCT ${includeLabels ? '?x ?lx ?y ?ly' : '?x ?y ?ly'}
  WHERE {
    ?x a <${classIRI}>;
       ${includeLabels ? 'rdfs:label ?lx' : ''}.
       
    ${!isDirect
        ? `?y <${objectPropertyIRI}> ?x.`
        : `?x <${objectPropertyIRI}> ?y.`}
       
    ?y rdfs:label ?ly.
    ${getSearchFilters('?ly', searchText)}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 9
 *
 * Get values of a data property for a given instance
 * @param instanceIRI
 * @param dataPropertyIRI
 * @returns
 */
function getInstanceDataPropertyValues(instanceIRI, dataPropertyIRI) {
    return `
  SELECT DISTINCT ?y
  WHERE {
    <${encodeURI(instanceIRI)}> <${dataPropertyIRI}> ?y
  }
  LIMIT 10
  `;
}
/**
 * 10-11
 *
 * Get instances of a given type participating to an object property with a given instance
 * @param instanceIRI the starting instance
 * @param objectPropertyIRI the object property connecting the instances
 * @param rangeTypeClassesIri the type of instances to retrieve
 * @param isDirect whether the object property is direct or inverse default: true (direct)
 * @param includeLabels retrieve labels or not, default: true
 * @param maxResults default: 1000
 * @returns
 */
function getInstancesThroughObjectProperty(instanceIRI, objectPropertyIRI, rangeTypeClassesIri, isDirect = true, includeLabels = true, maxResults) {
    let whereClausesInUnion;
    if (rangeTypeClassesIri) {
        whereClausesInUnion = rangeTypeClassesIri.map(rangeTypeClassIri => `
      ${!isDirect
            ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
            : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ?y a <${rangeTypeClassIri}>.
      ${includeLabels ? '?y rdfs:label ?ly' : ''}
    `);
    }
    else {
        // No rangeClassType
        whereClausesInUnion = [`
      ${!isDirect
                ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
                : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ${includeLabels ? '?y rdfs:label ?ly' : ''}
    `];
    }
    return `
    SELECT DISTINCT ?y ${includeLabels ? '?ly' : ''}
    WHERE {
      ${whereClausesInUnion.length > 1 ? '{' : ''}
      ${whereClausesInUnion.join('\n } UNION { \n')}
      ${whereClausesInUnion.length > 1 ? '}' : ''}
    }
    ${getLimit(maxResults)}
  `;
}
/**
 * 12
 *
 * Get instances of a given type participating to an object property with a given instance,
 * filtering by their label
 * @param instanceIRI the starting instance
 * @param objectPropertyIRI the object property connecting the instances
 * @param searchText the text to search in the label of results
 * @param rangeTypeClassesIri the type of instances to retrieve
 * @param isDirect whether the object property is direct or inverse default: true (direct)
 * @param maxResults default: 1000
 * @returns
 */
function getInstancesThroughObjectPropertyByLabel(instanceIRI, objectPropertyIRI, searchText, rangeTypeClassesIri, isDirect = true, maxResults) {
    let whereClausesInUnion;
    if (rangeTypeClassesIri) {
        whereClausesInUnion = rangeTypeClassesIri.map(rangeTypeClassIri => `
      ${!isDirect
            ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
            : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ?y a <${rangeTypeClassIri}>.
      ?y rdfs:label ?ly
      ${getSearchFilters('?ly', searchText)}
    `);
    }
    else {
        // No rangeClassType
        whereClausesInUnion = [`
      ${!isDirect
                ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
                : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ?y rdfs:label ?ly
      ${getSearchFilters('?ly', searchText)}
    `];
    }
    return `
  SELECT DISTINCT ?y ?ly
  WHERE {
    ${whereClausesInUnion.length > 1 ? '{' : ''}
    ${whereClausesInUnion.join('\n } UNION { \n')}
    ${whereClausesInUnion.length > 1 ? '}' : ''}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 13
 *
 * Get instances of a given type participating to an object property with a given instance,
 * filtering by their IRI
 * @param instanceIRI the starting instance
 * @param objectPropertyIRI the object property connecting the instances
 * @param searchText the text to search in the IRIs of results
 * @param rangeTypeClassesIri the type of instances to retrieve
 * @param isDirect whether the object property is direct or inverse default: true (direct)
 * @param maxResults default: 1000
 * @returns
 */
function getInstancesThroughObjectPropertyByIRI(instanceIRI, objectPropertyIRI, searchText, rangeTypeClassesIri, isDirect = true, maxResults) {
    let whereClausesInUnion;
    if (rangeTypeClassesIri) {
        whereClausesInUnion = rangeTypeClassesIri.map(rangeTypeClassIri => `
      ${!isDirect
            ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
            : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ?y a <${rangeTypeClassIri}>.
      ${getSearchFilters('?y', searchText)}
    `);
    }
    else {
        // No rangeClassType
        whereClausesInUnion = [`
      ${!isDirect
                ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
                : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}
      ${getSearchFilters('?y', searchText)}
    `];
    }
    return `
  SELECT DISTINCT ?y
  WHERE {
    ${whereClausesInUnion.length > 1 ? '{' : ''}
    ${whereClausesInUnion.join('\n } UNION { \n')}
    ${whereClausesInUnion.length > 1 ? '}' : ''}
  }
  ${getLimit(maxResults)}
  `;
}
/**
 * 14-15
 * Get instances of a given type, participating in the object property (domain/range)
 * with a given instance and participating in a data property with a value matching
 * the searchText.
 *
 * @param instanceIRI starting instance
 * @param objectPropertyIRI object properties connecting the instances
 * @param rangeTypeClassesIri the type of instances to search
 * @param dataPropertyFilterIRI the data property on which the filter must be done
 * @param searchText the value to search in the data property range (attribute value)
 * @param isDirect whether the object property is direct or inverse default: true (direct)
 * @param includeLabels whether to include the label of retrieved instances or not, default: true
 * @param maxResults max number of results, default: 1000
 * @returns the SPARQL query code
 */
function getInstancesThroughOPByDP(instanceIRI, objectPropertyIRI, rangeTypeClassesIri, dataPropertyFilterIRI, searchText, isDirect = true, includeLabels = true, maxResults) {
    let whereClausesInUnion;
    if (rangeTypeClassesIri) {
        whereClausesInUnion = rangeTypeClassesIri.map(rangeTypeClassIri => `
      ${!isDirect
            ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
            : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ?y a <${rangeTypeClassIri}>;
        ${includeLabels ? 'rdfs:label ?ly;' : ''}
        <${dataPropertyFilterIRI}> ?dp.
      ${getSearchFilters('?dp', searchText)}
    `);
    }
    else {
        // No rangeClassType
        whereClausesInUnion = [`
      ${!isDirect
                ? `?y <${objectPropertyIRI}> <${encodeURI(instanceIRI)}>.`
                : `<${encodeURI(instanceIRI)}> <${objectPropertyIRI}> ?y.`}

      ?y ${includeLabels ? 'rdfs:label ?ly;' : ''}
         <${dataPropertyFilterIRI}> ?dp.
      ${getSearchFilters('?dp', searchText)}
    `];
    }
    return `
  SELECT DISTINCT ${includeLabels ? '?y ?ly ?dp' : '?y ?dp'}
  WHERE {
    ${whereClausesInUnion.length > 1 ? '{' : ''}
    ${whereClausesInUnion.join('\n } UNION { \n')}
    ${whereClausesInUnion.length > 1 ? '}' : ''}
  }
  ${getLimit(maxResults)}
  `;
}
function getSearchFilters(variable, searchText) {
    const searchTexts = searchText.split(' ');
    const results = [];
    searchTexts.forEach(text => {
        results.push(`regex(${variable}, '${escapeRegExp(text.trim())}', 'i')`);
    });
    return `FILTER(${results.join('\n &&')})`;
}
/**
 * Get all the labels defined on a instance
 * @param instanceIri
 * @returns
 */
function getInstanceLabels(instanceIri) {
    return `
    SELECT DISTINCT ?l
    WHERE {
      <${encodeURI(instanceIri)}> rdfs:label ?l
    }
  `;
}

class VKGApi {
    constructor(requestOptions, endpoint, pageSize) {
        this.requestOptions = requestOptions;
        this.pageSize = pageSize;
        this.setEndpoint(endpoint);
    }
    getInstances(iri, includeLabels, onNewResults, onStop, searchText, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pageSize = pageSize || this.pageSize;
            let querySemantics, queryCode;
            if (searchText) {
                querySemantics = QuerySemantics.FULL_SPARQL;
                if (includeLabels) {
                    queryCode = getInstancesByLabel(iri, searchText);
                }
                else {
                    queryCode = getInstancesByIRI(iri, searchText);
                }
            }
            else {
                querySemantics = QuerySemantics.CQ;
                queryCode = getInstances(iri, includeLabels);
            }
            const queryPoller = yield this.queryManager.performQuery(queryCode, _pageSize, querySemantics);
            queryPoller.onNewResults = (result => {
                onNewResults(result.results.map(res => this.getClassInstanceFromQueryResult(res, result.headTerms, result.headTypes)), queryPoller.numberResultsAvailable);
            });
            if (onStop) {
                queryPoller.onStop = onStop;
            }
            queryPoller.start();
            return queryPoller.executionId;
        });
    }
    getNewResults(executionId, pageNumber, onNewResults, onStop, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pageSize = pageSize || this.pageSize;
            const queryPoller = yield this.queryManager.getQueryResults(executionId, _pageSize, pageNumber);
            queryPoller.onNewResults = (result => {
                onNewResults(result.results.map(res => this.getClassInstanceFromQueryResult(res, result.headTerms, result.headTypes)), queryPoller.numberResultsAvailable);
                queryPoller.stop();
            });
            if (onStop) {
                queryPoller.onStop = onStop;
            }
            queryPoller.start();
        });
    }
    getInstancesByPropertyValue(classIri, propertyIri, propertyType, propertyValue, includeLabels, onNewResults, isDirect, onStop, pageSize) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pageSize = pageSize || this.pageSize;
            const queryCode = propertyType === TypesEnum.OBJECT_PROPERTY
                ? getInstancesByObjectProperty(classIri, propertyIri, propertyValue, isDirect, includeLabels)
                : getInstancesByDataProperty(classIri, propertyIri, propertyValue, includeLabels);
            const queryPoller = yield this.queryManager.performQuery(queryCode, _pageSize, QuerySemantics.FULL_SPARQL);
            queryPoller.onNewResults = (result => {
                onNewResults(result.results.map(res => this.getClassInstanceFromQueryResult(res, result.headTerms, result.headTypes)), queryPoller.numberResultsAvailable);
            });
            if (onStop) {
                queryPoller.onStop = onStop;
            }
            queryPoller.start();
            return queryPoller.executionId;
        });
    }
    getInstancesNumber(iri, onResult, onStop) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryCode = getInstances(iri, false, 'unlimited');
            this.queryManager.performQueryCount(queryCode, onStop)
                .then(result => onResult(result))
                .catch(_ => {
                if (onStop)
                    onStop();
            });
        });
    }
    getHighlights(classIri) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams({ clickedClassIRI: classIri, version: this.requestOptions.version });
            const url = new URL(`${this.requestOptions.basePath}/owlOntology/${this.requestOptions.name}/highlights?${params.toString()}`);
            return yield (yield handleApiCall(fetch(url, {
                method: 'get',
                headers: this.requestOptions.headers
            }), this.requestOptions.onError)).json();
        });
    }
    getEntitiesEmptyUnfoldings(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                handleApiCall(fetch(`${this.requestOptions.basePath}/endpoint/${endpoint.name}/emptyUnfoldingEntities`, {
                    method: 'get',
                    headers: this.requestOptions.headers,
                }), this.requestOptions.onError).then((response) => __awaiter(this, void 0, void 0, function* () { return resolve(yield response.json()); }))
                    .catch(err => reject(err));
            });
        });
    }
    getInstanceDataPropertyValues(instanceIri, dataPropertyIri, onNewResults, onStop, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryCode = getInstanceDataPropertyValues(instanceIri, dataPropertyIri);
            // const pollPage = async (pageNumber: number) => {
            //   const queryPoller = await this.queryManager.performQuery(queryCode, this.limit, pageNumber)
            //   if (queryPoller.status === QueryPollerStatus.STOPPED) {
            //     if (onStop)
            //       onStop()
            //     return
            //   }
            //   queryPoller.start()
            //   queryPoller.onNewResults = (results) => {
            //     onNewResults(results.results.map(res => res[0].value))
            //   }
            //   // If stopped then we need to decide wether to poll next page or not.
            //   // if query has not finished and queryPoller has not been stopped, continue polling for next page
            //   // if has finished or queryPoller has been stopped, then return and call onStop
            //   queryPoller.onStop = async () => {
            //     const queryStatus = await this.queryManager.getQueryStatus(queryPoller.executionId)
            //     if (queryStatus.status === QueryStatusEnum.FINISHED || queryPoller.status === QueryPollerStatus.STOPPED) {
            //       if (onStop)
            //         onStop()
            //       return
            //     }
            //     if (!queryStatus.hasError) {
            //       pollPage(pageNumber + 1) // poll for another page
            //     } else {
            //       if (onError)
            //         onError()
            //     }
            //   }
            // }
            // pollPage(1)
            const queryPoller = yield this.queryManager.performQuery(queryCode, this.pageSize, QuerySemantics.CQ);
            queryPoller.onNewResults = (results) => {
                onNewResults(results.results.map(res => res[0].value));
            };
            if (onStop) {
                queryPoller.onStop = onStop;
            }
            queryPoller.start();
        });
    }
    getInstancesThroughObjectProperty(instanceIri, objectPropertyIri, isDirect, includeLabels, onNewResults, rangeClassesIri, dataPropertyIriFilter, textSearch, onStop, customLimit) {
        return __awaiter(this, void 0, void 0, function* () {
            let querySemantics, queryCode;
            if (textSearch) {
                querySemantics = QuerySemantics.FULL_SPARQL;
                if (rangeClassesIri && dataPropertyIriFilter) {
                    queryCode = getInstancesThroughOPByDP(instanceIri, objectPropertyIri, rangeClassesIri, dataPropertyIriFilter, textSearch, isDirect, includeLabels);
                }
                else {
                    if (includeLabels)
                        queryCode = getInstancesThroughObjectPropertyByLabel(instanceIri, objectPropertyIri, textSearch, rangeClassesIri, isDirect, customLimit);
                    else
                        queryCode = getInstancesThroughObjectPropertyByIRI(instanceIri, objectPropertyIri, textSearch, rangeClassesIri, isDirect, customLimit);
                }
            }
            else {
                querySemantics = QuerySemantics.CQ;
                queryCode = getInstancesThroughObjectProperty(instanceIri, objectPropertyIri, rangeClassesIri, isDirect, includeLabels, customLimit);
            }
            const queryPoller = yield this.queryManager.performQuery(queryCode, this.pageSize, querySemantics);
            queryPoller.onNewResults = (result) => {
                onNewResults(result.results.map(res => this.getClassInstanceFromQueryResult(res, result.headTerms, result.headTypes)), queryPoller.numberResultsAvailable);
            };
            if (onStop) {
                queryPoller.onStop = onStop;
            }
            queryPoller.start();
            return queryPoller.executionId;
        });
    }
    instanceCheck(instanceIri, classesToCheck, onResult, onStop) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.queryManager.instanceCheck(instanceIri, classesToCheck);
            poller.onNewResults = (result) => {
                if (result.resultClasses && result.state === QueryStatusEnum.FINISHED) {
                    onResult(result.resultClasses.map(entity => entity.entityIRI));
                }
            };
            if (onStop) {
                poller.onStop = onStop;
            }
            poller.start();
        });
    }
    getMaterializedCounts(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = new URL(`${this.requestOptions.basePath}/endpoint/${endpoint.name}/countClassInstances/info`);
            return new Promise((resolve, reject) => {
                fetch(url, {
                    method: 'get',
                    headers: this.requestOptions.headers
                }).then((response) => __awaiter(this, void 0, void 0, function* () {
                    if (response.status !== 200) {
                        const result = yield (response.json() || response.text());
                        this.requestOptions.onError(result);
                        reject(result);
                    }
                    else {
                        const result = yield response.json();
                        result.countsMap = new Map(Object.entries(result.countsMap));
                        resolve(result);
                    }
                }))
                    .catch(error => {
                    this.requestOptions.onError(error);
                    reject(error);
                });
            });
        });
    }
    stopAllQueries() {
        this.queryManager.stopRunningQueries();
    }
    stopCountsQueries() {
        this.queryManager.stopCountsQueries();
    }
    stopInstancesQueries() {
        this.queryManager.stopInstancesQueries();
    }
    setEndpoint(endpoint) {
        this.queryManager = new QueryManager(this.requestOptions, endpoint);
    }
    getInstanceLabels(instanceIri, onResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryCode = getInstanceLabels(instanceIri);
            const queryPoller = yield this.queryManager.performQuery(queryCode, 100, QuerySemantics.CQ, true);
            queryPoller.onNewResults = (result) => {
                onResult(result.results.map(r => this.parseLabel(r[0].value)).filter(l => l.value !== 'null'));
            };
            queryPoller.start();
        });
    }
    getIntensionalShortestPath(sourceClassIri, targetClassIri, kShortest = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams({
                lastSelectedIRI: sourceClassIri,
                clickedIRI: targetClassIri,
                version: this.requestOptions.version
            });
            if (kShortest)
                params.append('kShortest', 'true');
            const url = new URL(`${this.requestOptions.basePath}/owlOntology/${this.requestOptions.name}/highlights/paths?${params.toString()}`);
            return (yield (yield handleApiCall(fetch(url, {
                method: 'get',
                headers: this.requestOptions.headers
            }), this.requestOptions.onError)).json());
        });
    }
    getExtensionalShortestPath(sourceInstanceIri, targetIri, path, onNewResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams({
                sourceInstanceIri: sourceInstanceIri,
                targetInstanceIRI: targetIri,
                labels: 'true',
                version: this.requestOptions.version
            });
            const url = new URL(`${this.requestOptions.basePath}/owlOntology/${this.requestOptions.name}/instanceShortestPath?${params.toString()}`);
            const headers = this.requestOptions.headers;
            // headers['content-type'] = 'text/plain'
            const queryCode = (yield (yield handleApiCall(fetch(url, {
                method: 'post',
                headers: headers,
                body: JSON.stringify(path),
            }), this.requestOptions.onError)).text());
            if (queryCode && typeof queryCode === 'string') {
                this.queryManager.performQueryContrusct(queryCode)
                    .then(rdfGraph => onNewResult(rdfGraph));
            }
        });
    }
    shouldQueryUseLabels(executionId) {
        return this.queryManager.shouldQueryUseLabels(executionId);
    }
    getClassInstanceFromQueryResult(results, headTerms, headTypes) {
        let instance;
        const result = [];
        results.forEach((resultColumn, i) => {
            const columnType = getHeadType(headTerms[i]);
            if (columnType === HeadTypes.OBJECT) {
                instance = {
                    iri: decodeURI(resultColumn.value),
                    shortIri: decodeURI(resultColumn.shortIRI),
                };
                let nextColumnType = getHeadType(headTerms[i + 1]);
                let nextColumn = results[i + 1];
                // next column referes to this class instance only if it's a value
                if (headTerms[i + 1] && nextColumnType !== HeadTypes.OBJECT) {
                    if (headTerms[i + 1] === `l${headTerms[i]}`) {
                        const label = nextColumn.value ? this.parseLabel(nextColumn.value) : undefined;
                        instance.label = (label === null || label === void 0 ? void 0 : label.value) !== 'null' ? label : undefined;
                    }
                    else {
                        instance.searchMatch = nextColumn.value;
                    }
                    // this is necessary only for the queries 14/15
                    nextColumnType = getHeadType(headTerms[i + 2]);
                    nextColumn = results[i + 2];
                    if (headTerms[i + 2] && nextColumnType !== HeadTypes.OBJECT && headTerms[i + 2] !== `?l${headTerms[i].charAt(1)}`) {
                        instance.searchMatch = results[i + 2].value;
                    }
                }
                result.push(instance);
            }
        });
        return result;
        function getHeadType(headTerm) {
            if (headTerm && headTypes[headTerm])
                return headTypes[headTerm][0];
        }
    }
    parseLabel(labelWithLang) {
        let label = null;
        let lang = undefined;
        if (labelWithLang !== 'null') {
            const atIndex = labelWithLang.lastIndexOf('@');
            if (atIndex > 0) {
                lang = labelWithLang.substring(atIndex + 1);
                label = labelWithLang.substring(1, atIndex - 1);
            }
            else {
                label = labelWithLang;
            }
        }
        return {
            value: label || 'null',
            language: lang || undefined
        };
    }
}
// Stubbed API
// export let vKGApiStub: IVirtualKnowledgeGraphApi = {
//   getInstances: (iri: string) => {
//     return [
//       {
//         iri: `http://obdm.obdasystems.com/book/1`,
//         label: 'Harry Potter',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/2`,
//         label: 'It',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/3`
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/4`,
//         label: 'Divina Commedia',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/5`,
//         label: 'Promessi Sposi',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/6`,
//         label: 'Songs Of My Nightmares',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/7`,
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/8`,
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/9`,
//         label: 'Losing The Sun',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/10`,
//         label: 'Sailing Into The Void',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/11`,
//         label: 'Calling Myself',
//       },
//       {
//         iri: `http://obdm.obdasystems.com/book/12`,
//         label: 'Bleeding At The Mountains',
//       },
//     ]
//   },
//   getInstancesNumber: function (iri: string, onResult) {
//     onResult(2)
//   },
//   // getObjectProperties: function (iri: string): Promise<Branch[]> {
//   //   throw new Error('Function not implemented.')
//   // }
// }

class HighlightsManager {
    constructor(vkgApi, emptyUnfoldingEntities) {
        this.vkgApi = vkgApi;
        this.emptyUnfoldingEntities = emptyUnfoldingEntities;
        this.highlightsCallsPromises = [];
        this.lastClassIris = [];
        this.currentClassIris = [];
        this.emptyUnfoldingsDataProperties = [];
        this.emptyUnfoldingsObjectProperties = [];
        this.emptyUnfoldingsClasses = [];
        this._dataProperties = new Set();
        this._objectProperties = new Map();
        this.computationPromise = new Promise(() => { });
        this.emptyUnfoldingsDataProperties = this.emptyUnfoldingEntities.emptyUnfoldingDataProperties.map(e => e.entityIRI);
        this.emptyUnfoldingsObjectProperties = this.emptyUnfoldingEntities.emptyUnfoldingObjectProperties.map(e => e.entityIRI);
        this.emptyUnfoldingsClasses = this.emptyUnfoldingEntities.emptyUnfoldingClasses.map(e => e.entityIRI);
    }
    computeHighlights(classIriStringOrArray) {
        return __awaiter(this, void 0, void 0, function* () {
            this.lastClassIris = this.currentClassIris;
            this.currentClassIris = typeof classIriStringOrArray === 'string' ? [classIriStringOrArray] : classIriStringOrArray;
            this.clear();
            this.computationPromise = new Promise((resolve, reject) => {
                for (let classIri of this.currentClassIris) {
                    this.highlightsCallsPromises.push(this.vkgApi.getHighlights(classIri));
                }
                Promise.all(this.highlightsCallsPromises)
                    .then(results => {
                    var _a, _b;
                    for (let highlights of results) {
                        (_a = highlights.dataProperties) === null || _a === void 0 ? void 0 : _a.forEach(dp => this._dataProperties.add(dp));
                        (_b = highlights.objectProperties) === null || _b === void 0 ? void 0 : _b.forEach(op => {
                            if (op.objectPropertyIRI && !this._objectProperties.has(op.objectPropertyIRI)) {
                                this._objectProperties.set(op.objectPropertyIRI, op);
                            }
                        });
                    }
                    resolve();
                });
            });
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            this.highlightsCallsPromises = [];
            this._dataProperties.clear();
            this._objectProperties.clear();
        });
    }
    dataProperties() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.computationPromise;
            return Array.from(this._dataProperties);
        });
    }
    objectProperties() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.computationPromise;
            return Array.from(this._objectProperties).map(([_, opBranch]) => opBranch);
        });
    }
    getShortestPath(sourceClassIri, targetClassIri) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.vkgApi.getIntensionalShortestPath(sourceClassIri, targetClassIri);
        });
    }
    getShortestKPaths(sourceClassIri, targetClassIri) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.vkgApi.getIntensionalShortestPath(sourceClassIri, targetClassIri, true);
        });
    }
    hasUnfoldings(entityIri, entityType) {
        switch (entityType) {
            case TypesEnum.DATA_PROPERTY:
                return !this.emptyUnfoldingsDataProperties.includes(entityIri);
            case TypesEnum.OBJECT_PROPERTY:
                return !this.emptyUnfoldingsObjectProperties.includes(entityIri);
            case TypesEnum.CLASS:
                return !this.emptyUnfoldingsClasses.includes(entityIri);
            default:
                return false;
        }
    }
}

var IncrementalEvent;
(function (IncrementalEvent) {
    IncrementalEvent["RequestStopped"] = "requestStopped";
    IncrementalEvent["NewInstances"] = "newInstances";
    IncrementalEvent["InstancesSearchFinished"] = "instancesSearchFinished";
    IncrementalEvent["LimitChange"] = "limitChange";
    IncrementalEvent["EndpointChange"] = "endpointChange";
    IncrementalEvent["Reset"] = "reset";
    IncrementalEvent["ClassInstanceSelection"] = "classInstanceSselection";
    IncrementalEvent["ClassSelection"] = "classSelection";
    IncrementalEvent["ContextClick"] = "contextClick";
    IncrementalEvent["DoubleTap"] = "doubleTap";
    IncrementalEvent["DiagramUpdated"] = "diagramUpdated";
    IncrementalEvent["ReasonerSet"] = "reasonerSet";
    IncrementalEvent["NewDataPropertyValues"] = "newDataPropertyValues";
    IncrementalEvent["DataPropertyValuesLoadingFinished"] = "dpvaluesloadfinish";
    IncrementalEvent["InstanceCheckingStarted"] = "instanceCheckingStarted";
    IncrementalEvent["InstanceCheckingFinished"] = "instanceCheckingFinished";
    IncrementalEvent["CountStarted"] = "countStarted";
    IncrementalEvent["NewCountResult"] = "newCountResult";
    IncrementalEvent["FocusStarted"] = "focusStarted";
    IncrementalEvent["FocusFinished"] = "focusFinished";
})(IncrementalEvent || (IncrementalEvent = {}));
class IncrementalLifecycle {
    constructor() {
        this.requestStopped = [];
        this.newInstances = [];
        this.instancesSearchFinished = [];
        this.limitChange = [];
        this.endpointChange = [];
        this.reset = [];
        this.classInstanceSselection = [];
        this.classSelection = [];
        this.diagramUpdated = [];
        this.reasonerSet = [];
        this.newDataPropertyValues = [];
        this.dpvaluesloadfinish = [];
        this.instanceCheckingStarted = [];
        this.instanceCheckingFinished = [];
        this.newCountResult = [];
        this.countStarted = [];
        this.focusStarted = [];
        this.focusFinished = [];
        this.on = (event, callback) => {
            this[event].push(callback);
        };
    }
    trigger(event, ...params) {
        this[event].forEach((callback) => callback(...params));
    }
}

class EndpointController {
    constructor(requestOptions, lifecycle) {
        this.requestOptions = requestOptions;
        this.lifecycle = lifecycle;
        this.pageSize = 100;
        this.endpointApi = new EndpointApi(this.requestOptions);
        this.getRunningEndpoints();
        this.setPageSize(this.pageSize);
    }
    getRunningEndpoints() {
        return __awaiter(this, void 0, void 0, function* () {
            this.endpoints = yield this.endpointApi.getRunningEndpoints();
            return this.endpoints;
        });
    }
    setEndpoint(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            const _endpoint = typeof (endpoint) === 'string' ? this.endpoints.find(e => e.name === endpoint) : endpoint;
            if (_endpoint) {
                this.selectedEndpoint = _endpoint;
                if (!this.vkgApi) {
                    this.vkgApi = new VKGApi(this.requestOptions, _endpoint, this.pageSize);
                }
                else {
                    this.vkgApi.setEndpoint(_endpoint);
                }
                const emptyUnfoldingEntities = yield this.vkgApi.getEntitiesEmptyUnfoldings(_endpoint);
                this.highlightsManager = new HighlightsManager(this.vkgApi, emptyUnfoldingEntities);
                this.lifecycle.trigger(IncrementalEvent.EndpointChange, _endpoint);
            }
            else {
                console.warn(`[VKG-API] The endpoint you tried to set cannot be found`);
            }
        });
    }
    setPageSize(newPageSize) {
        this.pageSize = newPageSize;
        if (this.vkgApi) {
            this.vkgApi.pageSize = newPageSize;
            this.lifecycle.trigger(IncrementalEvent.LimitChange, newPageSize);
        }
    }
    clear() {
        var _a;
        (_a = this.highlightsManager) === null || _a === void 0 ? void 0 : _a.clear();
        this.stopRequests();
    }
    stopRequests(requestType = 'all') {
        var _a, _b, _c;
        switch (requestType) {
            case 'instances':
                (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.stopInstancesQueries();
                break;
            case 'counts':
                (_b = this.vkgApi) === null || _b === void 0 ? void 0 : _b.stopCountsQueries();
                break;
            case 'all':
                (_c = this.vkgApi) === null || _c === void 0 ? void 0 : _c.stopAllQueries();
                break;
        }
    }
    requestInstancesForClass(classIri, includeLabels = true, searchText, propertyIriFilter, propertyType, isDirect) {
        var _a, _b;
        if (searchText && propertyIriFilter && propertyType)
            return (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getInstancesByPropertyValue(classIri, propertyIriFilter, propertyType, searchText, includeLabels, (classInstances, numberResultsAvailable) => this.lifecycle.trigger(IncrementalEvent.NewInstances, classInstances, numberResultsAvailable), isDirect, () => this.lifecycle.trigger(IncrementalEvent.InstancesSearchFinished));
        else
            return (_b = this.vkgApi) === null || _b === void 0 ? void 0 : _b.getInstances(classIri, includeLabels, (classInstances, numberResultsAvailable) => this.lifecycle.trigger(IncrementalEvent.NewInstances, classInstances, numberResultsAvailable), () => this.lifecycle.trigger(IncrementalEvent.InstancesSearchFinished), searchText);
    }
    requestNewInstances(requestId, pageNumber) {
        var _a;
        (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getNewResults(requestId, pageNumber, (classInstances, numberResultsAvailable) => this.lifecycle.trigger(IncrementalEvent.NewInstances, classInstances, numberResultsAvailable), () => this.lifecycle.trigger(IncrementalEvent.InstancesSearchFinished));
    }
    requestInstancesThroughObjectProperty(instanceIri, objectPropertyIri, isDirect = true, includeLabels = true, rangeClassIri, propertyIriFilter, searchText) {
        var _a;
        return (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getInstancesThroughObjectProperty(instanceIri, objectPropertyIri, isDirect, includeLabels, (classInstances, numberResultsAvailable) => this.lifecycle.trigger(IncrementalEvent.NewInstances, classInstances, numberResultsAvailable), rangeClassIri, propertyIriFilter, searchText, () => this.lifecycle.trigger(IncrementalEvent.InstancesSearchFinished));
    }
    requestDataPropertyValues(instanceIri, dataPropertyIri) {
        var _a;
        (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getInstanceDataPropertyValues(instanceIri, dataPropertyIri, (newValues) => this.lifecycle.trigger(IncrementalEvent.NewDataPropertyValues, instanceIri, dataPropertyIri, newValues), () => this.lifecycle.trigger(IncrementalEvent.DataPropertyValuesLoadingFinished, instanceIri, dataPropertyIri));
    }
    requestCountForClass(classIri) {
        var _a;
        this.lifecycle.trigger(IncrementalEvent.CountStarted, classIri);
        (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getInstancesNumber(classIri, (result) => this.lifecycle.trigger(IncrementalEvent.NewCountResult, classIri, { value: result, materialized: false }), () => this.lifecycle.trigger(IncrementalEvent.NewCountResult, classIri));
    }
    shouldQueryUseLabels(queryExecutionId) {
        var _a;
        return (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.shouldQueryUseLabels(queryExecutionId);
    }
    getMaterializedCounts() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.selectedEndpoint)
                return yield ((_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getMaterializedCounts(this.selectedEndpoint));
        });
    }
    instanceCheck(instanceIri, classesToCheck) {
        return __awaiter(this, void 0, void 0, function* () {
            this.lifecycle.trigger(IncrementalEvent.InstanceCheckingStarted, instanceIri);
            return new Promise((resolve) => {
                var _a;
                (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.instanceCheck(instanceIri, classesToCheck, (res) => {
                    resolve(res);
                    this.lifecycle.trigger(IncrementalEvent.InstanceCheckingFinished, instanceIri);
                }, () => this.lifecycle.trigger(IncrementalEvent.InstanceCheckingFinished, instanceIri));
            });
        });
    }
    requestLabels(instanceIri) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                var _a;
                (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getInstanceLabels(instanceIri, (res) => resolve(res));
            });
        });
    }
    requestInstancesPath(sourceInstanceIri, targetIri, path) {
        return new Promise((resolve) => {
            var _a;
            (_a = this.vkgApi) === null || _a === void 0 ? void 0 : _a.getExtensionalShortestPath(sourceInstanceIri, targetIri, path, (rdfGraph) => resolve(rdfGraph));
        });
    }
    setLanguage(lang) {
        if (this.vkgApi)
            this.vkgApi.language = lang;
    }
    isReasonerAvailable() {
        return this.selectedEndpoint !== undefined;
    }
    get endpoint() { return this.selectedEndpoint; }
}

class NeighbourhoodFinder {
    constructor(ontology) {
        this.ontology = ontology;
    }
    getDataProperties(classIriString) {
        const res = [];
        const classIri = this.getIriObject(classIriString);
        const dataPropertySelector = `[type = "${TypesEnum.DATA_PROPERTY}"]`;
        this.ontology.diagrams.forEach(diagram => {
            var _a;
            (_a = diagram.representations.get(RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.cy.$(`node[iri = "${classIri.fullIri}"]`).forEach(classNode => {
                classNode.neighborhood(dataPropertySelector).forEach(dataPropertyNode => {
                    const dataPropertyEntity = this.ontology.getEntity(dataPropertyNode.data().iri);
                    if (dataPropertyEntity && !res.includes(dataPropertyEntity)) {
                        res.push(dataPropertyEntity);
                    }
                });
            });
        });
        return res;
    }
    getObjectProperties(classIriString) {
        const res = new Map();
        const classIri = this.getIriObject(classIriString);
        const objectPropertyEdgeSelector = `[type = "${TypesEnum.OBJECT_PROPERTY}"]`;
        this.ontology.diagrams.forEach(diagram => {
            var _a;
            (_a = diagram.representations.get(RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.cy.$(`node[iri = "${classIri.fullIri}"]`).forEach(classNode => {
                classNode.connectedEdges(objectPropertyEdgeSelector).forEach(objectPropertyEdge => {
                    const objectPropertyEntity = this.ontology.getEntity(objectPropertyEdge.data().iri);
                    let classIriConnected;
                    let direct = true;
                    if (objectPropertyEntity) {
                        // if classIri is the source of the edge (i.e. domain of the object property)
                        // then add target's iri to results
                        if (classIri.equals(objectPropertyEdge.source().data().iri)) {
                            classIriConnected = objectPropertyEdge.target().data().iri;
                        }
                        // if classIri is the target of the edge (i.e. range of the object property)
                        // then add source's iri to results
                        else if (classIri.equals(objectPropertyEdge.target().data().iri)) {
                            classIriConnected = objectPropertyEdge.source().data().iri;
                            direct = false;
                        }
                        if (classIriConnected) {
                            const connectedClassEntity = this.ontology.getEntity(classIriConnected);
                            if (connectedClassEntity) {
                                const resEntry = res.get(objectPropertyEntity);
                                if (resEntry) {
                                    if (!resEntry.list.includes(connectedClassEntity)) // add only new classes
                                        resEntry.list.push(connectedClassEntity);
                                }
                                else {
                                    res.set(objectPropertyEntity, { list: [connectedClassEntity], direct: direct });
                                }
                            }
                        }
                    }
                });
            });
        });
        return res;
    }
    /**
     * Given a class and an object property, get all classes connected to the given class through such an
     * object property.
     * @param sourceClassIriString the class' iri involved in the object property
     * either as domain or range
     * @param objectPropertyIriString the object property's iri for which to retrieve the connected classes' iris
     * @returns an array of entities
     */
    getClassesConnectedToObjectProperty(sourceClassIriString, objectPropertyIriString) {
        const res = [];
        const sourceClassIri = this.getIriObject(sourceClassIriString);
        const objectPropertyIri = this.getIriObject(objectPropertyIriString);
        const cyObjectPropertySelector = `edge[iri = "${objectPropertyIri.fullIri}"]`;
        let classIriConnected;
        /**
         * For each diagram in floaty representation, search the object property
         * and check if it's connected to the source class and if so, get
         * the other end of the edge.
         */
        this.ontology.diagrams.forEach(diagram => {
            var _a;
            (_a = diagram.representations.get(RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.cy.$(cyObjectPropertySelector).forEach(objectPropertyEdge => {
                // if sourceClass is the source of the edge (i.e. domain of the object property)
                // then add target's iri to results
                if (sourceClassIri.equals(objectPropertyEdge.source().data().iri)) {
                    classIriConnected = objectPropertyEdge.target().data().iri;
                }
                // if sourceClass is the target of the edge (i.e. range of the object property)
                // then add source's iri to results
                else if (sourceClassIri.equals(objectPropertyEdge.target().data().iri)) {
                    classIriConnected = objectPropertyEdge.source().data().iri;
                }
                if (classIriConnected) {
                    const entityToAdd = this.ontology.getEntity(classIriConnected);
                    if (entityToAdd) {
                        res.push(entityToAdd);
                    }
                }
            });
        });
        return res;
    }
    getConnectedClassesIrisByType(classIri, type, inclusionType = 'subclass') {
        var _a;
        const res = [];
        let resultingNodes;
        let diagram;
        (_a = this.ontology.getEntityOccurrences(classIri, undefined, RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.forEach(classOccurrences => {
            classOccurrences.forEach(classOccurrence => {
                var _a;
                diagram = this.ontology.getDiagram(classOccurrence.diagramId);
                if (diagram) {
                    const inclusionEdges = (_a = diagram.representations.get(RendererStatesEnum.FLOATY)) === null || _a === void 0 ? void 0 : _a.cy.$id(classOccurrence.id).edgesWith(`[ type = "${TypesEnum.CLASS}" ]`).filter(edge => edge.data().type === type); // take only inclusions/equivalence edges
                    if (!inclusionEdges)
                        return;
                    if (type === TypesEnum.EQUIVALENCE) {
                        resultingNodes = inclusionEdges.connectedNodes(`[ iri != "${classIri}" ]`);
                    }
                    else if (inclusionType === 'subclass') {
                        resultingNodes = inclusionEdges.sources(`[ iri != "${classIri}" ]`); // of these inclusions, take sources different from the class we are considering as superclass
                    }
                    else {
                        resultingNodes = inclusionEdges.targets(`[ iri != "${classIri}" ]`); // of these inclusions, take targets different from the class we are considering as superclass
                    }
                    resultingNodes.forEach(node => {
                        if (!res.includes(node.data().iri)) {
                            res.push(node.data().iri);
                        }
                    });
                }
            });
        });
        return res;
    }
    getSubclassesIris(classIri) {
        return this.getConnectedClassesIrisByType(classIri, TypesEnum.INCLUSION, 'subclass');
    }
    getEquivalentClassesIris(classIri) {
        return this.getConnectedClassesIrisByType(classIri, TypesEnum.EQUIVALENCE);
    }
    getSuperclassesIris(classIri) {
        return this.getConnectedClassesIrisByType(classIri, TypesEnum.INCLUSION, 'superclass');
    }
    getIriObject(iri) {
        return new Iri(iri, this.ontology.namespaces);
    }
}

var style = i$1 `
  .gscape-panel {
    overflow: auto;
  }

  .counter {
    position: absolute;
    margin-left: 18px;
  }

  .chip {
    line-height: 1;
  }

  .chip.data-property-value {
    color: var(--gscape-color-fg-default);
    border-color: var(--gscape-color-data-property-contrast);
    background-color: var(--gscape-color-data-property);
  }

  .neutral-chip {
    color: var(--gscape-color-fg-default);
    border-color: var(--gscape-color-border-default);
    background-color: var(--gscape-color-neutral-subtle);
  }

  .section-body {
    position: relative;
  }

  .content-wrapper > * {
    margin: 8px 0;
  }

  details.entity-list-item > .summary-body {
    white-space: normal;
  }

  .summary-body > .lds-ring {
    margin: 4px auto 8px;
  }

  .limit-box {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    padding: 4px 0 8px;
  }

  .limit-box > input {
    padding: 4px 8px;
    max-width: 80px;
  }
`;

class GscapeClassInstanceDetails extends BaseMixin$3(s) {
    constructor() {
        super(...arguments);
        this._dataProperties = [];
        /** @internal */
        this.canShowDataPropertiesValues = false;
        /** @internal */
        this.onParentClassSelection = (iri) => { };
    }
    render() {
        var _a;
        return x `
    <div>
      ${this.parentClasses && this.parentClasses.length > 0
            ? x `
          <div class="section">
            <div class="section-header"><span class="bold-text">Parent Classes</span> - rdf:type</div>
            <div class="section-body" style="padding-left: 0px; padding-right: 0px">
              ${(_a = this.parentClasses) === null || _a === void 0 ? void 0 : _a.map(parentClass => {
                return x `
                  <gscape-entity-list-item
                    displayedname=${parentClass.displayedName}
                    iri=${parentClass.value.iri.fullIri}
                    .types=${parentClass.value.types}
                    @click=${this.handleEntityClick}
                  >
                  </gscape-entity-list-item>
                `;
            })}
            </div>
          </div>
        `
            : null}

      ${this.dataProperties && this.dataProperties.length > 0
            ? x `
          <div class="section">
            <div class="section-header bold-text">Data Properties</div>
            <div class="section-body" style="padding-left: 0px; padding-right: 0px">
              ${this.dataProperties.map(dataProperty => {
                var _a;
                const values = (_a = this._dataPropertiesValues) === null || _a === void 0 ? void 0 : _a.get(dataProperty.value.iri.fullIri);
                return x `
                  <gscape-entity-list-item
                    displayedname=${dataProperty.displayedName}
                    iri=${dataProperty.value.iri.fullIri}
                    .types=${dataProperty.value.types}
                  >
                    ${this.canShowDataPropertiesValues && values
                    ? x `
                        <div slot="trailing-element">
                          ${!values.loading && values.values.size === 0 ? x `<span class="chip neutral-chip">${GscapeClassInstanceDetails.notAvailableText}</span>` : null}
                          ${Array.from(values.values).map(v => x `<span class="chip data-property-value">${v}</span>`)}
                          ${values.loading
                        ? x `<span class="chip neutral-chip">${textSpinner()}</span>`
                        : null}
                        </div>
                      `
                    : null}
                  </gscape-entity-list-item>
                `;
            })}
            </div>
          </div>
        `
            : null} 
    </div>
    `;
    }
    /**
    private getEntitySuggestionTemplate(entity: EntityViewData, objectPropertyIri?: string, parentClassIri?: string, direct?: boolean) {
      const values = this.dataPropertiesValues?.get(entity.value.iri.fullIri)
  
      return html`
        <div
          title=${entity.displayedName}
          iri=${entity.value.iri.fullIri}
          entity-type="${entity.value.type}"
          class="ellipsed entity-list-item ${entity.value.type !== TypesEnum.DATA_PROPERTY ? 'actionable' : null }"
          @click=${(e: Event)=> this.handleEntityClick(e, objectPropertyIri, parentClassIri, direct)}
        >
          <span class="entity-icon slotted-icon">${entityIcons[entity.value.type]}</span>
          <span class="entity-name">${entity.displayedName}</span>
          ${this.canShowDataPropertiesValues && values
            ? html`
              ${!values.loading && values.values.length === 0 ? html`<span class="chip neutral-chip">${GscapeClassInstanceDetails.notAvailableText}</span>` : null}
              ${values.values.map(v => html`<span class="chip data-property-value">${v}</span>`)}
              ${values.loading
                ? html`<span class="chip neutral-chip">${textSpinner()}</span>`
                : null
              }
            `
            : null
          }
        </div>
      `
    }
    */
    handleEntityClick(e) {
        const target = e.currentTarget;
        const iri = target.getAttribute('iri');
        if (!iri)
            return;
        this.onParentClassSelection(iri);
    }
    show() {
        var _a, _b;
        super.show();
        (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(`details`)) === null || _b === void 0 ? void 0 : _b.forEach(detailsElement => detailsElement.open = false);
    }
    reset() {
        this.dataProperties = [];
        this.canShowDataPropertiesValues = false;
    }
    addDataPropertyValue(dataPropertyIri, value) {
        var _a, _b;
        (_b = (_a = this._dataPropertiesValues) === null || _a === void 0 ? void 0 : _a.get(dataPropertyIri)) === null || _b === void 0 ? void 0 : _b.values.add(value);
        this.requestUpdate();
    }
    /** @internal */
    setDataPropertyLoading(dataPropertyIri, isLoading) {
        var _a;
        const dataPropertyValues = (_a = this._dataPropertiesValues) === null || _a === void 0 ? void 0 : _a.get(dataPropertyIri);
        if (dataPropertyValues) {
            dataPropertyValues.loading = isLoading;
            this.requestUpdate();
        }
    }
    get dataProperties() {
        return this._dataProperties;
    }
    set dataProperties(newDataProperties) {
        const oldValue = this._dataProperties;
        this._dataProperties = newDataProperties.sort((a, b) => a.displayedName.localeCompare(b.displayedName));
        this._dataPropertiesValues = new Map(this._dataProperties.map(dp => [dp.value.iri.fullIri, { values: new Set(), loading: true }]));
        this.requestUpdate('dataProperties', oldValue);
    }
}
GscapeClassInstanceDetails.properties = {
    dataProperties: { type: Object, attribute: false },
    canShowDataPropertiesValues: { type: Boolean, attribute: false },
    parentClasses: { type: Object, attribute: false },
};
GscapeClassInstanceDetails.notAvailableText = 'n/a';
GscapeClassInstanceDetails.styles = [baseStyle$3, entityListItemStyle, style, textSpinnerStyle, contentSpinnerStyle,
    i$1 `
      gscape-entity-list-item {
        --custom-wrap: wrap;
      }
    `
];
customElements.define('gscape-class-instance-details', GscapeClassInstanceDetails);

function ClassInstanceDetailsFactory(ic) {
    const classInstanceDetails = new GscapeClassInstanceDetails();
    const entityDetailsWidget = ic.grapholscape.widgets.get(WidgetEnum$1.ENTITY_DETAILS);
    if (entityDetailsWidget)
        entityDetailsWidget.incrementalSection = classInstanceDetails;
    ic.grapholscape.widgets.set(WidgetEnum$1.CLASS_INSTANCE_DETAILS, classInstanceDetails);
    ic.grapholscape.on(LifecycleEvent.EntitySelection, (grapholEntity) => __awaiter(this, void 0, void 0, function* () {
        let dataProperties;
        if (grapholEntity.is(TypesEnum.CLASS) && ic.grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
            dataProperties = yield ic.getDataPropertiesByClasses([grapholEntity.iri.fullIri]);
            classInstanceDetails.dataProperties = dataProperties.map(dp => grapholEntityToEntityViewData(dp, ic.grapholscape));
            classInstanceDetails.parentClasses = undefined;
            classInstanceDetails.canShowDataPropertiesValues = false;
            classInstanceDetails.show();
        }
        else {
            classInstanceDetails.hide();
        }
    }));
    ic.on(IncrementalEvent.ClassInstanceSelection, (classInstanceEntity) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!(entityDetailsWidget === null || entityDetailsWidget === void 0 ? void 0 : entityDetailsWidget.grapholEntity) || !(entityDetailsWidget === null || entityDetailsWidget === void 0 ? void 0 : entityDetailsWidget.grapholEntity.iri.equals(classInstanceEntity.iri))) {
            (_a = ic.endpointController) === null || _a === void 0 ? void 0 : _a.stopRequests('instances');
            const parentClassesIris = classInstanceEntity.parentClassIris.map(i => i.fullIri);
            let dataProperties = [];
            if (classInstanceEntity.dataProperties.length > 0) {
                let dpEntity;
                classInstanceDetails.dataProperties = [];
                classInstanceEntity.dataProperties.forEach(dp => {
                    dpEntity = ic.grapholscape.ontology.getEntity(dp.iri);
                    if (dpEntity) {
                        dataProperties.push(dpEntity);
                        classInstanceDetails.addDataPropertyValue(dp.iri, dp.value);
                    }
                });
            }
            else {
                dataProperties = yield ic.getDataPropertiesByClasses(parentClassesIris);
                classInstanceDetails.dataProperties = dataProperties.map(dp => grapholEntityToEntityViewData(dp, ic.grapholscape));
                dataProperties.forEach(dp => {
                    var _a;
                    (_a = ic.endpointController) === null || _a === void 0 ? void 0 : _a.requestDataPropertyValues(classInstanceEntity.iri.fullIri, dp.iri.fullIri);
                });
            }
            classInstanceDetails.parentClasses = parentClassesIris.map(parentClassIri => {
                const parentClassEntity = ic.grapholscape.ontology.getEntity(parentClassIri);
                if (parentClassEntity)
                    return grapholEntityToEntityViewData(parentClassEntity, ic.grapholscape);
            }).filter(entity => entity !== undefined);
        }
        classInstanceDetails.canShowDataPropertiesValues = true;
        const classInstanceNode = classInstanceEntity.getOccurrenceByType(TypesEnum.CLASS_INSTANCE, RendererStatesEnum.INCREMENTAL);
        entityDetailsWidget === null || entityDetailsWidget === void 0 ? void 0 : entityDetailsWidget.setGrapholEntity(classInstanceEntity, classInstanceNode);
        classInstanceDetails.show();
    }));
    ic.on(IncrementalEvent.NewDataPropertyValues, (instanceIri, dataPropertyIri, newValues) => {
        if (entityDetailsWidget === null || entityDetailsWidget === void 0 ? void 0 : entityDetailsWidget.grapholEntity.iri.equals(instanceIri))
            newValues.forEach(v => classInstanceDetails.addDataPropertyValue(dataPropertyIri, v));
    });
    ic.on(IncrementalEvent.DataPropertyValuesLoadingFinished, (instanceIri, dataPropertyIri) => {
        if (entityDetailsWidget === null || entityDetailsWidget === void 0 ? void 0 : entityDetailsWidget.grapholEntity.iri.equals(instanceIri))
            classInstanceDetails.setDataPropertyLoading(dataPropertyIri, false);
    });
    return classInstanceDetails;
}

class GscapeVKGPreferences extends DropPanelMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.endpoints = [];
        this._onEndpointChangeCallback = () => { };
        this._onPageSizeChangeCallback = () => { };
        this._onStopRequestsCallback = () => { };
        this._onShowCountersChangeCallback = () => { };
        this.classList.add(BOTTOM_RIGHT_WIDGET.toString());
    }
    render() {
        return x `
      <gscape-button
        type="subtle"
        @click=${this.togglePanel}
        title="Virtual knowledge graph explorer preferences"
      >
        <span slot="icon">${tune}</span>
      </gscape-button>


      <div class="gscape-panel gscape-panel-in-tray hanging hide" id="drop-panel">
        <div class="header">VKG Preferences</div>
        <div class="content-wrapper">
          <div class="area">
            <span class="bold-text">Endpoint Settings</span>
            <div class="setting">
              <div class="title-wrap">
                <div class="setting-title">Endpoint list</div>
                <div class="setting-label muted-text">
                  select one of the currently running endpoints
                </div>
              </div>
              <div class="setting-obj endpoint-list">
                ${this.endpoints.map(endpoint => {
            return x `
                    <gscape-action-list-item
                      @click=${this.handleEndpointClick}
                      label="${endpoint.name}"
                      ?selected = "${this.selectedEndpointName === endpoint.name}"
                    >
                    </gscape-action-list-item>
                  `;
        })}

                ${this.endpoints.length === 0
            ? x `
                    <div class="blank-slate">
                      ${searchOff}
                      <div class="header">No endpoint available</div>
                    </div>
                  `
            : null}
              </div>
            </div>
            <div class="setting">
              <div class="title-wrap">
                <div class="setting-title">Page Size</div>
                <div class="setting-label muted-text">
                  Choose how many instances to retrieve for each page
                </div>
              </div>
              <div class="setting-obj">
                <input id="instances-limit" type="number" min="1" max="1000" value="${this.pageSize}" @change=${this.handlePageSizeChange}>
              </div>
            </div>
          </div>

          <div class="area">
            <span class="bold-text">Graph Settings</span>
            <div class="setting">
              <div class="setting-obj" style="width: 100%; max-width: unset;">
                <gscape-toggle
                  @click=${this.handleShowCountersChange}
                  label="Show Counters on Classes"
                  label-position="left"
                  class="actionable"
                  key = 'show-counts'
                  ?checked = ${this.showCounters}
                ></gscape-toggle>
              </div>
            </div>
          </div>

          <div class="area">
            <gscape-button
              size=${SizeEnum$1.S}
              label='Stop Pending Requests'
              type='secondary'
              @click=${this._onStopRequestsCallback}
            >
              ${getIconSlot$1('icon', stopCircle)}
            </gscape-button>
          </div>
        </div>
      </div>
    `;
    }
    handleEndpointClick(e) {
        if (e.currentTarget.label && e.currentTarget.label !== this.selectedEndpointName)
            this._onEndpointChangeCallback(e.currentTarget.label);
    }
    handlePageSizeChange(e) {
        const input = e.currentTarget;
        if (input.reportValidity()) {
            this._onPageSizeChangeCallback(input.valueAsNumber);
        }
    }
    handleShowCountersChange(e) {
        e.preventDefault();
        const toggle = e.currentTarget;
        toggle.checked = !toggle.checked;
        this._onShowCountersChangeCallback(toggle.checked);
    }
    onEndpointChange(callback) {
        this._onEndpointChangeCallback = callback;
    }
    onPageSizeChange(callback) {
        this._onPageSizeChangeCallback = callback;
    }
    onShowCountersChange(callback) {
        this._onShowCountersChangeCallback = callback;
    }
    onStopRequests(callback) {
        this._onStopRequestsCallback = callback;
    }
}
GscapeVKGPreferences.properties = {
    endpoints: { type: Array, attribute: false },
    selectedEndpointName: { type: String, reflect: true },
    pageSize: { type: Number, reflect: true },
    showCounters: { type: Boolean, reflect: true }
};
GscapeVKGPreferences.styles = [baseStyle$3, settingsStyle,
    i$1 `
      :host {
        order: 8;
      }

      .gscape-panel {
        min-width: 150px
      }

      .area:last-child {
        background: unset;
        border: unset;
        text-align: center;
        padding-top: unset;
      }

      .setting-obj {
        max-width: 200px;
        min-width: 150px;
      }

      .endpoint-list {
        display: flex;
        flex-direction: column;
        justify-content: stretch;
      }

      input {
        width: 100%;
      }
    `
];
customElements.define('gscape-vkg-preferences', GscapeVKGPreferences);

function VKGPreferencesFactory(incrementalController) {
    var _a, _b;
    const vkgPreferences = new GscapeVKGPreferences();
    vkgPreferences.showCounters = incrementalController.countersEnabled;
    incrementalController.grapholscape.widgets.set(WidgetEnum$1.VKG_PREFERENCES, vkgPreferences);
    (_b = (_a = incrementalController.grapholscape.uiContainer) === null || _a === void 0 ? void 0 : _a.querySelector('.gscape-ui-buttons-tray')) === null || _b === void 0 ? void 0 : _b.appendChild(vkgPreferences);
    if (incrementalController.grapholscape.renderState !== RendererStatesEnum.INCREMENTAL || !incrementalController.endpointController)
        vkgPreferences.disable();
    if (incrementalController.endpointController) {
        // Starting data
        setEndpointList();
    }
    incrementalController.on(IncrementalEvent.EndpointChange, newEndpoint => {
        vkgPreferences.selectedEndpointName = newEndpoint.name;
    });
    incrementalController.on(IncrementalEvent.LimitChange, limit => {
        vkgPreferences.pageSize = limit;
    });
    incrementalController.on(IncrementalEvent.ReasonerSet, () => {
        if (incrementalController.grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
            vkgPreferences.enable();
        }
        setEndpointList();
        if (incrementalController.endpointController)
            vkgPreferences.pageSize = incrementalController.endpointController.pageSize;
    });
    vkgPreferences.onTogglePanel = () => setEndpointList();
    vkgPreferences.onEndpointChange(newEndpointName => {
        if (incrementalController.grapholscape.uiContainer) {
            showMessage(`Are you sure? \nIf you change the current endpoint, your exploration will be reset.`, 'Confirm', incrementalController.grapholscape.uiContainer).onConfirm(() => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                incrementalController.reset();
                (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.setEndpoint(newEndpointName);
                (_b = incrementalController.endpointController) === null || _b === void 0 ? void 0 : _b.setLanguage(incrementalController.grapholscape.language);
            }));
        }
    });
    vkgPreferences.onPageSizeChange(limit => {
        var _a;
        (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.setPageSize(limit);
    });
    vkgPreferences.onShowCountersChange(state => {
        incrementalController.countersEnabled = state;
    });
    vkgPreferences.onStopRequests(() => { var _a; return (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.stopRequests(); });
    function setEndpointList() {
        var _a;
        (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.getRunningEndpoints().then(endpoints => {
            var _a, _b;
            vkgPreferences.endpoints = endpoints.map(e => {
                return {
                    name: e.name
                };
            }).sort((a, b) => a.name.localeCompare(b.name));
            if (endpoints.length >= 1 && !vkgPreferences.selectedEndpointName) {
                (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.setEndpoint(endpoints[0]);
                (_b = incrementalController.endpointController) === null || _b === void 0 ? void 0 : _b.setLanguage(incrementalController.grapholscape.language);
            }
        });
    }
    return vkgPreferences;
}

function onHideMenu (menu, incrementalController) {
    var _a, _b;
    (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.stopRequests('instances');
    if (menu.referenceEntity && menu.referenceEntityType) {
        const refNodeId = incrementalController.getIDByIRI(menu.referenceEntity.value.iri.fullIri, menu.referenceEntityType);
        if (!refNodeId)
            return;
        const refNode = (_b = incrementalController
            .diagram
            .representation) === null || _b === void 0 ? void 0 : _b.cy.$id(refNodeId);
        if (refNode === null || refNode === void 0 ? void 0 : refNode.scratch('should-unpin')) {
            refNode.removeScratch('should-unpin');
            incrementalController.unpinNode(refNode);
        }
    }
}

var menuBaseStyle = i$1 `
:host {
  min-width: 300px;
  max-height: 600px;
  display: block;
}

.gscape-panel {
  min-width: inherit;
  max-width: inherit;
  min-height: inherit;
  max-height: inherit;
  width: inherit;
  height: inherit;
  display: flex;
  gap: 16px;
  flex-direction: column;
  overflow: unset;
  padding-right: 0;
  padding-left: 0;
}

.header {
  width: fit-content;
  margin: 0 auto;
}

gscape-entity-list-item {
  --custom-min-height: 26.5px;
}

.hover-btn {
  display: none;
}

gscape-entity-list-item:hover > .hover-btn {
  display: initial;
}

.entity-list {
  min-height: 0;
  overflow: auto;
  display: flex;
  flex-direction: column;
}

.gscape-panel > * {
  padding: 0 8px;
}

.section {
  overflow: auto;
}

`;

class GscapeInstanceExplorer extends ContextualWidgetMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        this.instances = new Map();
        this.propertiesFilterList = [];
        this.isPropertyDirect = true;
        this.numberOfPagesShown = 1;
        this.numberResultsAvailable = 0;
        /**
         * Not all received instances are shown, no duplicates allowed.
         * i.e. different results for different labels but same instance.
         */
        this.numberOfInstancesReceived = 0;
        this.explanation = `
  Number of available results: it's the maximum number of results you can see in the list below. \n\
  It can be lower than the total number of possible results due to manual filters or due to
  labels, if labels are available, we will show you results with label.
  You can find instances without a label by manually searching selecting the ID filter option.
  `;
        this.lastSearchedText = '';
        this.cxtWidgetProps.placement = 'right';
        this.tippyWidget.setProps({ maxWidth: '' });
    }
    render() {
        var _a, _b, _c, _d, _e, _f;
        return x `
      <div class="gscape-panel">
        <div class="header">
          
          <gscape-entity-list-item
            displayedname=${(_a = this.referenceEntity) === null || _a === void 0 ? void 0 : _a.displayedName}
            iri=${(_b = this.referenceEntity) === null || _b === void 0 ? void 0 : _b.value.iri.fullIri}
            .types=${(_c = this.referenceEntity) === null || _c === void 0 ? void 0 : _c.value.types}
          ></gscape-entity-list-item>

          ${this.referencePropertyEntity
            ? x `
              <gscape-entity-list-item
                displayedname=${(_d = this.referencePropertyEntity) === null || _d === void 0 ? void 0 : _d.displayedName}
                iri=${(_e = this.referencePropertyEntity) === null || _e === void 0 ? void 0 : _e.value.iri.fullIri}
                .types=${(_f = this.referencePropertyEntity) === null || _f === void 0 ? void 0 : _f.value.types}
              >
                ${!this.isPropertyDirect
                ? x `
                    <span slot="trailing-element" class="chip" style="line-height: 1">Inverse</span>
                  `
                : null}
              </gscape-entity-list-item>
            `
            : null}
        </div>
        <div class="search-box">
          ${this.classTypeFilterList && this.classTypeFilterList.length > 0
            ? this.classTypeFilterList.length > 1
                ? x `
                <gscape-select
                  style="align-self: center"
                  id="classtype-filter-select"
                  size=${SizeEnum$1.S}
                  .options=${this.classTypeFilterList.map(entity => {
                    return {
                        id: entity.entityViewData.value.iri.fullIri,
                        text: entity.entityViewData.displayedName,
                        leadingIcon: entityIcons[Array.from(entity.entityViewData.value.types)[0]],
                        disabled: !entity.hasUnfolding
                    };
                })}
                  .placeholder=${{ text: 'Filter by type' }}
                  ?multiple-selection=${true}
                  ?clearable=${true}
                  @change=${this.handleClassTypeFilterChange}
                >
              `
                : x `
                <gscape-entity-list-item
                  displayedname=${this.classTypeFilterList[0].entityViewData.displayedName}
                  iri=${this.classTypeFilterList[0].entityViewData.value.iri.fullIri}
                  .types=${this.classTypeFilterList[0].entityViewData.value.types}
                ></gscape-entity-list-item>
              `
            : null}

          ${this.propertiesFilterList
            ? x `
              <gscape-select
                id="property-filter-select"
                size=${SizeEnum$1.S}
                .options=${[
                {
                    id: 'label',
                    text: 'Label',
                    disabled: this.shouldAskForLabels === false,
                    leadingIcon: undefined,
                },
                {
                    id: 'id',
                    text: 'ID',
                    disabled: false,
                    leadingIcon: undefined,
                },
            ].concat(this.propertiesFilterList.map(entity => {
                return {
                    id: entity.entityViewData.value.iri.fullIri,
                    text: entity.entityViewData.displayedName,
                    leadingIcon: entityIcons[Array.from(entity.entityViewData.value.types)[0]],
                    disabled: !entity.hasUnfolding
                };
            }))}
                default-option=${this.shouldAskForLabels !== false ? 'label' : 'id'}
                ?clearable=${false}
                @change=${this.handleFilterChange}
              >
            `
            : null}
          <input id="instances-search" @keyup=${this.handleInputKeypress} type="text" placeholder="Filter instances" />
          <gscape-button
            title="Search"
            @click=${this.handleFilter}
          >
            ${getIconSlot$1('icon', search$1)}
          </gscape-button>
        </div>

        ${this.numberResultsAvailable
            ? x `
            <div style="align-self: center; display: flex; align-items: center; gap: 8px">
              <span class="chip-neutral">
                ${this.numberOfInstancesReceived}/${this.numberResultsAvailable}
              </span>
              <span class="tip" style="width: 12px; text-align: center" title=${this.explanation}>?</span>
            </div>
          `
            : null}

        <div class="entity-list">
        ${this.instances.size > 0
            ? x `
            ${Array.from(this.instances).map(([_, instance]) => {
                var _a;
                let displayedName = ((_a = instance.label) === null || _a === void 0 ? void 0 : _a.value) || instance.shortIri || instance.iri;
                let searchMatch;
                if (instance.searchMatch && instance.searchMatch.toLowerCase() !== displayedName.toLowerCase()) {
                    searchMatch = this.getHighlightInSearchMatch(instance.searchMatch);
                }
                return x `
                <gscape-entity-list-item
                  displayedname=${displayedName}
                  iri=${instance.connectedInstance ? `${instance.iri}-${instance.connectedInstance.iri}` : instance.iri}
                  .types=${new Set([TypesEnum.CLASS_INSTANCE])}
                >
                  <div slot="trailing-element" class="hover-btn">
                    <gscape-button
                      size="s"
                      type="subtle"
                      @click=${this.handleInsertInGraph}
                    >
                      ${getIconSlot$1('icon', insertInGraph)}
                    </gscape-button>
                  </div>
                  ${searchMatch
                    ? x `
                      <div slot="subrow-item" class="search-match muted-text">${searchMatch.preString ? x `<span>${searchMatch.preString}</span>` : A}${searchMatch.highlightString ? x `<span class="highlight">${searchMatch.highlightString}</span>` : A}${searchMatch.postString ? x `<span>${searchMatch.postString}</span>` : A}</div>
                    `
                    : null}
                </gscape-entity-list-item>
              `;
            })}
          `
            : !this.areInstancesLoading ? x `
              <div class="blank-slate">
                ${searchOff}
                <div class="header">No Instances Available</div>
              </div>
            `
                : null}

        ${this.areInstancesLoading
            ? x `<div id="loading-content-spinner">${getContentSpinner()}</div>`
            : this.canShowMore
                ? x `
              <gscape-button id="show-more-btn" size="s" label="Show More" type="subtle" @click=${this.handleShowMore}></gscape-button>
            `
                : this.numberOfPagesShown > 1 ? x `<span style="align-self: center; margin: 8px 8px 16px" class="bold-text muted-text">No more data</span>` : null}
        </div>
      </div>
    `;
    }
    handleFilter(e) {
        var _a;
        const inputElement = this.instancesSearchInput;
        if (!inputElement)
            return;
        const event = new CustomEvent('instances-filter', {
            bubbles: true,
            composed: true,
            detail: {
                filterText: inputElement.value.length > 0 ? inputElement.value : undefined,
                filterByProperty: undefined,
                filterByType: undefined,
            }
        });
        if (this.propertyFilterSelect) {
            const selectedOption = Array.from(this.propertyFilterSelect.selectedOptionsId)[0];
            if (selectedOption && selectedOption !== 'id' && selectedOption !== 'label' && event.detail.filterText) {
                event.detail.filterByProperty = selectedOption;
                const property = this.propertiesFilterList.find(p => {
                    var _a;
                    return ((_a = this.propertyFilterSelect) === null || _a === void 0 ? void 0 : _a.selectedOptionsId) &&
                        p.entityViewData.value.iri.equals(selectedOption);
                });
                if (property) {
                    event.detail.propertyType = Array.from(property.entityViewData.value.types)[0];
                    if (property.entityViewData.value.types.has(TypesEnum.OBJECT_PROPERTY)) {
                        event.detail.direct = property.direct;
                    }
                }
            }
            if (this.shouldAskForLabels !== undefined)
                event.detail.shouldAskForLabels = this.shouldAskForLabels && selectedOption !== 'id';
            if (selectedOption === 'id') {
                event.detail.shouldAskForLabels = false;
            }
        }
        // if only one class type, then use it, there is not select element
        if (((_a = this.classTypeFilterList) === null || _a === void 0 ? void 0 : _a.length) === 1) {
            event.detail.filterByType = [this.classTypeFilterList[0].entityViewData.value.iri.fullIri];
        }
        else if (this.classTypeFilterSelect && this.classTypeFilterSelect.selectedOptionsId.size > 0) { // otherwise check selected option
            event.detail.filterByType = Array.from(this.classTypeFilterSelect.selectedOptionsId);
        }
        this.lastSearchedText = event.detail.filterText || '';
        this.numberOfPagesShown = 1;
        this.dispatchEvent(event);
    }
    handleInputKeypress(e) {
        const inputElement = e.target;
        // on ESC key press
        if (e.key === 'Escape') {
            inputElement.blur();
            inputElement.value = '';
        }
        clearTimeout(this.searchTimeout);
        this.searchTimeout = setTimeout(() => {
            this.handleFilter();
        }, 500);
    }
    handleFilterChange() {
        var _a, _b;
        (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#instances-search')) === null || _b === void 0 ? void 0 : _b.focus();
    }
    handleClassTypeFilterChange(e) {
        var _a;
        if (!((_a = this.classTypeFilterSelect) === null || _a === void 0 ? void 0 : _a.selectedOptionsId)) {
            this.propertiesFilterList = [];
        }
        this.handleFilter(e);
    }
    handleInsertInGraph(e) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            const targetListItem = (_a = e.currentTarget.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
            if (targetListItem) {
                const instance = this.instances.get(targetListItem.iri);
                if (instance) {
                    let parentClassIris;
                    if ((_b = this.referenceEntity) === null || _b === void 0 ? void 0 : _b.value.types.has(TypesEnum.CLASS)) { // if class, take class iri as parent
                        parentClassIris = (_c = this.referenceEntity) === null || _c === void 0 ? void 0 : _c.value.iri.fullIri;
                    }
                    else if ((_d = this.referenceEntity) === null || _d === void 0 ? void 0 : _d.value.types.has(TypesEnum.CLASS_INSTANCE)) { // otherwise check selected filter type
                        if (((_e = this.classTypeFilterList) === null || _e === void 0 ? void 0 : _e.length) === 1) {
                            parentClassIris = this.classTypeFilterList[0].entityViewData.value.iri.fullIri; // if only one type, take it as parent class
                        }
                        else if ((_f = this.classTypeFilterSelect) === null || _f === void 0 ? void 0 : _f.selectedOptionsId) {
                            parentClassIris = Array.from(this.classTypeFilterSelect.selectedOptionsId); // otherwise take the selected one
                        }
                        else if (this.classTypeFilterList) {
                            parentClassIris = this.classTypeFilterList.map(e => e.entityViewData.value.iri.fullIri); // if no option is selected, take them all, instance checking will decide
                        }
                        else
                            return;
                    }
                    else {
                        return;
                    }
                    let filterByPropertyIri;
                    if (this.propertyFilterSelect) {
                        const selectedOption = Array.from(this.propertyFilterSelect.selectedOptionsId)[0];
                        if (selectedOption && selectedOption !== 'id' && selectedOption !== 'label' && ((_g = this.instancesSearchInput) === null || _g === void 0 ? void 0 : _g.value))
                            filterByPropertyIri = selectedOption;
                    }
                    this.requestUpdate();
                    yield this.updateComplete;
                    this.dispatchEvent(new CustomEvent('instanceselection', {
                        bubbles: true,
                        composed: true,
                        detail: {
                            parentClassIris: parentClassIris,
                            instance: instance,
                            filterByProperty: filterByPropertyIri,
                        }
                    }));
                }
            }
        });
    }
    handleShowMore(e) {
        this.dispatchEvent(new CustomEvent('showmoreinstances', {
            bubbles: true,
            composed: true
        }));
        this.numberOfPagesShown += 1;
    }
    addInstances(newInstances) {
        this.numberOfInstancesReceived += newInstances.length;
        newInstances.forEach(i => {
            const instanceKey = i.connectedInstance ? `${i.iri}-${i.connectedInstance.iri}` : i.iri;
            if (!this.instances.has(instanceKey)) {
                this.instances.set(instanceKey, i);
            }
        });
        this.requestUpdate();
    }
    clear() {
        var _a, _b;
        this.instances = new Map();
        this.numberOfPagesShown = 1;
        this.numberOfInstancesReceived = 0;
        this.areInstancesLoading = false;
        this.propertiesFilterList = [];
        (_a = this.propertyFilterSelect) === null || _a === void 0 ? void 0 : _a.clear();
        this.classTypeFilterList = [];
        (_b = this.classTypeFilterSelect) === null || _b === void 0 ? void 0 : _b.clear();
        this.referenceEntity = undefined;
        this.referenceEntityType = undefined;
        this.referencePropertyEntity = undefined;
        this.popperRef = undefined;
        this.shouldAskForLabels = undefined;
        this.numberResultsAvailable = 0;
        this.lastSearchedText = '';
        if (this.instancesSearchInput)
            this.instancesSearchInput.value = '';
    }
    updated() {
        if (this.popperRef)
            this.attachTo(this.popperRef);
    }
    attachTo(element) {
        this.popperRef = element;
        super.attachTo(element);
    }
    getHighlightInSearchMatch(searchMatch) {
        if (this.lastSearchedText.length > 0 && this.lastSearchedText !== ' ') {
            const startMatchIndex = searchMatch.toLowerCase().search(this.lastSearchedText.toLowerCase());
            if (startMatchIndex >= 0) {
                const endMatchIndex = startMatchIndex + this.lastSearchedText.length - 1;
                return {
                    preString: searchMatch.substring(0, startMatchIndex),
                    highlightString: searchMatch.substring(startMatchIndex, endMatchIndex + 1),
                    postString: searchMatch.substring(endMatchIndex + 1, searchMatch.length),
                };
            }
        }
        return {
            preString: searchMatch,
            highlightString: undefined,
            postString: undefined,
        };
    }
    get canShowMore() {
        if (!this.numberResultsAvailable)
            return this.numberOfInstancesReceived > 0;
        return this.numberOfInstancesReceived < this.numberResultsAvailable;
    }
    get propertyFilterSelect() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#property-filter-select'); }
    get classTypeFilterSelect() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#classtype-filter-select'); }
    get instancesSearchInput() { var _a; return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#instances-search'); }
    hide() {
        this.style.display = 'none';
    }
}
GscapeInstanceExplorer.properties = {
    areInstancesLoading: { type: Boolean },
    instances: { type: Object },
    referenceEntity: { type: Object },
    searchFilterList: { type: Object },
    referencePropertyEntity: { type: Object },
    classTypeFilterList: { type: Object },
    canShowMore: { type: Boolean },
    lastSearchedText: { type: String, state: true }
};
GscapeInstanceExplorer.styles = [
    baseStyle$3,
    menuBaseStyle,
    contentSpinnerStyle,
    textSpinnerStyle,
    i$1 `
      :host {
        min-height: 450px;
      }

      .search-box, .header {
        display: flex;
        align-items: center;
        gap: 8px;
      }
    
      .search-box > select {
        max-width: 30%;
        padding: 8px;
        border-bottom-right-radius: 0;
        border-top-right-radius: 0;
        border-right: none;
        min-width: 100px;
      }
    
      .search-box > input {
        flex-shrink: 0;
        min-width: 0px;
        flex-grow: 2;
      }

      gscape-select {
        max-width: 180px;
      }

      #show-more-btn, #loading-content-spinner {
        align-self: center;
        margin: 8px;
      }

      #loading-content-spinner {
        position: relative;
      }

      .search-match {
        background: var(--gscape-color-bg-inset);
        border-radius: var(--gscape-border-radius);
        padding: 4px 8px;
        font-size: 90%;
        width: fit-content;
      }

      .search-match > .highlight {
        background: var(--gscape-color-accent-muted);
        padding: 0 1px;
      }
    `
];
customElements.define('gscape-instances-explorer', GscapeInstanceExplorer);

function InstanceExplorerFactory(incrementalController) {
    const instancesExplorer = new GscapeInstanceExplorer();
    incrementalController.grapholscape.widgets.set(WidgetEnum$1.INSTANCES_EXPLORER, instancesExplorer);
    incrementalController.on(IncrementalEvent.NewInstances, (newInstances, numberResultsAvailable) => {
        instancesExplorer.addInstances(newInstances.map(i => {
            var _a;
            if (i[1]) {
                i[0].searchMatch = (_a = i[1].label) === null || _a === void 0 ? void 0 : _a.value;
            }
            i[0].connectedInstance = i[1];
            return i[0];
        }));
        if (!instancesExplorer.numberResultsAvailable && numberResultsAvailable)
            instancesExplorer.numberResultsAvailable = numberResultsAvailable;
    });
    incrementalController.on(IncrementalEvent.InstancesSearchFinished, () => instancesExplorer.areInstancesLoading = false);
    incrementalController.on(IncrementalEvent.Reset, () => {
        instancesExplorer.clear();
    });
    instancesExplorer.addEventListener('instanceselection', (e) => __awaiter(this, void 0, void 0, function* () {
        incrementalController.performActionWithBlockedGraph(() => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            let addedInstanceEntity;
            let refNodeId;
            let refPosition;
            if (instancesExplorer.referenceEntity && instancesExplorer.referenceEntityType) {
                refNodeId = incrementalController.getIDByIRI(instancesExplorer.referenceEntity.value.iri.fullIri, instancesExplorer.referenceEntityType);
                if (refNodeId) {
                    refPosition = (_a = incrementalController.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(refNodeId).position();
                }
            }
            addedInstanceEntity = incrementalController.addInstance(e.detail.instance, e.detail.parentClassIris, refPosition);
            const sourceId = incrementalController.getIDByIRI(e.detail.instance.iri, TypesEnum.CLASS_INSTANCE);
            if (!sourceId)
                return;
            addedInstanceEntity.parentClassIris.forEach(parentClassIri => {
                const targetId = incrementalController.getIDByIRI(parentClassIri.fullIri, TypesEnum.CLASS);
                if (targetId) {
                    incrementalController.addEdge(sourceId, targetId, TypesEnum.INSTANCE_OF);
                }
            });
            if (e.detail.instance.connectedInstance && e.detail.filterByProperty) {
                incrementalController.addInstance(e.detail.instance.connectedInstance, undefined, refPosition);
                const isDirect = (_e = (_d = (yield ((_c = (_b = incrementalController.endpointController) === null || _b === void 0 ? void 0 : _b.highlightsManager) === null || _c === void 0 ? void 0 : _c.objectProperties()))) === null || _d === void 0 ? void 0 : _d.find(ops => ops.objectPropertyIRI === e.detail.filterByProperty)) === null || _e === void 0 ? void 0 : _e.direct;
                if (isDirect !== undefined) {
                    isDirect
                        ? incrementalController.addExtensionalObjectProperty(e.detail.filterByProperty, e.detail.instance.iri, e.detail.instance.connectedInstance.iri)
                        : incrementalController.addExtensionalObjectProperty(e.detail.filterByProperty, e.detail.instance.connectedInstance.iri, e.detail.instance.iri);
                }
            }
            if (instancesExplorer.referenceEntity && instancesExplorer.referencePropertyEntity && addedInstanceEntity) { // add object property between instances
                const sourceInstanceIri = instancesExplorer.referenceEntity.value.iri.fullIri;
                const objPropertyIri = instancesExplorer.referencePropertyEntity.value.iri.fullIri;
                if (instancesExplorer.isPropertyDirect)
                    incrementalController.addExtensionalObjectProperty(objPropertyIri, sourceInstanceIri, addedInstanceEntity.iri.fullIri);
                else
                    incrementalController.addExtensionalObjectProperty(objPropertyIri, addedInstanceEntity.iri.fullIri, sourceInstanceIri);
            }
        }));
    }));
    instancesExplorer.addEventListener('instances-filter', (e) => __awaiter(this, void 0, void 0, function* () {
        var _f, _g, _h, _j;
        (_f = incrementalController.endpointController) === null || _f === void 0 ? void 0 : _f.stopRequests('instances');
        instancesExplorer.instances = new Map();
        instancesExplorer.numberOfInstancesReceived = 0;
        instancesExplorer.numberResultsAvailable = 0;
        instancesExplorer.numberOfPagesShown = 1;
        instancesExplorer.areInstancesLoading = true;
        if (instancesExplorer.referenceEntity) {
            if (instancesExplorer.referenceEntity.value.types.has(TypesEnum.CLASS)) {
                instancesExplorer.requestId = yield ((_g = incrementalController.endpointController) === null || _g === void 0 ? void 0 : _g.requestInstancesForClass((_h = instancesExplorer.referenceEntity) === null || _h === void 0 ? void 0 : _h.value.iri.fullIri, e.detail.shouldAskForLabels, e.detail.filterText, e.detail.filterByProperty, e.detail.propertyType, e.detail.direct));
            }
            else if (instancesExplorer.referenceEntity.value.types.has(TypesEnum.CLASS_INSTANCE) && instancesExplorer.referencePropertyEntity) {
                // if (e.detail.filterByType) {
                //   instancesExplorer.propertiesFilterList = (await incrementalController.getDataPropertiesByClasses([e.detail.filterByType]))
                //     .map(dp => getEntityViewDataIncremental(dp, incrementalController))
                // }
                instancesExplorer.requestId = yield ((_j = incrementalController.endpointController) === null || _j === void 0 ? void 0 : _j.requestInstancesThroughObjectProperty(instancesExplorer.referenceEntity.value.iri.fullIri, instancesExplorer.referencePropertyEntity.value.iri.fullIri, instancesExplorer.isPropertyDirect, e.detail.shouldAskForLabels, e.detail.filterByType, e.detail.filterByProperty, e.detail.filterText));
            }
        }
    }));
    instancesExplorer.addEventListener('showmoreinstances', (e) => __awaiter(this, void 0, void 0, function* () {
        var _k, _l;
        (_k = incrementalController.endpointController) === null || _k === void 0 ? void 0 : _k.stopRequests('instances');
        instancesExplorer.areInstancesLoading = true;
        if (instancesExplorer.requestId) {
            (_l = incrementalController.endpointController) === null || _l === void 0 ? void 0 : _l.requestNewInstances(instancesExplorer.requestId, instancesExplorer.numberOfPagesShown + 1);
        }
    }));
    instancesExplorer.tippyWidget.setProps({
        onHide: () => {
            instancesExplorer.hide();
            onHideMenu(instancesExplorer, incrementalController);
        }
    });
    return instancesExplorer;
}

const edgeHandlesOptions = {
    canConnect: function (sourceNode, targetNode) {
        const sourceType = sourceNode.data('type');
        const targetType = targetNode.data('type');
        const isTypeValid = (type) => type === TypesEnum.CLASS || type === TypesEnum.CLASS_INSTANCE;
        return sourceNode !== targetNode && isTypeValid(sourceType) && isTypeValid(targetType);
    },
    edgeParams: function (sourceNode, targetNode) {
        // for edges between the specified source and target
        // return element object to be passed to cy.add() for edge
        return {
            data: {
                source: sourceNode.id(),
                targetNode: targetNode.id(),
            },
            classes: 'loading-edge'
        };
    },
    hoverDelay: 150,
    snap: true,
    snapThreshold: 50,
    snapFrequency: 15,
    noEdgeEventsInDraw: true,
    disableBrowserGestures: true // during an edge drawing gesture, disable browser gestures such as two-finger trackpad swipe and pinch-to-zoom
};

class GscapePathSelector extends ModalMixin$3(BaseMixin$3(s)) {
    constructor(theme) {
        super();
        this.theme = theme;
        this._paths = [];
        this.selectedPathID = 0;
        this.canShowMore = false;
        this.cy = cytoscape();
        this.getDisplayedName = (entity) => entity.iri;
    }
    render() {
        return x `
      <div class="gscape-panel">
        <div class="header">Select a path over the ontology</div>
      
        <!-- <div class="path-list">
                      ${this.paths.map((path, i) => {
            var _a;
            return x `
                          <div id=${i} class="path actionable" ?selected=${this.selectedPathID === i} @click=${this.handlePathClick}>
                            ${i === 0
                ? x `
                                <span class="chip">
                                  Shortest
                                </span>
                              `
                : null}
                            
                            ${(_a = path.entities) === null || _a === void 0 ? void 0 : _a.map((entity) => {
                var _a;
                let types = new Set();
                let displayedName;
                if (entity.type === EntityTypeEnum.ObjectProperty ||
                    entity.type === EntityTypeEnum.InverseObjectProperty) {
                    if (!((_a = entity.iri) === null || _a === void 0 ? void 0 : _a.endsWith('subClassOf'))) {
                        types.add(TypesEnum.OBJECT_PROPERTY);
                    }
                    else {
                        displayedName = 'subClassOf';
                    }
                }
                if (entity.type === EntityTypeEnum.Class) {
                    types.add(TypesEnum.CLASS);
                }
                return x `
                                <gscape-entity-list-item
                                  displayedName=${displayedName || this.getDisplayedName(entity)}
                                  iri=${entity.iri}
                                  .types=${types}
            
                                >
                                </gscape-entity-list-item>
                              `;
            })}
                          </div>
                        `;
        })}
                    </div> -->
      
        <div id="cy"></div>
      
        ${this.canShowMore
            ? x `
        <center>
          <gscape-button label="Show More" type="subtle" size=${SizeEnum$1.S} @click=${this.handleShowMoreClick}>
          </gscape-button>
        </center>
        `
            : null}
      
        <div class="buttons">
          <gscape-button label="Cancel" type="subtle" @click=${this.handleCancel}></gscape-button>
          <gscape-button label="Ok" @click=${this.handleConfirm}></gscape-button>
        </div>
      </div>
    `;
    }
    setTheme(theme) {
        var _a;
        const style = incrementalStyle(theme);
        style.push(...[
            {
                selector: 'node',
                style: {
                    shape: 'round-rectangle',
                    width: 100,
                    height: 35,
                }
            },
            {
                selector: 'edge',
                style: {
                    'curve-style': 'unbundled-bezier',
                    "control-point-distances": (elem) => this.getEdgePointDistances(elem),
                    "control-point-weights": (elem) => this.getEdgePointWeights(elem),
                    // 'source-endpoint': ['50%', 0],
                    // 'target-endpoint': ['-50%', 0],
                }
            },
            {
                selector: `[?inverseEdge]`,
                style: {
                    'source-arrow-shape': 'triangle',
                    'source-arrow-fill': 'filled',
                }
            },
            {
                selector: `[?inverseEdge][type = "${TypesEnum.INCLUSION}"]`,
                style: {
                    'target-arrow-shape': 'none',
                }
            },
            {
                selector: `[?inverseEdge][type = "${TypesEnum.OBJECT_PROPERTY}"]`,
                style: {
                    'target-arrow-shape': 'square',
                    'target-arrow-fill': 'hollow',
                }
            },
            {
                selector: `.dimmed`,
                style: {
                    'opacity': 0.4,
                }
            },
            {
                selector: `.highlighted`,
                style: {
                    'underlay-opacity': '1',
                    'underlay-color': theme.getColour(ColoursNames.neutral_muted),
                    'opacity': 1,
                }
            },
            {
                selector: `edge.selected`,
                style: {
                    'width': 4,
                }
            },
            {
                selector: `.selected`,
                style: {
                    'border-color': theme.getColour(ColoursNames.accent),
                    'border-width': 4,
                    'line-color': theme.getColour(ColoursNames.accent),
                    'target-arrow-color': theme.getColour(ColoursNames.accent),
                    'source-arrow-color': theme.getColour(ColoursNames.accent),
                    'z-index': 10,
                }
            }
        ]);
        ((_a = this.cy) === null || _a === void 0 ? void 0 : _a.style()).fromJson(style).update();
    }
    getEdgePointDistances(elem) {
        let result;
        const sourcePos = elem.source().position();
        const targetPos = elem.target().position();
        const xDiff = Math.abs(sourcePos.x - targetPos.x);
        let yDiff = sourcePos.y - targetPos.y;
        const isSourceAbove = yDiff < 0;
        yDiff = Math.abs(yDiff);
        if (xDiff < Math.abs(yDiff)) {
            result = xDiff;
        }
        else {
            result = yDiff;
        }
        result = result / 4;
        return isSourceAbove ? [-result, result] : [result, -result];
    }
    getEdgePointWeights(edge) {
        var _a;
        // if last edge in path and path is shorter than the longest one, we must move
        // control points towards the sink node to avoid cluttering diagram
        if (edge.target().degree(false) === 1) {
            Math.max(...this._paths.map(path => { var _a; return ((_a = path.entities) === null || _a === void 0 ? void 0 : _a.length) || 0; }));
            ((_a = this._paths[edge.data().pathId].entities) === null || _a === void 0 ? void 0 : _a.length) || 0;
        }
        return [0.25, 0.75];
    }
    handlePathClick(e) {
        var _a;
        const id = (_a = e.currentTarget) === null || _a === void 0 ? void 0 : _a.getAttribute('id');
        if (id) {
            this.selectedPathID = parseInt(id);
        }
    }
    handleShowMoreClick(e) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateComplete;
            this.dispatchEvent(new CustomEvent('show-more-paths', {
                bubbles: true,
                composed: true,
            }));
        });
    }
    handleConfirm() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateComplete;
            this.dispatchEvent(new CustomEvent('path-selection', {
                bubbles: true,
                composed: true,
                detail: this.selectedPath
            }));
            this.remove();
        });
    }
    handleCancel() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateComplete;
            this.dispatchEvent(new CustomEvent('cancel', {
                bubbles: true,
                composed: true
            }));
            this.remove();
        });
    }
    get selectedPath() {
        return this.paths[this.selectedPathID];
    }
    get paths() {
        return this._paths;
    }
    set paths(newPaths) {
        this.cyInit();
        if (!this.cy || newPaths.length <= 0 || !newPaths[0].entities)
            return;
        const oldValue = this._paths;
        this._paths = newPaths;
        const sourceNodeCy = this.cy.add(this.getEntityCyRepr(newPaths[0].entities[0], -1));
        const sinkNodeCy = this.cy.add(this.getEntityCyRepr(newPaths[0].entities[newPaths[0].entities.length - 1], -1));
        for (let [pathId, path] of newPaths.entries()) {
            if (path.entities) {
                let edge, previousClassCy, successorClassCy;
                for (let [i, entity] of path.entities.entries()) {
                    if (entity.type === EntityTypeEnum.ObjectProperty || entity.type === EntityTypeEnum.InverseObjectProperty) {
                        let previousClass = path.entities[i - 1];
                        let successorClass = path.entities[i + 1];
                        if (previousClass && successorClass) {
                            /**
                             * If i === 1 then previous class is sourceNode
                             * if i === length - 1 then successor class is sinkNode
                             *
                             * In all other cases check if there's already the class node
                             * for the current path, each path must have its own classes,
                             * so the can be replicated.
                             */
                            if (i === 1) {
                                previousClassCy = sourceNodeCy;
                            }
                            else {
                                previousClassCy = this.cy.$(`[iri = "${previousClass.iri}"][type = "${EntityTypeEnum.Class}"][pathId = ${pathId}]`).first();
                                if (previousClassCy.empty()) {
                                    previousClassCy = this.cy.add(this.getEntityCyRepr(previousClass, pathId));
                                }
                            }
                            if (i === path.entities.length - 2) {
                                successorClassCy = sinkNodeCy;
                            }
                            else {
                                successorClassCy = this.cy.$(`[iri = "${successorClass.iri}"][type = "${EntityTypeEnum.Class}"][pathId = ${pathId}]`).first();
                                if (successorClassCy.empty()) {
                                    successorClassCy = this.cy.add(this.getEntityCyRepr(successorClass, pathId));
                                }
                            }
                            if (previousClassCy.empty() || successorClassCy.empty()) {
                                break;
                            }
                            edge = this.getEntityCyRepr(entity, pathId);
                            edge.data.source = previousClassCy.id();
                            edge.data.target = successorClassCy.id();
                            this.cy.add(edge);
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        }
        this.cy.layout({
            name: 'klay',
            klay: {
                spacing: 80,
                fixedAlignment: 'BALANCED',
            },
            padding: 30,
            // some more options here...
        }).run();
        this.cy.fit();
        this.selectPath(0);
        this.requestUpdate('paths', oldValue);
    }
    getEntityCyRepr(entity, pathId) {
        var _a;
        let type;
        switch (entity.type) {
            case EntityTypeEnum.Class:
                type = TypesEnum.CLASS;
                break;
            case EntityTypeEnum.InverseObjectProperty:
            case EntityTypeEnum.ObjectProperty:
                type = ((_a = entity.iri) === null || _a === void 0 ? void 0 : _a.endsWith('subClassOf')) ? TypesEnum.INCLUSION : TypesEnum.OBJECT_PROPERTY;
                break;
            default:
                type = TypesEnum.CLASS;
        }
        return {
            data: {
                displayedName: this.getDisplayedName(entity),
                type: type,
                iri: entity.iri,
                pathId: pathId,
                inverseEdge: entity.type === EntityTypeEnum.InverseObjectProperty
            }
        };
    }
    cyInit() {
        var _a;
        this.cy = cytoscape({
            container: (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#cy'),
            autounselectify: true,
            autoungrabify: true,
            wheelSensitivity: 0.2,
        });
        this.setTheme(this.theme);
        this.fixHover();
        this.cy.on('mouseover', '*', (evt) => {
            var _a;
            const pathId = evt.target.data().pathId;
            if (pathId !== undefined) {
                this.highlightPath(pathId);
                const container = (_a = this.cy) === null || _a === void 0 ? void 0 : _a.container();
                if (container)
                    container.style.cursor = 'pointer';
            }
        });
        this.cy.on('tap', (evt) => {
            if (evt.target === this.cy) {
                this.paths.forEach((path, i) => {
                    this.deHighlightPath(i);
                });
            }
            else {
                const pathId = evt.target.data().pathId;
                if (pathId !== undefined) {
                    this.selectPath(pathId);
                }
            }
            this.fixHover();
        });
        this.cy.on('dbltap', (evt) => {
            var _a;
            if (evt.target === this.cy)
                (_a = this.cy) === null || _a === void 0 ? void 0 : _a.fit();
            this.fixHover();
        });
        this.cy.on('mouseout', '*', (evt) => {
            var _a;
            const pathId = evt.target.data().pathId;
            if (pathId !== undefined) {
                this.deHighlightPath(pathId);
                const container = (_a = this.cy) === null || _a === void 0 ? void 0 : _a.container();
                if (container)
                    container.style.cursor = 'initial';
            }
        });
    }
    highlightPath(pathId) {
        var _a;
        if (pathId !== -1) // -1 is for source and sink nodes, common to every path
            (_a = this.cy) === null || _a === void 0 ? void 0 : _a.$(`[pathId = ${pathId}]`).addClass('highlighted');
    }
    deHighlightPath(pathId) {
        var _a;
        if (pathId !== -1) // -1 is for source and sink nodes, common to every path
            (_a = this.cy) === null || _a === void 0 ? void 0 : _a.$(`[pathId = ${pathId}]`).removeClass('highlighted');
    }
    selectPath(pathId) {
        var _a, _b, _c, _d, _e;
        if (pathId !== -1) {
            (_a = this.cy) === null || _a === void 0 ? void 0 : _a.elements().removeClass('selected dimmed');
            (_b = this.cy) === null || _b === void 0 ? void 0 : _b.$(`[pathId = -1]`).addClass('selected');
            (_c = this.cy) === null || _c === void 0 ? void 0 : _c.$(`[pathId = ${pathId}]`).addClass('selected');
            (_d = this.cy) === null || _d === void 0 ? void 0 : _d.$('*').difference((_e = this.cy) === null || _e === void 0 ? void 0 : _e.$('.selected')).addClass('dimmed');
            this.selectedPathID = pathId;
        }
    }
    /**
     * --- HACKY ---
     * Allow events not involving buttons to work on cytoscape when it's in a shadow dom.
     * They don't work due to shadow dom event's retargeting
     * Cytoscape listen to events on window object. When the event reach window due to bubbling,
     * cytoscape handler for mouse movement handles it but event target appear to be the
     * custom component and not the canvas due to retargeting, therefore listeners are not triggered.
     * workaround found here: https://github.com/cytoscape/cytoscape.js/issues/2081
     */
    fixHover() {
        try {
            this.cy.renderer().hoverData.capture = true;
        }
        catch (_a) { }
    }
}
GscapePathSelector.properties = {
    getMorePaths: { type: Boolean },
    paths: { type: Array },
    selectedPathID: { type: Number },
    canShowMore: { type: Boolean }
};
GscapePathSelector.styles = [
    baseStyle$3,
    i$1 `
      .gscape-panel {
        position: absolute;
        overflow: hidden;
        top: 100px;
        left: 50%;
        transform: translate(-50%);
        max-width: 80%;
        min-width: 60%;
        min-height: 50%;
        display: flex;
        flex-direction: column;
      }

      .header {
        margin: 8px;
      }

      .buttons {
        display: flex;
        align-items: center;
        justify-content: right;
        gap: 8px;
      }

      .path {
        display: flex;
        align-items: center;
        overflow: auto;
        gap: 4px;
        border: solid 1px var(--gscape-color-border-subtle);
      }

      .path[selected] {
        border: solid 2px var(--gscape-color-accent);
        background: var(--gscape-color-neutral-subtle);
      }

      gscape-entity-list-item {
        max-width: 200px;
        pointer-events: none;
      }

      .path-list {
        margin: 16px 0;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      #cy {
        position: relative;
        flex-grow: 2;
      }
    `
];
customElements.define('gscape-path-selector', GscapePathSelector);

function pathSelectionInit(ic, sourceIri, targetIri) {
    var _a, _b;
    const pathSelector = new GscapePathSelector(ic.grapholscape.theme);
    (_b = (_a = ic.endpointController) === null || _a === void 0 ? void 0 : _a.highlightsManager) === null || _b === void 0 ? void 0 : _b.getShortestKPaths(sourceIri, targetIri).then(paths => pathSelector.paths = paths);
    pathSelector.getDisplayedName = (entity) => {
        if (!entity.iri)
            return;
        const grapholEntity = ic.grapholscape.ontology.getEntity(entity.iri);
        return grapholEntity === null || grapholEntity === void 0 ? void 0 : grapholEntity.getDisplayedName(ic.grapholscape.entityNameType, ic.grapholscape.language);
    };
    // pathSelector.canShowMore = true
    if (ic.grapholscape.uiContainer) {
        ic.grapholscape.uiContainer.appendChild(pathSelector);
    }
    return pathSelector;
}
function handlePathEdgeDraw(targetNode, ic, onComplete = (sourceNode, targetNode, loadingEdge) => { }) {
    if (ic.grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
        const cy = ic.grapholscape.renderer.cy;
        if (cy && !cy.scratch('eh')) {
            let eh = cy.edgehandles(edgeHandlesOptions);
            cy.scratch('eh', eh);
            eh.start(targetNode);
            cy.on('ehcomplete', (evt, sourceNode, targetNode, addedEdge) => __awaiter(this, void 0, void 0, function* () {
                onComplete(sourceNode, targetNode, addedEdge);
            }));
            const onStop = (ev) => {
                const eh = cy.scratch('eh');
                if (eh) {
                    eh.stop();
                    eh.destroy();
                    cy.removeScratch('eh');
                    cy.removeListener('ehcomplete ehstop');
                }
                document.removeEventListener('mouseup', onStop);
            };
            document.addEventListener('mouseup', (ev) => onStop());
        }
    }
}

function showMenu (menu, incrementalController) {
    if (menu.referenceEntity && menu.referenceEntityType) {
        const cy = incrementalController.grapholscape.renderer.cy;
        if (cy) {
            const nodeId = incrementalController.getIDByIRI(menu.referenceEntity.value.iri.fullIri, menu.referenceEntityType);
            if (!nodeId)
                return;
            const node = cy.$id(nodeId);
            if (node) {
                {
                    menu.attachTo(node.popperRef());
                    menu.show();
                }
                if (!node.data().pinned) {
                    node.scratch('should-unpin', true);
                    incrementalController.pinNode(node);
                }
            }
        }
    }
}

function showButtons(targetNode, nodeButtons) {
    var _a;
    const targetType = targetNode.data().type;
    if (!targetNode.hasClass('unknown-parent-class') && (targetType === TypesEnum.CLASS || targetType === TypesEnum.CLASS_INSTANCE)) {
        const buttons = [];
        (_a = nodeButtons.get(targetType)) === null || _a === void 0 ? void 0 : _a.forEach((btn, i) => {
            // set position relative to default placemente (right)
            btn.cxtWidgetProps.offset = (info) => getButtonOffset(info, i, nodeButtons.get(targetType).length);
            btn.node = targetNode;
            // save the function to attach the button in the scratch for later usage
            targetNode.scratch(`place-node-button-${i}`, () => btn.attachTo(targetNode.popperRef()));
            targetNode.on('position', targetNode.scratch(`place-node-button-${i}`)); // on position change, call the function in the scratch
            btn.attachTo(targetNode.popperRef());
            buttons.push(btn);
        });
        targetNode.scratch(`node-button-list`, buttons);
    }
}
function hideButtons(targetNode) {
    const nodeButtons = targetNode.scratch('node-button-list');
    nodeButtons === null || nodeButtons === void 0 ? void 0 : nodeButtons.forEach((btn, i) => {
        btn.hide();
        const updatePosFunction = targetNode.scratch(`place-node-button-${i}`);
        if (updatePosFunction) {
            targetNode.removeListener('position', undefined, updatePosFunction);
            targetNode.removeScratch(`place-node-button-${i}`);
        }
    });
}
function getButtonOffset(info, buttonIndex = 0, numberOfButtons = 1) {
    const btnHeight = info.popper.height + 4;
    const btnWidth = info.popper.width;
    return [
        -(btnHeight / 2) - (buttonIndex * btnHeight) + (btnHeight * (numberOfButtons / 2)),
        -btnWidth / 2 // x
    ];
}

function NodeButtonsFactory(ic) {
    const instancesButton = new NodeButton(classInstanceIcon);
    instancesButton.title = 'Search instances';
    const objectPropertyButton = new NodeButton(objectPropertyIcon);
    objectPropertyButton.title = 'Navigate through object properties';
    const pathDrawingButton = new NodeButton(pathIcon);
    pathDrawingButton.title = 'Find path to another entity';
    const nodeButtonsMap = new Map();
    nodeButtonsMap.set(TypesEnum.CLASS, [objectPropertyButton]);
    nodeButtonsMap.set(TypesEnum.CLASS_INSTANCE, [objectPropertyButton, pathDrawingButton]);
    instancesButton.onclick = (e) => handleInstancesButtonClick(e, ic);
    objectPropertyButton.onclick = (e) => handleObjectPropertyButtonClick(e, ic);
    pathDrawingButton.onmousedown = (e) => onPathDrawingButtonClick(e, ic);
    if (ic.grapholscape.renderState === RendererStatesEnum.INCREMENTAL && ic.diagram.representation) {
        setHandlersOnIncrementalCytoscape(ic.diagram.representation.cy, nodeButtonsMap);
    }
    ic.grapholscape.on(LifecycleEvent.RendererChange, (rendererState) => {
        if (rendererState === RendererStatesEnum.INCREMENTAL && ic.diagram.representation) {
            setHandlersOnIncrementalCytoscape(ic.diagram.representation.cy, nodeButtonsMap);
        }
    });
    ic.on(IncrementalEvent.Reset, () => {
        if (ic.grapholscape.renderState === RendererStatesEnum.INCREMENTAL && ic.diagram.representation) {
            setHandlersOnIncrementalCytoscape(ic.diagram.representation.cy, nodeButtonsMap);
            ic
                .grapholscape
                .container
                .querySelectorAll('[data-tippy-root]') // take all the tippy widgets (loading badges basically)
                .forEach(tippy => tippy.remove());
        }
    });
    ic.on(IncrementalEvent.EndpointChange, () => {
        var _a, _b, _c, _d;
        if (!((_a = nodeButtonsMap.get(TypesEnum.CLASS)) === null || _a === void 0 ? void 0 : _a.includes(instancesButton))) {
            (_b = nodeButtonsMap.get(TypesEnum.CLASS)) === null || _b === void 0 ? void 0 : _b.push(instancesButton);
        }
        if (!((_c = nodeButtonsMap.get(TypesEnum.CLASS)) === null || _c === void 0 ? void 0 : _c.includes(pathDrawingButton))) {
            (_d = nodeButtonsMap.get(TypesEnum.CLASS)) === null || _d === void 0 ? void 0 : _d.push(pathDrawingButton);
        }
    });
    ic.on(IncrementalEvent.FocusStarted, instanceIri => {
        var _a;
        const nodeId = ic.getIDByIRI(instanceIri, TypesEnum.CLASS_INSTANCE);
        if (nodeId) {
            const cyNode = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(nodeId);
            if (cyNode && cyNode.nonempty()) {
                addBadge(cyNode, textSpinner(), 'loading-badge');
            }
        }
    });
    ic.on(IncrementalEvent.FocusFinished, instanceIri => {
        var _a;
        const nodeId = ic.getIDByIRI(instanceIri, TypesEnum.CLASS_INSTANCE);
        if (nodeId) {
            const cyNode = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(nodeId);
            if (cyNode && cyNode.nonempty() && cyNode.scratch('loading-badge')) {
                removeBadge(cyNode, 'loading-badge');
            }
        }
    });
    ic.on(IncrementalEvent.InstanceCheckingStarted, (instanceIri) => {
        var _a;
        const nodeId = ic.getIDByIRI(instanceIri, TypesEnum.CLASS_INSTANCE);
        if (nodeId) {
            const cyNode = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(nodeId);
            if (cyNode && cyNode.nonempty()) {
                cyNode.addClass('unknown-parent-class');
                addBadge(cyNode, textSpinner(), 'loading-badge');
            }
        }
    });
    ic.on(IncrementalEvent.InstanceCheckingFinished, (instanceIri) => {
        var _a;
        const nodeId = ic.getIDByIRI(instanceIri, TypesEnum.CLASS_INSTANCE);
        if (nodeId) {
            const cyNode = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(nodeId);
            if (cyNode && cyNode.nonempty() && cyNode.scratch('loading-badge')) {
                removeBadge(cyNode, 'loading-badge');
            }
        }
    });
    ic.on(IncrementalEvent.CountStarted, classIri => {
        var _a;
        const nodeId = ic.getIDByIRI(classIri, TypesEnum.CLASS);
        if (nodeId) {
            const node = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(nodeId);
            if (!node || node.empty())
                return;
            removeBadge(node, 'instance-count');
            addBadge(node, textSpinner(), 'instance-count', 'bottom');
        }
    });
    ic.on(IncrementalEvent.NewCountResult, (classIri, count) => {
        var _a;
        const nodeId = ic.getIDByIRI(classIri, TypesEnum.CLASS);
        if (nodeId) {
            const cyNode = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(nodeId);
            if (cyNode && cyNode.nonempty() && cyNode.scratch('instance-count')) {
                const instanceCountBadge = cyNode.scratch('instance-count');
                instanceCountBadge.contentType = 'template';
                count = count || ic.counts.get(classIri);
                instanceCountBadge.content = (count === null || count === void 0 ? void 0 : count.value) !== undefined
                    ? new Intl.NumberFormat().format(count.value)
                    : 'n/a';
                instanceCountBadge.highlighted = !(count === null || count === void 0 ? void 0 : count.materialized);
                if (count === null || count === void 0 ? void 0 : count.date) {
                    instanceCountBadge.title = `Date: ${count.date}`;
                }
                else {
                    instanceCountBadge.title = 'Fresh Value';
                }
                const updateFun = cyNode.scratch('update-instance-count-position');
                if (updateFun)
                    updateFun();
                setTimeout(() => instanceCountBadge.hide(), 1000);
                cyNode.on('mouseover', () => {
                    if (ic.countersEnabled)
                        instanceCountBadge.tippyWidget.show();
                });
                cyNode.on('mouseout', () => instanceCountBadge.tippyWidget.hide());
                if (count && !count.materialized) // update only if it's a fresh value
                    ic.counts.set(classIri, count);
            }
        }
    });
}
function setHandlersOnIncrementalCytoscape(cy, nodeButtons) {
    if (cy.scratch('_gscape-graph-incremental-handlers-set'))
        return;
    cy.on('mouseover', 'node', e => {
        showButtons(e.target, nodeButtons);
    });
    cy.on('mouseout', 'node', e => {
        hideButtons(e.target);
    });
    cy.scratch('_gscape-graph-incremental-handlers-set', true);
}
function handleObjectPropertyButtonClick(e, incrementalController) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const targetButton = e.currentTarget;
        const navigationMenu = incrementalController.grapholscape.widgets.get(WidgetEnum$1.NAVIGATION_MENU);
        if (!navigationMenu)
            return;
        if (targetButton.node && targetButton.node.data().iri) {
            let referenceEnity;
            let objectProperties = new Map();
            if (targetButton.node.data().type === TypesEnum.CLASS) {
                referenceEnity = incrementalController.grapholscape.ontology.getEntity(targetButton.node.data().iri);
                if (!referenceEnity)
                    return;
                navigationMenu.referenceEntity = grapholEntityToEntityViewData(referenceEnity, incrementalController.grapholscape);
                navigationMenu.referenceEntityType = targetButton.node.data().type;
                navigationMenu.canShowObjectPropertiesRanges = true;
                objectProperties = yield incrementalController.getObjectPropertiesByClasses([targetButton.node.data().iri]);
            }
            else if (targetButton.node.data().type === TypesEnum.CLASS_INSTANCE) {
                referenceEnity = incrementalController.classInstanceEntities.get(targetButton.node.data().iri);
                if (!referenceEnity)
                    return;
                navigationMenu.referenceEntity = grapholEntityToEntityViewData(referenceEnity, incrementalController.grapholscape);
                navigationMenu.referenceEntityType = targetButton.node.data().type;
                navigationMenu.canShowObjectPropertiesRanges = false;
                const parentClassesIris = referenceEnity.parentClassIris.map(i => i.fullIri);
                objectProperties = yield incrementalController.getObjectPropertiesByClasses(parentClassesIris);
            }
            const hasUnfoldings = (_b = (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.highlightsManager) === null || _b === void 0 ? void 0 : _b.hasUnfoldings.bind((_c = incrementalController.endpointController) === null || _c === void 0 ? void 0 : _c.highlightsManager);
            navigationMenu.objectProperties = Array.from(objectProperties).map(v => {
                const newV = getEntityViewDataUnfolding(v[0], incrementalController.grapholscape, hasUnfoldings);
                const viewIncrementalObjProp = newV;
                viewIncrementalObjProp.connectedClasses = v[1].list.map(classEntity => {
                    return getEntityViewDataUnfolding(classEntity, incrementalController.grapholscape, hasUnfoldings);
                });
                viewIncrementalObjProp.direct = v[1].direct;
                return viewIncrementalObjProp;
            });
            // TODO: check why sometimes here targetButton.node is undefined, happens only few times
            // it should be defined due to previous initial if
            if (targetButton.node) {
                showMenu(navigationMenu, incrementalController);
            }
        }
    });
}
function handleInstancesButtonClick(e, incrementalController) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter(this, void 0, void 0, function* () {
        const targetButton = e.currentTarget;
        const instanceExplorer = incrementalController.grapholscape.widgets.get(WidgetEnum$1.INSTANCES_EXPLORER);
        if (!instanceExplorer)
            return;
        if (targetButton.node && targetButton.node.data().iri) {
            const referenceEntity = incrementalController.grapholscape.ontology.getEntity(targetButton.node.data().iri);
            const entityType = targetButton.node.data().type;
            if (referenceEntity && entityType === TypesEnum.CLASS) {
                if (!instanceExplorer.referenceEntity ||
                    !instanceExplorer.referenceEntity.value.iri.equals(referenceEntity.iri) ||
                    instanceExplorer.numberOfInstancesReceived === 0) {
                    instanceExplorer.clear();
                    instanceExplorer.areInstancesLoading = true;
                    instanceExplorer.referenceEntity = grapholEntityToEntityViewData(referenceEntity, incrementalController.grapholscape);
                    instanceExplorer.referenceEntityType = targetButton.node.data().type;
                    const hasUnfoldings = (_b = (_a = incrementalController.endpointController) === null || _a === void 0 ? void 0 : _a.highlightsManager) === null || _b === void 0 ? void 0 : _b.hasUnfoldings.bind((_c = incrementalController.endpointController) === null || _c === void 0 ? void 0 : _c.highlightsManager);
                    const dataProperties = yield incrementalController.getDataPropertiesByClasses([referenceEntity.iri.fullIri]);
                    const objectPropertiesMap = yield incrementalController.getObjectPropertiesByClasses([referenceEntity.iri.fullIri]);
                    const objectProperties = Array.from(objectPropertiesMap).map(([opEntity, connectedClasses]) => {
                        let opViewDataIncremental = getEntityViewDataUnfolding(opEntity, incrementalController.grapholscape, hasUnfoldings);
                        return {
                            entityViewData: opViewDataIncremental.entityViewData,
                            loading: opViewDataIncremental.loading,
                            hasUnfolding: opViewDataIncremental.hasUnfolding,
                            connectedClasses: [],
                            direct: connectedClasses.direct,
                        };
                    });
                    instanceExplorer.propertiesFilterList = dataProperties
                        .map(dp => getEntityViewDataUnfolding(dp, incrementalController.grapholscape, hasUnfoldings))
                        .concat(objectProperties)
                        .sort((a, b) => a.entityViewData.displayedName.localeCompare(b.entityViewData.displayedName));
                    instanceExplorer.requestId = yield ((_d = incrementalController.endpointController) === null || _d === void 0 ? void 0 : _d.requestInstancesForClass(referenceEntity.iri.fullIri));
                    if (instanceExplorer.requestId) {
                        (_f = (_e = incrementalController
                            .endpointController) === null || _e === void 0 ? void 0 : _e.shouldQueryUseLabels(instanceExplorer.requestId)) === null || _f === void 0 ? void 0 : _f.then((shouldAskForLabels) => __awaiter(this, void 0, void 0, function* () {
                            var _g;
                            if (!shouldAskForLabels) {
                                instanceExplorer.shouldAskForLabels = shouldAskForLabels;
                                instanceExplorer.areInstancesLoading = true;
                                instanceExplorer.requestId = yield ((_g = incrementalController.endpointController) === null || _g === void 0 ? void 0 : _g.requestInstancesForClass(referenceEntity.iri.fullIri, shouldAskForLabels));
                            }
                        }));
                    }
                }
            }
            // TODO: check why sometimes here targetButton.node is undefined, happens only few times
            // it should be defined due to previous initial if
            if (targetButton.node) {
                showMenu(instanceExplorer, incrementalController);
            }
        }
    });
}
function onPathDrawingButtonClick(e, ic) {
    const onComplete = (sourceNode, targetNode, loadingEdge) => {
        var _a, _b, _c, _d;
        let sourceIriForPath = sourceNode.data('iri');
        let targetIriForpath = targetNode.data('iri');
        const loadingAnimationInterval = setInterval(() => {
            loadingEdge.data('on', !loadingEdge.data('on'));
        }, 500);
        const stopAnimation = () => {
            loadingEdge.remove();
            clearInterval(loadingAnimationInterval);
        };
        if (sourceNode.edgesTo(targetNode).filter('.loading-edge').size() > 1) {
            stopAnimation();
        }
        if (sourceNode.data().type === TypesEnum.CLASS && sourceNode.data().type === targetNode.data().type) {
            if (sourceIriForPath && targetIriForpath) {
                (_b = (_a = ic.endpointController) === null || _a === void 0 ? void 0 : _a.highlightsManager) === null || _b === void 0 ? void 0 : _b.getShortestPath(sourceIriForPath, targetIriForpath).then(path => {
                    if (path[0].entities) {
                        ic.addPath(path[0].entities).finally(stopAnimation);
                    }
                    else {
                        stopAnimation();
                    }
                }).catch(stopAnimation);
            }
        }
        else {
            let entity;
            // Take parentClass IRI to find a path to the other node in the intensional level
            if (sourceNode.data().type === TypesEnum.CLASS_INSTANCE) {
                entity = ic.classInstanceEntities.get(sourceNode.data('iri'));
                if (entity) {
                    sourceIriForPath = entity.parentClassIris[0].fullIri;
                }
            }
            if (targetNode.data().type === TypesEnum.CLASS_INSTANCE) {
                entity = ic.classInstanceEntities.get(targetNode.data('iri'));
                if (entity) {
                    targetIriForpath = entity.parentClassIris[0].fullIri;
                }
            }
            (_d = (_c = ic.endpointController) === null || _c === void 0 ? void 0 : _c.highlightsManager) === null || _d === void 0 ? void 0 : _d.getShortestPath(sourceIriForPath, targetIriForpath).then(path => {
                if (path[0].entities) {
                    ic.addInstancesPath(sourceNode.data().iri, targetNode.data().iri, path[0])
                        .finally(stopAnimation);
                }
                else {
                    stopAnimation();
                }
            }).catch(stopAnimation);
        }
    };
    if (ic.grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
        const targetNode = e.currentTarget.node;
        if (targetNode) {
            handlePathEdgeDraw(targetNode, ic, onComplete);
        }
    }
}
function removeBadge(cyNode, name) {
    if (!cyNode.scratch(name))
        return;
    cyNode.scratch(name).tippyWidget.destroy();
    cyNode.removeClass('unknown-parent-class');
    cyNode.removeScratch(name);
    cyNode.removeAllListeners();
    cyNode.cy().removeListener('pan', cyNode.scratch(`update-${name}-position`));
    cyNode.removeScratch(`update-${name}-position`);
}
function addBadge(node, content, name, placement = 'bottom', isIcon = false) {
    const badge = isIcon
        ? new NodeButton(content)
        : new NodeButton(content, 'template');
    badge.cxtWidgetProps.placement = placement;
    node.scratch(name, badge);
    node.scratch(`update-${name}-position`, () => {
        badge.attachToSilently(node.popperRef());
    });
    badge.cxtWidgetProps.offset = info => getButtonOffset(info);
    badge.attachTo(node.popperRef());
    // update badge position on node moving around and on viewport pan state change
    node.on('position', node.scratch(`update-${name}-position`));
    node.cy().on('pan', node.scratch(`update-${name}-position`));
    node.scratch(`update-${name}-position`);
    node.on('remove', (e) => removeBadge(e.target, name));
    return badge;
}

function showHideSuperHierarchies(hide, callback) {
    return {
        content: `${hide ? `Hide` : `Show`} Super Hierarchies`,
        icon: superHierarchies,
        select: callback,
    };
}
function showHideSuperClasses(hide, callback) {
    return {
        content: `${hide ? `Hide` : `Show`} Super Classes`,
        icon: superHierarchies,
        select: callback,
    };
}
function showHideSubHierarchies(hide, callback) {
    return {
        content: `${hide ? `Hide` : `Show`} Sub Hierarchies`,
        icon: subHierarchies,
        select: callback,
    };
}
function showHideSubClasses(hide, callback) {
    return {
        content: `${hide ? `Hide` : `Show`} Sub Classes`,
        icon: subHierarchies,
        select: callback,
    };
}
function showHideEquivalentClasses(hide, callback) {
    return {
        content: `${hide ? `Hide` : `Show`} Equivalent Classes`,
        icon: equivalentClasses,
        select: callback
    };
}
function remove(callback) {
    return {
        content: 'Remove',
        icon: rubbishBin,
        select: callback,
    };
}
function showParentClass$1(callback) {
    return {
        content: 'Show Current Parent Classes',
        icon: classIcon,
        select: callback,
    };
}
function performInstanceChecking(callback) {
    return {
        content: 'Compute and Show Parent Classes',
        icon: classIcon,
        select: callback,
    };
}
function focusInstance(callback) {
    return {
        content: 'Show Relationships',
        icon: objectPropertyIcon,
        select: callback,
    };
}

function CommandsWidgetFactory(ic) {
    const commandsWidget = new GscapeContextMenu$1();
    ic.grapholscape.on(LifecycleEvent.ContextClick, event => {
        var _a, _b, _c;
        const commands = [];
        if (event.target === ic.grapholscape.renderer.cy ||
            !event.target.data().iri ||
            ic.grapholscape.renderState !== RendererStatesEnum.INCREMENTAL)
            return;
        const entity = ic.classInstanceEntities.get(event.target.data().iri) || ic.grapholscape.ontology.getEntity(event.target.data().iri);
        const grapholElement = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(event.target.id());
        if (!entity || !grapholElement)
            return;
        hideButtons(event.target);
        if (grapholElement.is(TypesEnum.OBJECT_PROPERTY) &&
            event.target.source().data().type === TypesEnum.CLASS_INSTANCE &&
            event.target.target().data().type === TypesEnum.CLASS_INSTANCE) {
            commands.push({
                content: 'Show Instance Types',
                icon: classIcon,
                select: () => {
                    ic.showObjectPropertyTypes(entity.iri.fullIri, event.target.source().id(), event.target.target().id());
                },
            });
        }
        if (grapholElement.is(TypesEnum.CLASS) ||
            grapholElement.is(TypesEnum.CLASS_INSTANCE)) {
            commands.push({
                content: 'Find paths to',
                icon: pathIcon,
                select: () => {
                    const onComplete = (sourceNode, targetNode, loadingEdge) => {
                        let pathSelector;
                        let sourceIriForPath = sourceNode.data('iri');
                        let targetIriForpath = targetNode.data('iri');
                        const loadingAnimationInterval = setInterval(() => {
                            loadingEdge.data('on', !loadingEdge.data('on'));
                        }, 500);
                        const stopAnimation = () => {
                            loadingEdge.remove();
                            clearInterval(loadingAnimationInterval);
                        };
                        if (sourceNode.edgesTo(targetNode).filter('.loading-edge').size() > 1) {
                            stopAnimation();
                        }
                        // let pathSelector: GscapePathSelector | undefined
                        if (sourceNode.data().type === TypesEnum.CLASS && sourceNode.data().type === targetNode.data().type) {
                            if (sourceIriForPath && targetIriForpath) {
                                pathSelector = pathSelectionInit(ic, sourceIriForPath, targetIriForpath);
                                pathSelector.addEventListener('path-selection', (evt) => __awaiter(this, void 0, void 0, function* () {
                                    if (evt.detail.entities)
                                        ic.addPath(evt.detail.entities);
                                    stopAnimation();
                                }));
                            }
                        }
                        else {
                            let entity;
                            // Take parentClass IRI to find a path to the other node in the intensional level
                            if (sourceNode.data().type === TypesEnum.CLASS_INSTANCE) {
                                entity = ic.classInstanceEntities.get(sourceNode.data('iri'));
                                if (entity) {
                                    sourceIriForPath = entity.parentClassIris[0].fullIri;
                                }
                            }
                            if (targetNode.data().type === TypesEnum.CLASS_INSTANCE) {
                                entity = ic.classInstanceEntities.get(targetNode.data('iri'));
                                if (entity) {
                                    targetIriForpath = entity.parentClassIris[0].fullIri;
                                }
                            }
                            if (sourceIriForPath && targetIriForpath) {
                                pathSelector = pathSelectionInit(ic, sourceIriForPath, targetIriForpath);
                                pathSelector.addEventListener('path-selection', (evt) => __awaiter(this, void 0, void 0, function* () {
                                    ic.addInstancesPath(sourceNode.data().iri, targetNode.data().iri, evt.detail)
                                        .finally(stopAnimation);
                                }));
                            }
                        }
                        if (pathSelector) {
                            pathSelector.addEventListener('cancel', stopAnimation);
                            pathSelector.show();
                        }
                    };
                    handlePathEdgeDraw(event.target, ic, onComplete);
                }
            });
        }
        if (grapholElement.is(TypesEnum.CLASS_INSTANCE)) {
            commands.push(focusInstance(() => ic.expandObjectPropertiesOnInstance(entity.iri.fullIri)));
            commands.push(performInstanceChecking(() => __awaiter(this, void 0, void 0, function* () {
                var _d;
                const allClassesIris = ic
                    .grapholscape
                    .ontology
                    .getEntitiesByType(TypesEnum.CLASS)
                    .map(e => e.iri.fullIri);
                const instanceCheckingClasses = yield ((_d = ic
                    .endpointController) === null || _d === void 0 ? void 0 : _d.instanceCheck(entity.iri.fullIri, allClassesIris));
                instanceCheckingClasses === null || instanceCheckingClasses === void 0 ? void 0 : instanceCheckingClasses.forEach(classIri => {
                    const classEntity = ic.grapholscape.ontology.getEntity(classIri);
                    if (classEntity) {
                        entity.addParentClass(classEntity.iri);
                    }
                });
                showParentClass(ic, entity);
            })));
            if (!entity.isRDFTypeUnknown) {
                commands.push(showParentClass$1(() => showParentClass(ic, entity)));
            }
        }
        const classIri = entity.iri.fullIri;
        if (grapholElement.is(TypesEnum.CLASS)) {
            const superHierarchies = ic.grapholscape.ontology.hierarchiesBySubclassMap.get(classIri);
            const subHierarchies = ic.grapholscape.ontology.hierarchiesBySuperclassMap.get(classIri);
            if (superHierarchies && superHierarchies.length > 0) {
                const areAllSuperHierarchiesVisible = ic.areHierarchiesVisible(superHierarchies);
                commands.push(showHideSuperHierarchies(areAllSuperHierarchiesVisible, () => {
                    areAllSuperHierarchiesVisible ? ic.hideSuperHierarchiesOf(classIri) : ic.showSuperHierarchiesOf(classIri);
                }));
            }
            if (subHierarchies && subHierarchies.length > 0) {
                const areAllSubHierarchiesVisible = ic.areHierarchiesVisible(subHierarchies);
                commands.push(showHideSubHierarchies(areAllSubHierarchiesVisible, () => {
                    areAllSubHierarchiesVisible ? ic.hideSubHierarchiesOf(classIri) : ic.showSubHierarchiesOf(classIri);
                }));
            }
            const subClasses = ic.neighbourhoodFinder.getSubclassesIris(classIri);
            const superClasses = ic.neighbourhoodFinder.getSuperclassesIris(classIri);
            const equivalentClasses = ic.neighbourhoodFinder.getEquivalentClassesIris(classIri);
            if (subClasses.length > 0) {
                const areAllSubclassesVisible = ic.areAllConnectedClassesVisibleForClass(classIri, subClasses, 'sub');
                commands.push(showHideSubClasses(areAllSubclassesVisible, () => {
                    areAllSubclassesVisible
                        ? subClasses.forEach(sc => ic.removeEntity(sc, [classIri]))
                        : ic.showSubClassesOf(classIri, subClasses);
                }));
            }
            if (superClasses.length > 0) {
                const areAllSuperclassesVisible = ic.areAllConnectedClassesVisibleForClass(classIri, superClasses, 'super');
                commands.push(showHideSuperClasses(areAllSuperclassesVisible, () => {
                    areAllSuperclassesVisible
                        ? superClasses.forEach(sc => ic.removeEntity(sc, [classIri]))
                        : ic.showSuperClassesOf(classIri, superClasses);
                }));
            }
            if (equivalentClasses.length > 0) {
                const areAllEquivalentClassesVisible = ic.areAllConnectedClassesVisibleForClass(classIri, equivalentClasses, 'equivalent');
                commands.push(showHideEquivalentClasses(areAllEquivalentClassesVisible, () => {
                    areAllEquivalentClassesVisible
                        ? equivalentClasses.forEach(sc => ic.removeEntity(sc, [classIri]))
                        : ic.showEquivalentClassesOf(classIri, equivalentClasses);
                }));
            }
            if (((_b = ic.endpointController) === null || _b === void 0 ? void 0 : _b.isReasonerAvailable()) && ic.countersEnabled) {
                commands.push({
                    icon: counter,
                    content: 'Count Instances',
                    select: () => {
                        var _a;
                        (_a = ic.endpointController) === null || _a === void 0 ? void 0 : _a.requestCountForClass(entity.iri.fullIri);
                    }
                });
            }
        }
        if (!grapholElement.is(TypesEnum.CLASS_INSTANCE) && ((_c = ic.endpointController) === null || _c === void 0 ? void 0 : _c.isReasonerAvailable())) {
            commands.push({
                content: 'Data Lineage',
                icon: sankey,
                select: () => ic.onShowDataLineage(entity.iri.fullIri),
            });
        }
        commands.push(remove(() => {
            var _a;
            if (grapholElement.is(TypesEnum.OBJECT_PROPERTY)) {
                const grapholOccurrence = (_a = ic.diagram.representation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(event.target.id());
                if (grapholOccurrence) {
                    entity.removeOccurrence(grapholOccurrence, RendererStatesEnum.INCREMENTAL);
                }
                ic.diagram.removeElement(event.target.id());
                ic.lifecycle.trigger(IncrementalEvent.DiagramUpdated);
            }
            else {
                ic.removeEntity(entity.iri.fullIri);
            }
        }));
        try {
            if (event.target.isEdge() && ic.grapholscape.uiContainer) {
                commandsWidget.attachToPosition(event.renderedPosition, ic.grapholscape.uiContainer, commands);
            }
            else {
                const htmlNodeReference = event.target.popperRef();
                if (htmlNodeReference && commands.length > 0) {
                    commandsWidget.attachTo(htmlNodeReference, commands);
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    });
}
function showParentClass(incrementalController, instanceEntity) {
    const parentClassIris = instanceEntity.parentClassIris;
    let parentClassNode;
    let classInstanceId = incrementalController.getIDByIRI(instanceEntity.iri.fullIri, TypesEnum.CLASS_INSTANCE);
    if (classInstanceId) {
        incrementalController.performActionWithBlockedGraph(() => {
            parentClassIris === null || parentClassIris === void 0 ? void 0 : parentClassIris.forEach(parentClassIri => {
                parentClassNode = incrementalController.addClass(parentClassIri.fullIri, false);
                if (parentClassNode) {
                    incrementalController.addEdge(classInstanceId, parentClassNode.id, TypesEnum.INSTANCE_OF);
                }
            });
        });
        if ((parentClassIris === null || parentClassIris === void 0 ? void 0 : parentClassIris.length) === 1 && parentClassNode) {
            setTimeout(() => {
                incrementalController.grapholscape.centerOnElement(parentClassNode.id);
            }, 250);
        }
    }
}

class GscapeNavigationMenu extends ContextualWidgetMixin(BaseMixin$3(s)) {
    constructor() {
        super();
        /** @internal */
        this._objectProperties = [];
        /** @internal */
        this.canShowObjectPropertiesRanges = true;
        this.render = () => {
            var _a, _b, _c;
            return x `
    <div class="gscape-panel" id="drop-panel">
      
      <div class="header">
        <gscape-entity-list-item
          displayedname=${(_a = this.referenceEntity) === null || _a === void 0 ? void 0 : _a.displayedName}
          iri=${(_b = this.referenceEntity) === null || _b === void 0 ? void 0 : _b.value.iri.fullIri}
          .types=${(_c = this.referenceEntity) === null || _c === void 0 ? void 0 : _c.value.types}
        ></gscape-entity-list-item>
      </div>

      ${this.objectProperties && this.objectProperties.length > 0
                ? x `
          <div class="section">
            <div class="section-body" style="padding-left: 0px; padding-right: 0px">
              ${this.objectProperties.map(objectProperty => {
                    // const values = this.dataPropertiesValues?.get(dataProperty.value.iri.fullIri)
                    const disabled = !this.canShowObjectPropertiesRanges && objectProperty.hasUnfolding === false;
                    return x `
                  <gscape-entity-list-item
                    displayedname=${objectProperty.entityViewData.displayedName}
                    iri=${objectProperty.entityViewData.value.iri.fullIri}
                    .types=${objectProperty.entityViewData.value.types}
                    ?actionable=${!this.canShowObjectPropertiesRanges}
                    ?asaccordion=${this.canShowObjectPropertiesRanges}
                    ?disabled=${disabled}
                    @click=${this.handleEntitySelection}
                    direct=${objectProperty.direct}
                    title=${disabled ? 'Property not mapped to data' : objectProperty.entityViewData.displayedName}
                  >
                    ${this.canShowObjectPropertiesRanges
                        ? x `
                        <div slot="accordion-body">
                          ${objectProperty.connectedClasses.map(connectedClass => {
                            return x `
                                <gscape-entity-list-item
                                  displayedname=${connectedClass.entityViewData.displayedName}
                                  iri=${connectedClass.entityViewData.value.iri.fullIri}
                                  objpropertyiri=${objectProperty.entityViewData.value.iri.fullIri}
                                  direct=${objectProperty.direct}
                                  .types=${connectedClass.entityViewData.value.types}
                                  ?actionable=${false}
                                >
                                  <div slot="trailing-element" class="hover-btn">
                                    <gscape-button
                                      size="s"
                                      type="subtle"
                                      @click=${this.handleInsertInGraphClick}
                                    >
                                      ${getIconSlot$1('icon', insertInGraph)}
                                    </gscape-button>
                                  </div>
                                </gscape-entity-list-item>
                            `;
                        })}
                        </div>
                      `
                        : null}

                    ${!objectProperty.direct
                        ? x `
                        <span slot="trailing-element" class="chip" style="line-height: 1">Inverse</span>
                      `
                        : null}
                  </gscape-entity-list-item>
                `;
                })}
            </div>
          </div>
        `
                : x `
          <div class="blank-slate" style="padding-bottom: 8px">
            ${blankSlateDiagrams}
            <div class="header">No Object Properties Available</div>
          </div>
        `} 
    </div>
  `;
        };
        this.cxtWidgetProps.placement = 'right';
    }
    handleEntitySelection(e) {
        var _a, _b;
        if (a11yClick(e)) {
            if (this.popperRef)
                this.attachTo(this.popperRef);
            const targetListItem = e.currentTarget;
            if (targetListItem &&
                ((_a = this.referenceEntity) === null || _a === void 0 ? void 0 : _a.value.types.has(TypesEnum.CLASS_INSTANCE)) &&
                !targetListItem.disabled) {
                this.dispatchEvent(new CustomEvent('onobjectpropertyselection', {
                    bubbles: true,
                    composed: true,
                    detail: {
                        referenceClassIri: (_b = this.referenceEntity) === null || _b === void 0 ? void 0 : _b.value.iri.fullIri,
                        objectPropertyIri: targetListItem.iri,
                        direct: targetListItem.getAttribute('direct') === 'true'
                    }
                }));
            }
        }
    }
    handleInsertInGraphClick(e) {
        var _a, _b;
        const targetListItem = (_a = e.currentTarget.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        if (targetListItem) {
            this.dispatchEvent(new CustomEvent('onclassselection', {
                bubbles: true,
                composed: true,
                detail: {
                    referenceClassIri: (_b = this.referenceEntity) === null || _b === void 0 ? void 0 : _b.value.iri.fullIri,
                    rangeClassIri: targetListItem.iri,
                    objectPropertyIri: targetListItem.getAttribute('objpropertyiri'),
                    direct: targetListItem.getAttribute('direct') === 'true',
                }
            }));
        }
    }
    handleSearchInstancesRange() {
    }
    hide() {
        // wait a bit.
        // if you don't wait, the user will see all accordions closing before the menu disappear
        setTimeout(() => {
            var _a;
            (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(`gscape-entity-list-item[asaccordion]`).forEach((listItemAccordion) => listItemAccordion.closeAccordion());
        }, 500);
        super.hide();
    }
    attachTo(element) {
        this.popperRef = element;
        super.attachTo(element);
    }
    get objectProperties() {
        return this._objectProperties;
    }
    set objectProperties(newObjectProperties) {
        this._objectProperties = newObjectProperties.map(op => {
            op.connectedClasses.sort((a, b) => a.entityViewData.displayedName.localeCompare(b.entityViewData.displayedName));
            return op;
        }).sort((a, b) => a.entityViewData.displayedName.localeCompare(b.entityViewData.displayedName));
        this.requestUpdate();
    }
    updated() {
        if (this.popperRef)
            this.attachTo(this.popperRef);
    }
}
GscapeNavigationMenu.properties = {
    objectProperties: { type: Object },
    objectPropertiesRanges: { type: Object },
    canShowObjectPropertiesRanges: { type: Boolean },
};
GscapeNavigationMenu.styles = [
    baseStyle$3,
    menuBaseStyle,
    i$1 `
      .connected-class-wrapper, .object-property-wrapper {
        display: flex;
        justify-content: space-between;
      }
    `
];
customElements.define('gscape-navigation-menu', GscapeNavigationMenu);

function NavigationMenuFactory(incrementalController) {
    const navigationMenu = new GscapeNavigationMenu();
    incrementalController.grapholscape.widgets.set(WidgetEnum$1.NAVIGATION_MENU, navigationMenu);
    navigationMenu.requestUpdate();
    navigationMenu.addEventListener('onclassselection', (e) => {
        if (!e.detail.rangeClassIri)
            return;
        e.detail.direct
            ? incrementalController.addIntensionalObjectProperty(e.detail.objectPropertyIri, e.detail.referenceClassIri, e.detail.rangeClassIri)
            : incrementalController.addIntensionalObjectProperty(e.detail.objectPropertyIri, e.detail.rangeClassIri, e.detail.referenceClassIri);
        setTimeout(() => {
            const nodeId = incrementalController.getIDByIRI(e.detail.rangeClassIri, TypesEnum.CLASS);
            if (nodeId) {
                incrementalController.grapholscape.centerOnElement(nodeId);
            }
        }, 250);
        navigationMenu.popperRef = undefined;
        navigationMenu.hide();
    });
    navigationMenu.addEventListener('onobjectpropertyselection', (e) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const instancesExplorer = incrementalController.grapholscape.widgets.get(WidgetEnum$1.INSTANCES_EXPLORER);
        if (instancesExplorer) {
            const referenceEntity = incrementalController.classInstanceEntities.get(e.detail.referenceClassIri); // must be an instance to be here
            const objectPropertyEntity = incrementalController.grapholscape.ontology.getEntity(e.detail.objectPropertyIri);
            if (referenceEntity &&
                objectPropertyEntity &&
                !(((_a = instancesExplorer.referenceEntity) === null || _a === void 0 ? void 0 : _a.value.iri.equals(referenceEntity.iri)) &&
                    ((_b = instancesExplorer.referencePropertyEntity) === null || _b === void 0 ? void 0 : _b.value.iri.equals(objectPropertyEntity.iri)))) {
                navigationMenu.hide();
                instancesExplorer.clear();
                instancesExplorer.areInstancesLoading = true;
                instancesExplorer.referenceEntity = navigationMenu.referenceEntity;
                instancesExplorer.referenceEntityType = navigationMenu.referenceEntityType;
                instancesExplorer.referencePropertyEntity = grapholEntityToEntityViewData(objectPropertyEntity, incrementalController.grapholscape);
                instancesExplorer.isPropertyDirect = e.detail.direct;
                // const dataProperties = await incrementalController.getDataPropertiesByClassInstance(referenceEntity.iri.fullIri)
                // instancesExplorer.searchFilterList = dataProperties
                //   .map(dp => grapholEntityToEntityViewData(dp, incrementalController.grapholscape))
                //   .sort((a, b) => a.displayedName.localeCompare(b.displayedName))
                instancesExplorer.classTypeFilterList = (_c = navigationMenu.objectProperties
                    .find(op => op.entityViewData.value.iri.equals(e.detail.objectPropertyIri))) === null || _c === void 0 ? void 0 : _c.connectedClasses;
                // if only one related class for this object property, then retrieve data properties for this related class
                // as it will be selected by default
                if (((_d = instancesExplorer.classTypeFilterList) === null || _d === void 0 ? void 0 : _d.length) === 1) {
                    const hasUnfoldings = (_f = (_e = incrementalController.endpointController) === null || _e === void 0 ? void 0 : _e.highlightsManager) === null || _f === void 0 ? void 0 : _f.hasUnfoldings.bind(incrementalController.endpointController.highlightsManager);
                    instancesExplorer.propertiesFilterList = (yield incrementalController
                        .getDataPropertiesByClasses([instancesExplorer.classTypeFilterList[0].entityViewData.value.iri.fullIri]))
                        .map(dp => getEntityViewDataUnfolding(dp, incrementalController.grapholscape, hasUnfoldings));
                }
                instancesExplorer.requestId = yield ((_g = incrementalController.endpointController) === null || _g === void 0 ? void 0 : _g.requestInstancesThroughObjectProperty(referenceEntity.iri.fullIri, e.detail.objectPropertyIri, e.detail.direct, true, e.detail.rangeClassIri ? [e.detail.rangeClassIri] : undefined));
                if (instancesExplorer.requestId) {
                    (_j = (_h = incrementalController
                        .endpointController) === null || _h === void 0 ? void 0 : _h.shouldQueryUseLabels(instancesExplorer.requestId)) === null || _j === void 0 ? void 0 : _j.then((shouldAskForLabels) => __awaiter(this, void 0, void 0, function* () {
                        var _k;
                        if (!shouldAskForLabels) {
                            instancesExplorer.shouldAskForLabels = shouldAskForLabels;
                            instancesExplorer.areInstancesLoading = true;
                            instancesExplorer.requestId = yield ((_k = incrementalController.endpointController) === null || _k === void 0 ? void 0 : _k.requestInstancesThroughObjectProperty(referenceEntity.iri.fullIri, e.detail.objectPropertyIri, e.detail.direct, shouldAskForLabels, e.detail.rangeClassIri ? [e.detail.rangeClassIri] : undefined));
                        }
                    }));
                }
            }
            if (navigationMenu.popperRef) {
                showMenu(instancesExplorer, incrementalController);
            }
        }
    }));
    navigationMenu.tippyWidget.setProps({
        onHide: () => onHideMenu(navigationMenu, incrementalController),
    });
    return navigationMenu;
}

function moveUpLeft(widget) {
    widget.style.transition = 'all 0.5s';
    widget.style.top = '10px';
    widget.style.left = '10px';
    widget.style.transform = 'unset';
    widget.style.width = '20%';
    widget['sideMenuMode'] = true;
}
function restorePosition(widget) {
    widget.style.removeProperty('top');
    widget.style.removeProperty('left');
    widget.style.removeProperty('transform');
    widget.style.removeProperty('width');
    widget['sideMenuMode'] = false;
    setTimeout(() => {
        widget.style.removeProperty('transition');
    }, 500); // wait transition to end before removing it or no transition at all 
}

/** @internal */
class IncrementalController {
    constructor(grapholscape) {
        this.grapholscape = grapholscape;
        this.classInstanceEntities = new Map();
        this.diagram = new IncrementalDiagram();
        this.actionsWithBlockedGraph = 0;
        this.counts = new Map();
        this.countersEnabled = true;
        this.lifecycle = new IncrementalLifecycle();
        this.on = this.lifecycle.on;
        /**
         * Callback called when user click on data lineage command
         */
        this.onShowDataLineage = () => { };
        // runLayout = () => {
        //   this.incrementalRenderer?.runLayout()
        // }
        this.pinNode = (node) => { var _a; return (_a = this.incrementalRenderer) === null || _a === void 0 ? void 0 : _a.pinNode(node); };
        this.unpinNode = (node) => { var _a; return (_a = this.incrementalRenderer) === null || _a === void 0 ? void 0 : _a.unpinNode(node); };
        this.setIncrementalEventHandlers();
        this.diagramBuilder = new DiagramBuilder(this.diagram, RendererStatesEnum.INCREMENTAL);
        this.addEdge = this.diagramBuilder.addEdge.bind(this.diagramBuilder);
        this.neighbourhoodFinder = new NeighbourhoodFinder(this.ontology);
        // update instances displayed names
        grapholscape.on(LifecycleEvent.EntityNameTypeChange, _ => {
            this.classInstanceEntities.forEach(instanceEntity => this.updateEntityNameType(instanceEntity.iri));
        });
        grapholscape.on(LifecycleEvent.LanguageChange, newLang => {
            var _a;
            (_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.setLanguage(newLang);
            // update labels language only if they are actually visible
            if (grapholscape.entityNameType === RDFGraphConfigEntityNameTypeEnum.LABEL)
                this.classInstanceEntities.forEach(instanceEntity => this.updateEntityNameType(instanceEntity.iri));
        });
    }
    showDiagram(viewportState) {
        if (viewportState)
            this.diagram.lastViewportState = viewportState;
        setGraphEventHandlers(this.diagram, this.grapholscape.lifecycle, this.grapholscape.ontology);
        this.grapholscape.renderer.render(this.diagram);
    }
    performActionWithBlockedGraph(action, customLayoutOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.actionsWithBlockedGraph += 1;
            const oldElemNumbers = this.numberOfElements;
            (_a = this.incrementalRenderer) === null || _a === void 0 ? void 0 : _a.freezeGraph();
            yield action();
            this.actionsWithBlockedGraph -= 1;
            this.postDiagramEdit(oldElemNumbers, customLayoutOptions);
        });
    }
    /**
     * @internal
     *
     * Create new EndpointApi object with current mastro request options
     */
    setMastroConnection(mastroRequestOptions) {
        this.reset();
        if (!mastroRequestOptions.onError) {
            mastroRequestOptions.onError = (error) => console.error(error);
        }
        this.endpointController = new EndpointController(mastroRequestOptions, this.lifecycle);
        this.endpointController.setLanguage(this.grapholscape.language);
        this.lifecycle.trigger(IncrementalEvent.ReasonerSet);
    }
    /**
     * Inject in the current diagram the results from a construct query in RDFGraph form.
     * Here we assume entities are already in the loaded ontology.
     * If grapholscape is started right away with construct results, then the function
     * performing the init must take care of loading all the entities beforehand.
     * The only entities that will be loaded here are instance entities (individuals).
     * @param rdfGraph the graph to add to current vkg instance
     * @returns
     */
    addRDFGraph(rdfGraph) {
        if (!this.diagram.representation) {
            return;
        }
        const addElemToIncremental = (elem, rdfGraphRepr) => {
            let entity;
            if (isGrapholEdge(elem)) {
                elem.id = this.diagramBuilder.getNewId('edge');
            }
            if (elem.iri) {
                if (isGrapholNode(elem)) {
                    elem.originalId = this.diagramBuilder.getNewId('node');
                }
                entity = this.classInstanceEntities.get(elem.iri) || this.ontology.getEntity(elem.iri);
            }
            elem.diagramId = this.diagram.id;
            if (entity && elem.iri) {
                switch (elem.type) {
                    case TypesEnum.CLASS_INSTANCE:
                        this.diagramBuilder.addClassInstance(entity, elem);
                        break;
                    case TypesEnum.OBJECT_PROPERTY:
                        // Here we can be sure to find source and target cause nodes are added before edges, and
                        // object properties are always edges in vkg.
                        const source = rdfGraphRepr.grapholElements.get(elem.sourceId);
                        const target = rdfGraphRepr.grapholElements.get(elem.targetId);
                        let sourceEntity, targetEntity;
                        if ((source === null || source === void 0 ? void 0 : source.iri) && (target === null || target === void 0 ? void 0 : target.iri)) {
                            if (source.is(TypesEnum.CLASS_INSTANCE) && target.is(TypesEnum.CLASS_INSTANCE)) {
                                sourceEntity = this.classInstanceEntities.get(source.iri);
                                targetEntity = this.classInstanceEntities.get(target.iri);
                            }
                            else if (source.is(TypesEnum.CLASS) && target.is(TypesEnum.CLASS)) {
                                sourceEntity = this.ontology.getEntity(source.iri);
                                targetEntity = this.ontology.getEntity(target.iri);
                            }
                            else {
                                return;
                            }
                            if (sourceEntity && targetEntity)
                                this.diagramBuilder.addObjectProperty(entity, sourceEntity, targetEntity, source.type, elem);
                        }
                        break;
                    case TypesEnum.CLASS:
                        this.diagramBuilder.addClass(entity, elem);
                        break;
                }
                this.updateEntityNameType(entity.iri.fullIri);
            }
        };
        const classInstanceEntities = getClassInstances(rdfGraph, this.grapholscape.ontology.namespaces);
        classInstanceEntities.forEach((instanceEntity, iri) => {
            if (!this.classInstanceEntities.get(iri))
                this.classInstanceEntities.set(iri, instanceEntity);
        });
        const diagram = getDiagrams(rdfGraph, this.grapholscape.ontology, this.classInstanceEntities, RendererStatesEnum.INCREMENTAL)[0];
        if (diagram) {
            const diagramRepr = diagram.representations.get(RendererStatesEnum.INCREMENTAL);
            this.performActionWithBlockedGraph(() => {
                let elem;
                diagramRepr === null || diagramRepr === void 0 ? void 0 : diagramRepr.cy.nodes().forEach(node => {
                    elem = diagramRepr.grapholElements.get(node.id());
                    if (elem)
                        addElemToIncremental(elem, diagramRepr);
                });
                diagramRepr === null || diagramRepr === void 0 ? void 0 : diagramRepr.cy.edges().forEach(edge => {
                    elem = diagramRepr.grapholElements.get(edge.id());
                    if (elem)
                        addElemToIncremental(elem, diagramRepr);
                });
            }, {
                centerGraph: true,
                boundingBox: {
                    x1: 0,
                    y1: 0,
                    h: ((diagramRepr === null || diagramRepr === void 0 ? void 0 : diagramRepr.grapholElements.size) || 10) * 5,
                    w: ((diagramRepr === null || diagramRepr === void 0 ? void 0 : diagramRepr.grapholElements.size) || 10) * 5,
                },
                randomize: true,
                fit: true,
            });
        }
    }
    /**
     * Given source instance and target instance IRIs and a path to traverse,
     * add to the diagram the set of instances/object properties resulting
     * from the CONSTRUCT query over the path.
     */
    addInstancesPath(sourceIri, targetIri, path) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const rdfGraph = yield ((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.requestInstancesPath(sourceIri, targetIri, path).catch(() => {
                console.log('aaah');
            }));
            if (rdfGraph) {
                this.addRDFGraph(rdfGraph);
            }
            else {
                showMessage('No results found', 'Info', this.grapholscape.uiContainer);
            }
        });
    }
    addClass(iri, centerOnIt = true, position) {
        var _a;
        const entity = this.grapholscape.ontology.getEntity(iri);
        let classNode;
        if (entity && this.diagram.representation) {
            classNode = this.diagramBuilder.addClass(entity, position);
            this.updateEntityNameType(entity.iri);
            if (entity.is(TypesEnum.CLASS))
                this.countInstancesForClass(iri, false);
        }
        else {
            const classNodeId = this.getIDByIRI(iri, TypesEnum.CLASS);
            if (classNodeId)
                classNode = (_a = this.diagram.representation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(classNodeId);
        }
        if (centerOnIt && classNode)
            this.grapholscape.centerOnElement(classNode.id);
        return classNode;
    }
    areHierarchiesVisible(hierarchies) {
        var _a;
        let result = true;
        for (let hierarchy of hierarchies) {
            if (hierarchy.id && ((_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(hierarchy.id).empty())) {
                result = false;
                break;
            }
        }
        return result;
    }
    areAllConnectedClassesVisibleForClass(classIri, connectedClassesIris, positionType) {
        var _a;
        let subClassEntity;
        let subClassNode;
        let connectedEdges;
        for (let subClassIri of connectedClassesIris) {
            subClassEntity = this.grapholscape.ontology.getEntity(subClassIri);
            if (subClassEntity) {
                subClassNode = subClassEntity.getOccurrenceByType(TypesEnum.CLASS, RendererStatesEnum.INCREMENTAL);
                if (subClassNode) {
                    connectedEdges = (_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(subClassNode.id).connectedEdges(`[ type ="${positionType === 'equivalent' ? TypesEnum.EQUIVALENCE : TypesEnum.INCLUSION}" ]`);
                    if (connectedEdges) {
                        if (positionType === 'sub' && connectedEdges.targets(`[iri = "${classIri}"]`).empty())
                            return false;
                        if (positionType === 'super' && connectedEdges.sources(`[iri = "${classIri}"]`).empty())
                            return false;
                        if (positionType === 'equivalent' && connectedEdges.connectedNodes(`[iri = "${classIri}"]`).empty())
                            return false;
                    }
                }
                else {
                    return false;
                }
            }
        }
        return true;
    }
    reset() {
        var _a, _b;
        (_a = this.incrementalRenderer) === null || _a === void 0 ? void 0 : _a.reset();
        this.classInstanceEntities.clear();
        let clearedEntities = [];
        (_b = this.diagram.representation) === null || _b === void 0 ? void 0 : _b.grapholElements.forEach(elem => {
            if (elem.iri && !clearedEntities.includes(elem.iri) && elem.type !== TypesEnum.CLASS_INSTANCE) {
                const entity = this.grapholscape.ontology.getEntity(elem.iri);
                if (entity) {
                    entity.occurrences.set(RendererStatesEnum.INCREMENTAL, []);
                }
                clearedEntities.push(elem.iri);
            }
        });
        clearedEntities = [];
        this.diagram.clear();
        this.clearState();
        this.lifecycle.trigger(IncrementalEvent.Reset);
    }
    clearState() {
        var _a;
        (_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.clear();
    }
    updateEntityNameType(iri) {
        let entityIri;
        if (typeof (iri) !== 'string') {
            entityIri = iri.fullIri;
        }
        else {
            entityIri = iri;
        }
        const entity = this.classInstanceEntities.get(entityIri) || this.ontology.getEntity(entityIri);
        // let entityElement = this.diagram.representation?.grapholElements.get(entityIri)
        if (entity) {
            let entityOccurrences = entity.occurrences.get(RendererStatesEnum.INCREMENTAL);
            if (entityOccurrences) {
                // set the displayed name based on current entity name type
                entityOccurrences.forEach(element => {
                    var _a, _b;
                    element.displayedName = entity.getDisplayedName(this.grapholscape.entityNameType, this.grapholscape.language);
                    (_b = (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.representation) === null || _b === void 0 ? void 0 : _b.updateElement(element, false);
                });
            }
        }
    }
    removeEntity(entityOrIri, entitiesIrisToKeep = []) {
        let entity;
        if (typeof (entityOrIri) === 'string') {
            entity = this.classInstanceEntities.get(entityOrIri) || this.ontology.getEntity(entityOrIri);
        }
        else {
            entity = entityOrIri;
        }
        this.performActionWithBlockedGraph(() => {
            var _a;
            (_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$(`[iri = "${entity === null || entity === void 0 ? void 0 : entity.iri.fullIri}"]`).forEach(element => {
                var _a, _b, _c;
                // start from object properties connected to this entity, remove their occurrences from ontology entities
                const edges = element.connectedEdges(`[type = "${TypesEnum.OBJECT_PROPERTY}"]`);
                edges.forEach(objectPropertyEdge => {
                    var _a;
                    const objectPropertyEntity = this.ontology.getEntity(objectPropertyEdge.data().iri);
                    if (objectPropertyEntity) {
                        const grapholOccurrence = (_a = this.diagram.representation) === null || _a === void 0 ? void 0 : _a.grapholElements.get(objectPropertyEdge.id());
                        if (grapholOccurrence) {
                            objectPropertyEntity.removeOccurrence(grapholOccurrence, RendererStatesEnum.INCREMENTAL);
                        }
                    }
                });
                if (element.data().type === TypesEnum.CLASS) {
                    element.neighborhood().forEach(neighbourElement => {
                        if (neighbourElement.isNode()) {
                            // remove nodes only if they have 1 connection, i.e. with the class we want to remove
                            if (neighbourElement.degree(false) === 1 && !entitiesIrisToKeep.includes(neighbourElement.data().iri)) {
                                if (neighbourElement.data().iri) {
                                    // it's an entity, recursively remove entities
                                    entitiesIrisToKeep.push((entity === null || entity === void 0 ? void 0 : entity.iri.fullIri) || ''); // the entity we are removing must be skipped, otherwise cyclic recursion
                                    this.removeEntity(neighbourElement.data().iri, entitiesIrisToKeep);
                                }
                                else {
                                    this.diagram.removeElement(neighbourElement.id());
                                }
                            }
                        }
                        else {
                            // edges must be removed anyway
                            // (cytoscape removes them automatically
                            // but we need to update the grapholElements 
                            // map in diagram representation and entity occurrences)
                            this.diagram.removeElement(neighbourElement.id());
                        }
                    });
                    (_a = this.ontology.hierarchiesBySubclassMap.get(entity.iri.fullIri)) === null || _a === void 0 ? void 0 : _a.forEach(hierarchy => {
                        this.removeHierarchy(hierarchy);
                    });
                    (_b = this.ontology.hierarchiesBySuperclassMap.get(entity.iri.fullIri)) === null || _b === void 0 ? void 0 : _b.forEach(hierarchy => {
                        this.removeHierarchy(hierarchy);
                    });
                }
                const grapholOccurrence = (_c = this.diagram.representation) === null || _c === void 0 ? void 0 : _c.grapholElements.get(element.id());
                if (grapholOccurrence) {
                    entity === null || entity === void 0 ? void 0 : entity.removeOccurrence(grapholOccurrence, RendererStatesEnum.INCREMENTAL);
                }
                this.diagram.removeElement(element.id());
                if (entity === null || entity === void 0 ? void 0 : entity.is(TypesEnum.CLASS_INSTANCE))
                    this.classInstanceEntities.delete(entity.iri.fullIri);
            });
        });
    }
    addInstance(instance, parentClassesIris, position) {
        var _a, _b;
        let classInstanceEntity = this.classInstanceEntities.get(instance.iri);
        // if not already present, then build classInstanceEntity and add it to diagram
        if (!classInstanceEntity) {
            const classInstanceIri = new Iri(instance.iri, this.ontology.namespaces, instance.shortIri);
            classInstanceEntity = new ClassInstanceEntity(classInstanceIri);
            if (instance.label) {
                classInstanceEntity.addAnnotation(new Annotation(AnnotationProperty.label, instance.label.value, instance.label.language));
            }
            (_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.requestLabels(instance.iri).then(labels => {
                labels === null || labels === void 0 ? void 0 : labels.forEach(label => {
                    classInstanceEntity.addAnnotation(new Annotation(AnnotationProperty.label, label.value, label.language));
                });
                this.updateEntityNameType(classInstanceEntity.iri);
            });
            this.classInstanceEntities.set(instance.iri, classInstanceEntity);
        }
        this.diagramBuilder.addClassInstance(classInstanceEntity, position);
        // update parent class Iri
        if (typeof (parentClassesIris) !== 'string') {
            if (!parentClassesIris || parentClassesIris.length === 0) {
                parentClassesIris = this.ontology.getEntitiesByType(TypesEnum.CLASS).map(entity => entity.iri.fullIri);
            }
            (_b = this.endpointController) === null || _b === void 0 ? void 0 : _b.instanceCheck(instance.iri, parentClassesIris).then(result => {
                result.forEach(classIri => {
                    const classEntity = this.ontology.getEntity(classIri);
                    if (classEntity && classInstanceEntity) {
                        classInstanceEntity.addParentClass(classEntity.iri);
                    }
                });
            });
        }
        else {
            const parentClassEntity = this.ontology.getEntity(parentClassesIris);
            if (parentClassEntity)
                classInstanceEntity.addParentClass(parentClassEntity.iri);
        }
        this.updateEntityNameType(classInstanceEntity.iri);
        this.lifecycle.trigger(IncrementalEvent.DiagramUpdated);
        return classInstanceEntity;
    }
    /**
     * Add object property edge between two classes.
     * @param objectPropertyIri the object property iri to add
     * @param sourceClassIri
     * @param targetClassIri
     */
    addIntensionalObjectProperty(objectPropertyIri, sourceClassIri, targetClassIri) {
        const objectPropertyEntity = this.ontology.getEntity(objectPropertyIri);
        const sourceClass = this.ontology.getEntity(sourceClassIri);
        const targetClass = this.ontology.getEntity(targetClassIri);
        let objectPropertyEdge;
        if (objectPropertyEntity && sourceClass && targetClass) {
            objectPropertyEdge = this.diagramBuilder.addObjectProperty(objectPropertyEntity, sourceClass, targetClass, TypesEnum.CLASS);
            this.updateEntityNameType(objectPropertyEntity.iri);
            this.updateEntityNameType(sourceClassIri);
            this.updateEntityNameType(targetClassIri);
            this.countInstancesForClass(sourceClassIri, false);
            this.countInstancesForClass(targetClassIri, false);
            return objectPropertyEdge;
        }
    }
    /**
     * Add object property edge between two instances
     * @param objectPropertyIri
     * @param sourceInstanceIri
     * @param targetInstanceIri
     */
    addExtensionalObjectProperty(objectPropertyIri, sourceInstanceIri, targetInstanceIri) {
        const objectPropertyEntity = this.ontology.getEntity(objectPropertyIri);
        const sourceInstanceEntity = this.classInstanceEntities.get(sourceInstanceIri);
        const targetInstanceEntity = this.classInstanceEntities.get(targetInstanceIri);
        if (objectPropertyEntity && sourceInstanceEntity && targetInstanceEntity) {
            this.diagramBuilder.addObjectProperty(objectPropertyEntity, sourceInstanceEntity, targetInstanceEntity, TypesEnum.CLASS_INSTANCE);
            this.updateEntityNameType(objectPropertyEntity.iri);
            this.updateEntityNameType(sourceInstanceEntity.iri);
            this.updateEntityNameType(targetInstanceEntity.iri);
        }
    }
    /**
     * Shows the domain/range types of an extensional object property
     * hence only if object property connects two instances, shows their rdf:types
     * and add the intensional object property between them.
     * @param objectPropertyIri
     * @param sourceClassInstanceIri
     * @param targetClassInstanceIri
     */
    showObjectPropertyTypes(objectPropertyIri, sourceClassInstanceIri, targetClassInstanceIri) {
        const sourceClassInstanceEntity = this.classInstanceEntities.get(sourceClassInstanceIri);
        const targetClassInstanceEntity = this.classInstanceEntities.get(targetClassInstanceIri);
        if (sourceClassInstanceEntity && targetClassInstanceEntity) {
            let sourceParentClassId;
            let targetParentClassId;
            let sourceClassInstanceId;
            let targetClassInstanceId;
            this.performActionWithBlockedGraph(() => {
                sourceClassInstanceEntity.parentClassIris.forEach(sourceParentClassIri => {
                    targetClassInstanceEntity.parentClassIris.forEach(targetParentClassIri => {
                        sourceClassInstanceId = this.getIDByIRI(sourceClassInstanceIri, TypesEnum.CLASS_INSTANCE);
                        sourceParentClassId = this.getIDByIRI(sourceParentClassIri.fullIri, TypesEnum.CLASS);
                        targetClassInstanceId = this.getIDByIRI(targetClassInstanceIri, TypesEnum.CLASS_INSTANCE);
                        targetParentClassId = this.getIDByIRI(targetParentClassIri.fullIri, TypesEnum.CLASS);
                        if (sourceParentClassId && targetParentClassId && sourceClassInstanceId && targetClassInstanceId) {
                            this.addIntensionalObjectProperty(objectPropertyIri, sourceParentClassIri.fullIri, targetParentClassIri.fullIri);
                            this.addEdge(sourceClassInstanceId, sourceParentClassId, TypesEnum.INSTANCE_OF);
                            this.addEdge(targetClassInstanceId, targetParentClassId, TypesEnum.INSTANCE_OF);
                        }
                    });
                });
            });
        }
    }
    /**
     * Show hierarchies for which the specified class is a subclass.
     * @param classIri
     */
    showSuperHierarchiesOf(classIri) {
        this.showOrHideHierarchies(classIri, 'super', 'show');
    }
    /**
     * Show hierarchies for which the specified class is a superclass.
     * @param classIri
     */
    showSubHierarchiesOf(classIri) {
        this.showOrHideHierarchies(classIri, 'sub', 'show');
    }
    /**
     * Hide hierarchies for which the specified class is a subClass (i.e. an input class).
     * Hierarchies are pre-computed, after the floaty-transformation is performed.
     * @param classIri
     */
    hideSuperHierarchiesOf(classIri) {
        this.showOrHideHierarchies(classIri, 'super', 'hide');
    }
    /**
     * Show hierarchies for which the specified class is a superclass (i.e. an input class).
     * Hierarchies are pre-computed, after the floaty-transformation is performed.
     * @param classIri
     */
    hideSubHierarchiesOf(classIri) {
        this.showOrHideHierarchies(classIri, 'sub', 'hide');
    }
    showOrHideHierarchies(classIri, hierarchyType, showORHide) {
        const classEntity = this.ontology.getEntity(classIri);
        if (!classEntity)
            return;
        let hierarchies;
        const sub = this.ontology.hierarchiesBySuperclassMap.get(classIri); // get hiearchies with class being a superclass => get sub classes
        const superh = this.ontology.hierarchiesBySubclassMap.get(classIri); // get hierarchies with class being a subclass => get super classes
        switch (hierarchyType) {
            case 'super':
                hierarchies = superh;
                break;
            case 'sub':
                hierarchies = sub;
                break;
            case 'any':
                hierarchies = [];
                if (sub)
                    hierarchies.concat(sub);
                if (superh)
                    hierarchies.concat(superh);
                break;
            default:
                return;
        }
        if (hierarchies && hierarchies.length > 0) {
            this.performActionWithBlockedGraph(() => {
                var _a;
                const classId = this.getIDByIRI(classIri, TypesEnum.CLASS);
                if (classId) {
                    const position = (_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(classId).position();
                    if (showORHide === 'show')
                        hierarchies === null || hierarchies === void 0 ? void 0 : hierarchies.forEach(hierarchy => this.diagramBuilder.addHierarchy(hierarchy, position));
                    else
                        hierarchies === null || hierarchies === void 0 ? void 0 : hierarchies.forEach(hierarchy => this.removeHierarchy(hierarchy, [classIri]));
                }
            });
        }
    }
    // private addHierarchy(hierarchy: Hierarchy, position?: Position) {
    //   // const unionNode = hierarchy.getUnionGrapholNode(position)
    //   // const inputEdges = hierarchy.getInputGrapholEdges(this.diagram.id, RendererStatesEnum.INCREMENTAL)
    //   // const inclusionEdges = hierarchy.getInclusionEdges(this.diagram.id, RendererStatesEnum.INCREMENTAL)
    //   if (!hierarchy.id)
    //     return
    //   // Add inputs
    //   for (const inputClassIri of hierarchy.inputs) {
    //     this.addClass(inputClassIri.iri.fullIri, false)
    //   }
    //   for (const superClass of hierarchy.superclasses) {
    //     this.addClass(superClass.classEntity.iri.fullIri, false)
    //   }
    //   this.diagramBuilder.addHierarchy(hierarchy)
    //   // hierarchy.getInputGrapholEdges()?.forEach(inputEdge => this.diagram.addElement(inputEdge))
    //   // hierarchy.getInclusionEdges()?.forEach(inclusionEdge => this.diagram.addElement(inclusionEdge))
    // }
    removeHierarchy(hierarchy, entitiesTokeep = []) {
        var _a, _b, _c;
        if (!this.incrementalRenderer || !hierarchy.id || (hierarchy.id && ((_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(hierarchy.id).empty())))
            return;
        // remove union node
        this.diagram.removeElement(hierarchy.id);
        // remove input edges
        (_b = hierarchy.getInputGrapholEdges(this.diagram.id, RendererStatesEnum.INCREMENTAL)) === null || _b === void 0 ? void 0 : _b.forEach(inputEdge => {
            var _a;
            (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.removeElement(inputEdge.id);
        });
        // remove inclusion edges
        (_c = hierarchy.getInclusionEdges(this.diagram.id, RendererStatesEnum.INCREMENTAL)) === null || _c === void 0 ? void 0 : _c.forEach(inclusionEdge => {
            var _a;
            (_a = this.diagram) === null || _a === void 0 ? void 0 : _a.removeElement(inclusionEdge.id);
        });
        let classId;
        // remove input classes or superclasses left with no edges
        hierarchy.inputs.forEach(inputClass => {
            var _a;
            classId = this.getIDByIRI(inputClass.iri.fullIri, TypesEnum.CLASS);
            if (classId &&
                ((_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(classId).degree(false)) === 0 &&
                !entitiesTokeep.includes(inputClass.iri.fullIri)) {
                this.removeEntity(inputClass);
            }
        });
        hierarchy.superclasses.forEach(superclass => {
            var _a;
            classId = this.getIDByIRI(superclass.classEntity.iri.fullIri, TypesEnum.CLASS);
            if (classId &&
                ((_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.$id(classId).degree(false)) === 0 &&
                !entitiesTokeep.includes(superclass.classEntity.iri.fullIri)) {
                this.removeEntity(superclass.classEntity);
            }
        });
    }
    // ------------------------ SHOW CLASSES IN ISA ---------------------------------------
    showSubClassesOf(classIri, subclassesIris) {
        if (!subclassesIris) {
            subclassesIris = this.neighbourhoodFinder.getSubclassesIris(classIri);
        }
        this.showClassesInIsa(classIri, subclassesIris, TypesEnum.INCLUSION);
    }
    showSuperClassesOf(classIri, superclassesIris) {
        if (!superclassesIris) {
            superclassesIris = this.neighbourhoodFinder.getSuperclassesIris(classIri);
        }
        this.showClassesInIsa(classIri, superclassesIris, TypesEnum.INCLUSION, 'super');
    }
    showEquivalentClassesOf(classIri, equivalentClassesIris) {
        if (!equivalentClassesIris) {
            equivalentClassesIris = this.neighbourhoodFinder.getEquivalentClassesIris(classIri);
        }
        this.showClassesInIsa(classIri, equivalentClassesIris, TypesEnum.EQUIVALENCE);
    }
    showClassesInIsa(sourceIri, targetsIris, isaType, subOrSuper = 'sub') {
        const sourceId = this.getIDByIRI(sourceIri, TypesEnum.CLASS);
        if (sourceId) {
            this.performActionWithBlockedGraph(() => {
                let targetNode;
                targetsIris.forEach(targetIri => {
                    var _a, _b;
                    targetNode = this.addClass(targetIri, false);
                    if (targetNode) {
                        const cySource = (_a = this.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(sourceId);
                        const cyTarget = (_b = this.diagram.representation) === null || _b === void 0 ? void 0 : _b.cy.$id(targetNode.id);
                        if ((cySource === null || cySource === void 0 ? void 0 : cySource.nonempty()) && (cyTarget === null || cyTarget === void 0 ? void 0 : cyTarget.nonempty())) {
                            if (subOrSuper === 'super') {
                                const isEdgeAlreadyPresent = cySource.edgesTo(cyTarget)
                                    .filter(e => e.data().type === TypesEnum.INCLUSION ||
                                    e.data().type === TypesEnum.EQUIVALENCE)
                                    .nonempty();
                                if (!isEdgeAlreadyPresent) {
                                    this.diagramBuilder.addEdge(sourceId, targetNode.id, isaType);
                                }
                            }
                            else {
                                const isEdgeAlreadyPresent = cyTarget.edgesTo(cySource)
                                    .filter(e => e.data().type === TypesEnum.INCLUSION ||
                                    e.data().type === TypesEnum.EQUIVALENCE)
                                    .nonempty();
                                if (!isEdgeAlreadyPresent) {
                                    this.diagramBuilder.addEdge(targetNode.id, sourceId, isaType);
                                }
                            }
                        }
                    }
                });
            });
        }
    }
    /**
     * Given the iri of a class, retrieve connected object properties.
     * These object properties are inferred if the reasoner is available.
     * Otherwise only object properties directly asserted in the ontology
     * will be retrieved.
     * @param classIri
     * @returns
     */
    getObjectPropertiesByClasses(classIris) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.isReasonerAvailable()) {
                (_b = this.endpointController.highlightsManager) === null || _b === void 0 ? void 0 : _b.computeHighlights(classIris);
                const branches = yield ((_c = this.endpointController.highlightsManager) === null || _c === void 0 ? void 0 : _c.objectProperties());
                const objectPropertiesMap = new Map();
                branches === null || branches === void 0 ? void 0 : branches.forEach(branch => {
                    var _a;
                    if (!branch.objectPropertyIRI)
                        return;
                    const objectPropertyEntity = this.ontology.getEntity(branch.objectPropertyIRI);
                    if (!objectPropertyEntity)
                        return;
                    const connectedClasses = {
                        list: [],
                        direct: branch.direct || false,
                    };
                    (_a = branch.relatedClasses) === null || _a === void 0 ? void 0 : _a.forEach(relatedClass => {
                        const relatedClassEntity = this.ontology.getEntity(relatedClass);
                        if (relatedClassEntity) {
                            connectedClasses.list.push(relatedClassEntity);
                        }
                    });
                    objectPropertiesMap.set(objectPropertyEntity, connectedClasses);
                });
                return objectPropertiesMap;
            }
            else {
                return this.neighbourhoodFinder.getObjectProperties(classIris[0]);
            }
        });
    }
    getDataPropertiesByClasses(classIris) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.isReasonerAvailable()) {
                (_b = this.endpointController.highlightsManager) === null || _b === void 0 ? void 0 : _b.computeHighlights(classIris);
                const dataProperties = yield ((_c = this.endpointController.highlightsManager) === null || _c === void 0 ? void 0 : _c.dataProperties());
                return (dataProperties === null || dataProperties === void 0 ? void 0 : dataProperties.map(dp => this.ontology.getEntity(dp) || new GrapholEntity(new Iri(dp, this.ontology.namespaces))).filter(dpEntity => dpEntity !== undefined))
                    || [];
            }
            else {
                return this.neighbourhoodFinder.getDataProperties(classIris[0]);
            }
        });
    }
    getDataPropertiesByClassInstance(instanceIri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const instanceEntity = this.classInstanceEntities.get(instanceIri);
            if (instanceEntity && ((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.highlightsManager)) {
                this.endpointController.highlightsManager
                    .computeHighlights(instanceEntity.parentClassIris.map(i => i.fullIri));
                return (yield this.endpointController.highlightsManager.dataProperties())
                    .map(dp => this.ontology.getEntity(dp))
                    .filter(dpEntity => dpEntity !== null);
            }
            else {
                return [];
            }
        });
    }
    expandObjectPropertiesOnInstance(instanceIri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.isReasonerAvailable()) || !this.endpointController.vkgApi) {
                return;
            }
            const instanceEntity = this.classInstanceEntities.get(instanceIri);
            if (instanceEntity) {
                const objectProperties = yield this.getObjectPropertiesByClasses(instanceEntity.parentClassIris.map(iri => iri.fullIri));
                if (objectProperties) {
                    let promisesCount = 0;
                    this.lifecycle.trigger(IncrementalEvent.FocusStarted, instanceIri);
                    const results = new Map();
                    objectProperties.forEach((rangeClasses, objectPropertyEntity) => {
                        results.set(objectPropertyEntity, { ranges: [], isDirect: rangeClasses.direct });
                        rangeClasses.list.forEach(rangeClassEntity => {
                            promisesCount += 1;
                            this.endpointController.vkgApi.getInstancesThroughObjectProperty(instanceIri, objectPropertyEntity.iri.fullIri, rangeClasses.direct, false, (result) => {
                                var _a;
                                if (result.length > 0) {
                                    (_a = results.get(objectPropertyEntity)) === null || _a === void 0 ? void 0 : _a.ranges.push({
                                        classEntity: rangeClassEntity,
                                        classInstance: result[0][0]
                                    });
                                }
                            }, [rangeClassEntity.iri.fullIri], undefined, undefined, () => {
                                promisesCount -= 1;
                            }, 1);
                        });
                    });
                    const onDone = () => {
                        this.addResultsFromFocus(instanceIri, results);
                        this.lifecycle.trigger(IncrementalEvent.FocusFinished, instanceIri);
                    };
                    let interval = setInterval(() => {
                        if (promisesCount === 0) {
                            onDone();
                            clearInterval(interval);
                        }
                    }, 500);
                    setTimeout(() => {
                        if (promisesCount > 0) {
                            clearInterval(interval);
                            if (this.grapholscape.uiContainer) {
                                showMessage(`
                Focus instance [${instanceEntity.getDisplayedName(this.grapholscape.entityNameType, this.grapholscape.language)}] took too long, reached timeout limit.
                Partial results might be shown, ok?
              `, 'Timeout Reached', this.grapholscape.uiContainer)
                                    .onConfirm(onDone)
                                    .onCancel(() => this.lifecycle.trigger(IncrementalEvent.FocusFinished, instanceIri));
                            }
                        }
                    }, 10000);
                }
            }
        });
    }
    focusInstance(classInstance) {
        this.addInstance(classInstance);
        this.expandObjectPropertiesOnInstance(classInstance.iri);
    }
    addResultsFromFocus(sourceInstanceIri, results) {
        this.performActionWithBlockedGraph(() => {
            var _a;
            let addedClassNode;
            let addedClassInstanceEntity;
            let classInstanceId;
            let position;
            const sourceId = this.getIDByIRI(sourceInstanceIri, TypesEnum.CLASS_INSTANCE);
            if (sourceId) {
                position = (_a = this.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.$id(sourceId).position();
            }
            results.forEach((result, objectPropertyEntity) => {
                result.ranges.forEach(range => {
                    var _a;
                    addedClassInstanceEntity = this.addInstance(range.classInstance, range.classEntity.iri.fullIri, position);
                    classInstanceId = (_a = addedClassInstanceEntity.getOccurrenceByType(TypesEnum.CLASS_INSTANCE, RendererStatesEnum.INCREMENTAL)) === null || _a === void 0 ? void 0 : _a.id;
                    addedClassNode = this.addClass(range.classEntity.iri.fullIri);
                    if (classInstanceId && addedClassNode) {
                        this.addEdge(classInstanceId, addedClassNode.id, TypesEnum.INSTANCE_OF);
                        result.isDirect
                            ? this.addExtensionalObjectProperty(objectPropertyEntity.iri.fullIri, sourceInstanceIri, range.classInstance.iri)
                            : this.addExtensionalObjectProperty(objectPropertyEntity.iri.fullIri, range.classInstance.iri, sourceInstanceIri);
                    }
                });
            });
        });
    }
    addPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            this.performActionWithBlockedGraph(() => {
                var _a, _b, _c, _d, _e, _f;
                if (!this.diagram.representation)
                    return;
                let i = 0;
                let cyElems = this.diagram.representation.cy.collection();
                let elemId;
                let sourceClassIri, targetClassIri;
                for (let entity of path) {
                    if (entity.type === EntityTypeEnum.ObjectProperty || entity.type === EntityTypeEnum.InverseObjectProperty) {
                        if (!path[i + 1] || !path[i - 1])
                            return;
                        sourceClassIri = path[i - 1].iri;
                        targetClassIri = path[i + 1].iri;
                        if (!sourceClassIri || !targetClassIri)
                            return;
                        if (entity.iri === "http://www.w3.org/2000/01/rdf-schema#subClassOf") {
                            const sourceId = (_a = this.addClass(sourceClassIri)) === null || _a === void 0 ? void 0 : _a.id;
                            const targetId = (_b = this.addClass(targetClassIri)) === null || _b === void 0 ? void 0 : _b.id;
                            if (sourceId && targetId) {
                                if (entity.type === EntityTypeEnum.ObjectProperty)
                                    elemId = (_c = this.addEdge(sourceId, targetId, TypesEnum.INCLUSION)) === null || _c === void 0 ? void 0 : _c.id;
                                else
                                    elemId = (_d = this.addEdge(targetId, sourceId, TypesEnum.INCLUSION)) === null || _d === void 0 ? void 0 : _d.id;
                            }
                        }
                        else if (entity.iri) {
                            if (entity.type === EntityTypeEnum.ObjectProperty)
                                elemId = (_e = this.addIntensionalObjectProperty(entity.iri, sourceClassIri, targetClassIri)) === null || _e === void 0 ? void 0 : _e.id;
                            else
                                elemId = (_f = this.addIntensionalObjectProperty(entity.iri, targetClassIri, sourceClassIri)) === null || _f === void 0 ? void 0 : _f.id;
                        }
                        // create collection of elems to flash class and highlight them
                        if (elemId)
                            cyElems = cyElems.union(this.diagram.representation.cy.$id(elemId));
                        elemId = this.getIDByIRI(sourceClassIri, TypesEnum.CLASS);
                        if (elemId)
                            cyElems = cyElems.union(this.diagram.representation.cy.$id(elemId));
                        elemId = this.getIDByIRI(targetClassIri, TypesEnum.CLASS);
                        if (elemId)
                            cyElems = cyElems.union(this.diagram.representation.cy.$id(elemId));
                    }
                    i += 1;
                }
                // clear previous highlighting
                this.diagram.representation.cy.$('.path').removeClass('path');
                // highlight current path
                cyElems.addClass('path');
                // clear highlight at any tap
                this.diagram.representation.cy.one('tap', e => cyElems.removeClass('path'));
                setTimeout(() => { var _a; return (_a = this.diagram.representation) === null || _a === void 0 ? void 0 : _a.cy.fit(cyElems, 200); }, 500);
            });
        });
    }
    postDiagramEdit(oldElemsNumber, customLayoutOptions) {
        var _a, _b, _c;
        if (this.numberOfElements !== oldElemsNumber) {
            if (this.actionsWithBlockedGraph === 0) {
                customLayoutOptions
                    ? (_a = this.incrementalRenderer) === null || _a === void 0 ? void 0 : _a.runCustomLayout(customLayoutOptions)
                    : (_b = this.incrementalRenderer) === null || _b === void 0 ? void 0 : _b.runLayout();
            }
            this.lifecycle.trigger(IncrementalEvent.DiagramUpdated);
        }
        else {
            (_c = this.incrementalRenderer) === null || _c === void 0 ? void 0 : _c.unFreezeGraph();
        }
    }
    countInstancesForClass(classIri, askFreshValue = true) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.countersEnabled || !((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.isReasonerAvailable()))
                return;
            const nodeId = this.getIDByIRI(classIri, TypesEnum.CLASS);
            if (!nodeId)
                return;
            const node = (_c = (_b = this.diagram) === null || _b === void 0 ? void 0 : _b.representation) === null || _c === void 0 ? void 0 : _c.cy.$id(nodeId);
            if (!node || node.empty())
                return;
            yield this.updateMaterializedCounts();
            if (this.counts.get(classIri) === undefined) {
                if (askFreshValue)
                    (_d = this.endpointController) === null || _d === void 0 ? void 0 : _d.requestCountForClass(classIri);
            }
            else { // Value already present
                let instanceCountBadge;
                const countEntry = this.counts.get(classIri);
                if (!countEntry)
                    return;
                if (!node.scratch('instance-count')) {
                    instanceCountBadge = addBadge(node, countEntry.value, 'instance-count', 'bottom');
                    setTimeout(() => instanceCountBadge.hide(), 1000);
                    node.on('mouseover', () => {
                        if (this.countersEnabled)
                            instanceCountBadge.tippyWidget.show();
                    });
                    node.on('mouseout', () => instanceCountBadge.tippyWidget.hide());
                }
                else {
                    instanceCountBadge = node.scratch('instance-count');
                    instanceCountBadge.content = countEntry.value;
                }
                if (countEntry.materialized) {
                    instanceCountBadge.highlighted = false;
                    instanceCountBadge.title = `Date: ${countEntry.date}`;
                }
                else {
                    instanceCountBadge.highlighted = true;
                    instanceCountBadge.title = 'Fresh Value';
                }
            }
        });
    }
    updateMaterializedCounts() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const materializedCounts = yield ((_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.getMaterializedCounts());
            if (materializedCounts) {
                materializedCounts.countsMap.forEach(countEntry => {
                    var _a;
                    if (countEntry.state === QueryStatusEnum.FINISHED) {
                        const currentCount = this.counts.get(countEntry.entity.entityIRI);
                        if (!currentCount || currentCount.materialized) {
                            this.counts.set(countEntry.entity.entityIRI, {
                                value: countEntry.count,
                                materialized: true,
                                date: materializedCounts.endTime !== 0
                                    ? new Date(materializedCounts.endTime).toDateString()
                                    : new Date(materializedCounts.startTime).toDateString()
                            });
                            this.lifecycle.trigger(IncrementalEvent.NewCountResult, countEntry.entity.entityIRI, {
                                value: countEntry.count,
                                materialized: true,
                                date: (_a = this.counts.get(countEntry.entity.entityIRI)) === null || _a === void 0 ? void 0 : _a.date
                            });
                        }
                    }
                });
            }
        });
    }
    setIncrementalEventHandlers() {
        var _a, _b, _c, _d;
        if (((_a = this.diagram.representation) === null || _a === void 0 ? void 0 : _a.hasEverBeenRendered) || ((_b = this.diagram.representation) === null || _b === void 0 ? void 0 : _b.cy.scratch('_gscape-incremental-graph-handlers-set')))
            return;
        // const classOrInstanceSelector = `node[type = "${TypesEnum.CLASS}"], node[type = "${TypesEnum.CLASS_INSTANCE}"]`
        (_c = this.diagram.representation) === null || _c === void 0 ? void 0 : _c.cy.on('tap', evt => {
            const targetType = evt.target.data().type;
            if (targetType === TypesEnum.CLASS || targetType === TypesEnum.CLASS_INSTANCE) {
                const triggerSelectionEvent = () => {
                    var _a, _b;
                    // this.diagramBuilder.referenceNodeId = evt.target.id()
                    const targetIri = evt.target.data().iri;
                    if (targetType === TypesEnum.CLASS_INSTANCE) {
                        const instanceEntity = this.classInstanceEntities.get(targetIri);
                        if (instanceEntity) {
                            if (targetIri !== this.lastInstanceIri)
                                (_a = this.endpointController) === null || _a === void 0 ? void 0 : _a.stopRequests('instances');
                            this.lifecycle.trigger(IncrementalEvent.ClassInstanceSelection, instanceEntity);
                        }
                    }
                    else {
                        if (targetIri !== this.lastClassIri)
                            (_b = this.endpointController) === null || _b === void 0 ? void 0 : _b.stopRequests('instances');
                        const classEntity = this.grapholscape.ontology.getEntity(targetIri);
                        if (classEntity)
                            this.lifecycle.trigger(IncrementalEvent.ClassSelection, classEntity);
                    }
                };
                // In case of reasoning, perform update only after 500ms of no click by the user
                // Prevent query flooding
                if (this.endpointController) {
                    clearTimeout(this.entitySelectionTimeout);
                    this.entitySelectionTimeout = setTimeout(triggerSelectionEvent, 400);
                }
                else {
                    triggerSelectionEvent(); // otherwise no http-request will be made
                }
            }
        });
        (_d = this.diagram.representation) === null || _d === void 0 ? void 0 : _d.cy.scratch('_gscape-incremental-graph-handlers-set', true);
    }
    get ontology() { return this.grapholscape.ontology; }
    // public get incrementalDiagram() { return this.incrementalRenderer?.incrementalDiagram }
    get incrementalRenderer() {
        if (this.grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
            return this.grapholscape.renderer.renderState;
        }
    }
    getIDByIRI(iri, type) {
        var _a;
        const entity = this.classInstanceEntities.get(iri) || this.grapholscape.ontology.getEntity(iri);
        if (entity) {
            return (_a = entity.getOccurrenceByType(type, RendererStatesEnum.INCREMENTAL)) === null || _a === void 0 ? void 0 : _a.id;
        }
    }
    get numberOfElements() { var _a; return ((_a = this.grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.elements().size()) || 0; }
}

class IncrementalInitialMenu extends BaseMixin$3(s) {
    constructor(ic) {
        super();
        this.ic = ic;
        this.shortestPathMode = false;
        this.sideMenuMode = false;
        this.render = () => {
            return x `
      ${this.shortestPathMode
                ? x `
          <center><p class="bold-text">Find the shortest path between two classes</p></center>
          <div class="column-container">
            ${this.getTemplate(1, this.class1)}

            <div style="width: fit-content; margin: 20px auto;"><span class="dots bold-text">...</span>to<span class="dots bold-text">...</span></div>

            ${this.getTemplate(2, this.class2)}
          </div>
        `
                : x `
          <gscape-entity-selector
            .onClassSelection=${(iri) => this.handleClassSelection(iri)}
            .entityList=${this.classes}
          ></gscape-entity-selector>
        `}

      ${!this.sideMenuMode
                ? x `
          <gscape-button
            id="shortest-path-btn"
            label=${this.shortestPathMode ? `Single Class` : `Shortest Path`}
            @click=${this.handleShortestPathBtnClick}
          ></gscape-button>
        `
                : null}

      ${this.shortestPathMode && this.class1 && this.class2 ? x `
        <center>
          <gscape-button
            title="Find Shortest Path"
            type="primary"
            label="Confirm"
            @click=${this.handleConfirm}
          ></gscape-button>
        </center>
      ` : null}
    `;
        };
        this.classes = createEntitiesList(this.ic.grapholscape, { class: 1, areAllFiltersDisabled: false });
    }
    focusInputSearch() {
        var _a, _b;
        (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('gscape-entity-selector')) === null || _b === void 0 ? void 0 : _b.focusInputSearch();
    }
    closePanel() {
        var _a;
        let entitySelectors = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('gscape-entity-selector');
        entitySelectors === null || entitySelectors === void 0 ? void 0 : entitySelectors.forEach(entitySelector => entitySelector.closePanel());
        this.requestUpdate();
    }
    openPanel() {
        var _a;
        let entitySelectors = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('gscape-entity-selector');
        entitySelectors === null || entitySelectors === void 0 ? void 0 : entitySelectors.forEach(entitySelector => entitySelector.openPanel());
        this.requestUpdate();
    }
    getTemplate(id, entity) {
        return !entity
            ? x `
        <gscape-entity-selector
          .onClassSelection=${(iri) => this.handleClassSelection(iri, id)}
          .entityList=${this.classes}
        ></gscape-entity-selector>
      `
            : x `
        <div class="gscape-panel selected-entity-wrapper">
          <gscape-entity-list-item
            .types=${entity.value.types}
            displayedName=${entity.displayedName}
            iri=${entity.value.iri}
          >
          </gscape-entity-list-item>
          <gscape-button
            title="Clear"
            size=${SizeEnum$1.S}
            @click=${() => { this[`class${id}`] = undefined; }}
          >
            ${getIconSlot$1('icon', cross)}
          </gscape-button>
        </div>
      `;
    }
    handleShortestPathBtnClick() {
        this.shortestPathMode = !this.shortestPathMode;
        this.style.width = this.shortestPathMode ? '70%' : '40%';
    }
    handleClassSelection(iri, selectorId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const selectedClass = (_a = this.classes) === null || _a === void 0 ? void 0 : _a.find(c => c.value.iri.equals(iri));
            if (selectorId === 1) {
                this.class1 = selectedClass;
            }
            if (selectorId === 2) {
                this.class2 = selectedClass;
            }
            if (!this.shortestPathMode) {
                yield this.updateComplete;
                this.dispatchEvent(new CustomEvent('class-selection', {
                    bubbles: true,
                    composed: true,
                    detail: iri
                }));
            }
        });
    }
    handleConfirm() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.shortestPathMode && this.class1 && this.class2) {
                yield this.updateComplete;
                this.dispatchEvent(new CustomEvent('confirm-shortest-path', {
                    bubbles: true,
                    composed: true,
                    detail: {
                        sourceClassIri: this.class1.value.iri.fullIri,
                        targetClassIri: this.class2.value.iri.fullIri,
                    }
                }));
            }
        });
    }
}
IncrementalInitialMenu.properties = {
    class1: { type: Object, attribute: 'class1' },
    class2: { type: Object, attribute: 'class2' },
    shortestPathMode: { type: Boolean },
    sideMenuMode: { type: Boolean }
};
IncrementalInitialMenu.styles = [
    baseStyle$3,
    i$1 `
      :host {
        max-height: 70%;
        width: 40%;
        font-size: 14px;
        display: flex;
        flex-direction: column;
        top: 20%;
        left: 50%;
        transform: translate(-50%);
        position: absolute;
      }

      #shortest-path-btn {
        position: absolute;
        top: 200px;
        left: 50%;
        transform: translate(-50%);
      }

      gscape-entity-selector {
        display: block;
        z-index: 1;
      }

      .column-container {
        display: flex;
        gap: 36px;
      }

      .column-container > * {
        width: 40%
      }

      .dots {
        margin: 8px;
        position: relative;
        top: -3px;
      }

      .selected-entity-wrapper {
        display: flex;
        align-items: center;
        justify-content: space-between;
        height: fit-content;
        min-width: 200px;
        max-width: unset;
        box-sizing: border-box;
      }
    `,
];
customElements.define('incremental-initial-menu', IncrementalInitialMenu);

/** @internal */
function initIncremental(grapholscape) {
    var _a, _b;
    let incrementalController = new IncrementalController(grapholscape);
    grapholscape.incremental = incrementalController;
    // Create and initialize UI components
    ClassInstanceDetailsFactory(incrementalController);
    VKGPreferencesFactory(incrementalController);
    InstanceExplorerFactory(incrementalController);
    CommandsWidgetFactory(incrementalController);
    NodeButtonsFactory(incrementalController);
    NavigationMenuFactory(incrementalController);
    let initialMenu = incrementalController
        .grapholscape
        .widgets
        .get(WidgetEnum$1.INCREMENTAL_INITIAL_MENU);
    if (!initialMenu) {
        // initEntitySelector(incrementalController.grapholscape)
        initialMenu = new IncrementalInitialMenu(incrementalController);
        incrementalController.grapholscape.widgets.set(WidgetEnum$1.INCREMENTAL_INITIAL_MENU, initialMenu);
    }
    // entitySelector = grapholscape.widgets.get(WidgetEnum.ENTITY_SELECTOR) as GscapeEntitySelector
    (_a = incrementalController.grapholscape.uiContainer) === null || _a === void 0 ? void 0 : _a.appendChild(initialMenu);
    // entitySelector.hide()
    initialMenu.addEventListener('class-selection', (e) => {
        const randomPos = {
            x: Math.random() * 200,
            y: Math.random() * 200
        };
        incrementalController.addClass(e.detail, true, randomPos);
        grapholscape.selectElement(e.detail);
        moveUpLeft(initialMenu);
        initialMenu.closePanel();
    });
    initialMenu.addEventListener('confirm-shortest-path', (e) => __awaiter(this, void 0, void 0, function* () {
        var _c, _d;
        const path = yield ((_d = (_c = incrementalController.endpointController) === null || _c === void 0 ? void 0 : _c.highlightsManager) === null || _d === void 0 ? void 0 : _d.getShortestPath(e.detail.sourceClassIri, e.detail.targetClassIri));
        if (path && path[0].entities) {
            incrementalController.addPath(path[0].entities);
            initialMenu.shortestPathMode = false;
            moveUpLeft(initialMenu);
            initialMenu.closePanel();
        }
    }));
    if (grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
        grapholscape.renderer.unselect();
        manageWidgetsOnActivation(grapholscape.widgets, (_b = grapholscape.renderer.cy) === null || _b === void 0 ? void 0 : _b.elements().empty(), incrementalController.endpointController !== undefined);
    }
    else {
        manageWidgetsOnDeactivation(grapholscape.widgets);
    }
    // CORE's lifecycle reactions 
    grapholscape.on(LifecycleEvent.RendererChange, (rendererState) => {
        if (rendererState === RendererStatesEnum.INCREMENTAL) {
            onIncrementalStartup(grapholscape, incrementalController);
        }
        else {
            manageWidgetsOnDeactivation(grapholscape.widgets);
        }
    });
    incrementalController.on(IncrementalEvent.DiagramUpdated, () => {
        var _a;
        const initialMenu = grapholscape.widgets.get(WidgetEnum$1.INCREMENTAL_INITIAL_MENU);
        if ((_a = grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.elements().empty()) {
            onEmptyDiagram(grapholscape);
        }
        else {
            if (initialMenu) {
                moveUpLeft(initialMenu);
            }
        }
        const ontologyExplorer = grapholscape.widgets.get(WidgetEnum$1.ONTOLOGY_EXPLORER);
        if (ontologyExplorer) {
            ontologyExplorer.entities = createEntitiesList(grapholscape, ontologyExplorer.searchEntityComponent);
        }
    });
    incrementalController.on(IncrementalEvent.Reset, () => {
        var _a;
        if (incrementalController.grapholscape.renderState === RendererStatesEnum.INCREMENTAL) {
            manageWidgetsOnActivation(grapholscape.widgets, (_a = grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.elements().empty(), incrementalController.endpointController !== undefined);
            onEmptyDiagram(grapholscape);
        }
    });
}
function onIncrementalStartup(grapholscape, incrementalController) {
    var _a;
    grapholscape.renderer.unselect();
    // if (!incrementalController) {
    //   incrementalController = new IncrementalController(grapholscape)
    // }
    manageWidgetsOnActivation(grapholscape.widgets, (_a = grapholscape.renderer.cy) === null || _a === void 0 ? void 0 : _a.elements().empty(), incrementalController.endpointController !== undefined);
    // if (grapholscape.renderer.diagram)
    //   setGraphEventHandlers(grapholscape.renderer.diagram, grapholscape.lifecycle, grapholscape.ontology)
    // incrementalController.setIncrementalEventHandlers()
}
function manageWidgetsOnActivation(widgets, isCanvasEmpty = false, isReasonerAvailable) {
    const filtersWidget = widgets.get(WidgetEnum$1.FILTERS);
    const diagramSelector = widgets.get(WidgetEnum$1.DIAGRAM_SELECTOR);
    const initialMenu = widgets.get(WidgetEnum$1.INCREMENTAL_INITIAL_MENU);
    const classInstanceDetails = widgets.get(WidgetEnum$1.CLASS_INSTANCE_DETAILS);
    const vkgPreferences = widgets.get(WidgetEnum$1.VKG_PREFERENCES);
    const entityDetails = widgets.get(WidgetEnum$1.ENTITY_DETAILS);
    entityDetails.showOccurrences = false;
    classInstanceDetails === null || classInstanceDetails === void 0 ? void 0 : classInstanceDetails.enable();
    diagramSelector === null || diagramSelector === void 0 ? void 0 : diagramSelector.disable();
    initialMenu === null || initialMenu === void 0 ? void 0 : initialMenu.show();
    if (isCanvasEmpty && initialMenu) {
        restorePosition(initialMenu);
        initialMenu.focusInputSearch();
    }
    if (isReasonerAvailable)
        vkgPreferences === null || vkgPreferences === void 0 ? void 0 : vkgPreferences.enable();
    filtersWidget === null || filtersWidget === void 0 ? void 0 : filtersWidget.disable();
}
function manageWidgetsOnDeactivation(widgets) {
    const filtersWidget = widgets.get(WidgetEnum$1.FILTERS);
    const diagramSelector = widgets.get(WidgetEnum$1.DIAGRAM_SELECTOR);
    const initialMenu = widgets.get(WidgetEnum$1.INCREMENTAL_INITIAL_MENU);
    const classInstanceDetails = widgets.get(WidgetEnum$1.CLASS_INSTANCE_DETAILS);
    const vkgPreferences = widgets.get(WidgetEnum$1.VKG_PREFERENCES);
    const entityDetails = widgets.get(WidgetEnum$1.ENTITY_DETAILS);
    entityDetails.showOccurrences = true;
    classInstanceDetails === null || classInstanceDetails === void 0 ? void 0 : classInstanceDetails.disable();
    vkgPreferences === null || vkgPreferences === void 0 ? void 0 : vkgPreferences.disable();
    diagramSelector === null || diagramSelector === void 0 ? void 0 : diagramSelector.enable();
    initialMenu === null || initialMenu === void 0 ? void 0 : initialMenu.hide();
    filtersWidget === null || filtersWidget === void 0 ? void 0 : filtersWidget.enable();
}
function onEmptyDiagram(grapholscape) {
    var _a;
    const initialMenu = grapholscape.widgets.get(WidgetEnum$1.INCREMENTAL_INITIAL_MENU);
    (_a = grapholscape.widgets.get(WidgetEnum$1.ENTITY_DETAILS)) === null || _a === void 0 ? void 0 : _a.hide();
    if (initialMenu) {
        restorePosition(initialMenu);
        initialMenu.focusInputSearch();
    }
}

class FakeGrapholNode extends GrapholNode {
    constructor(originalNode) {
        super(originalNode.id, originalNode.type);
        Object.assign(this, originalNode);
        this.shape = Shape$1.POLYGON;
        this._fakeNodes = [];
    }
    getCytoscapeRepr(grapholEntity) {
        const result = super.getCytoscapeRepr(grapholEntity);
        result[0].selectable = false;
        result[0].classes += ' no_overlay';
        result[0].data.fake = true;
        delete result[0].data.id;
        delete result[0].data.displayedName;
        return result;
    }
}

class FakeCircle extends FakeGrapholNode {
    constructor(originalNode) {
        super(originalNode);
        this.shape = Shape$1.ELLIPSE;
        this.width = this.height;
    }
}
class FakeCircleRight extends FakeCircle {
    constructor(originalNode) {
        super(originalNode);
        this.x = originalNode.x + (originalNode.width / 2) - (this.width / 2);
    }
}
class FakeCircleLeft extends FakeCircle {
    constructor(originalNode) {
        super(originalNode);
        this.x = originalNode.x - (originalNode.width / 2) + (this.width / 2);
    }
}

class FakeRectangle extends FakeGrapholNode {
    constructor(originalNode) {
        super(originalNode);
        this.shape = Shape$1.RECTANGLE;
        this.width = this.width - this.height;
    }
}
class FakeRectangleFront extends FakeRectangle {
    constructor(originalNode) {
        super(originalNode);
        this.height -= 1;
    }
    getCytoscapeRepr(grapholEntity) {
        const result = super.getCytoscapeRepr(grapholEntity);
        result[0].classes += ' no_border';
        return result;
    }
}

class FakeTopRhomboid extends FakeGrapholNode {
    constructor(originalNode) {
        super(originalNode);
        this.shapePoints = '-0.9 -1 1 -1 0.95 0 -0.95 0';
        this.fillColor = '#dedede';
    }
    getCytoscapeRepr(grapholEntity) {
        const result = super.getCytoscapeRepr(grapholEntity);
        result[0].classes += ' fake-top-rhomboid';
        return result;
    }
}
class FakeBottomRhomboid extends FakeGrapholNode {
    constructor(originalNode) {
        super(originalNode);
        this.shapePoints = '-0.95 0 0.95 0 0.9 1 -1 1';
    }
    getCytoscapeRepr(grapholEntity) {
        const result = super.getCytoscapeRepr(grapholEntity);
        result[0].classes += ' fake-bottom-rhomboid';
        return result;
    }
}

class FakeTriangleLeft extends FakeGrapholNode {
    constructor(originalNode) {
        super(originalNode);
        this.width = this.width + 2;
        this.fillColor = '#fcfcfc';
        this.shapePoints = '0 -1 -1 0 0 1';
    }
    getCytoscapeRepr(grapholEntity) {
        const result = super.getCytoscapeRepr(grapholEntity);
        result[0].classes = ' fake-triangle';
        return result;
    }
}
class FakeTriangleRight extends FakeGrapholNode {
    constructor(originalNode) {
        super(originalNode);
        this.width = this.width + 2;
        this.fillColor = '#000';
        this.shapePoints = '0 -1 1 0 0 1';
    }
    getCytoscapeRepr(grapholEntity) {
        const result = super.getCytoscapeRepr(grapholEntity);
        result[0].classes += ' fake-triangle fake-triangle-right';
        return result;
    }
}

let warnings$1 = new Set();
function getOntologyInfo$1(xmlDocument) {
    var _a, _b;
    let xml_ontology_tag = xmlDocument.getElementsByTagName('ontology')[0];
    let ontology_name = ((_a = xml_ontology_tag.getElementsByTagName('name')[0]) === null || _a === void 0 ? void 0 : _a.textContent) || 'Undefined';
    let ontology_version = '';
    ontology_version = ((_b = xml_ontology_tag.getElementsByTagName('version')[0]) === null || _b === void 0 ? void 0 : _b.textContent) || 'Undefined';
    return new Ontology(ontology_name, ontology_version);
}
function getNamespaces$1(xmlDocument) {
    let result = [];
    if (xmlDocument.getElementsByTagName('IRI_prefixes_nodes_dict').length === 0) {
        // for old graphol files
        result.push(new Namespace([''], xmlDocument.getElementsByTagName('iri')[0].textContent || '', false));
    }
    else {
        let iri_prefixes;
        let iri_value, is_standard, prefixes, properties;
        let iris = xmlDocument.getElementsByTagName('iri');
        // Foreach iri create a Iri object
        for (let iri of iris) {
            iri_value = iri.getAttribute('iri_value');
            if (!iri_value)
                continue;
            is_standard = false;
            prefixes = iri.getElementsByTagName('prefix');
            iri_prefixes = [];
            for (let prefix of prefixes) {
                const prefixValue = prefix.getAttribute('prefix_value');
                if (prefixValue)
                    iri_prefixes.push(prefixValue);
            }
            if (iri_prefixes.length == 0)
                iri_prefixes.push('');
            // check if it's a standard iri
            properties = iri.getElementsByTagName('property');
            for (let property of properties) {
                is_standard = property.getAttribute('property_value') == 'Standard_IRI';
            }
            result.push(new Namespace(iri_prefixes, iri_value, is_standard));
        }
    }
    return result;
}
function getIri$1(element, ontology) {
    var _a;
    let labelElement = element.getElementsByTagName('label')[0];
    if (!labelElement)
        return undefined;
    let label = (_a = labelElement.textContent) === null || _a === void 0 ? void 0 : _a.replace(/\n/g, '');
    if (!label)
        return;
    let splitted_label = label.split(':');
    // if no ':' in label, then use empty prefix
    let node_prefix_iri = splitted_label.length > 1 ? splitted_label[0] : '';
    // facets
    if (node_prefix_iri.search(/"[\w]+"\^\^[\w]+:/) != -1) {
        node_prefix_iri = node_prefix_iri.slice(node_prefix_iri.lastIndexOf('^') + 1, node_prefix_iri.lastIndexOf(':') + 1);
    }
    else {
        //rem_chars = splitted_label.length > 1 ? label.slice(label.indexOf(':')+1) : label
        //namespace = ontology.getNamespaceFromPrefix(node_prefix_iri)
        // if (!namespace && ParserUtil.isPredicate(element)) {
        //   this.warnings.add(`The prefix "${node_prefix_iri}" is not associated to any namespace`)
        // }
        return new Iri(label, ontology.namespaces);
    }
    // iri_infos.remainingChars = rem_chars
    // iri_infos.prefix = node_prefix_iri
    // iri_infos.fullIri = namespace + rem_chars
    // iri_infos.namespace = namespace
    // iri_infos.prefixed = node_prefix_iri + ':' + rem_chars
    // return iri_infos
}
function getFacetDisplayedName$1(element) {
    if (element.getElementsByTagName('label')[0])
        // language undefined for v2 = ''
        return element.getElementsByTagName('label')[0].textContent || undefined;
}
function getFunctionalities$1(element, xmlDocument) {
    var _a;
    let result = [];
    const labelNoBreak = (_a = element.getElementsByTagName('label')[0].textContent) === null || _a === void 0 ? void 0 : _a.replace(/\n/g, '');
    // for searching predicates' functionalities in graphol v2
    const xmlPredicates = xmlDocument.getElementsByTagName('predicate');
    const type = element.getAttribute('type');
    for (let predicateXml of xmlPredicates) {
        if (labelNoBreak === predicateXml.getAttribute('name') && type === predicateXml.getAttribute('type')) {
            Object.values(FunctionPropertiesEnum).forEach(functionalityKind => {
                var _a;
                const value = parseInt(((_a = predicateXml.getElementsByTagName(functionalityKind)[0]) === null || _a === void 0 ? void 0 : _a.textContent) || '0');
                if (value !== 0)
                    result.push(functionalityKind);
            });
            break;
        }
    }
    return result;
}
function getEntityAnnotations$1(element, xmlDocument) {
    var _a, _b;
    let result = [];
    const label = element.getElementsByTagName('label')[0].textContent;
    if (label) {
        const labelNoBreak = label.replace(/\n/g, '');
        // push label annotation
        result.push(new Annotation(AnnotationProperty.label, label));
        // for searching predicates' description in graphol v2
        const xmlPredicates = xmlDocument.getElementsByTagName('predicate');
        for (let predicateXml of xmlPredicates) {
            if (labelNoBreak === predicateXml.getAttribute('name') && element.getAttribute('type') === predicateXml.getAttribute('type')) {
                let description = (_b = (_a = predicateXml.getElementsByTagName('description')[0]) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.replace(/font-size:0pt/g, '');
                if (description) {
                    let bodyStartIndex = description.indexOf('<p');
                    let bodyEndIndex = description.indexOf('</body');
                    description = description.slice(bodyStartIndex, bodyEndIndex);
                    result.push(new Annotation(AnnotationProperty.comment, description));
                }
                break;
            }
        }
    }
    return result;
}

var Graphol2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    warnings: warnings$1,
    getOntologyInfo: getOntologyInfo$1,
    getNamespaces: getNamespaces$1,
    getIri: getIri$1,
    getFacetDisplayedName: getFacetDisplayedName$1,
    getFunctionalities: getFunctionalities$1,
    getEntityAnnotations: getEntityAnnotations$1
});

let warnings = new Set();
function getOntologyInfo(xmlDocument) {
    var _a, _b, _c;
    let project = getTag(xmlDocument, 'project');
    let ontology_languages = (_a = getTag(xmlDocument, 'languages')) === null || _a === void 0 ? void 0 : _a.children;
    let iri = (_b = getTag(xmlDocument, 'ontology')) === null || _b === void 0 ? void 0 : _b.getAttribute('iri');
    const ontology = new Ontology((project === null || project === void 0 ? void 0 : project.getAttribute('name')) || '', (project === null || project === void 0 ? void 0 : project.getAttribute('version')) || '');
    if (ontology_languages)
        ontology.languages = [...ontology_languages].map(lang => lang.textContent).filter(l => l !== null) || [];
    ontology.defaultLanguage = ((_c = getTag(xmlDocument, 'ontology')) === null || _c === void 0 ? void 0 : _c.getAttribute('lang')) || ontology.languages[0];
    if (iri) {
        ontology.iri = iri;
        ontology.annotations = getIriAnnotations(iri, xmlDocument, ontology.namespaces);
    }
    return ontology;
}
/**
 *
 * @param {Element} xmlDocument
 * @returns
 */
function getNamespaces(xmlDocument) {
    var _a;
    let result = [];
    let prefixes = (_a = getTag(xmlDocument, 'prefixes')) === null || _a === void 0 ? void 0 : _a.children;
    if (prefixes) {
        for (const p of prefixes) {
            const namespaceValue = getTagText(p, 'namespace');
            const prefixValue = getTagText(p, 'value');
            const namespace = result.find(n => n.toString() === namespaceValue);
            if (typeof (prefixValue) === 'string' && namespaceValue) {
                if (namespace) {
                    namespace.addPrefix(prefixValue);
                }
                else {
                    result.push(new Namespace([prefixValue], namespaceValue, false));
                }
            }
        }
    }
    return result;
}
function getIri(element, ontology) {
    let nodeIri = getTagText(element, 'iri');
    if (!nodeIri)
        return;
    return new Iri(nodeIri, ontology.namespaces);
}
/**
 *
 * @param {Element} element
 * @param {Ontology} ontology
 * @returns {string}
 */
function getFacetDisplayedName(element, ontology) {
    // Facets' label must be in the form: [constraining-facet-iri^^"value"] to be compliant to Graphol-V2
    if (element.getAttribute('type') === TypesEnum.FACET) {
        const constrainingFacet = getTagText(element, 'constrainingFacet');
        if (constrainingFacet) {
            const facetIri = new Iri(constrainingFacet, ontology.namespaces);
            //let constraining_facet = ontology.destructureIri(getTagText(element, 'constrainingFacet'))
            //constraining_facet = constraining_facet.prefix + ':' + constraining_facet.remainingChars
            const lexicalForm = getTagText(element, 'lexicalForm');
            const datatype = getTagText(element, 'datatype');
            if (datatype) {
                const datatypeIri = new Iri(datatype, ontology.namespaces);
                return `${facetIri.prefixed}\n\n"${lexicalForm}"^^${datatypeIri.prefixed}`;
            }
            // unused to be compliant to Graphol-V2
            //let datatype = ontology.destructureIri(getTagText(element, 'datatype'))
            //datatype = datatype.prefix + ':' + datatype.rem_chars
        }
    }
}
/**
 * Returns an object with annotations, description and the properties (functional, etc..) for DataProperties
 * @param {Element} element
 * @param {Element} xmlDocument
 * @returns {FunctionalityEnum[]}
 */
function getFunctionalities(element, xmlDocument) {
    let result = [];
    let current_iri_elem = getIriElem(element, xmlDocument);
    let elementType;
    switch (element.getAttribute('type')) {
        case 'concept':
            elementType = TypesEnum.CLASS;
            break;
        case 'role':
            elementType = TypesEnum.OBJECT_PROPERTY;
            break;
        case 'attribute':
            elementType = TypesEnum.DATA_PROPERTY;
            break;
    }
    if (elementType === TypesEnum.OBJECT_PROPERTY || elementType === TypesEnum.DATA_PROPERTY) {
        if (current_iri_elem && current_iri_elem.children) {
            for (let property of current_iri_elem.children) {
                const functionality = Object.values(FunctionPropertiesEnum).find(f => f.toString() === property.tagName);
                if (functionality) {
                    result.push(functionality);
                }
            }
        }
    }
    return result;
}
function getEntityAnnotations(element, xmlDocument, namespaces) {
    const entityIri = getTagText(element, 'iri');
    if (entityIri)
        return getIriAnnotations(entityIri, xmlDocument, namespaces);
    else
        return [];
}
function getIriAnnotations(iri, xmlDocument, namespaces) {
    let result = [];
    const iriElem = getIriElem(iri, xmlDocument);
    if (iriElem) {
        let annotations = getTag(iriElem, 'annotations');
        let language;
        let property;
        let lexicalForm;
        if (annotations) {
            for (let annotation of annotations.children) {
                property = getTagText(annotation, 'property');
                language = getTagText(annotation, 'language');
                lexicalForm = getTagText(annotation, 'lexicalForm');
                if (lexicalForm && language && property)
                    result.push(new Annotation(new Iri(property, namespaces), lexicalForm, language));
            }
        }
    }
    return result;
}
/**
 * Retrieve the xml tag element in a xml root element
 */
function getTag(root, tagName, n = 0) {
    if (root && root.getElementsByTagName(tagName[n]))
        return root.getElementsByTagName(tagName)[n];
}
/**
 * Retrieve the text inside a given tag in a xml root element
 */
function getTagText(root, tagName, n = 0) {
    if (root && root.getElementsByTagName(tagName)[n])
        return root.getElementsByTagName(tagName)[n].textContent;
}
function getIriElem(node, xmlDocument) {
    var _a;
    let node_iri;
    if (typeof (node) === 'string')
        node_iri = node;
    else
        node_iri = getTagText(node, 'iri');
    if (!node_iri)
        return null;
    let iris = (_a = getTag(xmlDocument, 'iris')) === null || _a === void 0 ? void 0 : _a.children;
    if (iris) {
        for (let iri of iris) {
            if (node_iri == getTagText(iri, 'value')) {
                return iri;
            }
        }
    }
    return null;
}

var Graphol3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    warnings: warnings,
    getOntologyInfo: getOntologyInfo,
    getNamespaces: getNamespaces,
    getIri: getIri,
    getFacetDisplayedName: getFacetDisplayedName,
    getFunctionalities: getFunctionalities,
    getEntityAnnotations: getEntityAnnotations,
    getTag: getTag,
    getTagText: getTagText
});

// Funzioni che ritornano il primo figlio o il fratello successivo di un dato nodo
// Ignorano quindi tutti gli elementi di tipo diverso da 1
// cioè gli attributi, gli spazi vuoti ecc...
function getFirstChild(node) {
    if (node == null || node.firstChild == null) {
        return null;
    }
    node = node.firstChild;
    if (node.nodeType !== 1) {
        node = getNextSibling(node);
    }
    return node;
}
function getNextSibling(node) {
    if (node == null || node.nextSibling == null) {
        return null;
    }
    node = node.nextSibling;
    while (node.nodeType !== 1) {
        if (node.nextSibling == null) {
            return null;
        }
        node = node.nextSibling;
    }
    return node;
}
/**
 * Funzione che decide se spostare un endpoint sul bordo del nodo (source o target) o meno
 * Facciamo quest'operazione per tutti gli archi che presentano degli endpoint
 * non al centro del nodo (source o target), in questi casi le
 * opzioni sono 2:
 * 1: l'arco parte (o arriva) in diagonale, in questo caso l'endpoint lo lasciamo al centro del nodo
 * 2: l'arco arriva perpendicolarmente al bordo del nodo (source o target), in questo caso
 *    vediamo se il breakpoint successivo (o precedente nel caso del target), ha la stessa X o la stessa Y
 *    del nodo in questione.
 *    Valutando poi la coordinata che non risulta uguale a quella del nodo, spostiamo l'endpoint sul bordo del
 *    nodo in direzione del breakpoint successivo (o precedente).
 *
 * Se lasciassimo intatti gli endpoint non centrati, cytoscape farebbe entrare la freccia nel nodo,
 * Traslando sul bordo l'endpoint in direzione del breakpoint successivo (nel caso di source) o precedente
 * (nel caso di target), cytoscape farà corrispondere la punta della freccia sul bordo del nodo e
 * sarà quindi visibile.
 * @param endpoint l'endpoint da spostare
 * @param node il nodo a cui si riferisce l'endpoint
 * @param breakpoint il breakpoint successivo (o precedente)
 */
function getNewEndpoint(endpoint, node, breakpoint) {
    // Calcoliamo le coordinate relative al nodo source (o target)
    const endpointRelativeToNode = { x: 0, y: 0 };
    endpointRelativeToNode.x = endpoint.x - node.x;
    endpointRelativeToNode.y = endpoint.y - node.y;
    if (endpointRelativeToNode.x == 0 && endpointRelativeToNode.y == 0)
        // endpoint centrato sul nodo, non c'è bisogno di spostarlo
        return endpointRelativeToNode;
    const breakpointRelativeToNode = { x: 0, y: 0 };
    breakpointRelativeToNode.x = breakpoint.x - node.x;
    breakpointRelativeToNode.y = breakpoint.y - node.y;
    // Se l'endpoint non è centrato nel nodo ma ha la X uguale al breakpoint successivo (o precedente)
    // Allora l'arco parte (o arriva) perpendicolarmente dall'alto o dal basso
    if (endpointRelativeToNode.x == breakpointRelativeToNode.x) {
        // Se il breakpoint si trova più in basso (Ricorda: asse Y al contrario in cytoscape!),
        // allora spostiamo sul bordo inferiore l'endpoint
        if (breakpointRelativeToNode.y > 0) {
            endpointRelativeToNode.y = node.height / 2;
            return endpointRelativeToNode;
        }
        // Se invece il breakpoint è più in alto del nodo, allora spostiamo l'endpoint sul bordo superiore
        else if (breakpointRelativeToNode.y < 0) {
            endpointRelativeToNode.y = -node.height / 2;
            return endpointRelativeToNode;
        }
    }
    // Se invece ad essere uguale è la Y, l'arco arriva da destra o da sinistra, facciamo gli stessi passaggi appena fatti
    else if (endpointRelativeToNode.y == breakpointRelativeToNode.y) {
        if (breakpointRelativeToNode.x > 0) {
            endpointRelativeToNode.x = node.width / 2;
            return endpointRelativeToNode;
        }
        else if (breakpointRelativeToNode.x < 0) {
            endpointRelativeToNode.x = -node.width / 2;
            return endpointRelativeToNode;
        }
    }
    return endpointRelativeToNode;
}
function getPointOnEdge(point1, point2) {
    const m = (point1.y - point2.y) / (point1.x - point2.x);
    const result = new Breakpoint();
    const middleX = (point1.x - point2.x) / 2;
    const middleY = (point1.y - point2.y) / 2;
    if (point1.x !== point2.x && point1.y !== point2.y) {
        result.x = point1.x - middleX;
        // y = mx + q  [ q = y1 - mx1 ] => y = mx + y1 - mx1
        result.y = m * result.x + point1.y - m * point1.x;
    }
    // horizontal line
    else if (point1.y === point2.y) {
        result.x = point1.x - middleX;
        result.y = point1.y;
    }
    // vertical line
    else if (point1.x === point2.x) {
        result.x = point1.x;
        result.y = point1.y - middleY;
    }
    return result;
}

class GrapholParser {
    constructor(xmlString) {
        this.xmlDocument = (xmlString instanceof XMLDocument) ? xmlString : new DOMParser().parseFromString(xmlString, 'text/xml');
        this.graphol_ver = this.xmlDocument.getElementsByTagName('graphol')[0].getAttribute('version') || -1;
        if (this.graphol_ver == 2 || this.graphol_ver == -1)
            this.graphol = Graphol2;
        else if (this.graphol_ver == 3)
            this.graphol = Graphol3;
        else
            throw new Error(`Graphol version [${this.graphol_ver}] not supported`);
    }
    parseGraphol() {
        var _a, _b;
        this.ontology = this.graphol.getOntologyInfo(this.xmlDocument);
        this.ontology.namespaces = this.graphol.getNamespaces(this.xmlDocument);
        let i, k, nodes, edges;
        let diagrams = this.xmlDocument.getElementsByTagName('diagram');
        for (i = 0; i < diagrams.length; i++) {
            const diagram = new Diagram(diagrams[i].getAttribute('name') || '', i);
            this.ontology.addDiagram(diagram);
            nodes = diagrams[i].getElementsByTagName('node');
            edges = diagrams[i].getElementsByTagName('edge');
            // Create JSON for each node to be added to the collection
            for (k = 0; k < nodes.length; k++) {
                const nodeXmlElement = nodes[k];
                const grapholNodeType = (_a = this.getGrapholNodeInfo(nodeXmlElement)) === null || _a === void 0 ? void 0 : _a.TYPE;
                const node = this.getBasicGrapholNodeFromXML(nodeXmlElement, i);
                if (!node)
                    continue;
                let grapholEntity;
                if (node.isEntity() && grapholNodeType) {
                    const iri = this.graphol.getIri(nodeXmlElement, this.ontology);
                    if (iri) {
                        grapholEntity = this.ontology.entities.get(iri.fullIri);
                        node.iri = iri.fullIri;
                        if (!grapholEntity) {
                            grapholEntity = new GrapholEntity(iri);
                            this.ontology.addEntity(grapholEntity);
                        }
                        grapholEntity.addOccurrence(node);
                        if (node.is(TypesEnum.DATA_PROPERTY) || node.is(TypesEnum.OBJECT_PROPERTY)) {
                            const functionalities = this.graphol.getFunctionalities(nodeXmlElement, this.xmlDocument);
                            if (node.is(TypesEnum.DATA_PROPERTY)) {
                                grapholEntity.isDataPropertyFunctional = functionalities.includes(FunctionPropertiesEnum.FUNCTIONAL);
                            }
                            else {
                                grapholEntity.functionProperties = functionalities;
                            }
                        }
                        grapholEntity.annotations = this.graphol.getEntityAnnotations(nodeXmlElement, this.xmlDocument, this.ontology.namespaces);
                        // APPLY DISPLAYED NAME FROM LABELS
                        node.displayedName = grapholEntity.getDisplayedName(RDFGraphConfigEntityNameTypeEnum.LABEL, undefined);
                        // Add fake nodes
                        if (node.is(TypesEnum.OBJECT_PROPERTY) &&
                            grapholEntity.hasFunctionProperty(FunctionPropertiesEnum.FUNCTIONAL) &&
                            grapholEntity.hasFunctionProperty(FunctionPropertiesEnum.INVERSE_FUNCTIONAL)) {
                            node.addFakeNode(new FakeTriangleRight(node));
                            node.addFakeNode(new FakeTriangleLeft(node));
                            node.height -= 8;
                            node.width -= 10;
                        }
                    }
                }
                else {
                    // not an entity, take label from <label> tag or use those for constructor nodes          
                    switch (node === null || node === void 0 ? void 0 : node.type) {
                        case TypesEnum.FACET:
                            node.displayedName = this.graphol.getFacetDisplayedName(nodeXmlElement, this.ontology) || '';
                            break;
                        case TypesEnum.VALUE_DOMAIN:
                            const iri = this.graphol.getIri(nodeXmlElement, this.ontology);
                            node.displayedName = (iri === null || iri === void 0 ? void 0 : iri.prefixed) || '';
                            break;
                        default:
                            node.displayedName = (_b = GrapholNodesEnum[node.type]) === null || _b === void 0 ? void 0 : _b.LABEL;
                            break;
                    }
                    // for domain/range restrictions, cardinalities
                    if (node.type === TypesEnum.DOMAIN_RESTRICTION || node.type === TypesEnum.RANGE_RESTRICTION) {
                        node.displayedName = getTagText(nodes[k], 'label') || '';
                    }
                }
                diagram.addElement(node, grapholEntity);
            }
            for (k = 0; k < edges.length; k++) {
                const edgeXmlElement = edges[k];
                const grapholEdge = this.getGrapholEdgeFromXML(edgeXmlElement, diagram.id);
                if (grapholEdge)
                    diagram.addElement(grapholEdge);
            }
        }
        if (i == 0) {
            throw new Error("The selected .graphol file has no defined diagram");
        }
        this.getIdentityForNeutralNodes();
        this.ontology.computeDatatypesOnDataProperties();
        return this.ontology;
    }
    getBasicGrapholNodeFromXML(element, diagramId) {
        var _a, _b;
        const nodeInfoBasedOnType = this.getGrapholNodeInfo(element);
        if (!nodeInfoBasedOnType) {
            console.warn(`[GRAPHOL_PARSER]: ${element.getAttribute('type')} is not a Graphol node type`);
            return;
        }
        let grapholNode = new GrapholNode(element.getAttribute('id') || '', nodeInfoBasedOnType.TYPE);
        grapholNode.diagramId = diagramId;
        grapholNode.shape = nodeInfoBasedOnType.SHAPE;
        grapholNode.identity = nodeInfoBasedOnType.IDENTITY;
        grapholNode.fillColor = element.getAttribute('color') || '';
        // Parsing the <geometry> child node of node
        var geometry = element.getElementsByTagName('geometry')[0];
        grapholNode.width = parseInt(geometry.getAttribute('width') || '');
        grapholNode.height = parseInt(geometry.getAttribute('height') || '');
        grapholNode.x = parseInt(geometry.getAttribute('x') || '');
        grapholNode.y = parseInt(geometry.getAttribute('y') || '');
        if (grapholNode.is(TypesEnum.ROLE_CHAIN) || grapholNode.is(TypesEnum.PROPERTY_ASSERTION)) {
            if (element.getAttribute('inputs') !== '')
                grapholNode.inputs = (_a = element.getAttribute('inputs')) === null || _a === void 0 ? void 0 : _a.split(',');
        }
        let label = element.getElementsByTagName('label')[0];
        // apply label position and font size
        if (label != null) {
            grapholNode.labelHeight = parseInt(label.getAttribute('height') || '12');
            grapholNode.setLabelXposFromXML(parseInt(label.getAttribute('x') || '12'));
            grapholNode.setLabelYposFromXML(parseInt(label.getAttribute('y') || '12'));
            grapholNode.fontSize = parseInt(label.getAttribute('size') || '12');
        }
        if (grapholNode.is(TypesEnum.FACET)) {
            grapholNode.shapePoints = (_b = GrapholNodesEnum.facet) === null || _b === void 0 ? void 0 : _b.SHAPE_POINTS;
            grapholNode.fillColor = '#ffffff';
            // Add fake nodes
            //grapholNode.displayedName = grapholNode.displayedName.replace('^^', '\n\n')
            grapholNode.labelYpos = 1;
            grapholNode.addFakeNode(new FakeTopRhomboid(grapholNode));
            grapholNode.addFakeNode(new FakeBottomRhomboid(grapholNode));
        }
        if (grapholNode.is(TypesEnum.PROPERTY_ASSERTION)) {
            // Add fake nodes
            grapholNode.height -= 1;
            grapholNode.addFakeNode(new FakeRectangle(grapholNode));
            const fakeCircle1 = new FakeCircleRight(grapholNode);
            // fakeCircle1.x = grapholNode.x - ((grapholNode.width - grapholNode.height) / 2)
            grapholNode.addFakeNode(fakeCircle1);
            const fakeCircle2 = new FakeCircleLeft(grapholNode);
            // fakeCircle2.x = grapholNode.x + ((grapholNode.width - grapholNode.height) / 2)
            grapholNode.addFakeNode(fakeCircle2);
            grapholNode.addFakeNode(new FakeRectangleFront(grapholNode));
        }
        // if (ParserUtil.isPredicate(element))
        //   nodo.classes += ' predicate'
        return grapholNode;
    }
    getGrapholEdgeFromXML(edgeXmlElement, diagramId) {
        const typeKey = Object.keys(TypesEnum).find(k => TypesEnum[k] === edgeXmlElement.getAttribute('type'));
        if (!typeKey)
            return;
        const grapholEdge = new GrapholEdge(edgeXmlElement.getAttribute('id') || '', TypesEnum[typeKey]);
        const sourceId = edgeXmlElement.getAttribute('source');
        if (sourceId)
            grapholEdge.sourceId = sourceId;
        const targetId = edgeXmlElement.getAttribute('target');
        if (targetId)
            grapholEdge.targetId = targetId;
        // Prendiamo i nodi source e target
        var sourceGrapholNode = this.ontology.getGrapholNode(grapholEdge.sourceId, diagramId);
        var targetGrapholNode = this.ontology.getGrapholNode(grapholEdge.targetId, diagramId);
        if (sourceGrapholNode && targetGrapholNode) {
            // Impostiamo le label numeriche per gli archi che entrano nei role-chain
            // I role-chain hanno un campo <input> con una lista di id di archi all'interno
            // che sono gli archi che entrano, l'ordine nella sequenza stabilisce la label
            // numerica che deve avere l'arco
            // Quindi se l'arco che stiamo aggiungendo ha come target un nodo role-chain,
            // Cerchiamo l'id dell'arco negli inputs del role-chain e se lo troviamo impostiamo
            // la target_label in base alla posizione nella sequenza
            if (targetGrapholNode.is(TypesEnum.ROLE_CHAIN) || targetGrapholNode.is(TypesEnum.PROPERTY_ASSERTION)) {
                if (targetGrapholNode === null || targetGrapholNode === void 0 ? void 0 : targetGrapholNode.inputs) {
                    for (let k = 0; k < targetGrapholNode.inputs.length; k++) {
                        if (targetGrapholNode.inputs[k] === grapholEdge.id) {
                            grapholEdge.targetLabel = (k + 1).toString();
                            break;
                        }
                    }
                }
            }
            // info = <POINT>
            // Processiamo i breakpoints dell'arco
            // NOTA: ogni arco ha sempre almeno 2 breakpoints, cioè gli endpoints
            let point = getFirstChild(edgeXmlElement);
            // let breakpoints = []
            // let segment_weights = []
            // let segment_distances = []
            let count = 0;
            for (let j = 0; j < edgeXmlElement.childNodes.length; j++) {
                // Ignoriamo spazi vuoti, e altri figli di tipo diverso da 1
                if (edgeXmlElement.childNodes[j].nodeType != 1) {
                    continue;
                }
                const breakpoint = new Breakpoint(parseInt(point.getAttribute('x')), parseInt(point.getAttribute('y')));
                //breakpoints[count].push(parseInt(point.getAttribute('x')))
                //breakpoints[count].push(parseInt(point.getAttribute('y')))
                if (getNextSibling(point) != null) {
                    point = getNextSibling(point);
                    // Se il breakpoint in questione non è il primo
                    // e non è l'ultimo, visto che ha un fratello,
                    // allora calcoliamo peso e distanza per questo breakpoint
                    // [Il primo e l'ultimo breakpoint sono gli endpoint e non hanno peso e distanza]
                    if (count > 0) {
                        breakpoint.setSourceTarget(sourceGrapholNode.position, targetGrapholNode.position);
                        // var aux = ParserUtil.getDistanceWeight(targetGrapholNode.position, sourceGrapholNode.position, breakpoints[count])
                        // segment_distances.push(aux[0])
                        // segment_weights.push(aux[1])
                    }
                    count++;
                }
                grapholEdge.addBreakPoint(breakpoint);
            }
            // Calcoliamo gli endpoints sul source e sul target
            // Se non sono centrati sul nodo vanno spostati sul bordo del nodo
            grapholEdge.sourceEndpoint = getNewEndpoint(grapholEdge.controlpoints[0], // first breakpoint is the one on source
            sourceGrapholNode, grapholEdge.controlpoints[1]);
            // Facciamo la stessa cosa per il target
            grapholEdge.targetEndpoint = getNewEndpoint(grapholEdge.controlpoints[grapholEdge.controlpoints.length - 1], // last endpoint is the one on target
            targetGrapholNode, grapholEdge.controlpoints[grapholEdge.controlpoints.length - 2]);
            // If we have no control-points and only one endpoint, we need an intermediate breakpoint
            // why? see: https://github.com/obdasystems/grapholscape/issues/47#issuecomment-987175639
            let breakpoint;
            if (grapholEdge.controlpoints.length === 2) { // 2 breakpoints means only endpoints
                if ((grapholEdge.sourceEndpoint && !grapholEdge.targetEndpoint)) {
                    /**
                     * we have custom endpoint only on source, get a middle breakpoint
                     * between the custom endpoint on source (breakpoints[0]) and target position
                     * (we don't have endpoint on target)
                     *
                     * NOTE: don't use source_endpoint because it contains relative coordinate
                     * with respect source node position. We need absolute coordinates which are
                     * the ones parsed from .graphol file
                     */
                    breakpoint = getPointOnEdge(grapholEdge.controlpoints[0], targetGrapholNode.position);
                }
                if (!grapholEdge.sourceEndpoint && grapholEdge.targetEndpoint) {
                    // same as above but with endpoint on target, which is the last breakpoints (1 since they are just 2)
                    breakpoint = getPointOnEdge(sourceGrapholNode.position, grapholEdge.controlpoints[1]);
                }
                if (breakpoint) {
                    // now if we have the breakpoint we need, let's get distance and weight for cytoscape
                    // just like any other breakpoint
                    breakpoint.setSourceTarget(sourceGrapholNode.position, targetGrapholNode.position);
                    // insert new breakpoint between the the other two we already have
                    grapholEdge.controlpoints.splice(1, 0, breakpoint);
                }
            }
        }
        return grapholEdge;
    }
    getIdentityForNeutralNodes() {
        this.ontology.diagrams.forEach(diagram => {
            var _a;
            const cy = (_a = diagram.representations.get(RendererStatesEnum.GRAPHOL)) === null || _a === void 0 ? void 0 : _a.cy;
            cy === null || cy === void 0 ? void 0 : cy.nodes('[identity = "neutral"]').forEach(node => {
                const newIdentity = findIdentity(node);
                node.data('identity', newIdentity);
                const grapholNode = this.ontology.getGrapholNode(node.id(), diagram.id);
                if (grapholNode)
                    grapholNode.identity = newIdentity;
            });
        });
        // Recursively traverse first input node and return his identity
        // if he is neutral => recursive step
        function findIdentity(node) {
            var _a;
            var first_input_node = node.incomers('[type = "input"]').sources();
            var identity = first_input_node.data('identity');
            if (identity === TypesEnum.NEUTRAL) {
                return findIdentity(first_input_node);
            }
            else {
                switch (node.data('type')) {
                    case TypesEnum.RANGE_RESTRICTION:
                        if (identity === TypesEnum.OBJECT_PROPERTY) {
                            return TypesEnum.CLASS;
                        }
                        else if (identity === TypesEnum.DATA_PROPERTY) {
                            return TypesEnum.VALUE_DOMAIN;
                        }
                        else {
                            return identity;
                        }
                    case TypesEnum.ENUMERATION:
                        if (identity === TypesEnum.INDIVIDUAL) {
                            return (_a = GrapholNodesEnum.class) === null || _a === void 0 ? void 0 : _a.TYPE;
                        }
                        else {
                            return identity;
                        }
                    default:
                        return identity;
                }
            }
        }
    }
    getGrapholNodeInfo(element) {
        let elementTypeFromXmL = element.getAttribute('type');
        if (!elementTypeFromXmL)
            return;
        switch (elementTypeFromXmL) {
            case 'concept':
                elementTypeFromXmL = TypesEnum.CLASS;
                break;
            case 'role':
                elementTypeFromXmL = TypesEnum.OBJECT_PROPERTY;
                break;
            case 'attribute':
                elementTypeFromXmL = TypesEnum.DATA_PROPERTY;
                break;
        }
        let nodeTypeKey = Object.keys(GrapholNodesEnum).find(k => GrapholNodesEnum[k].TYPE === elementTypeFromXmL);
        if (!nodeTypeKey)
            return;
        return GrapholNodesEnum[nodeTypeKey];
    }
    getCorrectLabelYpos(labelYpos, positionY, height) {
        return (labelYpos - positionY) + (height + 2) / 2 + LABEL_HEIGHT / 4;
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var lib = {exports: {}};

var _FullInternals = {};

var _CoreInternals = {};

var Global = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports._registerNode = exports._NODES_REGISTRY = exports.Konva = exports.glob = exports._parseUA = void 0;
	var PI_OVER_180 = Math.PI / 180;
	function detectBrowser() {
	    return (typeof window !== 'undefined' &&
	        ({}.toString.call(window) === '[object Window]' ||
	            {}.toString.call(window) === '[object global]'));
	}
	var _detectIE = function (ua) {
	    var msie = ua.indexOf('msie ');
	    if (msie > 0) {
	        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	    }
	    var trident = ua.indexOf('trident/');
	    if (trident > 0) {
	        var rv = ua.indexOf('rv:');
	        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	    }
	    var edge = ua.indexOf('edge/');
	    if (edge > 0) {
	        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	    }
	    return false;
	};
	var _parseUA = function (userAgent) {
	    var ua = userAgent.toLowerCase(), match = /(chrome)[ /]([\w.]+)/.exec(ua) ||
	        /(webkit)[ /]([\w.]+)/.exec(ua) ||
	        /(opera)(?:.*version|)[ /]([\w.]+)/.exec(ua) ||
	        /(msie) ([\w.]+)/.exec(ua) ||
	        (ua.indexOf('compatible') < 0 &&
	            /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua)) ||
	        [], mobile = !!userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i), ieMobile = !!userAgent.match(/IEMobile/i);
	    return {
	        browser: match[1] || '',
	        version: match[2] || '0',
	        isIE: _detectIE(ua),
	        mobile: mobile,
	        ieMobile: ieMobile
	    };
	};
	exports._parseUA = _parseUA;
	exports.glob = typeof commonjsGlobal !== 'undefined'
	    ? commonjsGlobal
	    : typeof window !== 'undefined'
	        ? window
	        : typeof WorkerGlobalScope !== 'undefined'
	            ? self
	            : {};
	exports.Konva = {
	    _global: exports.glob,
	    version: '7.2.5',
	    isBrowser: detectBrowser(),
	    isUnminified: /param/.test(function (param) { }.toString()),
	    dblClickWindow: 400,
	    getAngle: function (angle) {
	        return exports.Konva.angleDeg ? angle * PI_OVER_180 : angle;
	    },
	    enableTrace: false,
	    _pointerEventsEnabled: false,
	    hitOnDragEnabled: false,
	    captureTouchEventsEnabled: false,
	    listenClickTap: false,
	    inDblClickWindow: false,
	    pixelRatio: undefined,
	    dragDistance: 3,
	    angleDeg: true,
	    showWarnings: true,
	    dragButtons: [0, 1],
	    isDragging: function () {
	        return exports.Konva['DD'].isDragging;
	    },
	    isDragReady: function () {
	        return !!exports.Konva['DD'].node;
	    },
	    UA: exports._parseUA((exports.glob.navigator && exports.glob.navigator.userAgent) || ''),
	    document: exports.glob.document,
	    _injectGlobal: function (Konva) {
	        exports.glob.Konva = Konva;
	    },
	    _parseUA: exports._parseUA
	};
	exports._NODES_REGISTRY = {};
	var _registerNode = function (NodeClass) {
	    exports._NODES_REGISTRY[NodeClass.prototype.getClassName()] = NodeClass;
	    exports.Konva[NodeClass.prototype.getClassName()] = NodeClass;
	};
	exports._registerNode = _registerNode;
} (Global));

var Util = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Util = exports.Transform = exports.Collection = void 0;
	var Global_1 = Global;
	var Collection = (function () {
	    function Collection() {
	    }
	    Collection.toCollection = function (arr) {
	        var collection = new Collection(), len = arr.length, n;
	        for (n = 0; n < len; n++) {
	            collection.push(arr[n]);
	        }
	        return collection;
	    };
	    Collection._mapMethod = function (methodName) {
	        Collection.prototype[methodName] = function () {
	            var len = this.length, i;
	            var args = [].slice.call(arguments);
	            for (i = 0; i < len; i++) {
	                this[i][methodName].apply(this[i], args);
	            }
	            return this;
	        };
	    };
	    Collection.mapMethods = function (constructor) {
	        var prot = constructor.prototype;
	        for (var methodName in prot) {
	            Collection._mapMethod(methodName);
	        }
	    };
	    return Collection;
	}());
	exports.Collection = Collection;
	Collection.prototype = [];
	Collection.prototype.each = function (func) {
	    for (var n = 0; n < this.length; n++) {
	        func(this[n], n);
	    }
	};
	Collection.prototype.toArray = function () {
	    var arr = [], len = this.length, n;
	    for (n = 0; n < len; n++) {
	        arr.push(this[n]);
	    }
	    return arr;
	};
	var Transform = (function () {
	    function Transform(m) {
	        if (m === void 0) { m = [1, 0, 0, 1, 0, 0]; }
	        this.dirty = false;
	        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
	    }
	    Transform.prototype.reset = function () {
	        this.m[0] = 1;
	        this.m[1] = 0;
	        this.m[2] = 0;
	        this.m[3] = 1;
	        this.m[4] = 0;
	        this.m[5] = 0;
	    };
	    Transform.prototype.copy = function () {
	        return new Transform(this.m);
	    };
	    Transform.prototype.copyInto = function (tr) {
	        tr.m[0] = this.m[0];
	        tr.m[1] = this.m[1];
	        tr.m[2] = this.m[2];
	        tr.m[3] = this.m[3];
	        tr.m[4] = this.m[4];
	        tr.m[5] = this.m[5];
	    };
	    Transform.prototype.point = function (point) {
	        var m = this.m;
	        return {
	            x: m[0] * point.x + m[2] * point.y + m[4],
	            y: m[1] * point.x + m[3] * point.y + m[5],
	        };
	    };
	    Transform.prototype.translate = function (x, y) {
	        this.m[4] += this.m[0] * x + this.m[2] * y;
	        this.m[5] += this.m[1] * x + this.m[3] * y;
	        return this;
	    };
	    Transform.prototype.scale = function (sx, sy) {
	        this.m[0] *= sx;
	        this.m[1] *= sx;
	        this.m[2] *= sy;
	        this.m[3] *= sy;
	        return this;
	    };
	    Transform.prototype.rotate = function (rad) {
	        var c = Math.cos(rad);
	        var s = Math.sin(rad);
	        var m11 = this.m[0] * c + this.m[2] * s;
	        var m12 = this.m[1] * c + this.m[3] * s;
	        var m21 = this.m[0] * -s + this.m[2] * c;
	        var m22 = this.m[1] * -s + this.m[3] * c;
	        this.m[0] = m11;
	        this.m[1] = m12;
	        this.m[2] = m21;
	        this.m[3] = m22;
	        return this;
	    };
	    Transform.prototype.getTranslation = function () {
	        return {
	            x: this.m[4],
	            y: this.m[5],
	        };
	    };
	    Transform.prototype.skew = function (sx, sy) {
	        var m11 = this.m[0] + this.m[2] * sy;
	        var m12 = this.m[1] + this.m[3] * sy;
	        var m21 = this.m[2] + this.m[0] * sx;
	        var m22 = this.m[3] + this.m[1] * sx;
	        this.m[0] = m11;
	        this.m[1] = m12;
	        this.m[2] = m21;
	        this.m[3] = m22;
	        return this;
	    };
	    Transform.prototype.multiply = function (matrix) {
	        var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
	        var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
	        var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
	        var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
	        var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
	        var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
	        this.m[0] = m11;
	        this.m[1] = m12;
	        this.m[2] = m21;
	        this.m[3] = m22;
	        this.m[4] = dx;
	        this.m[5] = dy;
	        return this;
	    };
	    Transform.prototype.invert = function () {
	        var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
	        var m0 = this.m[3] * d;
	        var m1 = -this.m[1] * d;
	        var m2 = -this.m[2] * d;
	        var m3 = this.m[0] * d;
	        var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
	        var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
	        this.m[0] = m0;
	        this.m[1] = m1;
	        this.m[2] = m2;
	        this.m[3] = m3;
	        this.m[4] = m4;
	        this.m[5] = m5;
	        return this;
	    };
	    Transform.prototype.getMatrix = function () {
	        return this.m;
	    };
	    Transform.prototype.setAbsolutePosition = function (x, y) {
	        var m0 = this.m[0], m1 = this.m[1], m2 = this.m[2], m3 = this.m[3], m4 = this.m[4], m5 = this.m[5], yt = (m0 * (y - m5) - m1 * (x - m4)) / (m0 * m3 - m1 * m2), xt = (x - m4 - m2 * yt) / m0;
	        return this.translate(xt, yt);
	    };
	    Transform.prototype.decompose = function () {
	        var a = this.m[0];
	        var b = this.m[1];
	        var c = this.m[2];
	        var d = this.m[3];
	        var e = this.m[4];
	        var f = this.m[5];
	        var delta = a * d - b * c;
	        var result = {
	            x: e,
	            y: f,
	            rotation: 0,
	            scaleX: 0,
	            scaleY: 0,
	            skewX: 0,
	            skewY: 0,
	        };
	        if (a != 0 || b != 0) {
	            var r = Math.sqrt(a * a + b * b);
	            result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
	            result.scaleX = r;
	            result.scaleY = delta / r;
	            result.skewX = (a * c + b * d) / delta;
	            result.skewY = 0;
	        }
	        else if (c != 0 || d != 0) {
	            var s = Math.sqrt(c * c + d * d);
	            result.rotation =
	                Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
	            result.scaleX = delta / s;
	            result.scaleY = s;
	            result.skewX = 0;
	            result.skewY = (a * c + b * d) / delta;
	        }
	        else ;
	        result.rotation = exports.Util._getRotation(result.rotation);
	        return result;
	    };
	    return Transform;
	}());
	exports.Transform = Transform;
	var OBJECT_ARRAY = '[object Array]', OBJECT_NUMBER = '[object Number]', OBJECT_STRING = '[object String]', OBJECT_BOOLEAN = '[object Boolean]', PI_OVER_DEG180 = Math.PI / 180, DEG180_OVER_PI = 180 / Math.PI, HASH = '#', EMPTY_STRING = '', ZERO = '0', KONVA_WARNING = 'Konva warning: ', KONVA_ERROR = 'Konva error: ', RGB_PAREN = 'rgb(', COLORS = {
	    aliceblue: [240, 248, 255],
	    antiquewhite: [250, 235, 215],
	    aqua: [0, 255, 255],
	    aquamarine: [127, 255, 212],
	    azure: [240, 255, 255],
	    beige: [245, 245, 220],
	    bisque: [255, 228, 196],
	    black: [0, 0, 0],
	    blanchedalmond: [255, 235, 205],
	    blue: [0, 0, 255],
	    blueviolet: [138, 43, 226],
	    brown: [165, 42, 42],
	    burlywood: [222, 184, 135],
	    cadetblue: [95, 158, 160],
	    chartreuse: [127, 255, 0],
	    chocolate: [210, 105, 30],
	    coral: [255, 127, 80],
	    cornflowerblue: [100, 149, 237],
	    cornsilk: [255, 248, 220],
	    crimson: [220, 20, 60],
	    cyan: [0, 255, 255],
	    darkblue: [0, 0, 139],
	    darkcyan: [0, 139, 139],
	    darkgoldenrod: [184, 132, 11],
	    darkgray: [169, 169, 169],
	    darkgreen: [0, 100, 0],
	    darkgrey: [169, 169, 169],
	    darkkhaki: [189, 183, 107],
	    darkmagenta: [139, 0, 139],
	    darkolivegreen: [85, 107, 47],
	    darkorange: [255, 140, 0],
	    darkorchid: [153, 50, 204],
	    darkred: [139, 0, 0],
	    darksalmon: [233, 150, 122],
	    darkseagreen: [143, 188, 143],
	    darkslateblue: [72, 61, 139],
	    darkslategray: [47, 79, 79],
	    darkslategrey: [47, 79, 79],
	    darkturquoise: [0, 206, 209],
	    darkviolet: [148, 0, 211],
	    deeppink: [255, 20, 147],
	    deepskyblue: [0, 191, 255],
	    dimgray: [105, 105, 105],
	    dimgrey: [105, 105, 105],
	    dodgerblue: [30, 144, 255],
	    firebrick: [178, 34, 34],
	    floralwhite: [255, 255, 240],
	    forestgreen: [34, 139, 34],
	    fuchsia: [255, 0, 255],
	    gainsboro: [220, 220, 220],
	    ghostwhite: [248, 248, 255],
	    gold: [255, 215, 0],
	    goldenrod: [218, 165, 32],
	    gray: [128, 128, 128],
	    green: [0, 128, 0],
	    greenyellow: [173, 255, 47],
	    grey: [128, 128, 128],
	    honeydew: [240, 255, 240],
	    hotpink: [255, 105, 180],
	    indianred: [205, 92, 92],
	    indigo: [75, 0, 130],
	    ivory: [255, 255, 240],
	    khaki: [240, 230, 140],
	    lavender: [230, 230, 250],
	    lavenderblush: [255, 240, 245],
	    lawngreen: [124, 252, 0],
	    lemonchiffon: [255, 250, 205],
	    lightblue: [173, 216, 230],
	    lightcoral: [240, 128, 128],
	    lightcyan: [224, 255, 255],
	    lightgoldenrodyellow: [250, 250, 210],
	    lightgray: [211, 211, 211],
	    lightgreen: [144, 238, 144],
	    lightgrey: [211, 211, 211],
	    lightpink: [255, 182, 193],
	    lightsalmon: [255, 160, 122],
	    lightseagreen: [32, 178, 170],
	    lightskyblue: [135, 206, 250],
	    lightslategray: [119, 136, 153],
	    lightslategrey: [119, 136, 153],
	    lightsteelblue: [176, 196, 222],
	    lightyellow: [255, 255, 224],
	    lime: [0, 255, 0],
	    limegreen: [50, 205, 50],
	    linen: [250, 240, 230],
	    magenta: [255, 0, 255],
	    maroon: [128, 0, 0],
	    mediumaquamarine: [102, 205, 170],
	    mediumblue: [0, 0, 205],
	    mediumorchid: [186, 85, 211],
	    mediumpurple: [147, 112, 219],
	    mediumseagreen: [60, 179, 113],
	    mediumslateblue: [123, 104, 238],
	    mediumspringgreen: [0, 250, 154],
	    mediumturquoise: [72, 209, 204],
	    mediumvioletred: [199, 21, 133],
	    midnightblue: [25, 25, 112],
	    mintcream: [245, 255, 250],
	    mistyrose: [255, 228, 225],
	    moccasin: [255, 228, 181],
	    navajowhite: [255, 222, 173],
	    navy: [0, 0, 128],
	    oldlace: [253, 245, 230],
	    olive: [128, 128, 0],
	    olivedrab: [107, 142, 35],
	    orange: [255, 165, 0],
	    orangered: [255, 69, 0],
	    orchid: [218, 112, 214],
	    palegoldenrod: [238, 232, 170],
	    palegreen: [152, 251, 152],
	    paleturquoise: [175, 238, 238],
	    palevioletred: [219, 112, 147],
	    papayawhip: [255, 239, 213],
	    peachpuff: [255, 218, 185],
	    peru: [205, 133, 63],
	    pink: [255, 192, 203],
	    plum: [221, 160, 203],
	    powderblue: [176, 224, 230],
	    purple: [128, 0, 128],
	    rebeccapurple: [102, 51, 153],
	    red: [255, 0, 0],
	    rosybrown: [188, 143, 143],
	    royalblue: [65, 105, 225],
	    saddlebrown: [139, 69, 19],
	    salmon: [250, 128, 114],
	    sandybrown: [244, 164, 96],
	    seagreen: [46, 139, 87],
	    seashell: [255, 245, 238],
	    sienna: [160, 82, 45],
	    silver: [192, 192, 192],
	    skyblue: [135, 206, 235],
	    slateblue: [106, 90, 205],
	    slategray: [119, 128, 144],
	    slategrey: [119, 128, 144],
	    snow: [255, 255, 250],
	    springgreen: [0, 255, 127],
	    steelblue: [70, 130, 180],
	    tan: [210, 180, 140],
	    teal: [0, 128, 128],
	    thistle: [216, 191, 216],
	    transparent: [255, 255, 255, 0],
	    tomato: [255, 99, 71],
	    turquoise: [64, 224, 208],
	    violet: [238, 130, 238],
	    wheat: [245, 222, 179],
	    white: [255, 255, 255],
	    whitesmoke: [245, 245, 245],
	    yellow: [255, 255, 0],
	    yellowgreen: [154, 205, 5],
	}, RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, animQueue = [];
	exports.Util = {
	    _isElement: function (obj) {
	        return !!(obj && obj.nodeType == 1);
	    },
	    _isFunction: function (obj) {
	        return !!(obj && obj.constructor && obj.call && obj.apply);
	    },
	    _isPlainObject: function (obj) {
	        return !!obj && obj.constructor === Object;
	    },
	    _isArray: function (obj) {
	        return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
	    },
	    _isNumber: function (obj) {
	        return (Object.prototype.toString.call(obj) === OBJECT_NUMBER &&
	            !isNaN(obj) &&
	            isFinite(obj));
	    },
	    _isString: function (obj) {
	        return Object.prototype.toString.call(obj) === OBJECT_STRING;
	    },
	    _isBoolean: function (obj) {
	        return Object.prototype.toString.call(obj) === OBJECT_BOOLEAN;
	    },
	    isObject: function (val) {
	        return val instanceof Object;
	    },
	    isValidSelector: function (selector) {
	        if (typeof selector !== 'string') {
	            return false;
	        }
	        var firstChar = selector[0];
	        return (firstChar === '#' ||
	            firstChar === '.' ||
	            firstChar === firstChar.toUpperCase());
	    },
	    _sign: function (number) {
	        if (number === 0) {
	            return 1;
	        }
	        if (number > 0) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    },
	    requestAnimFrame: function (callback) {
	        animQueue.push(callback);
	        if (animQueue.length === 1) {
	            requestAnimationFrame(function () {
	                var queue = animQueue;
	                animQueue = [];
	                queue.forEach(function (cb) {
	                    cb();
	                });
	            });
	        }
	    },
	    createCanvasElement: function () {
	        var canvas = document.createElement('canvas');
	        try {
	            canvas.style = canvas.style || {};
	        }
	        catch (e) { }
	        return canvas;
	    },
	    createImageElement: function () {
	        return document.createElement('img');
	    },
	    _isInDocument: function (el) {
	        while ((el = el.parentNode)) {
	            if (el == document) {
	                return true;
	            }
	        }
	        return false;
	    },
	    _simplifyArray: function (arr) {
	        var retArr = [], len = arr.length, util = exports.Util, n, val;
	        for (n = 0; n < len; n++) {
	            val = arr[n];
	            if (util._isNumber(val)) {
	                val = Math.round(val * 1000) / 1000;
	            }
	            else if (!util._isString(val)) {
	                val = val.toString();
	            }
	            retArr.push(val);
	        }
	        return retArr;
	    },
	    _urlToImage: function (url, callback) {
	        var imageObj = new Global_1.glob.Image();
	        imageObj.onload = function () {
	            callback(imageObj);
	        };
	        imageObj.src = url;
	    },
	    _rgbToHex: function (r, g, b) {
	        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	    },
	    _hexToRgb: function (hex) {
	        hex = hex.replace(HASH, EMPTY_STRING);
	        var bigint = parseInt(hex, 16);
	        return {
	            r: (bigint >> 16) & 255,
	            g: (bigint >> 8) & 255,
	            b: bigint & 255,
	        };
	    },
	    getRandomColor: function () {
	        var randColor = ((Math.random() * 0xffffff) << 0).toString(16);
	        while (randColor.length < 6) {
	            randColor = ZERO + randColor;
	        }
	        return HASH + randColor;
	    },
	    get: function (val, def) {
	        if (val === undefined) {
	            return def;
	        }
	        else {
	            return val;
	        }
	    },
	    getRGB: function (color) {
	        var rgb;
	        if (color in COLORS) {
	            rgb = COLORS[color];
	            return {
	                r: rgb[0],
	                g: rgb[1],
	                b: rgb[2],
	            };
	        }
	        else if (color[0] === HASH) {
	            return this._hexToRgb(color.substring(1));
	        }
	        else if (color.substr(0, 4) === RGB_PAREN) {
	            rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
	            return {
	                r: parseInt(rgb[1], 10),
	                g: parseInt(rgb[2], 10),
	                b: parseInt(rgb[3], 10),
	            };
	        }
	        else {
	            return {
	                r: 0,
	                g: 0,
	                b: 0,
	            };
	        }
	    },
	    colorToRGBA: function (str) {
	        str = str || 'black';
	        return (exports.Util._namedColorToRBA(str) ||
	            exports.Util._hex3ColorToRGBA(str) ||
	            exports.Util._hex6ColorToRGBA(str) ||
	            exports.Util._rgbColorToRGBA(str) ||
	            exports.Util._rgbaColorToRGBA(str) ||
	            exports.Util._hslColorToRGBA(str));
	    },
	    _namedColorToRBA: function (str) {
	        var c = COLORS[str.toLowerCase()];
	        if (!c) {
	            return null;
	        }
	        return {
	            r: c[0],
	            g: c[1],
	            b: c[2],
	            a: 1,
	        };
	    },
	    _rgbColorToRGBA: function (str) {
	        if (str.indexOf('rgb(') === 0) {
	            str = str.match(/rgb\(([^)]+)\)/)[1];
	            var parts = str.split(/ *, */).map(Number);
	            return {
	                r: parts[0],
	                g: parts[1],
	                b: parts[2],
	                a: 1,
	            };
	        }
	    },
	    _rgbaColorToRGBA: function (str) {
	        if (str.indexOf('rgba(') === 0) {
	            str = str.match(/rgba\(([^)]+)\)/)[1];
	            var parts = str.split(/ *, */).map(Number);
	            return {
	                r: parts[0],
	                g: parts[1],
	                b: parts[2],
	                a: parts[3],
	            };
	        }
	    },
	    _hex6ColorToRGBA: function (str) {
	        if (str[0] === '#' && str.length === 7) {
	            return {
	                r: parseInt(str.slice(1, 3), 16),
	                g: parseInt(str.slice(3, 5), 16),
	                b: parseInt(str.slice(5, 7), 16),
	                a: 1,
	            };
	        }
	    },
	    _hex3ColorToRGBA: function (str) {
	        if (str[0] === '#' && str.length === 4) {
	            return {
	                r: parseInt(str[1] + str[1], 16),
	                g: parseInt(str[2] + str[2], 16),
	                b: parseInt(str[3] + str[3], 16),
	                a: 1,
	            };
	        }
	    },
	    _hslColorToRGBA: function (str) {
	        if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(str)) {
	            var _a = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(str); _a[0]; var hsl = _a.slice(1);
	            var h = Number(hsl[0]) / 360;
	            var s = Number(hsl[1]) / 100;
	            var l = Number(hsl[2]) / 100;
	            var t2 = void 0;
	            var t3 = void 0;
	            var val = void 0;
	            if (s === 0) {
	                val = l * 255;
	                return {
	                    r: Math.round(val),
	                    g: Math.round(val),
	                    b: Math.round(val),
	                    a: 1,
	                };
	            }
	            if (l < 0.5) {
	                t2 = l * (1 + s);
	            }
	            else {
	                t2 = l + s - l * s;
	            }
	            var t1 = 2 * l - t2;
	            var rgb = [0, 0, 0];
	            for (var i = 0; i < 3; i++) {
	                t3 = h + (1 / 3) * -(i - 1);
	                if (t3 < 0) {
	                    t3++;
	                }
	                if (t3 > 1) {
	                    t3--;
	                }
	                if (6 * t3 < 1) {
	                    val = t1 + (t2 - t1) * 6 * t3;
	                }
	                else if (2 * t3 < 1) {
	                    val = t2;
	                }
	                else if (3 * t3 < 2) {
	                    val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	                }
	                else {
	                    val = t1;
	                }
	                rgb[i] = val * 255;
	            }
	            return {
	                r: Math.round(rgb[0]),
	                g: Math.round(rgb[1]),
	                b: Math.round(rgb[2]),
	                a: 1,
	            };
	        }
	    },
	    haveIntersection: function (r1, r2) {
	        return !(r2.x > r1.x + r1.width ||
	            r2.x + r2.width < r1.x ||
	            r2.y > r1.y + r1.height ||
	            r2.y + r2.height < r1.y);
	    },
	    cloneObject: function (obj) {
	        var retObj = {};
	        for (var key in obj) {
	            if (this._isPlainObject(obj[key])) {
	                retObj[key] = this.cloneObject(obj[key]);
	            }
	            else if (this._isArray(obj[key])) {
	                retObj[key] = this.cloneArray(obj[key]);
	            }
	            else {
	                retObj[key] = obj[key];
	            }
	        }
	        return retObj;
	    },
	    cloneArray: function (arr) {
	        return arr.slice(0);
	    },
	    _degToRad: function (deg) {
	        return deg * PI_OVER_DEG180;
	    },
	    _radToDeg: function (rad) {
	        return rad * DEG180_OVER_PI;
	    },
	    _getRotation: function (radians) {
	        return Global_1.Konva.angleDeg ? exports.Util._radToDeg(radians) : radians;
	    },
	    _capitalize: function (str) {
	        return str.charAt(0).toUpperCase() + str.slice(1);
	    },
	    throw: function (str) {
	        throw new Error(KONVA_ERROR + str);
	    },
	    error: function (str) {
	        console.error(KONVA_ERROR + str);
	    },
	    warn: function (str) {
	        if (!Global_1.Konva.showWarnings) {
	            return;
	        }
	        console.warn(KONVA_WARNING + str);
	    },
	    extend: function (child, parent) {
	        function Ctor() {
	            this.constructor = child;
	        }
	        Ctor.prototype = parent.prototype;
	        var oldProto = child.prototype;
	        child.prototype = new Ctor();
	        for (var key in oldProto) {
	            if (oldProto.hasOwnProperty(key)) {
	                child.prototype[key] = oldProto[key];
	            }
	        }
	        child.__super__ = parent.prototype;
	        child.super = parent;
	    },
	    _getControlPoints: function (x0, y0, x1, y1, x2, y2, t) {
	        var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)), d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), fa = (t * d01) / (d01 + d12), fb = (t * d12) / (d01 + d12), p1x = x1 - fa * (x2 - x0), p1y = y1 - fa * (y2 - y0), p2x = x1 + fb * (x2 - x0), p2y = y1 + fb * (y2 - y0);
	        return [p1x, p1y, p2x, p2y];
	    },
	    _expandPoints: function (p, tension) {
	        var len = p.length, allPoints = [], n, cp;
	        for (n = 2; n < len - 2; n += 2) {
	            cp = exports.Util._getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
	            if (isNaN(cp[0])) {
	                continue;
	            }
	            allPoints.push(cp[0]);
	            allPoints.push(cp[1]);
	            allPoints.push(p[n]);
	            allPoints.push(p[n + 1]);
	            allPoints.push(cp[2]);
	            allPoints.push(cp[3]);
	        }
	        return allPoints;
	    },
	    each: function (obj, func) {
	        for (var key in obj) {
	            func(key, obj[key]);
	        }
	    },
	    _inRange: function (val, left, right) {
	        return left <= val && val < right;
	    },
	    _getProjectionToSegment: function (x1, y1, x2, y2, x3, y3) {
	        var x, y, dist;
	        var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	        if (pd2 == 0) {
	            x = x1;
	            y = y1;
	            dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
	        }
	        else {
	            var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
	            if (u < 0) {
	                x = x1;
	                y = y1;
	                dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
	            }
	            else if (u > 1.0) {
	                x = x2;
	                y = y2;
	                dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
	            }
	            else {
	                x = x1 + u * (x2 - x1);
	                y = y1 + u * (y2 - y1);
	                dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
	            }
	        }
	        return [x, y, dist];
	    },
	    _getProjectionToLine: function (pt, line, isClosed) {
	        var pc = exports.Util.cloneObject(pt);
	        var dist = Number.MAX_VALUE;
	        line.forEach(function (p1, i) {
	            if (!isClosed && i === line.length - 1) {
	                return;
	            }
	            var p2 = line[(i + 1) % line.length];
	            var proj = exports.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
	            var px = proj[0], py = proj[1], pdist = proj[2];
	            if (pdist < dist) {
	                pc.x = px;
	                pc.y = py;
	                dist = pdist;
	            }
	        });
	        return pc;
	    },
	    _prepareArrayForTween: function (startArray, endArray, isClosed) {
	        var n, start = [], end = [];
	        if (startArray.length > endArray.length) {
	            var temp = endArray;
	            endArray = startArray;
	            startArray = temp;
	        }
	        for (n = 0; n < startArray.length; n += 2) {
	            start.push({
	                x: startArray[n],
	                y: startArray[n + 1],
	            });
	        }
	        for (n = 0; n < endArray.length; n += 2) {
	            end.push({
	                x: endArray[n],
	                y: endArray[n + 1],
	            });
	        }
	        var newStart = [];
	        end.forEach(function (point) {
	            var pr = exports.Util._getProjectionToLine(point, start, isClosed);
	            newStart.push(pr.x);
	            newStart.push(pr.y);
	        });
	        return newStart;
	    },
	    _prepareToStringify: function (obj) {
	        var desc;
	        obj.visitedByCircularReferenceRemoval = true;
	        for (var key in obj) {
	            if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')) {
	                continue;
	            }
	            desc = Object.getOwnPropertyDescriptor(obj, key);
	            if (obj[key].visitedByCircularReferenceRemoval ||
	                exports.Util._isElement(obj[key])) {
	                if (desc.configurable) {
	                    delete obj[key];
	                }
	                else {
	                    return null;
	                }
	            }
	            else if (exports.Util._prepareToStringify(obj[key]) === null) {
	                if (desc.configurable) {
	                    delete obj[key];
	                }
	                else {
	                    return null;
	                }
	            }
	        }
	        delete obj.visitedByCircularReferenceRemoval;
	        return obj;
	    },
	    _assign: function (target, source) {
	        for (var key in source) {
	            target[key] = source[key];
	        }
	        return target;
	    },
	    _getFirstPointerId: function (evt) {
	        if (!evt.touches) {
	            return 999;
	        }
	        else {
	            return evt.changedTouches[0].identifier;
	        }
	    },
	};
} (Util));

var Node = {};

var Factory = {};

var Validators = {};

Object.defineProperty(Validators, "__esModule", { value: true });
Validators.getComponentValidator = Validators.getBooleanValidator = Validators.getNumberArrayValidator = Validators.getFunctionValidator = Validators.getStringOrGradientValidator = Validators.getStringValidator = Validators.getNumberOrAutoValidator = Validators.getNumberOrArrayOfNumbersValidator = Validators.getNumberValidator = Validators.alphaComponent = Validators.RGBComponent = void 0;
var Global_1$p = Global;
var Util_1$r = Util;
function _formatValue(val) {
    if (Util_1$r.Util._isString(val)) {
        return '"' + val + '"';
    }
    if (Object.prototype.toString.call(val) === '[object Number]') {
        return val;
    }
    if (Util_1$r.Util._isBoolean(val)) {
        return val;
    }
    return Object.prototype.toString.call(val);
}
function RGBComponent(val) {
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    return Math.round(val);
}
Validators.RGBComponent = RGBComponent;
function alphaComponent(val) {
    if (val > 1) {
        return 1;
    }
    else if (val < 0.0001) {
        return 0.0001;
    }
    return val;
}
Validators.alphaComponent = alphaComponent;
function getNumberValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$r.Util._isNumber(val)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a number.');
            }
            return val;
        };
    }
}
Validators.getNumberValidator = getNumberValidator;
function getNumberOrArrayOfNumbersValidator(noOfElements) {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            var isNumber = Util_1$r.Util._isNumber(val);
            var isValidArray = Util_1$r.Util._isArray(val) && val.length == noOfElements;
            if (!isNumber && !isValidArray) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a number or Array<number>(' + noOfElements + ')');
            }
            return val;
        };
    }
}
Validators.getNumberOrArrayOfNumbersValidator = getNumberOrArrayOfNumbersValidator;
function getNumberOrAutoValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            var isNumber = Util_1$r.Util._isNumber(val);
            var isAuto = val === 'auto';
            if (!(isNumber || isAuto)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a number or "auto".');
            }
            return val;
        };
    }
}
Validators.getNumberOrAutoValidator = getNumberOrAutoValidator;
function getStringValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$r.Util._isString(val)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a string.');
            }
            return val;
        };
    }
}
Validators.getStringValidator = getStringValidator;
function getStringOrGradientValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            var isString = Util_1$r.Util._isString(val);
            var isGradient = Object.prototype.toString.call(val) === '[object CanvasGradient]';
            if (!(isString || isGradient)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a string or a native gradient.');
            }
            return val;
        };
    }
}
Validators.getStringOrGradientValidator = getStringOrGradientValidator;
function getFunctionValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$r.Util._isFunction(val)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a function.');
            }
            return val;
        };
    }
}
Validators.getFunctionValidator = getFunctionValidator;
function getNumberArrayValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$r.Util._isArray(val)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a array of numbers.');
            }
            else {
                val.forEach(function (item) {
                    if (!Util_1$r.Util._isNumber(item)) {
                        Util_1$r.Util.warn('"' +
                            attr +
                            '" attribute has non numeric element ' +
                            item +
                            '. Make sure that all elements are numbers.');
                    }
                });
            }
            return val;
        };
    }
}
Validators.getNumberArrayValidator = getNumberArrayValidator;
function getBooleanValidator() {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            var isBool = val === true || val === false;
            if (!isBool) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be a boolean.');
            }
            return val;
        };
    }
}
Validators.getBooleanValidator = getBooleanValidator;
function getComponentValidator(components) {
    if (Global_1$p.Konva.isUnminified) {
        return function (val, attr) {
            if (!Util_1$r.Util.isObject(val)) {
                Util_1$r.Util.warn(_formatValue(val) +
                    ' is a not valid value for "' +
                    attr +
                    '" attribute. The value should be an object with properties ' +
                    components);
            }
            return val;
        };
    }
}
Validators.getComponentValidator = getComponentValidator;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Factory = void 0;
	var Util_1 = Util;
	var Validators_1 = Validators;
	var GET = 'get', SET = 'set';
	exports.Factory = {
	    addGetterSetter: function (constructor, attr, def, validator, after) {
	        exports.Factory.addGetter(constructor, attr, def);
	        exports.Factory.addSetter(constructor, attr, validator, after);
	        exports.Factory.addOverloadedGetterSetter(constructor, attr);
	    },
	    addGetter: function (constructor, attr, def) {
	        var method = GET + Util_1.Util._capitalize(attr);
	        constructor.prototype[method] =
	            constructor.prototype[method] ||
	                function () {
	                    var val = this.attrs[attr];
	                    return val === undefined ? def : val;
	                };
	    },
	    addSetter: function (constructor, attr, validator, after) {
	        var method = SET + Util_1.Util._capitalize(attr);
	        if (!constructor.prototype[method]) {
	            exports.Factory.overWriteSetter(constructor, attr, validator, after);
	        }
	    },
	    overWriteSetter: function (constructor, attr, validator, after) {
	        var method = SET + Util_1.Util._capitalize(attr);
	        constructor.prototype[method] = function (val) {
	            if (validator && val !== undefined && val !== null) {
	                val = validator.call(this, val, attr);
	            }
	            this._setAttr(attr, val);
	            if (after) {
	                after.call(this);
	            }
	            return this;
	        };
	    },
	    addComponentsGetterSetter: function (constructor, attr, components, validator, after) {
	        var len = components.length, capitalize = Util_1.Util._capitalize, getter = GET + capitalize(attr), setter = SET + capitalize(attr), n, component;
	        constructor.prototype[getter] = function () {
	            var ret = {};
	            for (n = 0; n < len; n++) {
	                component = components[n];
	                ret[component] = this.getAttr(attr + capitalize(component));
	            }
	            return ret;
	        };
	        var basicValidator = Validators_1.getComponentValidator(components);
	        constructor.prototype[setter] = function (val) {
	            var oldVal = this.attrs[attr], key;
	            if (validator) {
	                val = validator.call(this, val);
	            }
	            if (basicValidator) {
	                basicValidator.call(this, val, attr);
	            }
	            for (key in val) {
	                if (!val.hasOwnProperty(key)) {
	                    continue;
	                }
	                this._setAttr(attr + capitalize(key), val[key]);
	            }
	            this._fireChangeEvent(attr, oldVal, val);
	            if (after) {
	                after.call(this);
	            }
	            return this;
	        };
	        exports.Factory.addOverloadedGetterSetter(constructor, attr);
	    },
	    addOverloadedGetterSetter: function (constructor, attr) {
	        var capitalizedAttr = Util_1.Util._capitalize(attr), setter = SET + capitalizedAttr, getter = GET + capitalizedAttr;
	        constructor.prototype[attr] = function () {
	            if (arguments.length) {
	                this[setter](arguments[0]);
	                return this;
	            }
	            return this[getter]();
	        };
	    },
	    addDeprecatedGetterSetter: function (constructor, attr, def, validator) {
	        Util_1.Util.error('Adding deprecated ' + attr);
	        var method = GET + Util_1.Util._capitalize(attr);
	        var message = attr +
	            ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
	        constructor.prototype[method] = function () {
	            Util_1.Util.error(message);
	            var val = this.attrs[attr];
	            return val === undefined ? def : val;
	        };
	        exports.Factory.addSetter(constructor, attr, validator, function () {
	            Util_1.Util.error(message);
	        });
	        exports.Factory.addOverloadedGetterSetter(constructor, attr);
	    },
	    backCompat: function (constructor, methods) {
	        Util_1.Util.each(methods, function (oldMethodName, newMethodName) {
	            var method = constructor.prototype[newMethodName];
	            var oldGetter = GET + Util_1.Util._capitalize(oldMethodName);
	            var oldSetter = SET + Util_1.Util._capitalize(oldMethodName);
	            function deprecated() {
	                method.apply(this, arguments);
	                Util_1.Util.error('"' +
	                    oldMethodName +
	                    '" method is deprecated and will be removed soon. Use ""' +
	                    newMethodName +
	                    '" instead.');
	            }
	            constructor.prototype[oldMethodName] = deprecated;
	            constructor.prototype[oldGetter] = deprecated;
	            constructor.prototype[oldSetter] = deprecated;
	        });
	    },
	    afterSetFilter: function () {
	        this._filterUpToDate = false;
	    },
	};
} (Factory));

var Canvas$1 = {};

var Context$1 = {};

var __extends$m = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Context$1, "__esModule", { value: true });
Context$1.HitContext = Context$1.SceneContext = Context$1.Context = void 0;
var Util_1$q = Util;
var Global_1$o = Global;
var COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', EQUALS = '=', CONTEXT_METHODS = [
    'arc',
    'arcTo',
    'beginPath',
    'bezierCurveTo',
    'clearRect',
    'clip',
    'closePath',
    'createLinearGradient',
    'createPattern',
    'createRadialGradient',
    'drawImage',
    'ellipse',
    'fill',
    'fillText',
    'getImageData',
    'createImageData',
    'lineTo',
    'moveTo',
    'putImageData',
    'quadraticCurveTo',
    'rect',
    'restore',
    'rotate',
    'save',
    'scale',
    'setLineDash',
    'setTransform',
    'stroke',
    'strokeText',
    'transform',
    'translate',
];
var CONTEXT_PROPERTIES = [
    'fillStyle',
    'strokeStyle',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY',
    'lineCap',
    'lineDashOffset',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'font',
    'textAlign',
    'textBaseline',
    'globalAlpha',
    'globalCompositeOperation',
    'imageSmoothingEnabled',
];
var traceArrMax = 100;
var Context = (function () {
    function Context(canvas) {
        this.canvas = canvas;
        this._context = canvas._canvas.getContext('2d');
        if (Global_1$o.Konva.enableTrace) {
            this.traceArr = [];
            this._enableTrace();
        }
    }
    Context.prototype.fillShape = function (shape) {
        if (shape.fillEnabled()) {
            this._fill(shape);
        }
    };
    Context.prototype._fill = function (shape) {
    };
    Context.prototype.strokeShape = function (shape) {
        if (shape.hasStroke()) {
            this._stroke(shape);
        }
    };
    Context.prototype._stroke = function (shape) {
    };
    Context.prototype.fillStrokeShape = function (shape) {
        if (shape.attrs.fillAfterStrokeEnabled) {
            this.strokeShape(shape);
            this.fillShape(shape);
        }
        else {
            this.fillShape(shape);
            this.strokeShape(shape);
        }
    };
    Context.prototype.getTrace = function (relaxed) {
        var traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;
        for (n = 0; n < len; n++) {
            trace = traceArr[n];
            method = trace.method;
            if (method) {
                args = trace.args;
                str += method;
                if (relaxed) {
                    str += DOUBLE_PAREN;
                }
                else {
                    if (Util_1$q.Util._isArray(args[0])) {
                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
                    }
                    else {
                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
                    }
                }
            }
            else {
                str += trace.property;
                if (!relaxed) {
                    str += EQUALS + trace.val;
                }
            }
            str += SEMICOLON;
        }
        return str;
    };
    Context.prototype.clearTrace = function () {
        this.traceArr = [];
    };
    Context.prototype._trace = function (str) {
        var traceArr = this.traceArr, len;
        traceArr.push(str);
        len = traceArr.length;
        if (len >= traceArrMax) {
            traceArr.shift();
        }
    };
    Context.prototype.reset = function () {
        var pixelRatio = this.getCanvas().getPixelRatio();
        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
    };
    Context.prototype.getCanvas = function () {
        return this.canvas;
    };
    Context.prototype.clear = function (bounds) {
        var canvas = this.getCanvas();
        if (bounds) {
            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
        }
        else {
            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
        }
    };
    Context.prototype._applyLineCap = function (shape) {
        var lineCap = shape.getLineCap();
        if (lineCap) {
            this.setAttr('lineCap', lineCap);
        }
    };
    Context.prototype._applyOpacity = function (shape) {
        var absOpacity = shape.getAbsoluteOpacity();
        if (absOpacity !== 1) {
            this.setAttr('globalAlpha', absOpacity);
        }
    };
    Context.prototype._applyLineJoin = function (shape) {
        var lineJoin = shape.attrs.lineJoin;
        if (lineJoin) {
            this.setAttr('lineJoin', lineJoin);
        }
    };
    Context.prototype.setAttr = function (attr, val) {
        this._context[attr] = val;
    };
    Context.prototype.arc = function (a0, a1, a2, a3, a4, a5) {
        this._context.arc(a0, a1, a2, a3, a4, a5);
    };
    Context.prototype.arcTo = function (a0, a1, a2, a3, a4) {
        this._context.arcTo(a0, a1, a2, a3, a4);
    };
    Context.prototype.beginPath = function () {
        this._context.beginPath();
    };
    Context.prototype.bezierCurveTo = function (a0, a1, a2, a3, a4, a5) {
        this._context.bezierCurveTo(a0, a1, a2, a3, a4, a5);
    };
    Context.prototype.clearRect = function (a0, a1, a2, a3) {
        this._context.clearRect(a0, a1, a2, a3);
    };
    Context.prototype.clip = function () {
        this._context.clip();
    };
    Context.prototype.closePath = function () {
        this._context.closePath();
    };
    Context.prototype.createImageData = function (a0, a1) {
        var a = arguments;
        if (a.length === 2) {
            return this._context.createImageData(a0, a1);
        }
        else if (a.length === 1) {
            return this._context.createImageData(a0);
        }
    };
    Context.prototype.createLinearGradient = function (a0, a1, a2, a3) {
        return this._context.createLinearGradient(a0, a1, a2, a3);
    };
    Context.prototype.createPattern = function (a0, a1) {
        return this._context.createPattern(a0, a1);
    };
    Context.prototype.createRadialGradient = function (a0, a1, a2, a3, a4, a5) {
        return this._context.createRadialGradient(a0, a1, a2, a3, a4, a5);
    };
    Context.prototype.drawImage = function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        var a = arguments, _context = this._context;
        if (a.length === 3) {
            _context.drawImage(a0, a1, a2);
        }
        else if (a.length === 5) {
            _context.drawImage(a0, a1, a2, a3, a4);
        }
        else if (a.length === 9) {
            _context.drawImage(a0, a1, a2, a3, a4, a5, a6, a7, a8);
        }
    };
    Context.prototype.ellipse = function (a0, a1, a2, a3, a4, a5, a6, a7) {
        this._context.ellipse(a0, a1, a2, a3, a4, a5, a6, a7);
    };
    Context.prototype.isPointInPath = function (x, y) {
        return this._context.isPointInPath(x, y);
    };
    Context.prototype.fill = function () {
        this._context.fill();
    };
    Context.prototype.fillRect = function (x, y, width, height) {
        this._context.fillRect(x, y, width, height);
    };
    Context.prototype.strokeRect = function (x, y, width, height) {
        this._context.strokeRect(x, y, width, height);
    };
    Context.prototype.fillText = function (a0, a1, a2) {
        this._context.fillText(a0, a1, a2);
    };
    Context.prototype.measureText = function (text) {
        return this._context.measureText(text);
    };
    Context.prototype.getImageData = function (a0, a1, a2, a3) {
        return this._context.getImageData(a0, a1, a2, a3);
    };
    Context.prototype.lineTo = function (a0, a1) {
        this._context.lineTo(a0, a1);
    };
    Context.prototype.moveTo = function (a0, a1) {
        this._context.moveTo(a0, a1);
    };
    Context.prototype.rect = function (a0, a1, a2, a3) {
        this._context.rect(a0, a1, a2, a3);
    };
    Context.prototype.putImageData = function (a0, a1, a2) {
        this._context.putImageData(a0, a1, a2);
    };
    Context.prototype.quadraticCurveTo = function (a0, a1, a2, a3) {
        this._context.quadraticCurveTo(a0, a1, a2, a3);
    };
    Context.prototype.restore = function () {
        this._context.restore();
    };
    Context.prototype.rotate = function (a0) {
        this._context.rotate(a0);
    };
    Context.prototype.save = function () {
        this._context.save();
    };
    Context.prototype.scale = function (a0, a1) {
        this._context.scale(a0, a1);
    };
    Context.prototype.setLineDash = function (a0) {
        if (this._context.setLineDash) {
            this._context.setLineDash(a0);
        }
        else if ('mozDash' in this._context) {
            this._context['mozDash'] = a0;
        }
        else if ('webkitLineDash' in this._context) {
            this._context['webkitLineDash'] = a0;
        }
    };
    Context.prototype.getLineDash = function () {
        return this._context.getLineDash();
    };
    Context.prototype.setTransform = function (a0, a1, a2, a3, a4, a5) {
        this._context.setTransform(a0, a1, a2, a3, a4, a5);
    };
    Context.prototype.stroke = function () {
        this._context.stroke();
    };
    Context.prototype.strokeText = function (a0, a1, a2, a3) {
        this._context.strokeText(a0, a1, a2, a3);
    };
    Context.prototype.transform = function (a0, a1, a2, a3, a4, a5) {
        this._context.transform(a0, a1, a2, a3, a4, a5);
    };
    Context.prototype.translate = function (a0, a1) {
        this._context.translate(a0, a1);
    };
    Context.prototype._enableTrace = function () {
        var that = this, len = CONTEXT_METHODS.length, _simplifyArray = Util_1$q.Util._simplifyArray, origSetter = this.setAttr, n, args;
        var func = function (methodName) {
            var origMethod = that[methodName], ret;
            that[methodName] = function () {
                args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
                ret = origMethod.apply(that, arguments);
                that._trace({
                    method: methodName,
                    args: args,
                });
                return ret;
            };
        };
        for (n = 0; n < len; n++) {
            func(CONTEXT_METHODS[n]);
        }
        that.setAttr = function () {
            origSetter.apply(that, arguments);
            var prop = arguments[0];
            var val = arguments[1];
            if (prop === 'shadowOffsetX' ||
                prop === 'shadowOffsetY' ||
                prop === 'shadowBlur') {
                val = val / this.canvas.getPixelRatio();
            }
            that._trace({
                property: prop,
                val: val,
            });
        };
    };
    Context.prototype._applyGlobalCompositeOperation = function (node) {
        var globalCompositeOperation = node.getGlobalCompositeOperation();
        if (globalCompositeOperation !== 'source-over') {
            this.setAttr('globalCompositeOperation', globalCompositeOperation);
        }
    };
    return Context;
}());
Context$1.Context = Context;
CONTEXT_PROPERTIES.forEach(function (prop) {
    Object.defineProperty(Context.prototype, prop, {
        get: function () {
            return this._context[prop];
        },
        set: function (val) {
            this._context[prop] = val;
        },
    });
});
var SceneContext = (function (_super) {
    __extends$m(SceneContext, _super);
    function SceneContext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SceneContext.prototype._fillColor = function (shape) {
        var fill = shape.fill();
        this.setAttr('fillStyle', fill);
        shape._fillFunc(this);
    };
    SceneContext.prototype._fillPattern = function (shape) {
        var fillPatternX = shape.getFillPatternX(), fillPatternY = shape.getFillPatternY(), fillPatternRotation = Global_1$o.Konva.getAngle(shape.getFillPatternRotation()), fillPatternOffsetX = shape.getFillPatternOffsetX(), fillPatternOffsetY = shape.getFillPatternOffsetY(); shape.getFillPatternScaleX(); shape.getFillPatternScaleY();
        if (fillPatternX || fillPatternY) {
            this.translate(fillPatternX || 0, fillPatternY || 0);
        }
        if (fillPatternRotation) {
            this.rotate(fillPatternRotation);
        }
        if (fillPatternOffsetX || fillPatternOffsetY) {
            this.translate(-1 * fillPatternOffsetX, -1 * fillPatternOffsetY);
        }
        this.setAttr('fillStyle', shape._getFillPattern());
        shape._fillFunc(this);
    };
    SceneContext.prototype._fillLinearGradient = function (shape) {
        var grd = shape._getLinearGradient();
        if (grd) {
            this.setAttr('fillStyle', grd);
            shape._fillFunc(this);
        }
    };
    SceneContext.prototype._fillRadialGradient = function (shape) {
        var grd = shape._getRadialGradient();
        if (grd) {
            this.setAttr('fillStyle', grd);
            shape._fillFunc(this);
        }
    };
    SceneContext.prototype._fill = function (shape) {
        var hasColor = shape.fill(), fillPriority = shape.getFillPriority();
        if (hasColor && fillPriority === 'color') {
            this._fillColor(shape);
            return;
        }
        var hasPattern = shape.getFillPatternImage();
        if (hasPattern && fillPriority === 'pattern') {
            this._fillPattern(shape);
            return;
        }
        var hasLinearGradient = shape.getFillLinearGradientColorStops();
        if (hasLinearGradient && fillPriority === 'linear-gradient') {
            this._fillLinearGradient(shape);
            return;
        }
        var hasRadialGradient = shape.getFillRadialGradientColorStops();
        if (hasRadialGradient && fillPriority === 'radial-gradient') {
            this._fillRadialGradient(shape);
            return;
        }
        if (hasColor) {
            this._fillColor(shape);
        }
        else if (hasPattern) {
            this._fillPattern(shape);
        }
        else if (hasLinearGradient) {
            this._fillLinearGradient(shape);
        }
        else if (hasRadialGradient) {
            this._fillRadialGradient(shape);
        }
    };
    SceneContext.prototype._strokeLinearGradient = function (shape) {
        var start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
        if (colorStops) {
            for (var n = 0; n < colorStops.length; n += 2) {
                grd.addColorStop(colorStops[n], colorStops[n + 1]);
            }
            this.setAttr('strokeStyle', grd);
        }
    };
    SceneContext.prototype._stroke = function (shape) {
        var dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();
        if (shape.hasStroke()) {
            if (!strokeScaleEnabled) {
                this.save();
                var pixelRatio = this.getCanvas().getPixelRatio();
                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            }
            this._applyLineCap(shape);
            if (dash && shape.dashEnabled()) {
                this.setLineDash(dash);
                this.setAttr('lineDashOffset', shape.dashOffset());
            }
            this.setAttr('lineWidth', shape.strokeWidth());
            if (!shape.getShadowForStrokeEnabled()) {
                this.setAttr('shadowColor', 'rgba(0,0,0,0)');
            }
            var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
            if (hasLinearGradient) {
                this._strokeLinearGradient(shape);
            }
            else {
                this.setAttr('strokeStyle', shape.stroke());
            }
            shape._strokeFunc(this);
            if (!strokeScaleEnabled) {
                this.restore();
            }
        }
    };
    SceneContext.prototype._applyShadow = function (shape) {
        var util = Util_1$q.Util, color = util.get(shape.getShadowRGBA(), 'black'), blur = util.get(shape.getShadowBlur(), 5), offset = util.get(shape.getShadowOffset(), {
            x: 0,
            y: 0,
        }), scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;
        this.setAttr('shadowColor', color);
        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));
        this.setAttr('shadowOffsetX', offset.x * scaleX);
        this.setAttr('shadowOffsetY', offset.y * scaleY);
    };
    return SceneContext;
}(Context));
Context$1.SceneContext = SceneContext;
var HitContext = (function (_super) {
    __extends$m(HitContext, _super);
    function HitContext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HitContext.prototype._fill = function (shape) {
        this.save();
        this.setAttr('fillStyle', shape.colorKey);
        shape._fillFuncHit(this);
        this.restore();
    };
    HitContext.prototype.strokeShape = function (shape) {
        if (shape.hasHitStroke()) {
            this._stroke(shape);
        }
    };
    HitContext.prototype._stroke = function (shape) {
        if (shape.hasHitStroke()) {
            var strokeScaleEnabled = shape.getStrokeScaleEnabled();
            if (!strokeScaleEnabled) {
                this.save();
                var pixelRatio = this.getCanvas().getPixelRatio();
                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            }
            this._applyLineCap(shape);
            var hitStrokeWidth = shape.hitStrokeWidth();
            var strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;
            this.setAttr('lineWidth', strokeWidth);
            this.setAttr('strokeStyle', shape.colorKey);
            shape._strokeFuncHit(this);
            if (!strokeScaleEnabled) {
                this.restore();
            }
        }
    };
    return HitContext;
}(Context));
Context$1.HitContext = HitContext;

var __extends$l = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Canvas$1, "__esModule", { value: true });
Canvas$1.HitCanvas = Canvas$1.SceneCanvas = Canvas$1.Canvas = void 0;
var Util_1$p = Util;
var Context_1$1 = Context$1;
var Global_1$n = Global;
var Factory_1$y = Factory;
var Validators_1$x = Validators;
var _pixelRatio;
function getDevicePixelRatio() {
    if (_pixelRatio) {
        return _pixelRatio;
    }
    var canvas = Util_1$p.Util.createCanvasElement();
    var context = canvas.getContext('2d');
    _pixelRatio = (function () {
        var devicePixelRatio = Global_1$n.Konva._global.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio ||
            context.mozBackingStorePixelRatio ||
            context.msBackingStorePixelRatio ||
            context.oBackingStorePixelRatio ||
            context.backingStorePixelRatio ||
            1;
        return devicePixelRatio / backingStoreRatio;
    })();
    return _pixelRatio;
}
var Canvas = (function () {
    function Canvas(config) {
        this.pixelRatio = 1;
        this.width = 0;
        this.height = 0;
        this.isCache = false;
        var conf = config || {};
        var pixelRatio = conf.pixelRatio || Global_1$n.Konva.pixelRatio || getDevicePixelRatio();
        this.pixelRatio = pixelRatio;
        this._canvas = Util_1$p.Util.createCanvasElement();
        this._canvas.style.padding = '0';
        this._canvas.style.margin = '0';
        this._canvas.style.border = '0';
        this._canvas.style.background = 'transparent';
        this._canvas.style.position = 'absolute';
        this._canvas.style.top = '0';
        this._canvas.style.left = '0';
    }
    Canvas.prototype.getContext = function () {
        return this.context;
    };
    Canvas.prototype.getPixelRatio = function () {
        return this.pixelRatio;
    };
    Canvas.prototype.setPixelRatio = function (pixelRatio) {
        var previousRatio = this.pixelRatio;
        this.pixelRatio = pixelRatio;
        this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
    };
    Canvas.prototype.setWidth = function (width) {
        this.width = this._canvas.width = width * this.pixelRatio;
        this._canvas.style.width = width + 'px';
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
    };
    Canvas.prototype.setHeight = function (height) {
        this.height = this._canvas.height = height * this.pixelRatio;
        this._canvas.style.height = height + 'px';
        var pixelRatio = this.pixelRatio, _context = this.getContext()._context;
        _context.scale(pixelRatio, pixelRatio);
    };
    Canvas.prototype.getWidth = function () {
        return this.width;
    };
    Canvas.prototype.getHeight = function () {
        return this.height;
    };
    Canvas.prototype.setSize = function (width, height) {
        this.setWidth(width || 0);
        this.setHeight(height || 0);
    };
    Canvas.prototype.toDataURL = function (mimeType, quality) {
        try {
            return this._canvas.toDataURL(mimeType, quality);
        }
        catch (e) {
            try {
                return this._canvas.toDataURL();
            }
            catch (err) {
                Util_1$p.Util.error('Unable to get data URL. ' +
                    err.message +
                    ' For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html.');
                return '';
            }
        }
    };
    return Canvas;
}());
Canvas$1.Canvas = Canvas;
Factory_1$y.Factory.addGetterSetter(Canvas, 'pixelRatio', undefined, Validators_1$x.getNumberValidator());
var SceneCanvas = (function (_super) {
    __extends$l(SceneCanvas, _super);
    function SceneCanvas(config) {
        if (config === void 0) { config = { width: 0, height: 0 }; }
        var _this = _super.call(this, config) || this;
        _this.context = new Context_1$1.SceneContext(_this);
        _this.setSize(config.width, config.height);
        return _this;
    }
    return SceneCanvas;
}(Canvas));
Canvas$1.SceneCanvas = SceneCanvas;
var HitCanvas = (function (_super) {
    __extends$l(HitCanvas, _super);
    function HitCanvas(config) {
        if (config === void 0) { config = { width: 0, height: 0 }; }
        var _this = _super.call(this, config) || this;
        _this.hitCanvas = true;
        _this.context = new Context_1$1.HitContext(_this);
        _this.setSize(config.width, config.height);
        return _this;
    }
    return HitCanvas;
}(Canvas));
Canvas$1.HitCanvas = HitCanvas;

var DragAndDrop = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DD = void 0;
	var Global_1 = Global;
	var Util_1 = Util;
	exports.DD = {
	    get isDragging() {
	        var flag = false;
	        exports.DD._dragElements.forEach(function (elem) {
	            if (elem.dragStatus === 'dragging') {
	                flag = true;
	            }
	        });
	        return flag;
	    },
	    justDragged: false,
	    get node() {
	        var node;
	        exports.DD._dragElements.forEach(function (elem) {
	            node = elem.node;
	        });
	        return node;
	    },
	    _dragElements: new Map(),
	    _drag: function (evt) {
	        var nodesToFireEvents = [];
	        exports.DD._dragElements.forEach(function (elem, key) {
	            var node = elem.node;
	            var stage = node.getStage();
	            stage.setPointersPositions(evt);
	            if (elem.pointerId === undefined) {
	                elem.pointerId = Util_1.Util._getFirstPointerId(evt);
	            }
	            var pos = stage._changedPointerPositions.find(function (pos) { return pos.id === elem.pointerId; });
	            if (!pos) {
	                return;
	            }
	            if (elem.dragStatus !== 'dragging') {
	                var dragDistance = node.dragDistance();
	                var distance = Math.max(Math.abs(pos.x - elem.startPointerPos.x), Math.abs(pos.y - elem.startPointerPos.y));
	                if (distance < dragDistance) {
	                    return;
	                }
	                node.startDrag({ evt: evt });
	                if (!node.isDragging()) {
	                    return;
	                }
	            }
	            node._setDragPosition(evt, elem);
	            nodesToFireEvents.push(node);
	        });
	        nodesToFireEvents.forEach(function (node) {
	            node.fire('dragmove', {
	                type: 'dragmove',
	                target: node,
	                evt: evt,
	            }, true);
	        });
	    },
	    _endDragBefore: function (evt) {
	        exports.DD._dragElements.forEach(function (elem, key) {
	            var node = elem.node;
	            var stage = node.getStage();
	            if (evt) {
	                stage.setPointersPositions(evt);
	            }
	            var pos = stage._changedPointerPositions.find(function (pos) { return pos.id === elem.pointerId; });
	            if (!pos) {
	                return;
	            }
	            if (elem.dragStatus === 'dragging' || elem.dragStatus === 'stopped') {
	                exports.DD.justDragged = true;
	                Global_1.Konva.listenClickTap = false;
	                elem.dragStatus = 'stopped';
	            }
	            var drawNode = elem.node.getLayer() ||
	                (elem.node instanceof Global_1.Konva['Stage'] && elem.node);
	            if (drawNode) {
	                drawNode.batchDraw();
	            }
	        });
	    },
	    _endDragAfter: function (evt) {
	        exports.DD._dragElements.forEach(function (elem, key) {
	            if (elem.dragStatus === 'stopped') {
	                elem.node.fire('dragend', {
	                    type: 'dragend',
	                    target: elem.node,
	                    evt: evt,
	                }, true);
	            }
	            if (elem.dragStatus !== 'dragging') {
	                exports.DD._dragElements.delete(key);
	            }
	        });
	    },
	};
	if (Global_1.Konva.isBrowser) {
	    window.addEventListener('mouseup', exports.DD._endDragBefore, true);
	    window.addEventListener('touchend', exports.DD._endDragBefore, true);
	    window.addEventListener('mousemove', exports.DD._drag);
	    window.addEventListener('touchmove', exports.DD._drag);
	    window.addEventListener('mouseup', exports.DD._endDragAfter, false);
	    window.addEventListener('touchend', exports.DD._endDragAfter, false);
	}
} (DragAndDrop));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Node = exports._removeName = exports._addName = exports._removeId = exports.names = exports.ids = void 0;
	var Util_1 = Util;
	var Factory_1 = Factory;
	var Canvas_1 = Canvas$1;
	var Global_1 = Global;
	var DragAndDrop_1 = DragAndDrop;
	var Validators_1 = Validators;
	exports.ids = {};
	exports.names = {};
	var _addId = function (node, id) {
	    if (!id) {
	        return;
	    }
	    exports.ids[id] = node;
	};
	var _removeId = function (id, node) {
	    if (!id) {
	        return;
	    }
	    if (exports.ids[id] !== node) {
	        return;
	    }
	    delete exports.ids[id];
	};
	exports._removeId = _removeId;
	var _addName = function (node, name) {
	    if (name) {
	        if (!exports.names[name]) {
	            exports.names[name] = [];
	        }
	        exports.names[name].push(node);
	    }
	};
	exports._addName = _addName;
	var _removeName = function (name, _id) {
	    if (!name) {
	        return;
	    }
	    var nodes = exports.names[name];
	    if (!nodes) {
	        return;
	    }
	    for (var n = 0; n < nodes.length; n++) {
	        var no = nodes[n];
	        if (no._id === _id) {
	            nodes.splice(n, 1);
	        }
	    }
	    if (nodes.length === 0) {
	        delete exports.names[name];
	    }
	};
	exports._removeName = _removeName;
	var ABSOLUTE_OPACITY = 'absoluteOpacity', ALL_LISTENERS = 'allEventListeners', ABSOLUTE_TRANSFORM = 'absoluteTransform', ABSOLUTE_SCALE = 'absoluteScale', CANVAS = 'canvas', CHANGE = 'Change', CHILDREN = 'children', KONVA = 'konva', LISTENING = 'listening', MOUSEENTER = 'mouseenter', MOUSELEAVE = 'mouseleave', NAME = 'name', SET = 'set', SHAPE = 'Shape', SPACE = ' ', STAGE = 'stage', TRANSFORM = 'transform', UPPER_STAGE = 'Stage', VISIBLE = 'visible', TRANSFORM_CHANGE_STR = [
	    'xChange.konva',
	    'yChange.konva',
	    'scaleXChange.konva',
	    'scaleYChange.konva',
	    'skewXChange.konva',
	    'skewYChange.konva',
	    'rotationChange.konva',
	    'offsetXChange.konva',
	    'offsetYChange.konva',
	    'transformsEnabledChange.konva',
	].join(SPACE);
	var emptyChildren = new Util_1.Collection();
	var idCounter = 1;
	var Node = (function () {
	    function Node(config) {
	        this._id = idCounter++;
	        this.eventListeners = {};
	        this.attrs = {};
	        this.index = 0;
	        this._allEventListeners = null;
	        this.parent = null;
	        this._cache = new Map();
	        this._attachedDepsListeners = new Map();
	        this._lastPos = null;
	        this._batchingTransformChange = false;
	        this._needClearTransformCache = false;
	        this._filterUpToDate = false;
	        this._isUnderCache = false;
	        this.children = emptyChildren;
	        this._dragEventId = null;
	        this._shouldFireChangeEvents = false;
	        this.setAttrs(config);
	        this._shouldFireChangeEvents = true;
	    }
	    Node.prototype.hasChildren = function () {
	        return false;
	    };
	    Node.prototype.getChildren = function () {
	        return emptyChildren;
	    };
	    Node.prototype._clearCache = function (attr) {
	        if ((attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM) &&
	            this._cache.get(attr)) {
	            this._cache.get(attr).dirty = true;
	        }
	        else if (attr) {
	            this._cache.delete(attr);
	        }
	        else {
	            this._cache.clear();
	        }
	    };
	    Node.prototype._getCache = function (attr, privateGetter) {
	        var cache = this._cache.get(attr);
	        var isTransform = attr === TRANSFORM || attr === ABSOLUTE_TRANSFORM;
	        var invalid = cache === undefined || (isTransform && cache.dirty === true);
	        if (invalid) {
	            cache = privateGetter.call(this);
	            this._cache.set(attr, cache);
	        }
	        return cache;
	    };
	    Node.prototype._calculate = function (name, deps, getter) {
	        var _this = this;
	        if (!this._attachedDepsListeners.get(name)) {
	            var depsString = deps.map(function (dep) { return dep + 'Change.konva'; }).join(SPACE);
	            this.on(depsString, function () {
	                _this._clearCache(name);
	            });
	            this._attachedDepsListeners.set(name, true);
	        }
	        return this._getCache(name, getter);
	    };
	    Node.prototype._getCanvasCache = function () {
	        return this._cache.get(CANVAS);
	    };
	    Node.prototype._clearSelfAndDescendantCache = function (attr, forceEvent) {
	        this._clearCache(attr);
	        if (forceEvent && attr === ABSOLUTE_TRANSFORM) {
	            this.fire('_clearTransformCache');
	        }
	        if (this.isCached()) {
	            return;
	        }
	        if (this.children) {
	            this.children.each(function (node) {
	                node._clearSelfAndDescendantCache(attr, true);
	            });
	        }
	    };
	    Node.prototype.clearCache = function () {
	        this._cache.delete(CANVAS);
	        this._clearSelfAndDescendantCache();
	        return this;
	    };
	    Node.prototype.cache = function (config) {
	        var conf = config || {};
	        var rect = {};
	        if (conf.x === undefined ||
	            conf.y === undefined ||
	            conf.width === undefined ||
	            conf.height === undefined) {
	            rect = this.getClientRect({
	                skipTransform: true,
	                relativeTo: this.getParent(),
	            });
	        }
	        var width = Math.ceil(conf.width || rect.width), height = Math.ceil(conf.height || rect.height), pixelRatio = conf.pixelRatio, x = conf.x === undefined ? rect.x : conf.x, y = conf.y === undefined ? rect.y : conf.y, offset = conf.offset || 0, drawBorder = conf.drawBorder || false;
	        if (!width || !height) {
	            Util_1.Util.error('Can not cache the node. Width or height of the node equals 0. Caching is skipped.');
	            return;
	        }
	        width += offset * 2;
	        height += offset * 2;
	        x -= offset;
	        y -= offset;
	        var cachedSceneCanvas = new Canvas_1.SceneCanvas({
	            pixelRatio: pixelRatio,
	            width: width,
	            height: height,
	        }), cachedFilterCanvas = new Canvas_1.SceneCanvas({
	            pixelRatio: pixelRatio,
	            width: 0,
	            height: 0,
	        }), cachedHitCanvas = new Canvas_1.HitCanvas({
	            pixelRatio: 1,
	            width: width,
	            height: height,
	        }), sceneContext = cachedSceneCanvas.getContext(), hitContext = cachedHitCanvas.getContext();
	        cachedHitCanvas.isCache = true;
	        cachedSceneCanvas.isCache = true;
	        this._cache.delete('canvas');
	        this._filterUpToDate = false;
	        if (conf.imageSmoothingEnabled === false) {
	            cachedSceneCanvas.getContext()._context.imageSmoothingEnabled = false;
	            cachedFilterCanvas.getContext()._context.imageSmoothingEnabled = false;
	        }
	        sceneContext.save();
	        hitContext.save();
	        sceneContext.translate(-x, -y);
	        hitContext.translate(-x, -y);
	        this._isUnderCache = true;
	        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
	        this.drawScene(cachedSceneCanvas, this);
	        this.drawHit(cachedHitCanvas, this);
	        this._isUnderCache = false;
	        sceneContext.restore();
	        hitContext.restore();
	        if (drawBorder) {
	            sceneContext.save();
	            sceneContext.beginPath();
	            sceneContext.rect(0, 0, width, height);
	            sceneContext.closePath();
	            sceneContext.setAttr('strokeStyle', 'red');
	            sceneContext.setAttr('lineWidth', 5);
	            sceneContext.stroke();
	            sceneContext.restore();
	        }
	        this._cache.set(CANVAS, {
	            scene: cachedSceneCanvas,
	            filter: cachedFilterCanvas,
	            hit: cachedHitCanvas,
	            x: x,
	            y: y,
	        });
	        return this;
	    };
	    Node.prototype.isCached = function () {
	        return this._cache.has('canvas');
	    };
	    Node.prototype.getClientRect = function (config) {
	        throw new Error('abstract "getClientRect" method call');
	    };
	    Node.prototype._transformedRect = function (rect, top) {
	        var points = [
	            { x: rect.x, y: rect.y },
	            { x: rect.x + rect.width, y: rect.y },
	            { x: rect.x + rect.width, y: rect.y + rect.height },
	            { x: rect.x, y: rect.y + rect.height },
	        ];
	        var minX, minY, maxX, maxY;
	        var trans = this.getAbsoluteTransform(top);
	        points.forEach(function (point) {
	            var transformed = trans.point(point);
	            if (minX === undefined) {
	                minX = maxX = transformed.x;
	                minY = maxY = transformed.y;
	            }
	            minX = Math.min(minX, transformed.x);
	            minY = Math.min(minY, transformed.y);
	            maxX = Math.max(maxX, transformed.x);
	            maxY = Math.max(maxY, transformed.y);
	        });
	        return {
	            x: minX,
	            y: minY,
	            width: maxX - minX,
	            height: maxY - minY,
	        };
	    };
	    Node.prototype._drawCachedSceneCanvas = function (context) {
	        context.save();
	        context._applyOpacity(this);
	        context._applyGlobalCompositeOperation(this);
	        var canvasCache = this._getCanvasCache();
	        context.translate(canvasCache.x, canvasCache.y);
	        var cacheCanvas = this._getCachedSceneCanvas();
	        var ratio = cacheCanvas.pixelRatio;
	        context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
	        context.restore();
	    };
	    Node.prototype._drawCachedHitCanvas = function (context) {
	        var canvasCache = this._getCanvasCache(), hitCanvas = canvasCache.hit;
	        context.save();
	        context.translate(canvasCache.x, canvasCache.y);
	        context.drawImage(hitCanvas._canvas, 0, 0);
	        context.restore();
	    };
	    Node.prototype._getCachedSceneCanvas = function () {
	        var filters = this.filters(), cachedCanvas = this._getCanvasCache(), sceneCanvas = cachedCanvas.scene, filterCanvas = cachedCanvas.filter, filterContext = filterCanvas.getContext(), len, imageData, n, filter;
	        if (filters) {
	            if (!this._filterUpToDate) {
	                var ratio = sceneCanvas.pixelRatio;
	                filterCanvas.setSize(sceneCanvas.width / sceneCanvas.pixelRatio, sceneCanvas.height / sceneCanvas.pixelRatio);
	                try {
	                    len = filters.length;
	                    filterContext.clear();
	                    filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
	                    imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
	                    for (n = 0; n < len; n++) {
	                        filter = filters[n];
	                        if (typeof filter !== 'function') {
	                            Util_1.Util.error('Filter should be type of function, but got ' +
	                                typeof filter +
	                                ' instead. Please check correct filters');
	                            continue;
	                        }
	                        filter.call(this, imageData);
	                        filterContext.putImageData(imageData, 0, 0);
	                    }
	                }
	                catch (e) {
	                    Util_1.Util.error('Unable to apply filter. ' +
	                        e.message +
	                        ' This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.');
	                }
	                this._filterUpToDate = true;
	            }
	            return filterCanvas;
	        }
	        return sceneCanvas;
	    };
	    Node.prototype.on = function (evtStr, handler) {
	        this._cache && this._cache.delete(ALL_LISTENERS);
	        if (arguments.length === 3) {
	            return this._delegate.apply(this, arguments);
	        }
	        var events = evtStr.split(SPACE), len = events.length, n, event, parts, baseEvent, name;
	        for (n = 0; n < len; n++) {
	            event = events[n];
	            parts = event.split('.');
	            baseEvent = parts[0];
	            name = parts[1] || '';
	            if (!this.eventListeners[baseEvent]) {
	                this.eventListeners[baseEvent] = [];
	            }
	            this.eventListeners[baseEvent].push({
	                name: name,
	                handler: handler,
	            });
	        }
	        return this;
	    };
	    Node.prototype.off = function (evtStr, callback) {
	        var events = (evtStr || '').split(SPACE), len = events.length, n, t, event, parts, baseEvent, name;
	        this._cache && this._cache.delete(ALL_LISTENERS);
	        if (!evtStr) {
	            for (t in this.eventListeners) {
	                this._off(t);
	            }
	        }
	        for (n = 0; n < len; n++) {
	            event = events[n];
	            parts = event.split('.');
	            baseEvent = parts[0];
	            name = parts[1];
	            if (baseEvent) {
	                if (this.eventListeners[baseEvent]) {
	                    this._off(baseEvent, name, callback);
	                }
	            }
	            else {
	                for (t in this.eventListeners) {
	                    this._off(t, name, callback);
	                }
	            }
	        }
	        return this;
	    };
	    Node.prototype.dispatchEvent = function (evt) {
	        var e = {
	            target: this,
	            type: evt.type,
	            evt: evt,
	        };
	        this.fire(evt.type, e);
	        return this;
	    };
	    Node.prototype.addEventListener = function (type, handler) {
	        this.on(type, function (evt) {
	            handler.call(this, evt.evt);
	        });
	        return this;
	    };
	    Node.prototype.removeEventListener = function (type) {
	        this.off(type);
	        return this;
	    };
	    Node.prototype._delegate = function (event, selector, handler) {
	        var stopNode = this;
	        this.on(event, function (evt) {
	            var targets = evt.target.findAncestors(selector, true, stopNode);
	            for (var i = 0; i < targets.length; i++) {
	                evt = Util_1.Util.cloneObject(evt);
	                evt.currentTarget = targets[i];
	                handler.call(targets[i], evt);
	            }
	        });
	    };
	    Node.prototype.remove = function () {
	        if (this.isDragging()) {
	            this.stopDrag();
	        }
	        DragAndDrop_1.DD._dragElements.delete(this._id);
	        this._remove();
	        return this;
	    };
	    Node.prototype._clearCaches = function () {
	        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
	        this._clearSelfAndDescendantCache(STAGE);
	        this._clearSelfAndDescendantCache(VISIBLE);
	        this._clearSelfAndDescendantCache(LISTENING);
	    };
	    Node.prototype._remove = function () {
	        this._clearCaches();
	        var parent = this.getParent();
	        if (parent && parent.children) {
	            parent.children.splice(this.index, 1);
	            parent._setChildrenIndices();
	            this.parent = null;
	        }
	    };
	    Node.prototype.destroy = function () {
	        exports._removeId(this.id(), this);
	        var names = (this.name() || '').split(/\s/g);
	        for (var i = 0; i < names.length; i++) {
	            var subname = names[i];
	            exports._removeName(subname, this._id);
	        }
	        this.remove();
	        return this;
	    };
	    Node.prototype.getAttr = function (attr) {
	        var method = 'get' + Util_1.Util._capitalize(attr);
	        if (Util_1.Util._isFunction(this[method])) {
	            return this[method]();
	        }
	        return this.attrs[attr];
	    };
	    Node.prototype.getAncestors = function () {
	        var parent = this.getParent(), ancestors = new Util_1.Collection();
	        while (parent) {
	            ancestors.push(parent);
	            parent = parent.getParent();
	        }
	        return ancestors;
	    };
	    Node.prototype.getAttrs = function () {
	        return this.attrs || {};
	    };
	    Node.prototype.setAttrs = function (config) {
	        var _this = this;
	        this._batchTransformChanges(function () {
	            var key, method;
	            if (!config) {
	                return _this;
	            }
	            for (key in config) {
	                if (key === CHILDREN) {
	                    continue;
	                }
	                method = SET + Util_1.Util._capitalize(key);
	                if (Util_1.Util._isFunction(_this[method])) {
	                    _this[method](config[key]);
	                }
	                else {
	                    _this._setAttr(key, config[key]);
	                }
	            }
	        });
	        return this;
	    };
	    Node.prototype.isListening = function () {
	        return this._getCache(LISTENING, this._isListening);
	    };
	    Node.prototype._isListening = function (relativeTo) {
	        var listening = this.listening();
	        if (!listening) {
	            return false;
	        }
	        var parent = this.getParent();
	        if (parent && parent !== relativeTo && this !== relativeTo) {
	            return parent._isListening(relativeTo);
	        }
	        else {
	            return true;
	        }
	    };
	    Node.prototype.isVisible = function () {
	        return this._getCache(VISIBLE, this._isVisible);
	    };
	    Node.prototype._isVisible = function (relativeTo) {
	        var visible = this.visible();
	        if (!visible) {
	            return false;
	        }
	        var parent = this.getParent();
	        if (parent && parent !== relativeTo && this !== relativeTo) {
	            return parent._isVisible(relativeTo);
	        }
	        else {
	            return true;
	        }
	    };
	    Node.prototype.shouldDrawHit = function (top, skipDragCheck) {
	        if (skipDragCheck === void 0) { skipDragCheck = false; }
	        if (top) {
	            return this._isVisible(top) && this._isListening(top);
	        }
	        var layer = this.getLayer();
	        var layerUnderDrag = false;
	        DragAndDrop_1.DD._dragElements.forEach(function (elem) {
	            if (elem.dragStatus !== 'dragging') {
	                return;
	            }
	            else if (elem.node.nodeType === 'Stage') {
	                layerUnderDrag = true;
	            }
	            else if (elem.node.getLayer() === layer) {
	                layerUnderDrag = true;
	            }
	        });
	        var dragSkip = !skipDragCheck && !Global_1.Konva.hitOnDragEnabled && layerUnderDrag;
	        return this.isListening() && this.isVisible() && !dragSkip;
	    };
	    Node.prototype.show = function () {
	        this.visible(true);
	        return this;
	    };
	    Node.prototype.hide = function () {
	        this.visible(false);
	        return this;
	    };
	    Node.prototype.getZIndex = function () {
	        return this.index || 0;
	    };
	    Node.prototype.getAbsoluteZIndex = function () {
	        var depth = this.getDepth(), that = this, index = 0, nodes, len, n, child;
	        function addChildren(children) {
	            nodes = [];
	            len = children.length;
	            for (n = 0; n < len; n++) {
	                child = children[n];
	                index++;
	                if (child.nodeType !== SHAPE) {
	                    nodes = nodes.concat(child.getChildren().toArray());
	                }
	                if (child._id === that._id) {
	                    n = len;
	                }
	            }
	            if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
	                addChildren(nodes);
	            }
	        }
	        if (that.nodeType !== UPPER_STAGE) {
	            addChildren(that.getStage().getChildren());
	        }
	        return index;
	    };
	    Node.prototype.getDepth = function () {
	        var depth = 0, parent = this.parent;
	        while (parent) {
	            depth++;
	            parent = parent.parent;
	        }
	        return depth;
	    };
	    Node.prototype._batchTransformChanges = function (func) {
	        this._batchingTransformChange = true;
	        func();
	        this._batchingTransformChange = false;
	        if (this._needClearTransformCache) {
	            this._clearCache(TRANSFORM);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM, true);
	        }
	        this._needClearTransformCache = false;
	    };
	    Node.prototype.setPosition = function (pos) {
	        var _this = this;
	        this._batchTransformChanges(function () {
	            _this.x(pos.x);
	            _this.y(pos.y);
	        });
	        return this;
	    };
	    Node.prototype.getPosition = function () {
	        return {
	            x: this.x(),
	            y: this.y(),
	        };
	    };
	    Node.prototype.getAbsolutePosition = function (top) {
	        var haveCachedParent = false;
	        var parent = this.parent;
	        while (parent) {
	            if (parent.isCached()) {
	                haveCachedParent = true;
	                break;
	            }
	            parent = parent.parent;
	        }
	        if (haveCachedParent && !top) {
	            top = true;
	        }
	        var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(), absoluteTransform = new Util_1.Transform(), offset = this.offset();
	        absoluteTransform.m = absoluteMatrix.slice();
	        absoluteTransform.translate(offset.x, offset.y);
	        return absoluteTransform.getTranslation();
	    };
	    Node.prototype.setAbsolutePosition = function (pos) {
	        var origTrans = this._clearTransform();
	        this.attrs.x = origTrans.x;
	        this.attrs.y = origTrans.y;
	        delete origTrans.x;
	        delete origTrans.y;
	        this._clearCache(TRANSFORM);
	        var it = this._getAbsoluteTransform().copy();
	        it.invert();
	        it.translate(pos.x, pos.y);
	        pos = {
	            x: this.attrs.x + it.getTranslation().x,
	            y: this.attrs.y + it.getTranslation().y,
	        };
	        this._setTransform(origTrans);
	        this.setPosition({ x: pos.x, y: pos.y });
	        this._clearCache(TRANSFORM);
	        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        return this;
	    };
	    Node.prototype._setTransform = function (trans) {
	        var key;
	        for (key in trans) {
	            this.attrs[key] = trans[key];
	        }
	    };
	    Node.prototype._clearTransform = function () {
	        var trans = {
	            x: this.x(),
	            y: this.y(),
	            rotation: this.rotation(),
	            scaleX: this.scaleX(),
	            scaleY: this.scaleY(),
	            offsetX: this.offsetX(),
	            offsetY: this.offsetY(),
	            skewX: this.skewX(),
	            skewY: this.skewY(),
	        };
	        this.attrs.x = 0;
	        this.attrs.y = 0;
	        this.attrs.rotation = 0;
	        this.attrs.scaleX = 1;
	        this.attrs.scaleY = 1;
	        this.attrs.offsetX = 0;
	        this.attrs.offsetY = 0;
	        this.attrs.skewX = 0;
	        this.attrs.skewY = 0;
	        return trans;
	    };
	    Node.prototype.move = function (change) {
	        var changeX = change.x, changeY = change.y, x = this.x(), y = this.y();
	        if (changeX !== undefined) {
	            x += changeX;
	        }
	        if (changeY !== undefined) {
	            y += changeY;
	        }
	        this.setPosition({ x: x, y: y });
	        return this;
	    };
	    Node.prototype._eachAncestorReverse = function (func, top) {
	        var family = [], parent = this.getParent(), len, n;
	        if (top && top._id === this._id) {
	            return;
	        }
	        family.unshift(this);
	        while (parent && (!top || parent._id !== top._id)) {
	            family.unshift(parent);
	            parent = parent.parent;
	        }
	        len = family.length;
	        for (n = 0; n < len; n++) {
	            func(family[n]);
	        }
	    };
	    Node.prototype.rotate = function (theta) {
	        this.rotation(this.rotation() + theta);
	        return this;
	    };
	    Node.prototype.moveToTop = function () {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveToTop function is ignored.');
	            return false;
	        }
	        var index = this.index;
	        this.parent.children.splice(index, 1);
	        this.parent.children.push(this);
	        this.parent._setChildrenIndices();
	        return true;
	    };
	    Node.prototype.moveUp = function () {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveUp function is ignored.');
	            return false;
	        }
	        var index = this.index, len = this.parent.getChildren().length;
	        if (index < len - 1) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.splice(index + 1, 0, this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    };
	    Node.prototype.moveDown = function () {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveDown function is ignored.');
	            return false;
	        }
	        var index = this.index;
	        if (index > 0) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.splice(index - 1, 0, this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    };
	    Node.prototype.moveToBottom = function () {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. moveToBottom function is ignored.');
	            return false;
	        }
	        var index = this.index;
	        if (index > 0) {
	            this.parent.children.splice(index, 1);
	            this.parent.children.unshift(this);
	            this.parent._setChildrenIndices();
	            return true;
	        }
	        return false;
	    };
	    Node.prototype.setZIndex = function (zIndex) {
	        if (!this.parent) {
	            Util_1.Util.warn('Node has no parent. zIndex parameter is ignored.');
	            return this;
	        }
	        if (zIndex < 0 || zIndex >= this.parent.children.length) {
	            Util_1.Util.warn('Unexpected value ' +
	                zIndex +
	                ' for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to ' +
	                (this.parent.children.length - 1) +
	                '.');
	        }
	        var index = this.index;
	        this.parent.children.splice(index, 1);
	        this.parent.children.splice(zIndex, 0, this);
	        this.parent._setChildrenIndices();
	        return this;
	    };
	    Node.prototype.getAbsoluteOpacity = function () {
	        return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
	    };
	    Node.prototype._getAbsoluteOpacity = function () {
	        var absOpacity = this.opacity();
	        var parent = this.getParent();
	        if (parent && !parent._isUnderCache) {
	            absOpacity *= parent.getAbsoluteOpacity();
	        }
	        return absOpacity;
	    };
	    Node.prototype.moveTo = function (newContainer) {
	        if (this.getParent() !== newContainer) {
	            this._remove();
	            newContainer.add(this);
	        }
	        return this;
	    };
	    Node.prototype.toObject = function () {
	        var obj = {}, attrs = this.getAttrs(), key, val, getter, defaultValue, nonPlainObject;
	        obj.attrs = {};
	        for (key in attrs) {
	            val = attrs[key];
	            nonPlainObject =
	                Util_1.Util.isObject(val) && !Util_1.Util._isPlainObject(val) && !Util_1.Util._isArray(val);
	            if (nonPlainObject) {
	                continue;
	            }
	            getter = typeof this[key] === 'function' && this[key];
	            delete attrs[key];
	            defaultValue = getter ? getter.call(this) : null;
	            attrs[key] = val;
	            if (defaultValue !== val) {
	                obj.attrs[key] = val;
	            }
	        }
	        obj.className = this.getClassName();
	        return Util_1.Util._prepareToStringify(obj);
	    };
	    Node.prototype.toJSON = function () {
	        return JSON.stringify(this.toObject());
	    };
	    Node.prototype.getParent = function () {
	        return this.parent;
	    };
	    Node.prototype.findAncestors = function (selector, includeSelf, stopNode) {
	        var res = [];
	        if (includeSelf && this._isMatch(selector)) {
	            res.push(this);
	        }
	        var ancestor = this.parent;
	        while (ancestor) {
	            if (ancestor === stopNode) {
	                return res;
	            }
	            if (ancestor._isMatch(selector)) {
	                res.push(ancestor);
	            }
	            ancestor = ancestor.parent;
	        }
	        return res;
	    };
	    Node.prototype.isAncestorOf = function (node) {
	        return false;
	    };
	    Node.prototype.findAncestor = function (selector, includeSelf, stopNode) {
	        return this.findAncestors(selector, includeSelf, stopNode)[0];
	    };
	    Node.prototype._isMatch = function (selector) {
	        if (!selector) {
	            return false;
	        }
	        if (typeof selector === 'function') {
	            return selector(this);
	        }
	        var selectorArr = selector.replace(/ /g, '').split(','), len = selectorArr.length, n, sel;
	        for (n = 0; n < len; n++) {
	            sel = selectorArr[n];
	            if (!Util_1.Util.isValidSelector(sel)) {
	                Util_1.Util.warn('Selector "' +
	                    sel +
	                    '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
	                Util_1.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
	                Util_1.Util.warn('Konva is awesome, right?');
	            }
	            if (sel.charAt(0) === '#') {
	                if (this.id() === sel.slice(1)) {
	                    return true;
	                }
	            }
	            else if (sel.charAt(0) === '.') {
	                if (this.hasName(sel.slice(1))) {
	                    return true;
	                }
	            }
	            else if (this.className === sel || this.nodeType === sel) {
	                return true;
	            }
	        }
	        return false;
	    };
	    Node.prototype.getLayer = function () {
	        var parent = this.getParent();
	        return parent ? parent.getLayer() : null;
	    };
	    Node.prototype.getStage = function () {
	        return this._getCache(STAGE, this._getStage);
	    };
	    Node.prototype._getStage = function () {
	        var parent = this.getParent();
	        if (parent) {
	            return parent.getStage();
	        }
	        else {
	            return undefined;
	        }
	    };
	    Node.prototype.fire = function (eventType, evt, bubble) {
	        if (evt === void 0) { evt = {}; }
	        evt.target = evt.target || this;
	        if (bubble) {
	            this._fireAndBubble(eventType, evt);
	        }
	        else {
	            this._fire(eventType, evt);
	        }
	        return this;
	    };
	    Node.prototype.getAbsoluteTransform = function (top) {
	        if (top) {
	            return this._getAbsoluteTransform(top);
	        }
	        else {
	            return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
	        }
	    };
	    Node.prototype._getAbsoluteTransform = function (top) {
	        var at;
	        if (top) {
	            at = new Util_1.Transform();
	            this._eachAncestorReverse(function (node) {
	                var transformsEnabled = node.transformsEnabled();
	                if (transformsEnabled === 'all') {
	                    at.multiply(node.getTransform());
	                }
	                else if (transformsEnabled === 'position') {
	                    at.translate(node.x() - node.offsetX(), node.y() - node.offsetY());
	                }
	            }, top);
	            return at;
	        }
	        else {
	            at = this._cache.get(ABSOLUTE_TRANSFORM) || new Util_1.Transform();
	            if (this.parent) {
	                this.parent.getAbsoluteTransform().copyInto(at);
	            }
	            else {
	                at.reset();
	            }
	            var transformsEnabled = this.transformsEnabled();
	            if (transformsEnabled === 'all') {
	                at.multiply(this.getTransform());
	            }
	            else if (transformsEnabled === 'position') {
	                var x = this.attrs.x || 0;
	                var y = this.attrs.y || 0;
	                var offsetX = this.attrs.offsetX || 0;
	                var offsetY = this.attrs.offsetY || 0;
	                at.translate(x - offsetX, y - offsetY);
	            }
	            at.dirty = false;
	            return at;
	        }
	    };
	    Node.prototype.getAbsoluteScale = function (top) {
	        var parent = this;
	        while (parent) {
	            if (parent._isUnderCache) {
	                top = parent;
	            }
	            parent = parent.getParent();
	        }
	        var transform = this.getAbsoluteTransform(top);
	        var attrs = transform.decompose();
	        return {
	            x: attrs.scaleX,
	            y: attrs.scaleY,
	        };
	    };
	    Node.prototype.getAbsoluteRotation = function () {
	        return this.getAbsoluteTransform().decompose().rotation;
	    };
	    Node.prototype.getTransform = function () {
	        return this._getCache(TRANSFORM, this._getTransform);
	    };
	    Node.prototype._getTransform = function () {
	        var _a, _b;
	        var m = this._cache.get(TRANSFORM) || new Util_1.Transform();
	        m.reset();
	        var x = this.x(), y = this.y(), rotation = Global_1.Konva.getAngle(this.rotation()), scaleX = (_a = this.attrs.scaleX) !== null && _a !== void 0 ? _a : 1, scaleY = (_b = this.attrs.scaleY) !== null && _b !== void 0 ? _b : 1, skewX = this.attrs.skewX || 0, skewY = this.attrs.skewY || 0, offsetX = this.attrs.offsetX || 0, offsetY = this.attrs.offsetY || 0;
	        if (x !== 0 || y !== 0) {
	            m.translate(x, y);
	        }
	        if (rotation !== 0) {
	            m.rotate(rotation);
	        }
	        if (skewX !== 0 || skewY !== 0) {
	            m.skew(skewX, skewY);
	        }
	        if (scaleX !== 1 || scaleY !== 1) {
	            m.scale(scaleX, scaleY);
	        }
	        if (offsetX !== 0 || offsetY !== 0) {
	            m.translate(-1 * offsetX, -1 * offsetY);
	        }
	        m.dirty = false;
	        return m;
	    };
	    Node.prototype.clone = function (obj) {
	        var attrs = Util_1.Util.cloneObject(this.attrs), key, allListeners, len, n, listener;
	        for (key in obj) {
	            attrs[key] = obj[key];
	        }
	        var node = new this.constructor(attrs);
	        for (key in this.eventListeners) {
	            allListeners = this.eventListeners[key];
	            len = allListeners.length;
	            for (n = 0; n < len; n++) {
	                listener = allListeners[n];
	                if (listener.name.indexOf(KONVA) < 0) {
	                    if (!node.eventListeners[key]) {
	                        node.eventListeners[key] = [];
	                    }
	                    node.eventListeners[key].push(listener);
	                }
	            }
	        }
	        return node;
	    };
	    Node.prototype._toKonvaCanvas = function (config) {
	        config = config || {};
	        var box = this.getClientRect();
	        var stage = this.getStage(), x = config.x !== undefined ? config.x : box.x, y = config.y !== undefined ? config.y : box.y, pixelRatio = config.pixelRatio || 1, canvas = new Canvas_1.SceneCanvas({
	            width: config.width || box.width || (stage ? stage.width() : 0),
	            height: config.height || box.height || (stage ? stage.height() : 0),
	            pixelRatio: pixelRatio,
	        }), context = canvas.getContext();
	        context.save();
	        if (x || y) {
	            context.translate(-1 * x, -1 * y);
	        }
	        this.drawScene(canvas);
	        context.restore();
	        return canvas;
	    };
	    Node.prototype.toCanvas = function (config) {
	        return this._toKonvaCanvas(config)._canvas;
	    };
	    Node.prototype.toDataURL = function (config) {
	        config = config || {};
	        var mimeType = config.mimeType || null, quality = config.quality || null;
	        var url = this._toKonvaCanvas(config).toDataURL(mimeType, quality);
	        if (config.callback) {
	            config.callback(url);
	        }
	        return url;
	    };
	    Node.prototype.toImage = function (config) {
	        if (!config || !config.callback) {
	            throw 'callback required for toImage method config argument';
	        }
	        var callback = config.callback;
	        delete config.callback;
	        Util_1.Util._urlToImage(this.toDataURL(config), function (img) {
	            callback(img);
	        });
	    };
	    Node.prototype.setSize = function (size) {
	        this.width(size.width);
	        this.height(size.height);
	        return this;
	    };
	    Node.prototype.getSize = function () {
	        return {
	            width: this.width(),
	            height: this.height(),
	        };
	    };
	    Node.prototype.getClassName = function () {
	        return this.className || this.nodeType;
	    };
	    Node.prototype.getType = function () {
	        return this.nodeType;
	    };
	    Node.prototype.getDragDistance = function () {
	        if (this.attrs.dragDistance !== undefined) {
	            return this.attrs.dragDistance;
	        }
	        else if (this.parent) {
	            return this.parent.getDragDistance();
	        }
	        else {
	            return Global_1.Konva.dragDistance;
	        }
	    };
	    Node.prototype._off = function (type, name, callback) {
	        var evtListeners = this.eventListeners[type], i, evtName, handler;
	        for (i = 0; i < evtListeners.length; i++) {
	            evtName = evtListeners[i].name;
	            handler = evtListeners[i].handler;
	            if ((evtName !== 'konva' || name === 'konva') &&
	                (!name || evtName === name) &&
	                (!callback || callback === handler)) {
	                evtListeners.splice(i, 1);
	                if (evtListeners.length === 0) {
	                    delete this.eventListeners[type];
	                    break;
	                }
	                i--;
	            }
	        }
	    };
	    Node.prototype._fireChangeEvent = function (attr, oldVal, newVal) {
	        this._fire(attr + CHANGE, {
	            oldVal: oldVal,
	            newVal: newVal,
	        });
	    };
	    Node.prototype.setId = function (id) {
	        var oldId = this.id();
	        exports._removeId(oldId, this);
	        _addId(this, id);
	        this._setAttr('id', id);
	        return this;
	    };
	    Node.prototype.setName = function (name) {
	        var oldNames = (this.name() || '').split(/\s/g);
	        var newNames = (name || '').split(/\s/g);
	        var subname, i;
	        for (i = 0; i < oldNames.length; i++) {
	            subname = oldNames[i];
	            if (newNames.indexOf(subname) === -1 && subname) {
	                exports._removeName(subname, this._id);
	            }
	        }
	        for (i = 0; i < newNames.length; i++) {
	            subname = newNames[i];
	            if (oldNames.indexOf(subname) === -1 && subname) {
	                exports._addName(this, subname);
	            }
	        }
	        this._setAttr(NAME, name);
	        return this;
	    };
	    Node.prototype.addName = function (name) {
	        if (!this.hasName(name)) {
	            var oldName = this.name();
	            var newName = oldName ? oldName + ' ' + name : name;
	            this.setName(newName);
	        }
	        return this;
	    };
	    Node.prototype.hasName = function (name) {
	        if (!name) {
	            return false;
	        }
	        var fullName = this.name();
	        if (!fullName) {
	            return false;
	        }
	        var names = (fullName || '').split(/\s/g);
	        return names.indexOf(name) !== -1;
	    };
	    Node.prototype.removeName = function (name) {
	        var names = (this.name() || '').split(/\s/g);
	        var index = names.indexOf(name);
	        if (index !== -1) {
	            names.splice(index, 1);
	            this.setName(names.join(' '));
	        }
	        return this;
	    };
	    Node.prototype.setAttr = function (attr, val) {
	        var func = this[SET + Util_1.Util._capitalize(attr)];
	        if (Util_1.Util._isFunction(func)) {
	            func.call(this, val);
	        }
	        else {
	            this._setAttr(attr, val);
	        }
	        return this;
	    };
	    Node.prototype._setAttr = function (key, val, skipFire) {
	        var oldVal = this.attrs[key];
	        if (oldVal === val && !Util_1.Util.isObject(val)) {
	            return;
	        }
	        if (val === undefined || val === null) {
	            delete this.attrs[key];
	        }
	        else {
	            this.attrs[key] = val;
	        }
	        if (this._shouldFireChangeEvents) {
	            this._fireChangeEvent(key, oldVal, val);
	        }
	    };
	    Node.prototype._setComponentAttr = function (key, component, val) {
	        var oldVal;
	        if (val !== undefined) {
	            oldVal = this.attrs[key];
	            if (!oldVal) {
	                this.attrs[key] = this.getAttr(key);
	            }
	            this.attrs[key][component] = val;
	            this._fireChangeEvent(key, oldVal, val);
	        }
	    };
	    Node.prototype._fireAndBubble = function (eventType, evt, compareShape) {
	        if (evt && this.nodeType === SHAPE) {
	            evt.target = this;
	        }
	        var shouldStop = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
	            ((compareShape &&
	                (this === compareShape ||
	                    (this.isAncestorOf && this.isAncestorOf(compareShape)))) ||
	                (this.nodeType === 'Stage' && !compareShape));
	        if (!shouldStop) {
	            this._fire(eventType, evt);
	            var stopBubble = (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
	                compareShape &&
	                compareShape.isAncestorOf &&
	                compareShape.isAncestorOf(this) &&
	                !compareShape.isAncestorOf(this.parent);
	            if (((evt && !evt.cancelBubble) || !evt) &&
	                this.parent &&
	                this.parent.isListening() &&
	                !stopBubble) {
	                if (compareShape && compareShape.parent) {
	                    this._fireAndBubble.call(this.parent, eventType, evt, compareShape);
	                }
	                else {
	                    this._fireAndBubble.call(this.parent, eventType, evt);
	                }
	            }
	        }
	    };
	    Node.prototype._getProtoListeners = function (eventType) {
	        var listeners = this._cache.get(ALL_LISTENERS);
	        if (!listeners) {
	            listeners = {};
	            var obj = Object.getPrototypeOf(this);
	            while (obj) {
	                if (!obj.eventListeners) {
	                    obj = Object.getPrototypeOf(obj);
	                    continue;
	                }
	                for (var event in obj.eventListeners) {
	                    var newEvents = obj.eventListeners[event];
	                    var oldEvents = listeners[event] || [];
	                    listeners[event] = newEvents.concat(oldEvents);
	                }
	                obj = Object.getPrototypeOf(obj);
	            }
	            this._cache.set(ALL_LISTENERS, listeners);
	        }
	        return listeners[eventType];
	    };
	    Node.prototype._fire = function (eventType, evt) {
	        evt = evt || {};
	        evt.currentTarget = this;
	        evt.type = eventType;
	        var topListeners = this._getProtoListeners(eventType);
	        if (topListeners) {
	            for (var i = 0; i < topListeners.length; i++) {
	                topListeners[i].handler.call(this, evt);
	            }
	        }
	        var selfListeners = this.eventListeners[eventType];
	        if (selfListeners) {
	            for (var i = 0; i < selfListeners.length; i++) {
	                selfListeners[i].handler.call(this, evt);
	            }
	        }
	    };
	    Node.prototype.draw = function () {
	        this.drawScene();
	        this.drawHit();
	        return this;
	    };
	    Node.prototype._createDragElement = function (evt) {
	        var pointerId = evt ? evt.pointerId : undefined;
	        var stage = this.getStage();
	        var ap = this.getAbsolutePosition();
	        var pos = stage._getPointerById(pointerId) ||
	            stage._changedPointerPositions[0] ||
	            ap;
	        DragAndDrop_1.DD._dragElements.set(this._id, {
	            node: this,
	            startPointerPos: pos,
	            offset: {
	                x: pos.x - ap.x,
	                y: pos.y - ap.y,
	            },
	            dragStatus: 'ready',
	            pointerId: pointerId,
	        });
	    };
	    Node.prototype.startDrag = function (evt, bubbleEvent) {
	        if (bubbleEvent === void 0) { bubbleEvent = true; }
	        if (!DragAndDrop_1.DD._dragElements.has(this._id)) {
	            this._createDragElement(evt);
	        }
	        var elem = DragAndDrop_1.DD._dragElements.get(this._id);
	        elem.dragStatus = 'dragging';
	        this.fire('dragstart', {
	            type: 'dragstart',
	            target: this,
	            evt: evt && evt.evt,
	        }, bubbleEvent);
	    };
	    Node.prototype._setDragPosition = function (evt, elem) {
	        var pos = this.getStage()._getPointerById(elem.pointerId);
	        if (!pos) {
	            return;
	        }
	        var newNodePos = {
	            x: pos.x - elem.offset.x,
	            y: pos.y - elem.offset.y,
	        };
	        var dbf = this.dragBoundFunc();
	        if (dbf !== undefined) {
	            var bounded = dbf.call(this, newNodePos, evt);
	            if (!bounded) {
	                Util_1.Util.warn('dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.');
	            }
	            else {
	                newNodePos = bounded;
	            }
	        }
	        if (!this._lastPos ||
	            this._lastPos.x !== newNodePos.x ||
	            this._lastPos.y !== newNodePos.y) {
	            this.setAbsolutePosition(newNodePos);
	            if (this.getLayer()) {
	                this.getLayer().batchDraw();
	            }
	            else if (this.getStage()) {
	                this.getStage().batchDraw();
	            }
	        }
	        this._lastPos = newNodePos;
	    };
	    Node.prototype.stopDrag = function (evt) {
	        var elem = DragAndDrop_1.DD._dragElements.get(this._id);
	        if (elem) {
	            elem.dragStatus = 'stopped';
	        }
	        DragAndDrop_1.DD._endDragBefore(evt);
	        DragAndDrop_1.DD._endDragAfter(evt);
	    };
	    Node.prototype.setDraggable = function (draggable) {
	        this._setAttr('draggable', draggable);
	        this._dragChange();
	    };
	    Node.prototype.isDragging = function () {
	        var elem = DragAndDrop_1.DD._dragElements.get(this._id);
	        return elem ? elem.dragStatus === 'dragging' : false;
	    };
	    Node.prototype._listenDrag = function () {
	        this._dragCleanup();
	        this.on('mousedown.konva touchstart.konva', function (evt) {
	            var _this = this;
	            var shouldCheckButton = evt.evt['button'] !== undefined;
	            var canDrag = !shouldCheckButton || Global_1.Konva.dragButtons.indexOf(evt.evt['button']) >= 0;
	            if (!canDrag) {
	                return;
	            }
	            if (this.isDragging()) {
	                return;
	            }
	            var hasDraggingChild = false;
	            DragAndDrop_1.DD._dragElements.forEach(function (elem) {
	                if (_this.isAncestorOf(elem.node)) {
	                    hasDraggingChild = true;
	                }
	            });
	            if (!hasDraggingChild) {
	                this._createDragElement(evt);
	            }
	        });
	    };
	    Node.prototype._dragChange = function () {
	        if (this.attrs.draggable) {
	            this._listenDrag();
	        }
	        else {
	            this._dragCleanup();
	            var stage = this.getStage();
	            if (!stage) {
	                return;
	            }
	            var dragElement = DragAndDrop_1.DD._dragElements.get(this._id);
	            var isDragging = dragElement && dragElement.dragStatus === 'dragging';
	            var isReady = dragElement && dragElement.dragStatus === 'ready';
	            if (isDragging) {
	                this.stopDrag();
	            }
	            else if (isReady) {
	                DragAndDrop_1.DD._dragElements.delete(this._id);
	            }
	        }
	    };
	    Node.prototype._dragCleanup = function () {
	        this.off('mousedown.konva');
	        this.off('touchstart.konva');
	    };
	    Node.create = function (data, container) {
	        if (Util_1.Util._isString(data)) {
	            data = JSON.parse(data);
	        }
	        return this._createNode(data, container);
	    };
	    Node._createNode = function (obj, container) {
	        var className = Node.prototype.getClassName.call(obj), children = obj.children, no, len, n;
	        if (container) {
	            obj.attrs.container = container;
	        }
	        if (!Global_1._NODES_REGISTRY[className]) {
	            Util_1.Util.warn('Can not find a node with class name "' +
	                className +
	                '". Fallback to "Shape".');
	            className = 'Shape';
	        }
	        var Class = Global_1._NODES_REGISTRY[className];
	        no = new Class(obj.attrs);
	        if (children) {
	            len = children.length;
	            for (n = 0; n < len; n++) {
	                no.add(Node._createNode(children[n]));
	            }
	        }
	        return no;
	    };
	    return Node;
	}());
	exports.Node = Node;
	Node.prototype.nodeType = 'Node';
	Node.prototype._attrsAffectingSize = [];
	Node.prototype.eventListeners = {};
	Node.prototype.on.call(Node.prototype, TRANSFORM_CHANGE_STR, function () {
	    if (this._batchingTransformChange) {
	        this._needClearTransformCache = true;
	        return;
	    }
	    this._clearCache(TRANSFORM);
	    this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	});
	Node.prototype.on.call(Node.prototype, 'visibleChange.konva', function () {
	    this._clearSelfAndDescendantCache(VISIBLE);
	});
	Node.prototype.on.call(Node.prototype, 'listeningChange.konva', function () {
	    this._clearSelfAndDescendantCache(LISTENING);
	});
	Node.prototype.on.call(Node.prototype, 'opacityChange.konva', function () {
	    this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	});
	var addGetterSetter = Factory_1.Factory.addGetterSetter;
	addGetterSetter(Node, 'zIndex');
	addGetterSetter(Node, 'absolutePosition');
	addGetterSetter(Node, 'position');
	addGetterSetter(Node, 'x', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'y', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'globalCompositeOperation', 'source-over', Validators_1.getStringValidator());
	addGetterSetter(Node, 'opacity', 1, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'name', '', Validators_1.getStringValidator());
	addGetterSetter(Node, 'id', '', Validators_1.getStringValidator());
	addGetterSetter(Node, 'rotation', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addComponentsGetterSetter(Node, 'scale', ['x', 'y']);
	addGetterSetter(Node, 'scaleX', 1, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'scaleY', 1, Validators_1.getNumberValidator());
	Factory_1.Factory.addComponentsGetterSetter(Node, 'skew', ['x', 'y']);
	addGetterSetter(Node, 'skewX', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'skewY', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addComponentsGetterSetter(Node, 'offset', ['x', 'y']);
	addGetterSetter(Node, 'offsetX', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'offsetY', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'dragDistance', null, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'width', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'height', 0, Validators_1.getNumberValidator());
	addGetterSetter(Node, 'listening', true, Validators_1.getBooleanValidator());
	addGetterSetter(Node, 'preventDefault', true, Validators_1.getBooleanValidator());
	addGetterSetter(Node, 'filters', null, function (val) {
	    this._filterUpToDate = false;
	    return val;
	});
	addGetterSetter(Node, 'visible', true, Validators_1.getBooleanValidator());
	addGetterSetter(Node, 'transformsEnabled', 'all', Validators_1.getStringValidator());
	addGetterSetter(Node, 'size');
	addGetterSetter(Node, 'dragBoundFunc');
	addGetterSetter(Node, 'draggable', false, Validators_1.getBooleanValidator());
	Factory_1.Factory.backCompat(Node, {
	    rotateDeg: 'rotate',
	    setRotationDeg: 'setRotation',
	    getRotationDeg: 'getRotation',
	});
	Util_1.Collection.mapMethods(Node);
} (Node));

var Container$1 = {};

var __extends$k = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Container$1, "__esModule", { value: true });
Container$1.Container = void 0;
var Util_1$o = Util;
var Factory_1$x = Factory;
var Node_1$i = Node;
var Validators_1$w = Validators;
var Container = (function (_super) {
    __extends$k(Container, _super);
    function Container() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.children = new Util_1$o.Collection();
        return _this;
    }
    Container.prototype.getChildren = function (filterFunc) {
        if (!filterFunc) {
            return this.children;
        }
        var results = new Util_1$o.Collection();
        this.children.each(function (child) {
            if (filterFunc(child)) {
                results.push(child);
            }
        });
        return results;
    };
    Container.prototype.hasChildren = function () {
        return this.getChildren().length > 0;
    };
    Container.prototype.removeChildren = function () {
        var child;
        for (var i = 0; i < this.children.length; i++) {
            child = this.children[i];
            child.parent = null;
            child.index = 0;
            child.remove();
        }
        this.children = new Util_1$o.Collection();
        return this;
    };
    Container.prototype.destroyChildren = function () {
        var child;
        for (var i = 0; i < this.children.length; i++) {
            child = this.children[i];
            child.parent = null;
            child.index = 0;
            child.destroy();
        }
        this.children = new Util_1$o.Collection();
        return this;
    };
    Container.prototype.add = function () {
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            children[_i] = arguments[_i];
        }
        if (arguments.length > 1) {
            for (var i = 0; i < arguments.length; i++) {
                this.add(arguments[i]);
            }
            return this;
        }
        var child = children[0];
        if (child.getParent()) {
            child.moveTo(this);
            return this;
        }
        var _children = this.children;
        this._validateAdd(child);
        child._clearCaches();
        child.index = _children.length;
        child.parent = this;
        _children.push(child);
        this._fire('add', {
            child: child,
        });
        return this;
    };
    Container.prototype.destroy = function () {
        if (this.hasChildren()) {
            this.destroyChildren();
        }
        _super.prototype.destroy.call(this);
        return this;
    };
    Container.prototype.find = function (selector) {
        return this._generalFind(selector, false);
    };
    Container.prototype.get = function (selector) {
        Util_1$o.Util.warn('collection.get() method is deprecated. Please use collection.find() instead.');
        return this.find(selector);
    };
    Container.prototype.findOne = function (selector) {
        var result = this._generalFind(selector, true);
        return result.length > 0 ? result[0] : undefined;
    };
    Container.prototype._generalFind = function (selector, findOne) {
        var retArr = [];
        this._descendants(function (node) {
            var valid = node._isMatch(selector);
            if (valid) {
                retArr.push(node);
            }
            if (valid && findOne) {
                return true;
            }
            return false;
        });
        return Util_1$o.Collection.toCollection(retArr);
    };
    Container.prototype._descendants = function (fn) {
        var shouldStop = false;
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            shouldStop = fn(child);
            if (shouldStop) {
                return true;
            }
            if (!child.hasChildren()) {
                continue;
            }
            shouldStop = child._descendants(fn);
            if (shouldStop) {
                return true;
            }
        }
        return false;
    };
    Container.prototype.toObject = function () {
        var obj = Node_1$i.Node.prototype.toObject.call(this);
        obj.children = [];
        var children = this.getChildren();
        var len = children.length;
        for (var n = 0; n < len; n++) {
            var child = children[n];
            obj.children.push(child.toObject());
        }
        return obj;
    };
    Container.prototype.isAncestorOf = function (node) {
        var parent = node.getParent();
        while (parent) {
            if (parent._id === this._id) {
                return true;
            }
            parent = parent.getParent();
        }
        return false;
    };
    Container.prototype.clone = function (obj) {
        var node = Node_1$i.Node.prototype.clone.call(this, obj);
        this.getChildren().each(function (no) {
            node.add(no.clone());
        });
        return node;
    };
    Container.prototype.getAllIntersections = function (pos) {
        var arr = [];
        this.find('Shape').each(function (shape) {
            if (shape.isVisible() && shape.intersects(pos)) {
                arr.push(shape);
            }
        });
        return arr;
    };
    Container.prototype._setChildrenIndices = function () {
        this.children.each(function (child, n) {
            child.index = n;
        });
    };
    Container.prototype.drawScene = function (can, top) {
        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas()), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
        var caching = canvas && canvas.isCache;
        if (!this.isVisible() && !caching) {
            return this;
        }
        if (cachedSceneCanvas) {
            context.save();
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            this._drawCachedSceneCanvas(context);
            context.restore();
        }
        else {
            this._drawChildren('drawScene', canvas, top);
        }
        return this;
    };
    Container.prototype.drawHit = function (can, top) {
        if (!this.shouldDrawHit(top)) {
            return this;
        }
        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas), context = canvas && canvas.getContext(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
        if (cachedHitCanvas) {
            context.save();
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            this._drawCachedHitCanvas(context);
            context.restore();
        }
        else {
            this._drawChildren('drawHit', canvas, top);
        }
        return this;
    };
    Container.prototype._drawChildren = function (drawMethod, canvas, top) {
        var context = canvas && canvas.getContext(), clipWidth = this.clipWidth(), clipHeight = this.clipHeight(), clipFunc = this.clipFunc(), hasClip = (clipWidth && clipHeight) || clipFunc;
        var selfCache = top === this;
        if (hasClip) {
            context.save();
            var transform = this.getAbsoluteTransform(top);
            var m = transform.getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            context.beginPath();
            if (clipFunc) {
                clipFunc.call(this, context, this);
            }
            else {
                var clipX = this.clipX();
                var clipY = this.clipY();
                context.rect(clipX, clipY, clipWidth, clipHeight);
            }
            context.clip();
            m = transform.copy().invert().getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }
        var hasComposition = !selfCache &&
            this.globalCompositeOperation() !== 'source-over' &&
            drawMethod === 'drawScene';
        if (hasComposition) {
            context.save();
            context._applyGlobalCompositeOperation(this);
        }
        this.children.each(function (child) {
            child[drawMethod](canvas, top);
        });
        if (hasComposition) {
            context.restore();
        }
        if (hasClip) {
            context.restore();
        }
    };
    Container.prototype.getClientRect = function (config) {
        config = config || {};
        var skipTransform = config.skipTransform;
        var relativeTo = config.relativeTo;
        var minX, minY, maxX, maxY;
        var selfRect = {
            x: Infinity,
            y: Infinity,
            width: 0,
            height: 0,
        };
        var that = this;
        this.children.each(function (child) {
            if (!child.visible()) {
                return;
            }
            var rect = child.getClientRect({
                relativeTo: that,
                skipShadow: config.skipShadow,
                skipStroke: config.skipStroke,
            });
            if (rect.width === 0 && rect.height === 0) {
                return;
            }
            if (minX === undefined) {
                minX = rect.x;
                minY = rect.y;
                maxX = rect.x + rect.width;
                maxY = rect.y + rect.height;
            }
            else {
                minX = Math.min(minX, rect.x);
                minY = Math.min(minY, rect.y);
                maxX = Math.max(maxX, rect.x + rect.width);
                maxY = Math.max(maxY, rect.y + rect.height);
            }
        });
        var shapes = this.find('Shape');
        var hasVisible = false;
        for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (shape._isVisible(this)) {
                hasVisible = true;
                break;
            }
        }
        if (hasVisible && minX !== undefined) {
            selfRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
            };
        }
        else {
            selfRect = {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            };
        }
        if (!skipTransform) {
            return this._transformedRect(selfRect, relativeTo);
        }
        return selfRect;
    };
    return Container;
}(Node_1$i.Node));
Container$1.Container = Container;
Factory_1$x.Factory.addComponentsGetterSetter(Container, 'clip', [
    'x',
    'y',
    'width',
    'height',
]);
Factory_1$x.Factory.addGetterSetter(Container, 'clipX', undefined, Validators_1$w.getNumberValidator());
Factory_1$x.Factory.addGetterSetter(Container, 'clipY', undefined, Validators_1$w.getNumberValidator());
Factory_1$x.Factory.addGetterSetter(Container, 'clipWidth', undefined, Validators_1$w.getNumberValidator());
Factory_1$x.Factory.addGetterSetter(Container, 'clipHeight', undefined, Validators_1$w.getNumberValidator());
Factory_1$x.Factory.addGetterSetter(Container, 'clipFunc');
Util_1$o.Collection.mapMethods(Container);

var Stage = {};

var PointerEvents = {};

Object.defineProperty(PointerEvents, "__esModule", { value: true });
PointerEvents.releaseCapture = PointerEvents.setPointerCapture = PointerEvents.hasPointerCapture = PointerEvents.createEvent = PointerEvents.getCapturedShape = void 0;
var Global_1$m = Global;
var Captures = new Map();
var SUPPORT_POINTER_EVENTS = Global_1$m.Konva._global['PointerEvent'] !== undefined;
function getCapturedShape(pointerId) {
    return Captures.get(pointerId);
}
PointerEvents.getCapturedShape = getCapturedShape;
function createEvent(evt) {
    return {
        evt: evt,
        pointerId: evt.pointerId
    };
}
PointerEvents.createEvent = createEvent;
function hasPointerCapture(pointerId, shape) {
    return Captures.get(pointerId) === shape;
}
PointerEvents.hasPointerCapture = hasPointerCapture;
function setPointerCapture(pointerId, shape) {
    releaseCapture(pointerId);
    var stage = shape.getStage();
    if (!stage)
        return;
    Captures.set(pointerId, shape);
    if (SUPPORT_POINTER_EVENTS) {
        shape._fire('gotpointercapture', createEvent(new PointerEvent('gotpointercapture')));
    }
}
PointerEvents.setPointerCapture = setPointerCapture;
function releaseCapture(pointerId, target) {
    var shape = Captures.get(pointerId);
    if (!shape)
        return;
    var stage = shape.getStage();
    if (stage && stage.content) ;
    Captures.delete(pointerId);
    if (SUPPORT_POINTER_EVENTS) {
        shape._fire('lostpointercapture', createEvent(new PointerEvent('lostpointercapture')));
    }
}
PointerEvents.releaseCapture = releaseCapture;

(function (exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Stage = exports.stages = void 0;
	var Util_1 = Util;
	var Factory_1 = Factory;
	var Container_1 = Container$1;
	var Global_1 = Global;
	var Canvas_1 = Canvas$1;
	var DragAndDrop_1 = DragAndDrop;
	var Global_2 = Global;
	var PointerEvents$1 = PointerEvents;
	var STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', CONTEXTMENU = 'contextmenu', CLICK = 'click', DBL_CLICK = 'dblclick', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TAP = 'tap', DBL_TAP = 'dbltap', TOUCHMOVE = 'touchmove', WHEEL = 'wheel', CONTENT_MOUSEOUT = 'contentMouseout', CONTENT_MOUSEOVER = 'contentMouseover', CONTENT_MOUSEMOVE = 'contentMousemove', CONTENT_MOUSEDOWN = 'contentMousedown', CONTENT_MOUSEUP = 'contentMouseup', CONTENT_CONTEXTMENU = 'contentContextmenu', CONTENT_CLICK = 'contentClick', CONTENT_DBL_CLICK = 'contentDblclick', CONTENT_TOUCHSTART = 'contentTouchstart', CONTENT_TOUCHEND = 'contentTouchend', CONTENT_DBL_TAP = 'contentDbltap', CONTENT_TAP = 'contentTap', CONTENT_TOUCHMOVE = 'contentTouchmove', CONTENT_WHEEL = 'contentWheel', RELATIVE = 'relative', KONVA_CONTENT = 'konvajs-content', UNDERSCORE = '_', CONTAINER = 'container', MAX_LAYERS_NUMBER = 5, EMPTY_STRING = '', EVENTS = [
	    MOUSEENTER,
	    MOUSEDOWN,
	    MOUSEMOVE,
	    MOUSEUP,
	    MOUSELEAVE,
	    TOUCHSTART,
	    TOUCHMOVE,
	    TOUCHEND,
	    MOUSEOVER,
	    WHEEL,
	    CONTEXTMENU,
	    POINTERDOWN,
	    POINTERMOVE,
	    POINTERUP,
	    POINTERCANCEL,
	    LOSTPOINTERCAPTURE,
	], eventsLength = EVENTS.length;
	function addEvent(ctx, eventName) {
	    ctx.content.addEventListener(eventName, function (evt) {
	        ctx[UNDERSCORE + eventName](evt);
	    }, false);
	}
	var NO_POINTERS_MESSAGE = "Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);";
	exports.stages = [];
	function checkNoClip(attrs) {
	    if (attrs === void 0) { attrs = {}; }
	    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {
	        Util_1.Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');
	    }
	    return attrs;
	}
	var Stage = (function (_super) {
	    __extends(Stage, _super);
	    function Stage(config) {
	        var _this = _super.call(this, checkNoClip(config)) || this;
	        _this._pointerPositions = [];
	        _this._changedPointerPositions = [];
	        _this._buildDOM();
	        _this._bindContentEvents();
	        exports.stages.push(_this);
	        _this.on('widthChange.konva heightChange.konva', _this._resizeDOM);
	        _this.on('visibleChange.konva', _this._checkVisibility);
	        _this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', function () {
	            checkNoClip(_this.attrs);
	        });
	        _this._checkVisibility();
	        return _this;
	    }
	    Stage.prototype._validateAdd = function (child) {
	        var isLayer = child.getType() === 'Layer';
	        var isFastLayer = child.getType() === 'FastLayer';
	        var valid = isLayer || isFastLayer;
	        if (!valid) {
	            Util_1.Util.throw('You may only add layers to the stage.');
	        }
	    };
	    Stage.prototype._checkVisibility = function () {
	        if (!this.content) {
	            return;
	        }
	        var style = this.visible() ? '' : 'none';
	        this.content.style.display = style;
	    };
	    Stage.prototype.setContainer = function (container) {
	        if (typeof container === STRING) {
	            if (container.charAt(0) === '.') {
	                var className = container.slice(1);
	                container = document.getElementsByClassName(className)[0];
	            }
	            else {
	                var id;
	                if (container.charAt(0) !== '#') {
	                    id = container;
	                }
	                else {
	                    id = container.slice(1);
	                }
	                container = document.getElementById(id);
	            }
	            if (!container) {
	                throw 'Can not find container in document with id ' + id;
	            }
	        }
	        this._setAttr(CONTAINER, container);
	        if (this.content) {
	            if (this.content.parentElement) {
	                this.content.parentElement.removeChild(this.content);
	            }
	            container.appendChild(this.content);
	        }
	        return this;
	    };
	    Stage.prototype.shouldDrawHit = function () {
	        return true;
	    };
	    Stage.prototype.clear = function () {
	        var layers = this.children, len = layers.length, n;
	        for (n = 0; n < len; n++) {
	            layers[n].clear();
	        }
	        return this;
	    };
	    Stage.prototype.clone = function (obj) {
	        if (!obj) {
	            obj = {};
	        }
	        obj.container = document.createElement('div');
	        return Container_1.Container.prototype.clone.call(this, obj);
	    };
	    Stage.prototype.destroy = function () {
	        _super.prototype.destroy.call(this);
	        var content = this.content;
	        if (content && Util_1.Util._isInDocument(content)) {
	            this.container().removeChild(content);
	        }
	        var index = exports.stages.indexOf(this);
	        if (index > -1) {
	            exports.stages.splice(index, 1);
	        }
	        return this;
	    };
	    Stage.prototype.getPointerPosition = function () {
	        var pos = this._pointerPositions[0] || this._changedPointerPositions[0];
	        if (!pos) {
	            Util_1.Util.warn(NO_POINTERS_MESSAGE);
	            return null;
	        }
	        return {
	            x: pos.x,
	            y: pos.y,
	        };
	    };
	    Stage.prototype._getPointerById = function (id) {
	        return this._pointerPositions.find(function (p) { return p.id === id; });
	    };
	    Stage.prototype.getPointersPositions = function () {
	        return this._pointerPositions;
	    };
	    Stage.prototype.getStage = function () {
	        return this;
	    };
	    Stage.prototype.getContent = function () {
	        return this.content;
	    };
	    Stage.prototype._toKonvaCanvas = function (config) {
	        config = config || {};
	        config.x = config.x || 0;
	        config.y = config.y || 0;
	        config.width = config.width || this.width();
	        config.height = config.height || this.height();
	        var canvas = new Canvas_1.SceneCanvas({
	            width: config.width,
	            height: config.height,
	            pixelRatio: config.pixelRatio || 1,
	        });
	        var _context = canvas.getContext()._context;
	        var layers = this.children;
	        if (config.x || config.y) {
	            _context.translate(-1 * config.x, -1 * config.y);
	        }
	        layers.each(function (layer) {
	            if (!layer.isVisible()) {
	                return;
	            }
	            var layerCanvas = layer._toKonvaCanvas(config);
	            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());
	        });
	        return canvas;
	    };
	    Stage.prototype.getIntersection = function (pos, selector) {
	        if (!pos) {
	            return null;
	        }
	        var layers = this.children, len = layers.length, end = len - 1, n, shape;
	        for (n = end; n >= 0; n--) {
	            shape = layers[n].getIntersection(pos, selector);
	            if (shape) {
	                return shape;
	            }
	        }
	        return null;
	    };
	    Stage.prototype._resizeDOM = function () {
	        var width = this.width();
	        var height = this.height();
	        if (this.content) {
	            this.content.style.width = width + PX;
	            this.content.style.height = height + PX;
	        }
	        this.bufferCanvas.setSize(width, height);
	        this.bufferHitCanvas.setSize(width, height);
	        this.children.each(function (layer) {
	            layer.setSize({ width: width, height: height });
	            layer.draw();
	        });
	    };
	    Stage.prototype.add = function (layer) {
	        if (arguments.length > 1) {
	            for (var i = 0; i < arguments.length; i++) {
	                this.add(arguments[i]);
	            }
	            return this;
	        }
	        _super.prototype.add.call(this, layer);
	        var length = this.children.length;
	        if (length > MAX_LAYERS_NUMBER) {
	            Util_1.Util.warn('The stage has ' +
	                length +
	                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');
	        }
	        layer.setSize({ width: this.width(), height: this.height() });
	        layer.draw();
	        if (Global_1.Konva.isBrowser) {
	            this.content.appendChild(layer.canvas._canvas);
	        }
	        return this;
	    };
	    Stage.prototype.getParent = function () {
	        return null;
	    };
	    Stage.prototype.getLayer = function () {
	        return null;
	    };
	    Stage.prototype.hasPointerCapture = function (pointerId) {
	        return PointerEvents$1.hasPointerCapture(pointerId, this);
	    };
	    Stage.prototype.setPointerCapture = function (pointerId) {
	        PointerEvents$1.setPointerCapture(pointerId, this);
	    };
	    Stage.prototype.releaseCapture = function (pointerId) {
	        PointerEvents$1.releaseCapture(pointerId, this);
	    };
	    Stage.prototype.getLayers = function () {
	        return this.getChildren();
	    };
	    Stage.prototype._bindContentEvents = function () {
	        if (!Global_1.Konva.isBrowser) {
	            return;
	        }
	        for (var n = 0; n < eventsLength; n++) {
	            addEvent(this, EVENTS[n]);
	        }
	    };
	    Stage.prototype._mouseenter = function (evt) {
	        this.setPointersPositions(evt);
	        this._fire(MOUSEENTER, { evt: evt, target: this, currentTarget: this });
	    };
	    Stage.prototype._mouseover = function (evt) {
	        this.setPointersPositions(evt);
	        this._fire(CONTENT_MOUSEOVER, { evt: evt });
	        this._fire(MOUSEOVER, { evt: evt, target: this, currentTarget: this });
	    };
	    Stage.prototype._mouseleave = function (evt) {
	        var _a;
	        this.setPointersPositions(evt);
	        var targetShape = ((_a = this.targetShape) === null || _a === void 0 ? void 0 : _a.getStage()) ? this.targetShape : null;
	        var eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
	        if (targetShape && eventsEnabled) {
	            targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
	            targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
	            this._fire(MOUSELEAVE, { evt: evt, target: this, currentTarget: this });
	            this.targetShape = null;
	        }
	        else if (eventsEnabled) {
	            this._fire(MOUSELEAVE, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	            this._fire(MOUSEOUT, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	        }
	        this.pointerPos = undefined;
	        this._pointerPositions = [];
	        this._fire(CONTENT_MOUSEOUT, { evt: evt });
	    };
	    Stage.prototype._mousemove = function (evt) {
	        var _a;
	        if (Global_1.Konva.UA.ieMobile) {
	            return this._touchmove(evt);
	        }
	        this.setPointersPositions(evt);
	        var pointerId = Util_1.Util._getFirstPointerId(evt);
	        var shape;
	        var targetShape = ((_a = this.targetShape) === null || _a === void 0 ? void 0 : _a.getStage()) ? this.targetShape : null;
	        var eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
	        if (eventsEnabled) {
	            shape = this.getIntersection(this.getPointerPosition());
	            if (shape && shape.isListening()) {
	                var differentTarget = targetShape !== shape;
	                if (eventsEnabled && differentTarget) {
	                    if (targetShape) {
	                        targetShape._fireAndBubble(MOUSEOUT, { evt: evt, pointerId: pointerId }, shape);
	                        targetShape._fireAndBubble(MOUSELEAVE, { evt: evt, pointerId: pointerId }, shape);
	                    }
	                    shape._fireAndBubble(MOUSEOVER, { evt: evt, pointerId: pointerId }, targetShape);
	                    shape._fireAndBubble(MOUSEENTER, { evt: evt, pointerId: pointerId }, targetShape);
	                    shape._fireAndBubble(MOUSEMOVE, { evt: evt, pointerId: pointerId });
	                    this.targetShape = shape;
	                }
	                else {
	                    shape._fireAndBubble(MOUSEMOVE, { evt: evt, pointerId: pointerId });
	                }
	            }
	            else {
	                if (targetShape && eventsEnabled) {
	                    targetShape._fireAndBubble(MOUSEOUT, { evt: evt, pointerId: pointerId });
	                    targetShape._fireAndBubble(MOUSELEAVE, { evt: evt, pointerId: pointerId });
	                    this._fire(MOUSEOVER, {
	                        evt: evt,
	                        target: this,
	                        currentTarget: this,
	                        pointerId: pointerId,
	                    });
	                    this.targetShape = null;
	                }
	                this._fire(MOUSEMOVE, {
	                    evt: evt,
	                    target: this,
	                    currentTarget: this,
	                    pointerId: pointerId,
	                });
	            }
	            this._fire(CONTENT_MOUSEMOVE, { evt: evt });
	        }
	        if (evt.cancelable) {
	            evt.preventDefault();
	        }
	    };
	    Stage.prototype._mousedown = function (evt) {
	        if (Global_1.Konva.UA.ieMobile) {
	            return this._touchstart(evt);
	        }
	        this.setPointersPositions(evt);
	        var pointerId = Util_1.Util._getFirstPointerId(evt);
	        var shape = this.getIntersection(this.getPointerPosition());
	        DragAndDrop_1.DD.justDragged = false;
	        Global_1.Konva.listenClickTap = true;
	        if (shape && shape.isListening()) {
	            this.clickStartShape = shape;
	            shape._fireAndBubble(MOUSEDOWN, { evt: evt, pointerId: pointerId });
	        }
	        else {
	            this._fire(MOUSEDOWN, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: pointerId,
	            });
	        }
	        this._fire(CONTENT_MOUSEDOWN, { evt: evt });
	    };
	    Stage.prototype._mouseup = function (evt) {
	        if (Global_1.Konva.UA.ieMobile) {
	            return this._touchend(evt);
	        }
	        this.setPointersPositions(evt);
	        var pointerId = Util_1.Util._getFirstPointerId(evt);
	        var shape = this.getIntersection(this.getPointerPosition()), clickStartShape = this.clickStartShape, clickEndShape = this.clickEndShape, fireDblClick = false;
	        if (Global_1.Konva.inDblClickWindow) {
	            fireDblClick = true;
	            clearTimeout(this.dblTimeout);
	        }
	        else if (!DragAndDrop_1.DD.justDragged) {
	            Global_1.Konva.inDblClickWindow = true;
	            clearTimeout(this.dblTimeout);
	        }
	        this.dblTimeout = setTimeout(function () {
	            Global_1.Konva.inDblClickWindow = false;
	        }, Global_1.Konva.dblClickWindow);
	        if (shape && shape.isListening()) {
	            this.clickEndShape = shape;
	            shape._fireAndBubble(MOUSEUP, { evt: evt, pointerId: pointerId });
	            if (Global_1.Konva.listenClickTap &&
	                clickStartShape &&
	                clickStartShape._id === shape._id) {
	                shape._fireAndBubble(CLICK, { evt: evt, pointerId: pointerId });
	                if (fireDblClick && clickEndShape && clickEndShape === shape) {
	                    shape._fireAndBubble(DBL_CLICK, { evt: evt, pointerId: pointerId });
	                }
	            }
	        }
	        else {
	            this.clickEndShape = null;
	            this._fire(MOUSEUP, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: pointerId,
	            });
	            if (Global_1.Konva.listenClickTap) {
	                this._fire(CLICK, {
	                    evt: evt,
	                    target: this,
	                    currentTarget: this,
	                    pointerId: pointerId,
	                });
	            }
	            if (fireDblClick) {
	                this._fire(DBL_CLICK, {
	                    evt: evt,
	                    target: this,
	                    currentTarget: this,
	                    pointerId: pointerId,
	                });
	            }
	        }
	        this._fire(CONTENT_MOUSEUP, { evt: evt });
	        if (Global_1.Konva.listenClickTap) {
	            this._fire(CONTENT_CLICK, { evt: evt });
	            if (fireDblClick) {
	                this._fire(CONTENT_DBL_CLICK, { evt: evt });
	            }
	        }
	        Global_1.Konva.listenClickTap = false;
	        if (evt.cancelable) {
	            evt.preventDefault();
	        }
	    };
	    Stage.prototype._contextmenu = function (evt) {
	        this.setPointersPositions(evt);
	        var shape = this.getIntersection(this.getPointerPosition());
	        if (shape && shape.isListening()) {
	            shape._fireAndBubble(CONTEXTMENU, { evt: evt });
	        }
	        else {
	            this._fire(CONTEXTMENU, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	        }
	        this._fire(CONTENT_CONTEXTMENU, { evt: evt });
	    };
	    Stage.prototype._touchstart = function (evt) {
	        var _this = this;
	        this.setPointersPositions(evt);
	        var triggeredOnShape = false;
	        this._changedPointerPositions.forEach(function (pos) {
	            var shape = _this.getIntersection(pos);
	            Global_1.Konva.listenClickTap = true;
	            DragAndDrop_1.DD.justDragged = false;
	            var hasShape = shape && shape.isListening();
	            if (!hasShape) {
	                return;
	            }
	            if (Global_1.Konva.captureTouchEventsEnabled) {
	                shape.setPointerCapture(pos.id);
	            }
	            _this.tapStartShape = shape;
	            shape._fireAndBubble(TOUCHSTART, { evt: evt, pointerId: pos.id }, _this);
	            triggeredOnShape = true;
	            if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
	                evt.preventDefault();
	            }
	        });
	        if (!triggeredOnShape) {
	            this._fire(TOUCHSTART, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._changedPointerPositions[0].id,
	            });
	        }
	        this._fire(CONTENT_TOUCHSTART, { evt: evt });
	    };
	    Stage.prototype._touchmove = function (evt) {
	        var _this = this;
	        this.setPointersPositions(evt);
	        var eventsEnabled = !DragAndDrop_1.DD.isDragging || Global_1.Konva.hitOnDragEnabled;
	        if (eventsEnabled) {
	            var triggeredOnShape = false;
	            var processedShapesIds = {};
	            this._changedPointerPositions.forEach(function (pos) {
	                var shape = PointerEvents$1.getCapturedShape(pos.id) || _this.getIntersection(pos);
	                var hasShape = shape && shape.isListening();
	                if (!hasShape) {
	                    return;
	                }
	                if (processedShapesIds[shape._id]) {
	                    return;
	                }
	                processedShapesIds[shape._id] = true;
	                shape._fireAndBubble(TOUCHMOVE, { evt: evt, pointerId: pos.id });
	                triggeredOnShape = true;
	                if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
	                    evt.preventDefault();
	                }
	            });
	            if (!triggeredOnShape) {
	                this._fire(TOUCHMOVE, {
	                    evt: evt,
	                    target: this,
	                    currentTarget: this,
	                    pointerId: this._changedPointerPositions[0].id,
	                });
	            }
	            this._fire(CONTENT_TOUCHMOVE, { evt: evt });
	        }
	        if (DragAndDrop_1.DD.isDragging && DragAndDrop_1.DD.node.preventDefault() && evt.cancelable) {
	            evt.preventDefault();
	        }
	    };
	    Stage.prototype._touchend = function (evt) {
	        var _this = this;
	        this.setPointersPositions(evt);
	        var tapEndShape = this.tapEndShape, fireDblClick = false;
	        if (Global_1.Konva.inDblClickWindow) {
	            fireDblClick = true;
	            clearTimeout(this.dblTimeout);
	        }
	        else if (!DragAndDrop_1.DD.justDragged) {
	            Global_1.Konva.inDblClickWindow = true;
	            clearTimeout(this.dblTimeout);
	        }
	        this.dblTimeout = setTimeout(function () {
	            Global_1.Konva.inDblClickWindow = false;
	        }, Global_1.Konva.dblClickWindow);
	        var triggeredOnShape = false;
	        var processedShapesIds = {};
	        var tapTriggered = false;
	        var dblTapTriggered = false;
	        this._changedPointerPositions.forEach(function (pos) {
	            var shape = PointerEvents$1.getCapturedShape(pos.id) ||
	                _this.getIntersection(pos);
	            if (shape) {
	                shape.releaseCapture(pos.id);
	            }
	            var hasShape = shape && shape.isListening();
	            if (!hasShape) {
	                return;
	            }
	            if (processedShapesIds[shape._id]) {
	                return;
	            }
	            processedShapesIds[shape._id] = true;
	            _this.tapEndShape = shape;
	            shape._fireAndBubble(TOUCHEND, { evt: evt, pointerId: pos.id });
	            triggeredOnShape = true;
	            if (Global_1.Konva.listenClickTap && shape === _this.tapStartShape) {
	                tapTriggered = true;
	                shape._fireAndBubble(TAP, { evt: evt, pointerId: pos.id });
	                if (fireDblClick && tapEndShape && tapEndShape === shape) {
	                    dblTapTriggered = true;
	                    shape._fireAndBubble(DBL_TAP, { evt: evt, pointerId: pos.id });
	                }
	            }
	            if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
	                evt.preventDefault();
	            }
	        });
	        if (!triggeredOnShape) {
	            this._fire(TOUCHEND, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._changedPointerPositions[0].id,
	            });
	        }
	        if (Global_1.Konva.listenClickTap && !tapTriggered) {
	            this.tapEndShape = null;
	            this._fire(TAP, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._changedPointerPositions[0].id,
	            });
	        }
	        if (fireDblClick && !dblTapTriggered) {
	            this._fire(DBL_TAP, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	                pointerId: this._changedPointerPositions[0].id,
	            });
	        }
	        this._fire(CONTENT_TOUCHEND, { evt: evt });
	        if (Global_1.Konva.listenClickTap) {
	            this._fire(CONTENT_TAP, { evt: evt });
	            if (fireDblClick) {
	                this._fire(CONTENT_DBL_TAP, { evt: evt });
	            }
	        }
	        if (this.preventDefault() && evt.cancelable) {
	            evt.preventDefault();
	        }
	        Global_1.Konva.listenClickTap = false;
	    };
	    Stage.prototype._wheel = function (evt) {
	        this.setPointersPositions(evt);
	        var shape = this.getIntersection(this.getPointerPosition());
	        if (shape && shape.isListening()) {
	            shape._fireAndBubble(WHEEL, { evt: evt });
	        }
	        else {
	            this._fire(WHEEL, {
	                evt: evt,
	                target: this,
	                currentTarget: this,
	            });
	        }
	        this._fire(CONTENT_WHEEL, { evt: evt });
	    };
	    Stage.prototype._pointerdown = function (evt) {
	        if (!Global_1.Konva._pointerEventsEnabled) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        var shape = PointerEvents$1.getCapturedShape(evt.pointerId) ||
	            this.getIntersection(this.getPointerPosition());
	        if (shape) {
	            shape._fireAndBubble(POINTERDOWN, PointerEvents$1.createEvent(evt));
	        }
	    };
	    Stage.prototype._pointermove = function (evt) {
	        if (!Global_1.Konva._pointerEventsEnabled) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        var shape = PointerEvents$1.getCapturedShape(evt.pointerId) ||
	            this.getIntersection(this.getPointerPosition());
	        if (shape) {
	            shape._fireAndBubble(POINTERMOVE, PointerEvents$1.createEvent(evt));
	        }
	    };
	    Stage.prototype._pointerup = function (evt) {
	        if (!Global_1.Konva._pointerEventsEnabled) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        var shape = PointerEvents$1.getCapturedShape(evt.pointerId) ||
	            this.getIntersection(this.getPointerPosition());
	        if (shape) {
	            shape._fireAndBubble(POINTERUP, PointerEvents$1.createEvent(evt));
	        }
	        PointerEvents$1.releaseCapture(evt.pointerId);
	    };
	    Stage.prototype._pointercancel = function (evt) {
	        if (!Global_1.Konva._pointerEventsEnabled) {
	            return;
	        }
	        this.setPointersPositions(evt);
	        var shape = PointerEvents$1.getCapturedShape(evt.pointerId) ||
	            this.getIntersection(this.getPointerPosition());
	        if (shape) {
	            shape._fireAndBubble(POINTERUP, PointerEvents$1.createEvent(evt));
	        }
	        PointerEvents$1.releaseCapture(evt.pointerId);
	    };
	    Stage.prototype._lostpointercapture = function (evt) {
	        PointerEvents$1.releaseCapture(evt.pointerId);
	    };
	    Stage.prototype.setPointersPositions = function (evt) {
	        var _this = this;
	        var contentPosition = this._getContentPosition(), x = null, y = null;
	        evt = evt ? evt : window.event;
	        if (evt.touches !== undefined) {
	            this._pointerPositions = [];
	            this._changedPointerPositions = [];
	            Util_1.Collection.prototype.each.call(evt.touches, function (touch) {
	                _this._pointerPositions.push({
	                    id: touch.identifier,
	                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
	                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,
	                });
	            });
	            Util_1.Collection.prototype.each.call(evt.changedTouches || evt.touches, function (touch) {
	                _this._changedPointerPositions.push({
	                    id: touch.identifier,
	                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,
	                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,
	                });
	            });
	        }
	        else {
	            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;
	            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;
	            this.pointerPos = {
	                x: x,
	                y: y,
	            };
	            this._pointerPositions = [{ x: x, y: y, id: Util_1.Util._getFirstPointerId(evt) }];
	            this._changedPointerPositions = [
	                { x: x, y: y, id: Util_1.Util._getFirstPointerId(evt) },
	            ];
	        }
	    };
	    Stage.prototype._setPointerPosition = function (evt) {
	        Util_1.Util.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.');
	        this.setPointersPositions(evt);
	    };
	    Stage.prototype._getContentPosition = function () {
	        if (!this.content || !this.content.getBoundingClientRect) {
	            return {
	                top: 0,
	                left: 0,
	                scaleX: 1,
	                scaleY: 1,
	            };
	        }
	        var rect = this.content.getBoundingClientRect();
	        return {
	            top: rect.top,
	            left: rect.left,
	            scaleX: rect.width / this.content.clientWidth || 1,
	            scaleY: rect.height / this.content.clientHeight || 1,
	        };
	    };
	    Stage.prototype._buildDOM = function () {
	        this.bufferCanvas = new Canvas_1.SceneCanvas({
	            width: this.width(),
	            height: this.height(),
	        });
	        this.bufferHitCanvas = new Canvas_1.HitCanvas({
	            pixelRatio: 1,
	            width: this.width(),
	            height: this.height(),
	        });
	        if (!Global_1.Konva.isBrowser) {
	            return;
	        }
	        var container = this.container();
	        if (!container) {
	            throw 'Stage has no container. A container is required.';
	        }
	        container.innerHTML = EMPTY_STRING;
	        this.content = document.createElement('div');
	        this.content.style.position = RELATIVE;
	        this.content.style.userSelect = 'none';
	        this.content.className = KONVA_CONTENT;
	        this.content.setAttribute('role', 'presentation');
	        container.appendChild(this.content);
	        this._resizeDOM();
	    };
	    Stage.prototype.cache = function () {
	        Util_1.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
	        return this;
	    };
	    Stage.prototype.clearCache = function () {
	        return this;
	    };
	    Stage.prototype.batchDraw = function () {
	        this.children.each(function (layer) {
	            layer.batchDraw();
	        });
	        return this;
	    };
	    return Stage;
	}(Container_1.Container));
	exports.Stage = Stage;
	Stage.prototype.nodeType = STAGE;
	Global_2._registerNode(Stage);
	Factory_1.Factory.addGetterSetter(Stage, 'container');
} (Stage));

var Layer$1 = {};

var Shape = {};

(function (exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Shape = exports.shapes = void 0;
	var Util_1 = Util;
	var Factory_1 = Factory;
	var Node_1 = Node;
	var Validators_1 = Validators;
	var Global_1 = Global;
	var PointerEvents$1 = PointerEvents;
	var HAS_SHADOW = 'hasShadow';
	var SHADOW_RGBA = 'shadowRGBA';
	var patternImage = 'patternImage';
	var linearGradient = 'linearGradient';
	var radialGradient = 'radialGradient';
	var dummyContext;
	function getDummyContext() {
	    if (dummyContext) {
	        return dummyContext;
	    }
	    dummyContext = Util_1.Util.createCanvasElement().getContext('2d');
	    return dummyContext;
	}
	exports.shapes = {};
	function _fillFunc(context) {
	    context.fill();
	}
	function _strokeFunc(context) {
	    context.stroke();
	}
	function _fillFuncHit(context) {
	    context.fill();
	}
	function _strokeFuncHit(context) {
	    context.stroke();
	}
	function _clearHasShadowCache() {
	    this._clearCache(HAS_SHADOW);
	}
	function _clearGetShadowRGBACache() {
	    this._clearCache(SHADOW_RGBA);
	}
	function _clearFillPatternCache() {
	    this._clearCache(patternImage);
	}
	function _clearLinearGradientCache() {
	    this._clearCache(linearGradient);
	}
	function _clearRadialGradientCache() {
	    this._clearCache(radialGradient);
	}
	var Shape = (function (_super) {
	    __extends(Shape, _super);
	    function Shape(config) {
	        var _this = _super.call(this, config) || this;
	        var key;
	        while (true) {
	            key = Util_1.Util.getRandomColor();
	            if (key && !(key in exports.shapes)) {
	                break;
	            }
	        }
	        _this.colorKey = key;
	        exports.shapes[key] = _this;
	        return _this;
	    }
	    Shape.prototype.getContext = function () {
	        return this.getLayer().getContext();
	    };
	    Shape.prototype.getCanvas = function () {
	        return this.getLayer().getCanvas();
	    };
	    Shape.prototype.getSceneFunc = function () {
	        return this.attrs.sceneFunc || this['_sceneFunc'];
	    };
	    Shape.prototype.getHitFunc = function () {
	        return this.attrs.hitFunc || this['_hitFunc'];
	    };
	    Shape.prototype.hasShadow = function () {
	        return this._getCache(HAS_SHADOW, this._hasShadow);
	    };
	    Shape.prototype._hasShadow = function () {
	        return (this.shadowEnabled() &&
	            this.shadowOpacity() !== 0 &&
	            !!(this.shadowColor() ||
	                this.shadowBlur() ||
	                this.shadowOffsetX() ||
	                this.shadowOffsetY()));
	    };
	    Shape.prototype._getFillPattern = function () {
	        return this._getCache(patternImage, this.__getFillPattern);
	    };
	    Shape.prototype.__getFillPattern = function () {
	        if (this.fillPatternImage()) {
	            var ctx = getDummyContext();
	            var pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');
	            if (pattern && pattern.setTransform) {
	                pattern.setTransform({
	                    a: this.fillPatternScaleX(),
	                    b: 0,
	                    c: 0,
	                    d: this.fillPatternScaleY(),
	                    e: 0,
	                    f: 0,
	                });
	            }
	            return pattern;
	        }
	    };
	    Shape.prototype._getLinearGradient = function () {
	        return this._getCache(linearGradient, this.__getLinearGradient);
	    };
	    Shape.prototype.__getLinearGradient = function () {
	        var colorStops = this.fillLinearGradientColorStops();
	        if (colorStops) {
	            var ctx = getDummyContext();
	            var start = this.fillLinearGradientStartPoint();
	            var end = this.fillLinearGradientEndPoint();
	            var grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
	            for (var n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            return grd;
	        }
	    };
	    Shape.prototype._getRadialGradient = function () {
	        return this._getCache(radialGradient, this.__getRadialGradient);
	    };
	    Shape.prototype.__getRadialGradient = function () {
	        var colorStops = this.fillRadialGradientColorStops();
	        if (colorStops) {
	            var ctx = getDummyContext();
	            var start = this.fillRadialGradientStartPoint();
	            var end = this.fillRadialGradientEndPoint();
	            var grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());
	            for (var n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            return grd;
	        }
	    };
	    Shape.prototype.getShadowRGBA = function () {
	        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
	    };
	    Shape.prototype._getShadowRGBA = function () {
	        if (this.hasShadow()) {
	            var rgba = Util_1.Util.colorToRGBA(this.shadowColor());
	            return ('rgba(' +
	                rgba.r +
	                ',' +
	                rgba.g +
	                ',' +
	                rgba.b +
	                ',' +
	                rgba.a * (this.shadowOpacity() || 1) +
	                ')');
	        }
	    };
	    Shape.prototype.hasFill = function () {
	        var _this = this;
	        return this._calculate('hasFill', [
	            'fillEnabled',
	            'fill',
	            'fillPatternImage',
	            'fillLinearGradientColorStops',
	            'fillRadialGradientColorStops',
	        ], function () {
	            return (_this.fillEnabled() &&
	                !!(_this.fill() ||
	                    _this.fillPatternImage() ||
	                    _this.fillLinearGradientColorStops() ||
	                    _this.fillRadialGradientColorStops()));
	        });
	    };
	    Shape.prototype.hasStroke = function () {
	        var _this = this;
	        return this._calculate('hasStroke', [
	            'strokeEnabled',
	            'strokeWidth',
	            'stroke',
	            'strokeLinearGradientColorStops',
	        ], function () {
	            return (_this.strokeEnabled() &&
	                _this.strokeWidth() &&
	                !!(_this.stroke() || _this.strokeLinearGradientColorStops()));
	        });
	    };
	    Shape.prototype.hasHitStroke = function () {
	        var width = this.hitStrokeWidth();
	        if (width === 'auto') {
	            return this.hasStroke();
	        }
	        return this.strokeEnabled() && !!width;
	    };
	    Shape.prototype.intersects = function (point) {
	        var stage = this.getStage(), bufferHitCanvas = stage.bufferHitCanvas, p;
	        bufferHitCanvas.getContext().clear();
	        this.drawHit(bufferHitCanvas, null, true);
	        p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
	        return p[3] > 0;
	    };
	    Shape.prototype.destroy = function () {
	        Node_1.Node.prototype.destroy.call(this);
	        delete exports.shapes[this.colorKey];
	        delete this.colorKey;
	        return this;
	    };
	    Shape.prototype._useBufferCanvas = function (forceFill) {
	        var _a;
	        if (!this.getStage()) {
	            return false;
	        }
	        var perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;
	        if (!perfectDrawEnabled) {
	            return false;
	        }
	        var hasFill = forceFill || this.hasFill();
	        var hasStroke = this.hasStroke();
	        var isTransparent = this.getAbsoluteOpacity() !== 1;
	        if (hasFill && hasStroke && isTransparent) {
	            return true;
	        }
	        var hasShadow = this.hasShadow();
	        var strokeForShadow = this.shadowForStrokeEnabled();
	        if (hasFill && hasStroke && hasShadow && strokeForShadow) {
	            return true;
	        }
	        return false;
	    };
	    Shape.prototype.setStrokeHitEnabled = function (val) {
	        Util_1.Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');
	        if (val) {
	            this.hitStrokeWidth('auto');
	        }
	        else {
	            this.hitStrokeWidth(0);
	        }
	    };
	    Shape.prototype.getStrokeHitEnabled = function () {
	        if (this.hitStrokeWidth() === 0) {
	            return false;
	        }
	        else {
	            return true;
	        }
	    };
	    Shape.prototype.getSelfRect = function () {
	        var size = this.size();
	        return {
	            x: this._centroid ? -size.width / 2 : 0,
	            y: this._centroid ? -size.height / 2 : 0,
	            width: size.width,
	            height: size.height,
	        };
	    };
	    Shape.prototype.getClientRect = function (config) {
	        if (config === void 0) { config = {}; }
	        var skipTransform = config.skipTransform;
	        var relativeTo = config.relativeTo;
	        var fillRect = this.getSelfRect();
	        var applyStroke = !config.skipStroke && this.hasStroke();
	        var strokeWidth = (applyStroke && this.strokeWidth()) || 0;
	        var fillAndStrokeWidth = fillRect.width + strokeWidth;
	        var fillAndStrokeHeight = fillRect.height + strokeWidth;
	        var applyShadow = !config.skipShadow && this.hasShadow();
	        var shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;
	        var shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;
	        var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
	        var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
	        var blurRadius = (applyShadow && this.shadowBlur()) || 0;
	        var width = preWidth + blurRadius * 2;
	        var height = preHeight + blurRadius * 2;
	        var roundingOffset = 0;
	        if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
	            roundingOffset = 1;
	        }
	        var rect = {
	            width: width + roundingOffset,
	            height: height + roundingOffset,
	            x: -Math.round(strokeWidth / 2 + blurRadius) +
	                Math.min(shadowOffsetX, 0) +
	                fillRect.x,
	            y: -Math.round(strokeWidth / 2 + blurRadius) +
	                Math.min(shadowOffsetY, 0) +
	                fillRect.y,
	        };
	        if (!skipTransform) {
	            return this._transformedRect(rect, relativeTo);
	        }
	        return rect;
	    };
	    Shape.prototype.drawScene = function (can, top) {
	        var layer = this.getLayer(), canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow(), stage, bufferCanvas, bufferContext;
	        var caching = canvas.isCache;
	        var skipBuffer = canvas.isCache;
	        var cachingSelf = top === this;
	        if (!this.isVisible() && !caching) {
	            return this;
	        }
	        if (cachedCanvas) {
	            context.save();
	            var m = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            this._drawCachedSceneCanvas(context);
	            context.restore();
	            return this;
	        }
	        if (!drawFunc) {
	            return this;
	        }
	        context.save();
	        if (this._useBufferCanvas() && !skipBuffer) {
	            stage = this.getStage();
	            bufferCanvas = stage.bufferCanvas;
	            bufferContext = bufferCanvas.getContext();
	            bufferContext.clear();
	            bufferContext.save();
	            bufferContext._applyLineJoin(this);
	            var o = this.getAbsoluteTransform(top).getMatrix();
	            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	            drawFunc.call(this, bufferContext, this);
	            bufferContext.restore();
	            var ratio = bufferCanvas.pixelRatio;
	            if (hasShadow) {
	                context._applyShadow(this);
	            }
	            context._applyOpacity(this);
	            context._applyGlobalCompositeOperation(this);
	            context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);
	        }
	        else {
	            context._applyLineJoin(this);
	            if (!cachingSelf) {
	                var o = this.getAbsoluteTransform(top).getMatrix();
	                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	                context._applyOpacity(this);
	                context._applyGlobalCompositeOperation(this);
	            }
	            if (hasShadow) {
	                context._applyShadow(this);
	            }
	            drawFunc.call(this, context, this);
	        }
	        context.restore();
	        return this;
	    };
	    Shape.prototype.drawHit = function (can, top, skipDragCheck) {
	        if (skipDragCheck === void 0) { skipDragCheck = false; }
	        if (!this.shouldDrawHit(top, skipDragCheck)) {
	            return this;
	        }
	        var layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
	        if (!this.colorKey) {
	            console.log(this);
	            Util_1.Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. See the shape in logs above. If you want to reuse shape you should call remove() instead of destroy()');
	        }
	        if (cachedHitCanvas) {
	            context.save();
	            var m = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	            this._drawCachedHitCanvas(context);
	            context.restore();
	            return this;
	        }
	        if (!drawFunc) {
	            return this;
	        }
	        context.save();
	        context._applyLineJoin(this);
	        var selfCache = this === top;
	        if (!selfCache) {
	            var o = this.getAbsoluteTransform(top).getMatrix();
	            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	        }
	        drawFunc.call(this, context, this);
	        context.restore();
	        return this;
	    };
	    Shape.prototype.drawHitFromCache = function (alphaThreshold) {
	        if (alphaThreshold === void 0) { alphaThreshold = 0; }
	        var cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight(), hitImageData, hitData, len, rgbColorKey, i, alpha;
	        hitContext.clear();
	        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
	        try {
	            hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
	            hitData = hitImageData.data;
	            len = hitData.length;
	            rgbColorKey = Util_1.Util._hexToRgb(this.colorKey);
	            for (i = 0; i < len; i += 4) {
	                alpha = hitData[i + 3];
	                if (alpha > alphaThreshold) {
	                    hitData[i] = rgbColorKey.r;
	                    hitData[i + 1] = rgbColorKey.g;
	                    hitData[i + 2] = rgbColorKey.b;
	                    hitData[i + 3] = 255;
	                }
	                else {
	                    hitData[i + 3] = 0;
	                }
	            }
	            hitContext.putImageData(hitImageData, 0, 0);
	        }
	        catch (e) {
	            Util_1.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
	        }
	        return this;
	    };
	    Shape.prototype.hasPointerCapture = function (pointerId) {
	        return PointerEvents$1.hasPointerCapture(pointerId, this);
	    };
	    Shape.prototype.setPointerCapture = function (pointerId) {
	        PointerEvents$1.setPointerCapture(pointerId, this);
	    };
	    Shape.prototype.releaseCapture = function (pointerId) {
	        PointerEvents$1.releaseCapture(pointerId, this);
	    };
	    return Shape;
	}(Node_1.Node));
	exports.Shape = Shape;
	Shape.prototype._fillFunc = _fillFunc;
	Shape.prototype._strokeFunc = _strokeFunc;
	Shape.prototype._fillFuncHit = _fillFuncHit;
	Shape.prototype._strokeFuncHit = _strokeFuncHit;
	Shape.prototype._centroid = false;
	Shape.prototype.nodeType = 'Shape';
	Global_1._registerNode(Shape);
	Shape.prototype.eventListeners = {};
	Shape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);
	Shape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
	Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva', _clearFillPatternCache);
	Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);
	Shape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);
	Factory_1.Factory.addGetterSetter(Shape, 'stroke', undefined, Validators_1.getStringOrGradientValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'strokeWidth', 2, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);
	Factory_1.Factory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', Validators_1.getNumberOrAutoValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'strokeHitEnabled', true, Validators_1.getBooleanValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'perfectDrawEnabled', true, Validators_1.getBooleanValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, Validators_1.getBooleanValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'lineJoin');
	Factory_1.Factory.addGetterSetter(Shape, 'lineCap');
	Factory_1.Factory.addGetterSetter(Shape, 'sceneFunc');
	Factory_1.Factory.addGetterSetter(Shape, 'hitFunc');
	Factory_1.Factory.addGetterSetter(Shape, 'dash');
	Factory_1.Factory.addGetterSetter(Shape, 'dashOffset', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowColor', undefined, Validators_1.getStringValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowBlur', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowOpacity', 1, Validators_1.getNumberValidator());
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Shape, 'shadowOffsetX', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'shadowOffsetY', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternImage');
	Factory_1.Factory.addGetterSetter(Shape, 'fill', undefined, Validators_1.getStringOrGradientValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternX', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternY', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientColorStops');
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientColorStops');
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');
	Factory_1.Factory.addGetterSetter(Shape, 'fillEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'shadowEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'dashEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeScaleEnabled', true);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPriority', 'color');
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, Validators_1.getNumberValidator());
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleX', 1, Validators_1.getNumberValidator());
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternScaleY', 1, Validators_1.getNumberValidator());
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);
	Factory_1.Factory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [
	    'x',
	    'y',
	]);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);
	Factory_1.Factory.addGetterSetter(Shape, 'fillPatternRotation', 0);
	Factory_1.Factory.backCompat(Shape, {
	    dashArray: 'dash',
	    getDashArray: 'getDash',
	    setDashArray: 'getDash',
	    drawFunc: 'sceneFunc',
	    getDrawFunc: 'getSceneFunc',
	    setDrawFunc: 'setSceneFunc',
	    drawHitFunc: 'hitFunc',
	    getDrawHitFunc: 'getHitFunc',
	    setDrawHitFunc: 'setHitFunc',
	});
	Util_1.Collection.mapMethods(Shape);
} (Shape));

var __extends$j = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Layer$1, "__esModule", { value: true });
Layer$1.Layer = void 0;
var Util_1$n = Util;
var Container_1$2 = Container$1;
var Node_1$h = Node;
var Factory_1$w = Factory;
var Canvas_1$1 = Canvas$1;
var Validators_1$v = Validators;
var Shape_1$h = Shape;
var Global_1$l = Global;
var HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [
    { x: 0, y: 0 },
    { x: -1, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 1 },
    { x: -1, y: 1 },
], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
var Layer = (function (_super) {
    __extends$j(Layer, _super);
    function Layer(config) {
        var _this = _super.call(this, config) || this;
        _this.canvas = new Canvas_1$1.SceneCanvas();
        _this.hitCanvas = new Canvas_1$1.HitCanvas({
            pixelRatio: 1,
        });
        _this._waitingForDraw = false;
        _this.on('visibleChange.konva', _this._checkVisibility);
        _this._checkVisibility();
        _this.on('imageSmoothingEnabledChange.konva', _this._setSmoothEnabled);
        _this._setSmoothEnabled();
        return _this;
    }
    Layer.prototype.createPNGStream = function () {
        var c = this.canvas._canvas;
        return c.createPNGStream();
    };
    Layer.prototype.getCanvas = function () {
        return this.canvas;
    };
    Layer.prototype.getHitCanvas = function () {
        return this.hitCanvas;
    };
    Layer.prototype.getContext = function () {
        return this.getCanvas().getContext();
    };
    Layer.prototype.clear = function (bounds) {
        this.getContext().clear(bounds);
        this.getHitCanvas().getContext().clear(bounds);
        return this;
    };
    Layer.prototype.setZIndex = function (index) {
        _super.prototype.setZIndex.call(this, index);
        var stage = this.getStage();
        if (stage) {
            stage.content.removeChild(this.getCanvas()._canvas);
            if (index < stage.children.length - 1) {
                stage.content.insertBefore(this.getCanvas()._canvas, stage.children[index + 1].getCanvas()._canvas);
            }
            else {
                stage.content.appendChild(this.getCanvas()._canvas);
            }
        }
        return this;
    };
    Layer.prototype.moveToTop = function () {
        Node_1$h.Node.prototype.moveToTop.call(this);
        var stage = this.getStage();
        if (stage) {
            stage.content.removeChild(this.getCanvas()._canvas);
            stage.content.appendChild(this.getCanvas()._canvas);
        }
        return true;
    };
    Layer.prototype.moveUp = function () {
        var moved = Node_1$h.Node.prototype.moveUp.call(this);
        if (!moved) {
            return false;
        }
        var stage = this.getStage();
        if (!stage) {
            return false;
        }
        stage.content.removeChild(this.getCanvas()._canvas);
        if (this.index < stage.children.length - 1) {
            stage.content.insertBefore(this.getCanvas()._canvas, stage.children[this.index + 1].getCanvas()._canvas);
        }
        else {
            stage.content.appendChild(this.getCanvas()._canvas);
        }
        return true;
    };
    Layer.prototype.moveDown = function () {
        if (Node_1$h.Node.prototype.moveDown.call(this)) {
            var stage = this.getStage();
            if (stage) {
                var children = stage.children;
                stage.content.removeChild(this.getCanvas()._canvas);
                stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
            }
            return true;
        }
        return false;
    };
    Layer.prototype.moveToBottom = function () {
        if (Node_1$h.Node.prototype.moveToBottom.call(this)) {
            var stage = this.getStage();
            if (stage) {
                var children = stage.children;
                stage.content.removeChild(this.getCanvas()._canvas);
                stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
            }
            return true;
        }
        return false;
    };
    Layer.prototype.getLayer = function () {
        return this;
    };
    Layer.prototype.remove = function () {
        var _canvas = this.getCanvas()._canvas;
        Node_1$h.Node.prototype.remove.call(this);
        if (_canvas && _canvas.parentNode && Util_1$n.Util._isInDocument(_canvas)) {
            _canvas.parentNode.removeChild(_canvas);
        }
        return this;
    };
    Layer.prototype.getStage = function () {
        return this.parent;
    };
    Layer.prototype.setSize = function (_a) {
        var width = _a.width, height = _a.height;
        this.canvas.setSize(width, height);
        this.hitCanvas.setSize(width, height);
        this._setSmoothEnabled();
        return this;
    };
    Layer.prototype._validateAdd = function (child) {
        var type = child.getType();
        if (type !== 'Group' && type !== 'Shape') {
            Util_1$n.Util.throw('You may only add groups and shapes to a layer.');
        }
    };
    Layer.prototype._toKonvaCanvas = function (config) {
        config = config || {};
        config.width = config.width || this.getWidth();
        config.height = config.height || this.getHeight();
        config.x = config.x !== undefined ? config.x : this.x();
        config.y = config.y !== undefined ? config.y : this.y();
        return Node_1$h.Node.prototype._toKonvaCanvas.call(this, config);
    };
    Layer.prototype._checkVisibility = function () {
        var visible = this.visible();
        if (visible) {
            this.canvas._canvas.style.display = 'block';
        }
        else {
            this.canvas._canvas.style.display = 'none';
        }
    };
    Layer.prototype._setSmoothEnabled = function () {
        this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
    };
    Layer.prototype.getWidth = function () {
        if (this.parent) {
            return this.parent.width();
        }
    };
    Layer.prototype.setWidth = function () {
        Util_1$n.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
    };
    Layer.prototype.getHeight = function () {
        if (this.parent) {
            return this.parent.height();
        }
    };
    Layer.prototype.setHeight = function () {
        Util_1$n.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
    };
    Layer.prototype.batchDraw = function () {
        var _this = this;
        if (!this._waitingForDraw) {
            this._waitingForDraw = true;
            Util_1$n.Util.requestAnimFrame(function () {
                _this.draw();
                _this._waitingForDraw = false;
            });
        }
        return this;
    };
    Layer.prototype.getIntersection = function (pos, selector) {
        if (!this.isListening() || !this.isVisible()) {
            return null;
        }
        var spiralSearchDistance = 1;
        var continueSearch = false;
        while (true) {
            for (var i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
                var intersectionOffset = INTERSECTION_OFFSETS[i];
                var obj = this._getIntersection({
                    x: pos.x + intersectionOffset.x * spiralSearchDistance,
                    y: pos.y + intersectionOffset.y * spiralSearchDistance,
                });
                var shape = obj.shape;
                if (shape && selector) {
                    return shape.findAncestor(selector, true);
                }
                else if (shape) {
                    return shape;
                }
                continueSearch = !!obj.antialiased;
                if (!obj.antialiased) {
                    break;
                }
            }
            if (continueSearch) {
                spiralSearchDistance += 1;
            }
            else {
                return null;
            }
        }
    };
    Layer.prototype._getIntersection = function (pos) {
        var ratio = this.hitCanvas.pixelRatio;
        var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;
        var p3 = p[3];
        if (p3 === 255) {
            var colorKey = Util_1$n.Util._rgbToHex(p[0], p[1], p[2]);
            var shape = Shape_1$h.shapes[HASH + colorKey];
            if (shape) {
                return {
                    shape: shape,
                };
            }
            return {
                antialiased: true,
            };
        }
        else if (p3 > 0) {
            return {
                antialiased: true,
            };
        }
        return {};
    };
    Layer.prototype.drawScene = function (can, top) {
        var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());
        this._fire(BEFORE_DRAW, {
            node: this,
        });
        if (this.clearBeforeDraw()) {
            canvas.getContext().clear();
        }
        Container_1$2.Container.prototype.drawScene.call(this, canvas, top);
        this._fire(DRAW, {
            node: this,
        });
        return this;
    };
    Layer.prototype.drawHit = function (can, top) {
        var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);
        if (layer && layer.clearBeforeDraw()) {
            layer.getHitCanvas().getContext().clear();
        }
        Container_1$2.Container.prototype.drawHit.call(this, canvas, top);
        return this;
    };
    Layer.prototype.enableHitGraph = function () {
        this.hitGraphEnabled(true);
        return this;
    };
    Layer.prototype.disableHitGraph = function () {
        this.hitGraphEnabled(false);
        return this;
    };
    Layer.prototype.setHitGraphEnabled = function (val) {
        Util_1$n.Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');
        this.listening(val);
    };
    Layer.prototype.getHitGraphEnabled = function (val) {
        Util_1$n.Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');
        return this.listening();
    };
    Layer.prototype.toggleHitCanvas = function () {
        if (!this.parent) {
            return;
        }
        var parent = this.parent;
        var added = !!this.hitCanvas._canvas.parentNode;
        if (added) {
            parent.content.removeChild(this.hitCanvas._canvas);
        }
        else {
            parent.content.appendChild(this.hitCanvas._canvas);
        }
    };
    return Layer;
}(Container_1$2.Container));
Layer$1.Layer = Layer;
Layer.prototype.nodeType = 'Layer';
Global_1$l._registerNode(Layer);
Factory_1$w.Factory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);
Factory_1$w.Factory.addGetterSetter(Layer, 'clearBeforeDraw', true);
Factory_1$w.Factory.addGetterSetter(Layer, 'hitGraphEnabled', true, Validators_1$v.getBooleanValidator());
Util_1$n.Collection.mapMethods(Layer);

var FastLayer$1 = {};

var __extends$i = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(FastLayer$1, "__esModule", { value: true });
FastLayer$1.FastLayer = void 0;
var Util_1$m = Util;
var Layer_1$1 = Layer$1;
var Global_1$k = Global;
var FastLayer = (function (_super) {
    __extends$i(FastLayer, _super);
    function FastLayer(attrs) {
        var _this = _super.call(this, attrs) || this;
        _this.listening(false);
        Util_1$m.Util.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.');
        return _this;
    }
    return FastLayer;
}(Layer_1$1.Layer));
FastLayer$1.FastLayer = FastLayer;
FastLayer.prototype.nodeType = 'FastLayer';
Global_1$k._registerNode(FastLayer);
Util_1$m.Collection.mapMethods(FastLayer);

var Group$1 = {};

var __extends$h = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Group$1, "__esModule", { value: true });
Group$1.Group = void 0;
var Util_1$l = Util;
var Container_1$1 = Container$1;
var Global_1$j = Global;
var Group = (function (_super) {
    __extends$h(Group, _super);
    function Group() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Group.prototype._validateAdd = function (child) {
        var type = child.getType();
        if (type !== 'Group' && type !== 'Shape') {
            Util_1$l.Util.throw('You may only add groups and shapes to groups.');
        }
    };
    return Group;
}(Container_1$1.Container));
Group$1.Group = Group;
Group.prototype.nodeType = 'Group';
Global_1$j._registerNode(Group);
Util_1$l.Collection.mapMethods(Group);

var Animation$1 = {};

Object.defineProperty(Animation$1, "__esModule", { value: true });
Animation$1.Animation = void 0;
var Global_1$i = Global;
var now = (function () {
    if (Global_1$i.glob.performance && Global_1$i.glob.performance.now) {
        return function () {
            return Global_1$i.glob.performance.now();
        };
    }
    return function () {
        return new Date().getTime();
    };
})();
var Animation = (function () {
    function Animation(func, layers) {
        this.id = Animation.animIdCounter++;
        this.frame = {
            time: 0,
            timeDiff: 0,
            lastTime: now(),
            frameRate: 0
        };
        this.func = func;
        this.setLayers(layers);
    }
    Animation.prototype.setLayers = function (layers) {
        var lays = [];
        if (!layers) {
            lays = [];
        }
        else if (layers.length > 0) {
            lays = layers;
        }
        else {
            lays = [layers];
        }
        this.layers = lays;
        return this;
    };
    Animation.prototype.getLayers = function () {
        return this.layers;
    };
    Animation.prototype.addLayer = function (layer) {
        var layers = this.layers, len = layers.length, n;
        for (n = 0; n < len; n++) {
            if (layers[n]._id === layer._id) {
                return false;
            }
        }
        this.layers.push(layer);
        return true;
    };
    Animation.prototype.isRunning = function () {
        var a = Animation, animations = a.animations, len = animations.length, n;
        for (n = 0; n < len; n++) {
            if (animations[n].id === this.id) {
                return true;
            }
        }
        return false;
    };
    Animation.prototype.start = function () {
        this.stop();
        this.frame.timeDiff = 0;
        this.frame.lastTime = now();
        Animation._addAnimation(this);
        return this;
    };
    Animation.prototype.stop = function () {
        Animation._removeAnimation(this);
        return this;
    };
    Animation.prototype._updateFrameObject = function (time) {
        this.frame.timeDiff = time - this.frame.lastTime;
        this.frame.lastTime = time;
        this.frame.time += this.frame.timeDiff;
        this.frame.frameRate = 1000 / this.frame.timeDiff;
    };
    Animation._addAnimation = function (anim) {
        this.animations.push(anim);
        this._handleAnimation();
    };
    Animation._removeAnimation = function (anim) {
        var id = anim.id, animations = this.animations, len = animations.length, n;
        for (n = 0; n < len; n++) {
            if (animations[n].id === id) {
                this.animations.splice(n, 1);
                break;
            }
        }
    };
    Animation._runFrames = function () {
        var layerHash = {}, animations = this.animations, anim, layers, func, n, i, layersLen, layer, key, needRedraw;
        for (n = 0; n < animations.length; n++) {
            anim = animations[n];
            layers = anim.layers;
            func = anim.func;
            anim._updateFrameObject(now());
            layersLen = layers.length;
            if (func) {
                needRedraw = func.call(anim, anim.frame) !== false;
            }
            else {
                needRedraw = true;
            }
            if (!needRedraw) {
                continue;
            }
            for (i = 0; i < layersLen; i++) {
                layer = layers[i];
                if (layer._id !== undefined) {
                    layerHash[layer._id] = layer;
                }
            }
        }
        for (key in layerHash) {
            if (!layerHash.hasOwnProperty(key)) {
                continue;
            }
            layerHash[key].draw();
        }
    };
    Animation._animationLoop = function () {
        var Anim = Animation;
        if (Anim.animations.length) {
            Anim._runFrames();
            requestAnimationFrame(Anim._animationLoop);
        }
        else {
            Anim.animRunning = false;
        }
    };
    Animation._handleAnimation = function () {
        if (!this.animRunning) {
            this.animRunning = true;
            requestAnimationFrame(this._animationLoop);
        }
    };
    Animation.animations = [];
    Animation.animIdCounter = 0;
    Animation.animRunning = false;
    return Animation;
}());
Animation$1.Animation = Animation;

var Tween = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Easings = exports.Tween = void 0;
	var Util_1 = Util;
	var Animation_1 = Animation$1;
	var Node_1 = Node;
	var Global_1 = Global;
	var blacklist = {
	    node: 1,
	    duration: 1,
	    easing: 1,
	    onFinish: 1,
	    yoyo: 1,
	}, PAUSED = 1, PLAYING = 2, REVERSING = 3, idCounter = 0, colorAttrs = ['fill', 'stroke', 'shadowColor'];
	var TweenEngine = (function () {
	    function TweenEngine(prop, propFunc, func, begin, finish, duration, yoyo) {
	        this.prop = prop;
	        this.propFunc = propFunc;
	        this.begin = begin;
	        this._pos = begin;
	        this.duration = duration;
	        this._change = 0;
	        this.prevPos = 0;
	        this.yoyo = yoyo;
	        this._time = 0;
	        this._position = 0;
	        this._startTime = 0;
	        this._finish = 0;
	        this.func = func;
	        this._change = finish - this.begin;
	        this.pause();
	    }
	    TweenEngine.prototype.fire = function (str) {
	        var handler = this[str];
	        if (handler) {
	            handler();
	        }
	    };
	    TweenEngine.prototype.setTime = function (t) {
	        if (t > this.duration) {
	            if (this.yoyo) {
	                this._time = this.duration;
	                this.reverse();
	            }
	            else {
	                this.finish();
	            }
	        }
	        else if (t < 0) {
	            if (this.yoyo) {
	                this._time = 0;
	                this.play();
	            }
	            else {
	                this.reset();
	            }
	        }
	        else {
	            this._time = t;
	            this.update();
	        }
	    };
	    TweenEngine.prototype.getTime = function () {
	        return this._time;
	    };
	    TweenEngine.prototype.setPosition = function (p) {
	        this.prevPos = this._pos;
	        this.propFunc(p);
	        this._pos = p;
	    };
	    TweenEngine.prototype.getPosition = function (t) {
	        if (t === undefined) {
	            t = this._time;
	        }
	        return this.func(t, this.begin, this._change, this.duration);
	    };
	    TweenEngine.prototype.play = function () {
	        this.state = PLAYING;
	        this._startTime = this.getTimer() - this._time;
	        this.onEnterFrame();
	        this.fire('onPlay');
	    };
	    TweenEngine.prototype.reverse = function () {
	        this.state = REVERSING;
	        this._time = this.duration - this._time;
	        this._startTime = this.getTimer() - this._time;
	        this.onEnterFrame();
	        this.fire('onReverse');
	    };
	    TweenEngine.prototype.seek = function (t) {
	        this.pause();
	        this._time = t;
	        this.update();
	        this.fire('onSeek');
	    };
	    TweenEngine.prototype.reset = function () {
	        this.pause();
	        this._time = 0;
	        this.update();
	        this.fire('onReset');
	    };
	    TweenEngine.prototype.finish = function () {
	        this.pause();
	        this._time = this.duration;
	        this.update();
	        this.fire('onFinish');
	    };
	    TweenEngine.prototype.update = function () {
	        this.setPosition(this.getPosition(this._time));
	        this.fire('onUpdate');
	    };
	    TweenEngine.prototype.onEnterFrame = function () {
	        var t = this.getTimer() - this._startTime;
	        if (this.state === PLAYING) {
	            this.setTime(t);
	        }
	        else if (this.state === REVERSING) {
	            this.setTime(this.duration - t);
	        }
	    };
	    TweenEngine.prototype.pause = function () {
	        this.state = PAUSED;
	        this.fire('onPause');
	    };
	    TweenEngine.prototype.getTimer = function () {
	        return new Date().getTime();
	    };
	    return TweenEngine;
	}());
	var Tween = (function () {
	    function Tween(config) {
	        var that = this, node = config.node, nodeId = node._id, duration, easing = config.easing || exports.Easings.Linear, yoyo = !!config.yoyo, key;
	        if (typeof config.duration === 'undefined') {
	            duration = 0.3;
	        }
	        else if (config.duration === 0) {
	            duration = 0.001;
	        }
	        else {
	            duration = config.duration;
	        }
	        this.node = node;
	        this._id = idCounter++;
	        var layers = node.getLayer() ||
	            (node instanceof Global_1.Konva['Stage'] ? node.getLayers() : null);
	        if (!layers) {
	            Util_1.Util.error('Tween constructor have `node` that is not in a layer. Please add node into layer first.');
	        }
	        this.anim = new Animation_1.Animation(function () {
	            that.tween.onEnterFrame();
	        }, layers);
	        this.tween = new TweenEngine(key, function (i) {
	            that._tweenFunc(i);
	        }, easing, 0, 1, duration * 1000, yoyo);
	        this._addListeners();
	        if (!Tween.attrs[nodeId]) {
	            Tween.attrs[nodeId] = {};
	        }
	        if (!Tween.attrs[nodeId][this._id]) {
	            Tween.attrs[nodeId][this._id] = {};
	        }
	        if (!Tween.tweens[nodeId]) {
	            Tween.tweens[nodeId] = {};
	        }
	        for (key in config) {
	            if (blacklist[key] === undefined) {
	                this._addAttr(key, config[key]);
	            }
	        }
	        this.reset();
	        this.onFinish = config.onFinish;
	        this.onReset = config.onReset;
	        this.onUpdate = config.onUpdate;
	    }
	    Tween.prototype._addAttr = function (key, end) {
	        var node = this.node, nodeId = node._id, start, diff, tweenId, n, len, trueEnd, trueStart, endRGBA;
	        tweenId = Tween.tweens[nodeId][key];
	        if (tweenId) {
	            delete Tween.attrs[nodeId][tweenId][key];
	        }
	        start = node.getAttr(key);
	        if (Util_1.Util._isArray(end)) {
	            diff = [];
	            len = Math.max(end.length, start.length);
	            if (key === 'points' && end.length !== start.length) {
	                if (end.length > start.length) {
	                    trueStart = start;
	                    start = Util_1.Util._prepareArrayForTween(start, end, node.closed());
	                }
	                else {
	                    trueEnd = end;
	                    end = Util_1.Util._prepareArrayForTween(end, start, node.closed());
	                }
	            }
	            if (key.indexOf('fill') === 0) {
	                for (n = 0; n < len; n++) {
	                    if (n % 2 === 0) {
	                        diff.push(end[n] - start[n]);
	                    }
	                    else {
	                        var startRGBA = Util_1.Util.colorToRGBA(start[n]);
	                        endRGBA = Util_1.Util.colorToRGBA(end[n]);
	                        start[n] = startRGBA;
	                        diff.push({
	                            r: endRGBA.r - startRGBA.r,
	                            g: endRGBA.g - startRGBA.g,
	                            b: endRGBA.b - startRGBA.b,
	                            a: endRGBA.a - startRGBA.a,
	                        });
	                    }
	                }
	            }
	            else {
	                for (n = 0; n < len; n++) {
	                    diff.push(end[n] - start[n]);
	                }
	            }
	        }
	        else if (colorAttrs.indexOf(key) !== -1) {
	            start = Util_1.Util.colorToRGBA(start);
	            endRGBA = Util_1.Util.colorToRGBA(end);
	            diff = {
	                r: endRGBA.r - start.r,
	                g: endRGBA.g - start.g,
	                b: endRGBA.b - start.b,
	                a: endRGBA.a - start.a,
	            };
	        }
	        else {
	            diff = end - start;
	        }
	        Tween.attrs[nodeId][this._id][key] = {
	            start: start,
	            diff: diff,
	            end: end,
	            trueEnd: trueEnd,
	            trueStart: trueStart,
	        };
	        Tween.tweens[nodeId][key] = this._id;
	    };
	    Tween.prototype._tweenFunc = function (i) {
	        var node = this.node, attrs = Tween.attrs[node._id][this._id], key, attr, start, diff, newVal, n, len, end;
	        for (key in attrs) {
	            attr = attrs[key];
	            start = attr.start;
	            diff = attr.diff;
	            end = attr.end;
	            if (Util_1.Util._isArray(start)) {
	                newVal = [];
	                len = Math.max(start.length, end.length);
	                if (key.indexOf('fill') === 0) {
	                    for (n = 0; n < len; n++) {
	                        if (n % 2 === 0) {
	                            newVal.push((start[n] || 0) + diff[n] * i);
	                        }
	                        else {
	                            newVal.push('rgba(' +
	                                Math.round(start[n].r + diff[n].r * i) +
	                                ',' +
	                                Math.round(start[n].g + diff[n].g * i) +
	                                ',' +
	                                Math.round(start[n].b + diff[n].b * i) +
	                                ',' +
	                                (start[n].a + diff[n].a * i) +
	                                ')');
	                        }
	                    }
	                }
	                else {
	                    for (n = 0; n < len; n++) {
	                        newVal.push((start[n] || 0) + diff[n] * i);
	                    }
	                }
	            }
	            else if (colorAttrs.indexOf(key) !== -1) {
	                newVal =
	                    'rgba(' +
	                        Math.round(start.r + diff.r * i) +
	                        ',' +
	                        Math.round(start.g + diff.g * i) +
	                        ',' +
	                        Math.round(start.b + diff.b * i) +
	                        ',' +
	                        (start.a + diff.a * i) +
	                        ')';
	            }
	            else {
	                newVal = start + diff * i;
	            }
	            node.setAttr(key, newVal);
	        }
	    };
	    Tween.prototype._addListeners = function () {
	        var _this = this;
	        this.tween.onPlay = function () {
	            _this.anim.start();
	        };
	        this.tween.onReverse = function () {
	            _this.anim.start();
	        };
	        this.tween.onPause = function () {
	            _this.anim.stop();
	        };
	        this.tween.onFinish = function () {
	            var node = _this.node;
	            var attrs = Tween.attrs[node._id][_this._id];
	            if (attrs.points && attrs.points.trueEnd) {
	                node.setAttr('points', attrs.points.trueEnd);
	            }
	            if (_this.onFinish) {
	                _this.onFinish.call(_this);
	            }
	        };
	        this.tween.onReset = function () {
	            var node = _this.node;
	            var attrs = Tween.attrs[node._id][_this._id];
	            if (attrs.points && attrs.points.trueStart) {
	                node.points(attrs.points.trueStart);
	            }
	            if (_this.onReset) {
	                _this.onReset();
	            }
	        };
	        this.tween.onUpdate = function () {
	            if (_this.onUpdate) {
	                _this.onUpdate.call(_this);
	            }
	        };
	    };
	    Tween.prototype.play = function () {
	        this.tween.play();
	        return this;
	    };
	    Tween.prototype.reverse = function () {
	        this.tween.reverse();
	        return this;
	    };
	    Tween.prototype.reset = function () {
	        this.tween.reset();
	        return this;
	    };
	    Tween.prototype.seek = function (t) {
	        this.tween.seek(t * 1000);
	        return this;
	    };
	    Tween.prototype.pause = function () {
	        this.tween.pause();
	        return this;
	    };
	    Tween.prototype.finish = function () {
	        this.tween.finish();
	        return this;
	    };
	    Tween.prototype.destroy = function () {
	        var nodeId = this.node._id, thisId = this._id, attrs = Tween.tweens[nodeId], key;
	        this.pause();
	        for (key in attrs) {
	            delete Tween.tweens[nodeId][key];
	        }
	        delete Tween.attrs[nodeId][thisId];
	    };
	    Tween.attrs = {};
	    Tween.tweens = {};
	    return Tween;
	}());
	exports.Tween = Tween;
	Node_1.Node.prototype.to = function (params) {
	    var onFinish = params.onFinish;
	    params.node = this;
	    params.onFinish = function () {
	        this.destroy();
	        if (onFinish) {
	            onFinish();
	        }
	    };
	    var tween = new Tween(params);
	    tween.play();
	};
	exports.Easings = {
	    BackEaseIn: function (t, b, c, d) {
	        var s = 1.70158;
	        return c * (t /= d) * t * ((s + 1) * t - s) + b;
	    },
	    BackEaseOut: function (t, b, c, d) {
	        var s = 1.70158;
	        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	    },
	    BackEaseInOut: function (t, b, c, d) {
	        var s = 1.70158;
	        if ((t /= d / 2) < 1) {
	            return (c / 2) * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
	        }
	        return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
	    },
	    ElasticEaseIn: function (t, b, c, d, a, p) {
	        var s = 0;
	        if (t === 0) {
	            return b;
	        }
	        if ((t /= d) === 1) {
	            return b + c;
	        }
	        if (!p) {
	            p = d * 0.3;
	        }
	        if (!a || a < Math.abs(c)) {
	            a = c;
	            s = p / 4;
	        }
	        else {
	            s = (p / (2 * Math.PI)) * Math.asin(c / a);
	        }
	        return (-(a *
	            Math.pow(2, 10 * (t -= 1)) *
	            Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b);
	    },
	    ElasticEaseOut: function (t, b, c, d, a, p) {
	        var s = 0;
	        if (t === 0) {
	            return b;
	        }
	        if ((t /= d) === 1) {
	            return b + c;
	        }
	        if (!p) {
	            p = d * 0.3;
	        }
	        if (!a || a < Math.abs(c)) {
	            a = c;
	            s = p / 4;
	        }
	        else {
	            s = (p / (2 * Math.PI)) * Math.asin(c / a);
	        }
	        return (a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +
	            c +
	            b);
	    },
	    ElasticEaseInOut: function (t, b, c, d, a, p) {
	        var s = 0;
	        if (t === 0) {
	            return b;
	        }
	        if ((t /= d / 2) === 2) {
	            return b + c;
	        }
	        if (!p) {
	            p = d * (0.3 * 1.5);
	        }
	        if (!a || a < Math.abs(c)) {
	            a = c;
	            s = p / 4;
	        }
	        else {
	            s = (p / (2 * Math.PI)) * Math.asin(c / a);
	        }
	        if (t < 1) {
	            return (-0.5 *
	                (a *
	                    Math.pow(2, 10 * (t -= 1)) *
	                    Math.sin(((t * d - s) * (2 * Math.PI)) / p)) +
	                b);
	        }
	        return (a *
	            Math.pow(2, -10 * (t -= 1)) *
	            Math.sin(((t * d - s) * (2 * Math.PI)) / p) *
	            0.5 +
	            c +
	            b);
	    },
	    BounceEaseOut: function (t, b, c, d) {
	        if ((t /= d) < 1 / 2.75) {
	            return c * (7.5625 * t * t) + b;
	        }
	        else if (t < 2 / 2.75) {
	            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
	        }
	        else if (t < 2.5 / 2.75) {
	            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
	        }
	        else {
	            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
	        }
	    },
	    BounceEaseIn: function (t, b, c, d) {
	        return c - exports.Easings.BounceEaseOut(d - t, 0, c, d) + b;
	    },
	    BounceEaseInOut: function (t, b, c, d) {
	        if (t < d / 2) {
	            return exports.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
	        }
	        else {
	            return exports.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	        }
	    },
	    EaseIn: function (t, b, c, d) {
	        return c * (t /= d) * t + b;
	    },
	    EaseOut: function (t, b, c, d) {
	        return -c * (t /= d) * (t - 2) + b;
	    },
	    EaseInOut: function (t, b, c, d) {
	        if ((t /= d / 2) < 1) {
	            return (c / 2) * t * t + b;
	        }
	        return (-c / 2) * (--t * (t - 2) - 1) + b;
	    },
	    StrongEaseIn: function (t, b, c, d) {
	        return c * (t /= d) * t * t * t * t + b;
	    },
	    StrongEaseOut: function (t, b, c, d) {
	        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	    },
	    StrongEaseInOut: function (t, b, c, d) {
	        if ((t /= d / 2) < 1) {
	            return (c / 2) * t * t * t * t * t + b;
	        }
	        return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;
	    },
	    Linear: function (t, b, c, d) {
	        return (c * t) / d + b;
	    },
	};
} (Tween));

Object.defineProperty(_CoreInternals, "__esModule", { value: true });
_CoreInternals.Konva = void 0;
var Global_1$h = Global;
var Util_1$k = Util;
var Node_1$g = Node;
var Container_1 = Container$1;
var Stage_1 = Stage;
var Layer_1 = Layer$1;
var FastLayer_1 = FastLayer$1;
var Group_1$2 = Group$1;
var DragAndDrop_1 = DragAndDrop;
var Shape_1$g = Shape;
var Animation_1$1 = Animation$1;
var Tween_1 = Tween;
var Context_1 = Context$1;
var Canvas_1 = Canvas$1;
_CoreInternals.Konva = Util_1$k.Util._assign(Global_1$h.Konva, {
    Collection: Util_1$k.Collection,
    Util: Util_1$k.Util,
    Transform: Util_1$k.Transform,
    Node: Node_1$g.Node,
    ids: Node_1$g.ids,
    names: Node_1$g.names,
    Container: Container_1.Container,
    Stage: Stage_1.Stage,
    stages: Stage_1.stages,
    Layer: Layer_1.Layer,
    FastLayer: FastLayer_1.FastLayer,
    Group: Group_1$2.Group,
    DD: DragAndDrop_1.DD,
    Shape: Shape_1$g.Shape,
    shapes: Shape_1$g.shapes,
    Animation: Animation_1$1.Animation,
    Tween: Tween_1.Tween,
    Easings: Tween_1.Easings,
    Context: Context_1.Context,
    Canvas: Canvas_1.Canvas
});

var Arc$1 = {};

var __extends$g = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Arc$1, "__esModule", { value: true });
Arc$1.Arc = void 0;
var Util_1$j = Util;
var Factory_1$v = Factory;
var Shape_1$f = Shape;
var Global_1$g = Global;
var Validators_1$u = Validators;
var Global_2$3 = Global;
var Arc = (function (_super) {
    __extends$g(Arc, _super);
    function Arc() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Arc.prototype._sceneFunc = function (context) {
        var angle = Global_1$g.Konva.getAngle(this.angle()), clockwise = this.clockwise();
        context.beginPath();
        context.arc(0, 0, this.outerRadius(), 0, angle, clockwise);
        context.arc(0, 0, this.innerRadius(), angle, 0, !clockwise);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Arc.prototype.getWidth = function () {
        return this.outerRadius() * 2;
    };
    Arc.prototype.getHeight = function () {
        return this.outerRadius() * 2;
    };
    Arc.prototype.setWidth = function (width) {
        this.outerRadius(width / 2);
    };
    Arc.prototype.setHeight = function (height) {
        this.outerRadius(height / 2);
    };
    return Arc;
}(Shape_1$f.Shape));
Arc$1.Arc = Arc;
Arc.prototype._centroid = true;
Arc.prototype.className = 'Arc';
Arc.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
Global_2$3._registerNode(Arc);
Factory_1$v.Factory.addGetterSetter(Arc, 'innerRadius', 0, Validators_1$u.getNumberValidator());
Factory_1$v.Factory.addGetterSetter(Arc, 'outerRadius', 0, Validators_1$u.getNumberValidator());
Factory_1$v.Factory.addGetterSetter(Arc, 'angle', 0, Validators_1$u.getNumberValidator());
Factory_1$v.Factory.addGetterSetter(Arc, 'clockwise', false, Validators_1$u.getBooleanValidator());
Util_1$j.Collection.mapMethods(Arc);

var Arrow$1 = {};

var Line$1 = {};

var __extends$f = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (commonjsGlobal && commonjsGlobal.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(Line$1, "__esModule", { value: true });
Line$1.Line = void 0;
var Util_1$i = Util;
var Factory_1$u = Factory;
var Shape_1$e = Shape;
var Validators_1$t = Validators;
var Global_1$f = Global;
var Line = (function (_super) {
    __extends$f(Line, _super);
    function Line(config) {
        var _this = _super.call(this, config) || this;
        _this.on('pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva', function () {
            this._clearCache('tensionPoints');
        });
        return _this;
    }
    Line.prototype._sceneFunc = function (context) {
        var points = this.points(), length = points.length, tension = this.tension(), closed = this.closed(), bezier = this.bezier(), tp, len, n;
        if (!length) {
            return;
        }
        context.beginPath();
        context.moveTo(points[0], points[1]);
        if (tension !== 0 && length > 4) {
            tp = this.getTensionPoints();
            len = tp.length;
            n = closed ? 0 : 4;
            if (!closed) {
                context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
            }
            while (n < len - 2) {
                context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
            }
            if (!closed) {
                context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
            }
        }
        else if (bezier) {
            n = 2;
            while (n < length) {
                context.bezierCurveTo(points[n++], points[n++], points[n++], points[n++], points[n++], points[n++]);
            }
        }
        else {
            for (n = 2; n < length; n += 2) {
                context.lineTo(points[n], points[n + 1]);
            }
        }
        if (closed) {
            context.closePath();
            context.fillStrokeShape(this);
        }
        else {
            context.strokeShape(this);
        }
    };
    Line.prototype.getTensionPoints = function () {
        return this._getCache('tensionPoints', this._getTensionPoints);
    };
    Line.prototype._getTensionPoints = function () {
        if (this.closed()) {
            return this._getTensionPointsClosed();
        }
        else {
            return Util_1$i.Util._expandPoints(this.points(), this.tension());
        }
    };
    Line.prototype._getTensionPointsClosed = function () {
        var p = this.points(), len = p.length, tension = this.tension(), firstControlPoints = Util_1$i.Util._getControlPoints(p[len - 2], p[len - 1], p[0], p[1], p[2], p[3], tension), lastControlPoints = Util_1$i.Util._getControlPoints(p[len - 4], p[len - 3], p[len - 2], p[len - 1], p[0], p[1], tension), middle = Util_1$i.Util._expandPoints(p, tension), tp = [firstControlPoints[2], firstControlPoints[3]]
            .concat(middle)
            .concat([
            lastControlPoints[0],
            lastControlPoints[1],
            p[len - 2],
            p[len - 1],
            lastControlPoints[2],
            lastControlPoints[3],
            firstControlPoints[0],
            firstControlPoints[1],
            p[0],
            p[1]
        ]);
        return tp;
    };
    Line.prototype.getWidth = function () {
        return this.getSelfRect().width;
    };
    Line.prototype.getHeight = function () {
        return this.getSelfRect().height;
    };
    Line.prototype.getSelfRect = function () {
        var points = this.points();
        if (points.length < 4) {
            return {
                x: points[0] || 0,
                y: points[1] || 0,
                width: 0,
                height: 0
            };
        }
        if (this.tension() !== 0) {
            points = __spreadArrays([
                points[0],
                points[1]
            ], this._getTensionPoints(), [
                points[points.length - 2],
                points[points.length - 1]
            ]);
        }
        else {
            points = this.points();
        }
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x, y;
        for (var i = 0; i < points.length / 2; i++) {
            x = points[i * 2];
            y = points[i * 2 + 1];
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    };
    return Line;
}(Shape_1$e.Shape));
Line$1.Line = Line;
Line.prototype.className = 'Line';
Line.prototype._attrsAffectingSize = ['points', 'bezier', 'tension'];
Global_1$f._registerNode(Line);
Factory_1$u.Factory.addGetterSetter(Line, 'closed', false);
Factory_1$u.Factory.addGetterSetter(Line, 'bezier', false);
Factory_1$u.Factory.addGetterSetter(Line, 'tension', 0, Validators_1$t.getNumberValidator());
Factory_1$u.Factory.addGetterSetter(Line, 'points', [], Validators_1$t.getNumberArrayValidator());
Util_1$i.Collection.mapMethods(Line);

var __extends$e = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Arrow$1, "__esModule", { value: true });
Arrow$1.Arrow = void 0;
var Util_1$h = Util;
var Factory_1$t = Factory;
var Line_1$1 = Line$1;
var Validators_1$s = Validators;
var Global_1$e = Global;
var Arrow = (function (_super) {
    __extends$e(Arrow, _super);
    function Arrow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Arrow.prototype._sceneFunc = function (ctx) {
        _super.prototype._sceneFunc.call(this, ctx);
        var PI2 = Math.PI * 2;
        var points = this.points();
        var tp = points;
        var fromTension = this.tension() !== 0 && points.length > 4;
        if (fromTension) {
            tp = this.getTensionPoints();
        }
        var n = points.length;
        var dx, dy;
        if (fromTension) {
            dx = points[n - 2] - (tp[tp.length - 2] + tp[tp.length - 4]) / 2;
            dy = points[n - 1] - (tp[tp.length - 1] + tp[tp.length - 3]) / 2;
        }
        else {
            dx = points[n - 2] - points[n - 4];
            dy = points[n - 1] - points[n - 3];
        }
        var radians = (Math.atan2(dy, dx) + PI2) % PI2;
        var length = this.pointerLength();
        var width = this.pointerWidth();
        ctx.save();
        ctx.beginPath();
        ctx.translate(points[n - 2], points[n - 1]);
        ctx.rotate(radians);
        ctx.moveTo(0, 0);
        ctx.lineTo(-length, width / 2);
        ctx.lineTo(-length, -width / 2);
        ctx.closePath();
        ctx.restore();
        if (this.pointerAtBeginning()) {
            ctx.save();
            ctx.translate(points[0], points[1]);
            if (fromTension) {
                dx = (tp[0] + tp[2]) / 2 - points[0];
                dy = (tp[1] + tp[3]) / 2 - points[1];
            }
            else {
                dx = points[2] - points[0];
                dy = points[3] - points[1];
            }
            ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
            ctx.moveTo(0, 0);
            ctx.lineTo(-length, width / 2);
            ctx.lineTo(-length, -width / 2);
            ctx.closePath();
            ctx.restore();
        }
        var isDashEnabled = this.dashEnabled();
        if (isDashEnabled) {
            this.attrs.dashEnabled = false;
            ctx.setLineDash([]);
        }
        ctx.fillStrokeShape(this);
        if (isDashEnabled) {
            this.attrs.dashEnabled = true;
        }
    };
    Arrow.prototype.getSelfRect = function () {
        var lineRect = _super.prototype.getSelfRect.call(this);
        var offset = this.pointerWidth() / 2;
        return {
            x: lineRect.x - offset,
            y: lineRect.y - offset,
            width: lineRect.width + offset * 2,
            height: lineRect.height + offset * 2
        };
    };
    return Arrow;
}(Line_1$1.Line));
Arrow$1.Arrow = Arrow;
Arrow.prototype.className = 'Arrow';
Global_1$e._registerNode(Arrow);
Factory_1$t.Factory.addGetterSetter(Arrow, 'pointerLength', 10, Validators_1$s.getNumberValidator());
Factory_1$t.Factory.addGetterSetter(Arrow, 'pointerWidth', 10, Validators_1$s.getNumberValidator());
Factory_1$t.Factory.addGetterSetter(Arrow, 'pointerAtBeginning', false);
Util_1$h.Collection.mapMethods(Arrow);

var Circle$1 = {};

var __extends$d = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Circle$1, "__esModule", { value: true });
Circle$1.Circle = void 0;
var Util_1$g = Util;
var Factory_1$s = Factory;
var Shape_1$d = Shape;
var Validators_1$r = Validators;
var Global_1$d = Global;
var Circle = (function (_super) {
    __extends$d(Circle, _super);
    function Circle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle.prototype._sceneFunc = function (context) {
        context.beginPath();
        context.arc(0, 0, this.attrs.radius || 0, 0, Math.PI * 2, false);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Circle.prototype.getWidth = function () {
        return this.radius() * 2;
    };
    Circle.prototype.getHeight = function () {
        return this.radius() * 2;
    };
    Circle.prototype.setWidth = function (width) {
        if (this.radius() !== width / 2) {
            this.radius(width / 2);
        }
    };
    Circle.prototype.setHeight = function (height) {
        if (this.radius() !== height / 2) {
            this.radius(height / 2);
        }
    };
    return Circle;
}(Shape_1$d.Shape));
Circle$1.Circle = Circle;
Circle.prototype._centroid = true;
Circle.prototype.className = 'Circle';
Circle.prototype._attrsAffectingSize = ['radius'];
Global_1$d._registerNode(Circle);
Factory_1$s.Factory.addGetterSetter(Circle, 'radius', 0, Validators_1$r.getNumberValidator());
Util_1$g.Collection.mapMethods(Circle);

var Ellipse$1 = {};

var __extends$c = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Ellipse$1, "__esModule", { value: true });
Ellipse$1.Ellipse = void 0;
var Util_1$f = Util;
var Factory_1$r = Factory;
var Shape_1$c = Shape;
var Validators_1$q = Validators;
var Global_1$c = Global;
var Ellipse = (function (_super) {
    __extends$c(Ellipse, _super);
    function Ellipse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse.prototype._sceneFunc = function (context) {
        var rx = this.radiusX(), ry = this.radiusY();
        context.beginPath();
        context.save();
        if (rx !== ry) {
            context.scale(1, ry / rx);
        }
        context.arc(0, 0, rx, 0, Math.PI * 2, false);
        context.restore();
        context.closePath();
        context.fillStrokeShape(this);
    };
    Ellipse.prototype.getWidth = function () {
        return this.radiusX() * 2;
    };
    Ellipse.prototype.getHeight = function () {
        return this.radiusY() * 2;
    };
    Ellipse.prototype.setWidth = function (width) {
        this.radiusX(width / 2);
    };
    Ellipse.prototype.setHeight = function (height) {
        this.radiusY(height / 2);
    };
    return Ellipse;
}(Shape_1$c.Shape));
Ellipse$1.Ellipse = Ellipse;
Ellipse.prototype.className = 'Ellipse';
Ellipse.prototype._centroid = true;
Ellipse.prototype._attrsAffectingSize = ['radiusX', 'radiusY'];
Global_1$c._registerNode(Ellipse);
Factory_1$r.Factory.addComponentsGetterSetter(Ellipse, 'radius', ['x', 'y']);
Factory_1$r.Factory.addGetterSetter(Ellipse, 'radiusX', 0, Validators_1$q.getNumberValidator());
Factory_1$r.Factory.addGetterSetter(Ellipse, 'radiusY', 0, Validators_1$q.getNumberValidator());
Util_1$f.Collection.mapMethods(Ellipse);

var Image$1 = {};

var __extends$b = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Image$1, "__esModule", { value: true });
Image$1.Image = void 0;
var Util_1$e = Util;
var Factory_1$q = Factory;
var Shape_1$b = Shape;
var Validators_1$p = Validators;
var Global_1$b = Global;
var Image = (function (_super) {
    __extends$b(Image, _super);
    function Image() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Image.prototype._useBufferCanvas = function () {
        return _super.prototype._useBufferCanvas.call(this, true);
    };
    Image.prototype._sceneFunc = function (context) {
        var width = this.getWidth();
        var height = this.getHeight();
        var image = this.attrs.image;
        var params;
        if (image) {
            var cropWidth = this.attrs.cropWidth;
            var cropHeight = this.attrs.cropHeight;
            if (cropWidth && cropHeight) {
                params = [
                    image,
                    this.cropX(),
                    this.cropY(),
                    cropWidth,
                    cropHeight,
                    0,
                    0,
                    width,
                    height,
                ];
            }
            else {
                params = [image, 0, 0, width, height];
            }
        }
        if (this.hasFill() || this.hasStroke()) {
            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        }
        if (image) {
            context.drawImage.apply(context, params);
        }
    };
    Image.prototype._hitFunc = function (context) {
        var width = this.width(), height = this.height();
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Image.prototype.getWidth = function () {
        var _a, _b;
        return (_a = this.attrs.width) !== null && _a !== void 0 ? _a : (((_b = this.image()) === null || _b === void 0 ? void 0 : _b.width) || 0);
    };
    Image.prototype.getHeight = function () {
        var _a, _b;
        return (_a = this.attrs.height) !== null && _a !== void 0 ? _a : (((_b = this.image()) === null || _b === void 0 ? void 0 : _b.height) || 0);
    };
    Image.fromURL = function (url, callback) {
        var img = Util_1$e.Util.createImageElement();
        img.onload = function () {
            var image = new Image({
                image: img,
            });
            callback(image);
        };
        img.crossOrigin = 'Anonymous';
        img.src = url;
    };
    return Image;
}(Shape_1$b.Shape));
Image$1.Image = Image;
Image.prototype.className = 'Image';
Global_1$b._registerNode(Image);
Factory_1$q.Factory.addGetterSetter(Image, 'image');
Factory_1$q.Factory.addComponentsGetterSetter(Image, 'crop', ['x', 'y', 'width', 'height']);
Factory_1$q.Factory.addGetterSetter(Image, 'cropX', 0, Validators_1$p.getNumberValidator());
Factory_1$q.Factory.addGetterSetter(Image, 'cropY', 0, Validators_1$p.getNumberValidator());
Factory_1$q.Factory.addGetterSetter(Image, 'cropWidth', 0, Validators_1$p.getNumberValidator());
Factory_1$q.Factory.addGetterSetter(Image, 'cropHeight', 0, Validators_1$p.getNumberValidator());
Util_1$e.Collection.mapMethods(Image);

var Label$1 = {};

var __extends$a = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Label$1, "__esModule", { value: true });
Label$1.Tag = Label$1.Label = void 0;
var Util_1$d = Util;
var Factory_1$p = Factory;
var Shape_1$a = Shape;
var Group_1$1 = Group$1;
var Validators_1$o = Validators;
var Global_1$a = Global;
var ATTR_CHANGE_LIST$2 = [
    'fontFamily',
    'fontSize',
    'fontStyle',
    'padding',
    'lineHeight',
    'text',
    'width',
    'height',
], CHANGE_KONVA$1 = 'Change.konva', NONE$1 = 'none', UP = 'up', RIGHT$1 = 'right', DOWN = 'down', LEFT$1 = 'left', attrChangeListLen$1 = ATTR_CHANGE_LIST$2.length;
var Label = (function (_super) {
    __extends$a(Label, _super);
    function Label(config) {
        var _this = _super.call(this, config) || this;
        _this.on('add.konva', function (evt) {
            this._addListeners(evt.child);
            this._sync();
        });
        return _this;
    }
    Label.prototype.getText = function () {
        return this.find('Text')[0];
    };
    Label.prototype.getTag = function () {
        return this.find('Tag')[0];
    };
    Label.prototype._addListeners = function (text) {
        var that = this, n;
        var func = function () {
            that._sync();
        };
        for (n = 0; n < attrChangeListLen$1; n++) {
            text.on(ATTR_CHANGE_LIST$2[n] + CHANGE_KONVA$1, func);
        }
    };
    Label.prototype.getWidth = function () {
        return this.getText().width();
    };
    Label.prototype.getHeight = function () {
        return this.getText().height();
    };
    Label.prototype._sync = function () {
        var text = this.getText(), tag = this.getTag(), width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
        if (text && tag) {
            width = text.width();
            height = text.height();
            pointerDirection = tag.pointerDirection();
            pointerWidth = tag.pointerWidth();
            pointerHeight = tag.pointerHeight();
            x = 0;
            y = 0;
            switch (pointerDirection) {
                case UP:
                    x = width / 2;
                    y = -1 * pointerHeight;
                    break;
                case RIGHT$1:
                    x = width + pointerWidth;
                    y = height / 2;
                    break;
                case DOWN:
                    x = width / 2;
                    y = height + pointerHeight;
                    break;
                case LEFT$1:
                    x = -1 * pointerWidth;
                    y = height / 2;
                    break;
            }
            tag.setAttrs({
                x: -1 * x,
                y: -1 * y,
                width: width,
                height: height,
            });
            text.setAttrs({
                x: -1 * x,
                y: -1 * y,
            });
        }
    };
    return Label;
}(Group_1$1.Group));
Label$1.Label = Label;
Label.prototype.className = 'Label';
Global_1$a._registerNode(Label);
Util_1$d.Collection.mapMethods(Label);
var Tag = (function (_super) {
    __extends$a(Tag, _super);
    function Tag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tag.prototype._sceneFunc = function (context) {
        var width = this.width(), height = this.height(), pointerDirection = this.pointerDirection(), pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), cornerRadius = this.cornerRadius();
        var topLeft = 0;
        var topRight = 0;
        var bottomLeft = 0;
        var bottomRight = 0;
        if (typeof cornerRadius === 'number') {
            topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
        }
        else {
            topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
            topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
            bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
            bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
        }
        context.beginPath();
        context.moveTo(topLeft, 0);
        if (pointerDirection === UP) {
            context.lineTo((width - pointerWidth) / 2, 0);
            context.lineTo(width / 2, -1 * pointerHeight);
            context.lineTo((width + pointerWidth) / 2, 0);
        }
        context.lineTo(width - topRight, 0);
        context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);
        if (pointerDirection === RIGHT$1) {
            context.lineTo(width, (height - pointerHeight) / 2);
            context.lineTo(width + pointerWidth, height / 2);
            context.lineTo(width, (height + pointerHeight) / 2);
        }
        context.lineTo(width, height - bottomRight);
        context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        if (pointerDirection === DOWN) {
            context.lineTo((width + pointerWidth) / 2, height);
            context.lineTo(width / 2, height + pointerHeight);
            context.lineTo((width - pointerWidth) / 2, height);
        }
        context.lineTo(bottomLeft, height);
        context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        if (pointerDirection === LEFT$1) {
            context.lineTo(0, (height + pointerHeight) / 2);
            context.lineTo(-1 * pointerWidth, height / 2);
            context.lineTo(0, (height - pointerHeight) / 2);
        }
        context.lineTo(0, topLeft);
        context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Tag.prototype.getSelfRect = function () {
        var x = 0, y = 0, pointerWidth = this.pointerWidth(), pointerHeight = this.pointerHeight(), direction = this.pointerDirection(), width = this.width(), height = this.height();
        if (direction === UP) {
            y -= pointerHeight;
            height += pointerHeight;
        }
        else if (direction === DOWN) {
            height += pointerHeight;
        }
        else if (direction === LEFT$1) {
            x -= pointerWidth * 1.5;
            width += pointerWidth;
        }
        else if (direction === RIGHT$1) {
            width += pointerWidth * 1.5;
        }
        return {
            x: x,
            y: y,
            width: width,
            height: height,
        };
    };
    return Tag;
}(Shape_1$a.Shape));
Label$1.Tag = Tag;
Tag.prototype.className = 'Tag';
Global_1$a._registerNode(Tag);
Factory_1$p.Factory.addGetterSetter(Tag, 'pointerDirection', NONE$1);
Factory_1$p.Factory.addGetterSetter(Tag, 'pointerWidth', 0, Validators_1$o.getNumberValidator());
Factory_1$p.Factory.addGetterSetter(Tag, 'pointerHeight', 0, Validators_1$o.getNumberValidator());
Factory_1$p.Factory.addGetterSetter(Tag, 'cornerRadius', 0, Validators_1$o.getNumberOrArrayOfNumbersValidator(4));
Util_1$d.Collection.mapMethods(Tag);

var Path$1 = {};

var __extends$9 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Path$1, "__esModule", { value: true });
Path$1.Path = void 0;
var Util_1$c = Util;
var Factory_1$o = Factory;
var Shape_1$9 = Shape;
var Global_1$9 = Global;
var Path = (function (_super) {
    __extends$9(Path, _super);
    function Path(config) {
        var _this = _super.call(this, config) || this;
        _this.dataArray = [];
        _this.pathLength = 0;
        _this.dataArray = Path.parsePathData(_this.data());
        _this.pathLength = 0;
        for (var i = 0; i < _this.dataArray.length; ++i) {
            _this.pathLength += _this.dataArray[i].pathLength;
        }
        _this.on('dataChange.konva', function () {
            this.dataArray = Path.parsePathData(this.data());
            this.pathLength = 0;
            for (var i = 0; i < this.dataArray.length; ++i) {
                this.pathLength += this.dataArray[i].pathLength;
            }
        });
        return _this;
    }
    Path.prototype._sceneFunc = function (context) {
        var ca = this.dataArray;
        context.beginPath();
        var isClosed = false;
        for (var n = 0; n < ca.length; n++) {
            var c = ca[n].command;
            var p = ca[n].points;
            switch (c) {
                case 'L':
                    context.lineTo(p[0], p[1]);
                    break;
                case 'M':
                    context.moveTo(p[0], p[1]);
                    break;
                case 'C':
                    context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                    break;
                case 'Q':
                    context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                    break;
                case 'A':
                    var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    context.translate(cx, cy);
                    context.rotate(psi);
                    context.scale(scaleX, scaleY);
                    context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                    context.scale(1 / scaleX, 1 / scaleY);
                    context.rotate(-psi);
                    context.translate(-cx, -cy);
                    break;
                case 'z':
                    isClosed = true;
                    context.closePath();
                    break;
            }
        }
        if (!isClosed && !this.hasFill()) {
            context.strokeShape(this);
        }
        else {
            context.fillStrokeShape(this);
        }
    };
    Path.prototype.getSelfRect = function () {
        var points = [];
        this.dataArray.forEach(function (data) {
            if (data.command === 'A') {
                var start = data.points[4];
                var dTheta = data.points[5];
                var end = data.points[4] + dTheta;
                var inc = Math.PI / 180.0;
                if (Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                if (dTheta < 0) {
                    for (var t = start - inc; t > end; t -= inc) {
                        var point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                        points.push(point.x, point.y);
                    }
                }
                else {
                    for (var t = start + inc; t < end; t += inc) {
                        var point = Path.getPointOnEllipticalArc(data.points[0], data.points[1], data.points[2], data.points[3], t, 0);
                        points.push(point.x, point.y);
                    }
                }
            }
            else if (data.command === 'C') {
                for (var t = 0.0; t <= 1; t += 0.01) {
                    var point = Path.getPointOnCubicBezier(t, data.start.x, data.start.y, data.points[0], data.points[1], data.points[2], data.points[3], data.points[4], data.points[5]);
                    points.push(point.x, point.y);
                }
            }
            else {
                points = points.concat(data.points);
            }
        });
        var minX = points[0];
        var maxX = points[0];
        var minY = points[1];
        var maxY = points[1];
        var x, y;
        for (var i = 0; i < points.length / 2; i++) {
            x = points[i * 2];
            y = points[i * 2 + 1];
            if (!isNaN(x)) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
            }
            if (!isNaN(y)) {
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }
        return {
            x: Math.round(minX),
            y: Math.round(minY),
            width: Math.round(maxX - minX),
            height: Math.round(maxY - minY),
        };
    };
    Path.prototype.getLength = function () {
        return this.pathLength;
    };
    Path.prototype.getPointAtLength = function (length) {
        var point, i = 0, ii = this.dataArray.length;
        if (!ii) {
            return null;
        }
        while (i < ii && length > this.dataArray[i].pathLength) {
            length -= this.dataArray[i].pathLength;
            ++i;
        }
        if (i === ii) {
            point = this.dataArray[i - 1].points.slice(-2);
            return {
                x: point[0],
                y: point[1],
            };
        }
        if (length < 0.01) {
            point = this.dataArray[i].points.slice(0, 2);
            return {
                x: point[0],
                y: point[1],
            };
        }
        var cp = this.dataArray[i];
        var p = cp.points;
        switch (cp.command) {
            case 'L':
                return Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);
            case 'C':
                return Path.getPointOnCubicBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3], p[4], p[5]);
            case 'Q':
                return Path.getPointOnQuadraticBezier(length / cp.pathLength, cp.start.x, cp.start.y, p[0], p[1], p[2], p[3]);
            case 'A':
                var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6];
                theta += (dTheta * length) / cp.pathLength;
                return Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
        }
        return null;
    };
    Path.getLineLength = function (x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    };
    Path.getPointOnLine = function (dist, P1x, P1y, P2x, P2y, fromX, fromY) {
        if (fromX === undefined) {
            fromX = P1x;
        }
        if (fromY === undefined) {
            fromY = P1y;
        }
        var m = (P2y - P1y) / (P2x - P1x + 0.00000001);
        var run = Math.sqrt((dist * dist) / (1 + m * m));
        if (P2x < P1x) {
            run *= -1;
        }
        var rise = m * run;
        var pt;
        if (P2x === P1x) {
            pt = {
                x: fromX,
                y: fromY + rise,
            };
        }
        else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {
            pt = {
                x: fromX + run,
                y: fromY + rise,
            };
        }
        else {
            var ix, iy;
            var len = this.getLineLength(P1x, P1y, P2x, P2y);
            var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
            u = u / (len * len);
            ix = P1x + u * (P2x - P1x);
            iy = P1y + u * (P2y - P1y);
            var pRise = this.getLineLength(fromX, fromY, ix, iy);
            var pRun = Math.sqrt(dist * dist - pRise * pRise);
            run = Math.sqrt((pRun * pRun) / (1 + m * m));
            if (P2x < P1x) {
                run *= -1;
            }
            rise = m * run;
            pt = {
                x: ix + run,
                y: iy + rise,
            };
        }
        return pt;
    };
    Path.getPointOnCubicBezier = function (pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
        function CB1(t) {
            return t * t * t;
        }
        function CB2(t) {
            return 3 * t * t * (1 - t);
        }
        function CB3(t) {
            return 3 * t * (1 - t) * (1 - t);
        }
        function CB4(t) {
            return (1 - t) * (1 - t) * (1 - t);
        }
        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
        return {
            x: x,
            y: y,
        };
    };
    Path.getPointOnQuadraticBezier = function (pct, P1x, P1y, P2x, P2y, P3x, P3y) {
        function QB1(t) {
            return t * t;
        }
        function QB2(t) {
            return 2 * t * (1 - t);
        }
        function QB3(t) {
            return (1 - t) * (1 - t);
        }
        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
        return {
            x: x,
            y: y,
        };
    };
    Path.getPointOnEllipticalArc = function (cx, cy, rx, ry, theta, psi) {
        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
        var pt = {
            x: rx * Math.cos(theta),
            y: ry * Math.sin(theta),
        };
        return {
            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
            y: cy + (pt.x * sinPsi + pt.y * cosPsi),
        };
    };
    Path.parsePathData = function (data) {
        if (!data) {
            return [];
        }
        var cs = data;
        var cc = [
            'm',
            'M',
            'l',
            'L',
            'v',
            'V',
            'h',
            'H',
            'z',
            'Z',
            'c',
            'C',
            'q',
            'Q',
            't',
            'T',
            's',
            'S',
            'a',
            'A',
        ];
        cs = cs.replace(new RegExp(' ', 'g'), ',');
        for (var n = 0; n < cc.length; n++) {
            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
        }
        var arr = cs.split('|');
        var ca = [];
        var coords = [];
        var cpx = 0;
        var cpy = 0;
        var re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
        var match;
        for (n = 1; n < arr.length; n++) {
            var str = arr[n];
            var c = str.charAt(0);
            str = str.slice(1);
            coords.length = 0;
            while ((match = re.exec(str))) {
                coords.push(match[0]);
            }
            var p = [];
            for (var j = 0, jlen = coords.length; j < jlen; j++) {
                var parsed = parseFloat(coords[j]);
                if (!isNaN(parsed)) {
                    p.push(parsed);
                }
                else {
                    p.push(0);
                }
            }
            while (p.length > 0) {
                if (isNaN(p[0])) {
                    break;
                }
                var cmd = null;
                var points = [];
                var startX = cpx, startY = cpy;
                var prevCmd, ctlPtx, ctlPty;
                var rx, ry, psi, fa, fs, x1, y1;
                switch (c) {
                    case 'l':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'L':
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'm':
                        var dx = p.shift();
                        var dy = p.shift();
                        cpx += dx;
                        cpy += dy;
                        cmd = 'M';
                        if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
                            for (var idx = ca.length - 2; idx >= 0; idx--) {
                                if (ca[idx].command === 'M') {
                                    cpx = ca[idx].points[0] + dx;
                                    cpy = ca[idx].points[1] + dy;
                                    break;
                                }
                            }
                        }
                        points.push(cpx, cpy);
                        c = 'l';
                        break;
                    case 'M':
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'L';
                        break;
                    case 'h':
                        cpx += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'H':
                        cpx = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'v':
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'V':
                        cpy = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'C':
                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'c':
                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'S':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 's':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'Q':
                        points.push(p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'q':
                        points.push(cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(cpx, cpy);
                        break;
                    case 'T':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 't':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 'A':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    case 'a':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx;
                        y1 = cpy;
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'A';
                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                }
                ca.push({
                    command: cmd || c,
                    points: points,
                    start: {
                        x: startX,
                        y: startY,
                    },
                    pathLength: this.calcLength(startX, startY, cmd || c, points),
                });
            }
            if (c === 'z' || c === 'Z') {
                ca.push({
                    command: 'z',
                    points: [],
                    start: undefined,
                    pathLength: 0,
                });
            }
        }
        return ca;
    };
    Path.calcLength = function (x, y, cmd, points) {
        var len, p1, p2, t;
        var path = Path;
        switch (cmd) {
            case 'L':
                return path.getLineLength(x, y, points[0], points[1]);
            case 'C':
                len = 0.0;
                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                for (t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'Q':
                len = 0.0;
                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
                for (t = 0.01; t <= 1; t += 0.01) {
                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                    p1 = p2;
                }
                return len;
            case 'A':
                len = 0.0;
                var start = points[4];
                var dTheta = points[5];
                var end = points[4] + dTheta;
                var inc = Math.PI / 180.0;
                if (Math.abs(start - end) < inc) {
                    inc = Math.abs(start - end);
                }
                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
                if (dTheta < 0) {
                    for (t = start - inc; t > end; t -= inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                else {
                    for (t = start + inc; t < end; t += inc) {
                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                        p1 = p2;
                    }
                }
                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
                return len;
        }
        return 0;
    };
    Path.convertEndpointToCenterParameterization = function (x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
        var psi = psiDeg * (Math.PI / 180.0);
        var xp = (Math.cos(psi) * (x1 - x2)) / 2.0 + (Math.sin(psi) * (y1 - y2)) / 2.0;
        var yp = (-1 * Math.sin(psi) * (x1 - x2)) / 2.0 +
            (Math.cos(psi) * (y1 - y2)) / 2.0;
        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
        if (lambda > 1) {
            rx *= Math.sqrt(lambda);
            ry *= Math.sqrt(lambda);
        }
        var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /
            (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
        if (fa === fs) {
            f *= -1;
        }
        if (isNaN(f)) {
            f = 0;
        }
        var cxp = (f * rx * yp) / ry;
        var cyp = (f * -ry * xp) / rx;
        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
        var vMag = function (v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function (u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function (u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var dTheta = vAngle(u, v);
        if (vRatio(u, v) <= -1) {
            dTheta = Math.PI;
        }
        if (vRatio(u, v) >= 1) {
            dTheta = 0;
        }
        if (fs === 0 && dTheta > 0) {
            dTheta = dTheta - 2 * Math.PI;
        }
        if (fs === 1 && dTheta < 0) {
            dTheta = dTheta + 2 * Math.PI;
        }
        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
    };
    return Path;
}(Shape_1$9.Shape));
Path$1.Path = Path;
Path.prototype.className = 'Path';
Path.prototype._attrsAffectingSize = ['data'];
Global_1$9._registerNode(Path);
Factory_1$o.Factory.addGetterSetter(Path, 'data');
Util_1$c.Collection.mapMethods(Path);

var Rect$1 = {};

var __extends$8 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Rect$1, "__esModule", { value: true });
Rect$1.Rect = void 0;
var Util_1$b = Util;
var Factory_1$n = Factory;
var Shape_1$8 = Shape;
var Global_1$8 = Global;
var Validators_1$n = Validators;
var Rect = (function (_super) {
    __extends$8(Rect, _super);
    function Rect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect.prototype._sceneFunc = function (context) {
        var cornerRadius = this.cornerRadius(), width = this.width(), height = this.height();
        context.beginPath();
        if (!cornerRadius) {
            context.rect(0, 0, width, height);
        }
        else {
            var topLeft = 0;
            var topRight = 0;
            var bottomLeft = 0;
            var bottomRight = 0;
            if (typeof cornerRadius === 'number') {
                topLeft = topRight = bottomLeft = bottomRight = Math.min(cornerRadius, width / 2, height / 2);
            }
            else {
                topLeft = Math.min(cornerRadius[0] || 0, width / 2, height / 2);
                topRight = Math.min(cornerRadius[1] || 0, width / 2, height / 2);
                bottomRight = Math.min(cornerRadius[2] || 0, width / 2, height / 2);
                bottomLeft = Math.min(cornerRadius[3] || 0, width / 2, height / 2);
            }
            context.moveTo(topLeft, 0);
            context.lineTo(width - topRight, 0);
            context.arc(width - topRight, topRight, topRight, (Math.PI * 3) / 2, 0, false);
            context.lineTo(width, height - bottomRight);
            context.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
            context.lineTo(bottomLeft, height);
            context.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
            context.lineTo(0, topLeft);
            context.arc(topLeft, topLeft, topLeft, Math.PI, (Math.PI * 3) / 2, false);
        }
        context.closePath();
        context.fillStrokeShape(this);
    };
    return Rect;
}(Shape_1$8.Shape));
Rect$1.Rect = Rect;
Rect.prototype.className = 'Rect';
Global_1$8._registerNode(Rect);
Factory_1$n.Factory.addGetterSetter(Rect, 'cornerRadius', 0, Validators_1$n.getNumberOrArrayOfNumbersValidator(4));
Util_1$b.Collection.mapMethods(Rect);

var RegularPolygon$1 = {};

var __extends$7 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(RegularPolygon$1, "__esModule", { value: true });
RegularPolygon$1.RegularPolygon = void 0;
var Util_1$a = Util;
var Factory_1$m = Factory;
var Shape_1$7 = Shape;
var Validators_1$m = Validators;
var Global_1$7 = Global;
var RegularPolygon = (function (_super) {
    __extends$7(RegularPolygon, _super);
    function RegularPolygon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RegularPolygon.prototype._sceneFunc = function (context) {
        var points = this._getPoints();
        context.beginPath();
        context.moveTo(points[0].x, points[0].y);
        for (var n = 1; n < points.length; n++) {
            context.lineTo(points[n].x, points[n].y);
        }
        context.closePath();
        context.fillStrokeShape(this);
    };
    RegularPolygon.prototype._getPoints = function () {
        var sides = this.attrs.sides;
        var radius = this.attrs.radius || 0;
        var points = [];
        for (var n = 0; n < sides; n++) {
            points.push({
                x: radius * Math.sin((n * 2 * Math.PI) / sides),
                y: -1 * radius * Math.cos((n * 2 * Math.PI) / sides),
            });
        }
        return points;
    };
    RegularPolygon.prototype.getSelfRect = function () {
        var points = this._getPoints();
        var minX = points[0].x;
        var maxX = points[0].y;
        var minY = points[0].x;
        var maxY = points[0].y;
        points.forEach(function (point) {
            minX = Math.min(minX, point.x);
            maxX = Math.max(maxX, point.x);
            minY = Math.min(minY, point.y);
            maxY = Math.max(maxY, point.y);
        });
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY,
        };
    };
    RegularPolygon.prototype.getWidth = function () {
        return this.radius() * 2;
    };
    RegularPolygon.prototype.getHeight = function () {
        return this.radius() * 2;
    };
    RegularPolygon.prototype.setWidth = function (width) {
        this.radius(width / 2);
    };
    RegularPolygon.prototype.setHeight = function (height) {
        this.radius(height / 2);
    };
    return RegularPolygon;
}(Shape_1$7.Shape));
RegularPolygon$1.RegularPolygon = RegularPolygon;
RegularPolygon.prototype.className = 'RegularPolygon';
RegularPolygon.prototype._centroid = true;
RegularPolygon.prototype._attrsAffectingSize = ['radius'];
Global_1$7._registerNode(RegularPolygon);
Factory_1$m.Factory.addGetterSetter(RegularPolygon, 'radius', 0, Validators_1$m.getNumberValidator());
Factory_1$m.Factory.addGetterSetter(RegularPolygon, 'sides', 0, Validators_1$m.getNumberValidator());
Util_1$a.Collection.mapMethods(RegularPolygon);

var Ring$1 = {};

var __extends$6 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Ring$1, "__esModule", { value: true });
Ring$1.Ring = void 0;
var Util_1$9 = Util;
var Factory_1$l = Factory;
var Shape_1$6 = Shape;
var Validators_1$l = Validators;
var Global_1$6 = Global;
var PIx2 = Math.PI * 2;
var Ring = (function (_super) {
    __extends$6(Ring, _super);
    function Ring() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Ring.prototype._sceneFunc = function (context) {
        context.beginPath();
        context.arc(0, 0, this.innerRadius(), 0, PIx2, false);
        context.moveTo(this.outerRadius(), 0);
        context.arc(0, 0, this.outerRadius(), PIx2, 0, true);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Ring.prototype.getWidth = function () {
        return this.outerRadius() * 2;
    };
    Ring.prototype.getHeight = function () {
        return this.outerRadius() * 2;
    };
    Ring.prototype.setWidth = function (width) {
        this.outerRadius(width / 2);
    };
    Ring.prototype.setHeight = function (height) {
        this.outerRadius(height / 2);
    };
    return Ring;
}(Shape_1$6.Shape));
Ring$1.Ring = Ring;
Ring.prototype.className = 'Ring';
Ring.prototype._centroid = true;
Ring.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
Global_1$6._registerNode(Ring);
Factory_1$l.Factory.addGetterSetter(Ring, 'innerRadius', 0, Validators_1$l.getNumberValidator());
Factory_1$l.Factory.addGetterSetter(Ring, 'outerRadius', 0, Validators_1$l.getNumberValidator());
Util_1$9.Collection.mapMethods(Ring);

var Sprite$1 = {};

var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Sprite$1, "__esModule", { value: true });
Sprite$1.Sprite = void 0;
var Util_1$8 = Util;
var Factory_1$k = Factory;
var Shape_1$5 = Shape;
var Animation_1 = Animation$1;
var Validators_1$k = Validators;
var Global_1$5 = Global;
var Sprite = (function (_super) {
    __extends$5(Sprite, _super);
    function Sprite(config) {
        var _this = _super.call(this, config) || this;
        _this._updated = true;
        _this.anim = new Animation_1.Animation(function () {
            var updated = _this._updated;
            _this._updated = false;
            return updated;
        });
        _this.on('animationChange.konva', function () {
            this.frameIndex(0);
        });
        _this.on('frameIndexChange.konva', function () {
            this._updated = true;
        });
        _this.on('frameRateChange.konva', function () {
            if (!this.anim.isRunning()) {
                return;
            }
            clearInterval(this.interval);
            this._setInterval();
        });
        return _this;
    }
    Sprite.prototype._sceneFunc = function (context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), x = set[ix4 + 0], y = set[ix4 + 1], width = set[ix4 + 2], height = set[ix4 + 3], image = this.image();
        if (this.hasFill() || this.hasStroke()) {
            context.beginPath();
            context.rect(0, 0, width, height);
            context.closePath();
            context.fillStrokeShape(this);
        }
        if (image) {
            if (offsets) {
                var offset = offsets[anim], ix2 = index * 2;
                context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
            }
            else {
                context.drawImage(image, x, y, width, height, 0, 0, width, height);
            }
        }
    };
    Sprite.prototype._hitFunc = function (context) {
        var anim = this.animation(), index = this.frameIndex(), ix4 = index * 4, set = this.animations()[anim], offsets = this.frameOffsets(), width = set[ix4 + 2], height = set[ix4 + 3];
        context.beginPath();
        if (offsets) {
            var offset = offsets[anim];
            var ix2 = index * 2;
            context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
        }
        else {
            context.rect(0, 0, width, height);
        }
        context.closePath();
        context.fillShape(this);
    };
    Sprite.prototype._useBufferCanvas = function () {
        return _super.prototype._useBufferCanvas.call(this, true);
    };
    Sprite.prototype._setInterval = function () {
        var that = this;
        this.interval = setInterval(function () {
            that._updateIndex();
        }, 1000 / this.frameRate());
    };
    Sprite.prototype.start = function () {
        if (this.isRunning()) {
            return;
        }
        var layer = this.getLayer();
        this.anim.setLayers(layer);
        this._setInterval();
        this.anim.start();
    };
    Sprite.prototype.stop = function () {
        this.anim.stop();
        clearInterval(this.interval);
    };
    Sprite.prototype.isRunning = function () {
        return this.anim.isRunning();
    };
    Sprite.prototype._updateIndex = function () {
        var index = this.frameIndex(), animation = this.animation(), animations = this.animations(), anim = animations[animation], len = anim.length / 4;
        if (index < len - 1) {
            this.frameIndex(index + 1);
        }
        else {
            this.frameIndex(0);
        }
    };
    return Sprite;
}(Shape_1$5.Shape));
Sprite$1.Sprite = Sprite;
Sprite.prototype.className = 'Sprite';
Global_1$5._registerNode(Sprite);
Factory_1$k.Factory.addGetterSetter(Sprite, 'animation');
Factory_1$k.Factory.addGetterSetter(Sprite, 'animations');
Factory_1$k.Factory.addGetterSetter(Sprite, 'frameOffsets');
Factory_1$k.Factory.addGetterSetter(Sprite, 'image');
Factory_1$k.Factory.addGetterSetter(Sprite, 'frameIndex', 0, Validators_1$k.getNumberValidator());
Factory_1$k.Factory.addGetterSetter(Sprite, 'frameRate', 17, Validators_1$k.getNumberValidator());
Factory_1$k.Factory.backCompat(Sprite, {
    index: 'frameIndex',
    getIndex: 'getFrameIndex',
    setIndex: 'setFrameIndex',
});
Util_1$8.Collection.mapMethods(Sprite);

var Star$1 = {};

var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Star$1, "__esModule", { value: true });
Star$1.Star = void 0;
var Util_1$7 = Util;
var Factory_1$j = Factory;
var Shape_1$4 = Shape;
var Validators_1$j = Validators;
var Global_1$4 = Global;
var Star = (function (_super) {
    __extends$4(Star, _super);
    function Star() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Star.prototype._sceneFunc = function (context) {
        var innerRadius = this.innerRadius(), outerRadius = this.outerRadius(), numPoints = this.numPoints();
        context.beginPath();
        context.moveTo(0, 0 - outerRadius);
        for (var n = 1; n < numPoints * 2; n++) {
            var radius = n % 2 === 0 ? outerRadius : innerRadius;
            var x = radius * Math.sin((n * Math.PI) / numPoints);
            var y = -1 * radius * Math.cos((n * Math.PI) / numPoints);
            context.lineTo(x, y);
        }
        context.closePath();
        context.fillStrokeShape(this);
    };
    Star.prototype.getWidth = function () {
        return this.outerRadius() * 2;
    };
    Star.prototype.getHeight = function () {
        return this.outerRadius() * 2;
    };
    Star.prototype.setWidth = function (width) {
        this.outerRadius(width / 2);
    };
    Star.prototype.setHeight = function (height) {
        this.outerRadius(height / 2);
    };
    return Star;
}(Shape_1$4.Shape));
Star$1.Star = Star;
Star.prototype.className = 'Star';
Star.prototype._centroid = true;
Star.prototype._attrsAffectingSize = ['innerRadius', 'outerRadius'];
Global_1$4._registerNode(Star);
Factory_1$j.Factory.addGetterSetter(Star, 'numPoints', 5, Validators_1$j.getNumberValidator());
Factory_1$j.Factory.addGetterSetter(Star, 'innerRadius', 0, Validators_1$j.getNumberValidator());
Factory_1$j.Factory.addGetterSetter(Star, 'outerRadius', 0, Validators_1$j.getNumberValidator());
Util_1$7.Collection.mapMethods(Star);

var Text$1 = {};

var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Text$1, "__esModule", { value: true });
Text$1.Text = Text$1.stringToArray = void 0;
var Util_1$6 = Util;
var Factory_1$i = Factory;
var Shape_1$3 = Shape;
var Global_1$3 = Global;
var Validators_1$i = Validators;
var Global_2$2 = Global;
function stringToArray(string) {
    return Array.from(string);
}
Text$1.stringToArray = stringToArray;
var AUTO = 'auto', CENTER = 'center', JUSTIFY = 'justify', CHANGE_KONVA = 'Change.konva', CONTEXT_2D = '2d', DASH = '-', LEFT = 'left', TEXT = 'text', TEXT_UPPER = 'Text', TOP = 'top', BOTTOM = 'bottom', MIDDLE = 'middle', NORMAL$1 = 'normal', PX_SPACE = 'px ', SPACE = ' ', RIGHT = 'right', WORD = 'word', CHAR = 'char', NONE = 'none', ELLIPSIS = '…', ATTR_CHANGE_LIST$1 = [
    'fontFamily',
    'fontSize',
    'fontStyle',
    'fontVariant',
    'padding',
    'align',
    'verticalAlign',
    'lineHeight',
    'text',
    'width',
    'height',
    'wrap',
    'ellipsis',
    'letterSpacing',
], attrChangeListLen = ATTR_CHANGE_LIST$1.length;
function normalizeFontFamily(fontFamily) {
    return fontFamily
        .split(',')
        .map(function (family) {
        family = family.trim();
        var hasSpace = family.indexOf(' ') >= 0;
        var hasQuotes = family.indexOf('"') >= 0 || family.indexOf("'") >= 0;
        if (hasSpace && !hasQuotes) {
            family = "\"" + family + "\"";
        }
        return family;
    })
        .join(', ');
}
var dummyContext;
function getDummyContext() {
    if (dummyContext) {
        return dummyContext;
    }
    dummyContext = Util_1$6.Util.createCanvasElement().getContext(CONTEXT_2D);
    return dummyContext;
}
function _fillFunc$1(context) {
    context.fillText(this._partialText, this._partialTextX, this._partialTextY);
}
function _strokeFunc$1(context) {
    context.strokeText(this._partialText, this._partialTextX, this._partialTextY);
}
function checkDefaultFill(config) {
    config = config || {};
    if (!config.fillLinearGradientColorStops &&
        !config.fillRadialGradientColorStops &&
        !config.fillPatternImage) {
        config.fill = config.fill || 'black';
    }
    return config;
}
var Text = (function (_super) {
    __extends$3(Text, _super);
    function Text(config) {
        var _this = _super.call(this, checkDefaultFill(config)) || this;
        _this._partialTextX = 0;
        _this._partialTextY = 0;
        for (var n = 0; n < attrChangeListLen; n++) {
            _this.on(ATTR_CHANGE_LIST$1[n] + CHANGE_KONVA, _this._setTextData);
        }
        _this._setTextData();
        return _this;
    }
    Text.prototype._sceneFunc = function (context) {
        var textArr = this.textArr, textArrLen = textArr.length;
        if (!this.text()) {
            return;
        }
        var padding = this.padding(), fontSize = this.fontSize(), lineHeightPx = this.lineHeight() * fontSize, verticalAlign = this.verticalAlign(), alignY = 0, align = this.align(), totalWidth = this.getWidth(), letterSpacing = this.letterSpacing(), fill = this.fill(), textDecoration = this.textDecoration(), shouldUnderline = textDecoration.indexOf('underline') !== -1, shouldLineThrough = textDecoration.indexOf('line-through') !== -1, n;
        var translateY = 0;
        var translateY = lineHeightPx / 2;
        var lineTranslateX = 0;
        var lineTranslateY = 0;
        context.setAttr('font', this._getContextFont());
        context.setAttr('textBaseline', MIDDLE);
        context.setAttr('textAlign', LEFT);
        if (verticalAlign === MIDDLE) {
            alignY = (this.getHeight() - textArrLen * lineHeightPx - padding * 2) / 2;
        }
        else if (verticalAlign === BOTTOM) {
            alignY = this.getHeight() - textArrLen * lineHeightPx - padding * 2;
        }
        context.translate(padding, alignY + padding);
        for (n = 0; n < textArrLen; n++) {
            var lineTranslateX = 0;
            var lineTranslateY = 0;
            var obj = textArr[n], text = obj.text, width = obj.width, lastLine = n !== textArrLen - 1, spacesNumber, oneWord, lineWidth;
            context.save();
            if (align === RIGHT) {
                lineTranslateX += totalWidth - width - padding * 2;
            }
            else if (align === CENTER) {
                lineTranslateX += (totalWidth - width - padding * 2) / 2;
            }
            if (shouldUnderline) {
                context.save();
                context.beginPath();
                context.moveTo(lineTranslateX, translateY + lineTranslateY + Math.round(fontSize / 2));
                spacesNumber = text.split(' ').length - 1;
                oneWord = spacesNumber === 0;
                lineWidth =
                    align === JUSTIFY && lastLine && !oneWord
                        ? totalWidth - padding * 2
                        : width;
                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY + Math.round(fontSize / 2));
                context.lineWidth = fontSize / 15;
                context.strokeStyle = fill;
                context.stroke();
                context.restore();
            }
            if (shouldLineThrough) {
                context.save();
                context.beginPath();
                context.moveTo(lineTranslateX, translateY + lineTranslateY);
                spacesNumber = text.split(' ').length - 1;
                oneWord = spacesNumber === 0;
                lineWidth =
                    align === JUSTIFY && lastLine && !oneWord
                        ? totalWidth - padding * 2
                        : width;
                context.lineTo(lineTranslateX + Math.round(lineWidth), translateY + lineTranslateY);
                context.lineWidth = fontSize / 15;
                context.strokeStyle = fill;
                context.stroke();
                context.restore();
            }
            if (letterSpacing !== 0 || align === JUSTIFY) {
                spacesNumber = text.split(' ').length - 1;
                var array = stringToArray(text);
                for (var li = 0; li < array.length; li++) {
                    var letter = array[li];
                    if (letter === ' ' && n !== textArrLen - 1 && align === JUSTIFY) {
                        lineTranslateX += (totalWidth - padding * 2 - width) / spacesNumber;
                    }
                    this._partialTextX = lineTranslateX;
                    this._partialTextY = translateY + lineTranslateY;
                    this._partialText = letter;
                    context.fillStrokeShape(this);
                    lineTranslateX += this.measureSize(letter).width + letterSpacing;
                }
            }
            else {
                this._partialTextX = lineTranslateX;
                this._partialTextY = translateY + lineTranslateY;
                this._partialText = text;
                context.fillStrokeShape(this);
            }
            context.restore();
            if (textArrLen > 1) {
                translateY += lineHeightPx;
            }
        }
    };
    Text.prototype._hitFunc = function (context) {
        var width = this.getWidth(), height = this.getHeight();
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Text.prototype.setText = function (text) {
        var str = Util_1$6.Util._isString(text)
            ? text
            : text === null || text === undefined
                ? ''
                : text + '';
        this._setAttr(TEXT, str);
        return this;
    };
    Text.prototype.getWidth = function () {
        var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
        return isAuto ? this.getTextWidth() + this.padding() * 2 : this.attrs.width;
    };
    Text.prototype.getHeight = function () {
        var isAuto = this.attrs.height === AUTO || this.attrs.height === undefined;
        return isAuto
            ? this.fontSize() * this.textArr.length * this.lineHeight() +
                this.padding() * 2
            : this.attrs.height;
    };
    Text.prototype.getTextWidth = function () {
        return this.textWidth;
    };
    Text.prototype.getTextHeight = function () {
        Util_1$6.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');
        return this.textHeight;
    };
    Text.prototype.measureSize = function (text) {
        var _context = getDummyContext(), fontSize = this.fontSize(), metrics;
        _context.save();
        _context.font = this._getContextFont();
        metrics = _context.measureText(text);
        _context.restore();
        return {
            width: metrics.width,
            height: fontSize,
        };
    };
    Text.prototype._getContextFont = function () {
        if (Global_1$3.Konva.UA.isIE) {
            return (this.fontStyle() +
                SPACE +
                this.fontSize() +
                PX_SPACE +
                this.fontFamily());
        }
        return (this.fontStyle() +
            SPACE +
            this.fontVariant() +
            SPACE +
            (this.fontSize() + PX_SPACE) +
            normalizeFontFamily(this.fontFamily()));
    };
    Text.prototype._addTextLine = function (line) {
        if (this.align() === JUSTIFY) {
            line = line.trim();
        }
        var width = this._getTextWidth(line);
        return this.textArr.push({ text: line, width: width });
    };
    Text.prototype._getTextWidth = function (text) {
        var letterSpacing = this.letterSpacing();
        var length = text.length;
        return (getDummyContext().measureText(text).width +
            (length ? letterSpacing * (length - 1) : 0));
    };
    Text.prototype._setTextData = function () {
        var lines = this.text().split('\n'), fontSize = +this.fontSize(), textWidth = 0, lineHeightPx = this.lineHeight() * fontSize, width = this.attrs.width, height = this.attrs.height, fixedWidth = width !== AUTO && width !== undefined, fixedHeight = height !== AUTO && height !== undefined, padding = this.padding(), maxWidth = width - padding * 2, maxHeightPx = height - padding * 2, currentHeightPx = 0, wrap = this.wrap(), shouldWrap = wrap !== NONE, wrapAtWord = wrap !== CHAR && shouldWrap, shouldAddEllipsis = this.ellipsis();
        this.textArr = [];
        getDummyContext().font = this._getContextFont();
        var additionalWidth = shouldAddEllipsis ? this._getTextWidth(ELLIPSIS) : 0;
        for (var i = 0, max = lines.length; i < max; ++i) {
            var line = lines[i];
            var lineWidth = this._getTextWidth(line);
            if (fixedWidth && lineWidth > maxWidth) {
                while (line.length > 0) {
                    var low = 0, high = line.length, match = '', matchWidth = 0;
                    while (low < high) {
                        var mid = (low + high) >>> 1, substr = line.slice(0, mid + 1), substrWidth = this._getTextWidth(substr) + additionalWidth;
                        if (substrWidth <= maxWidth) {
                            low = mid + 1;
                            match = substr;
                            matchWidth = substrWidth;
                        }
                        else {
                            high = mid;
                        }
                    }
                    if (match) {
                        if (wrapAtWord) {
                            var wrapIndex;
                            var nextChar = line[match.length];
                            var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
                            if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                                wrapIndex = match.length;
                            }
                            else {
                                wrapIndex =
                                    Math.max(match.lastIndexOf(SPACE), match.lastIndexOf(DASH)) +
                                        1;
                            }
                            if (wrapIndex > 0) {
                                low = wrapIndex;
                                match = match.slice(0, low);
                                matchWidth = this._getTextWidth(match);
                            }
                        }
                        match = match.trimRight();
                        this._addTextLine(match);
                        textWidth = Math.max(textWidth, matchWidth);
                        currentHeightPx += lineHeightPx;
                        if (!shouldWrap ||
                            (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
                            var lastLine = this.textArr[this.textArr.length - 1];
                            if (lastLine) {
                                if (shouldAddEllipsis) {
                                    var haveSpace = this._getTextWidth(lastLine.text + ELLIPSIS) < maxWidth;
                                    if (!haveSpace) {
                                        lastLine.text = lastLine.text.slice(0, lastLine.text.length - 3);
                                    }
                                    this.textArr.splice(this.textArr.length - 1, 1);
                                    this._addTextLine(lastLine.text + ELLIPSIS);
                                }
                            }
                            break;
                        }
                        line = line.slice(low);
                        line = line.trimLeft();
                        if (line.length > 0) {
                            lineWidth = this._getTextWidth(line);
                            if (lineWidth <= maxWidth) {
                                this._addTextLine(line);
                                currentHeightPx += lineHeightPx;
                                textWidth = Math.max(textWidth, lineWidth);
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                this._addTextLine(line);
                currentHeightPx += lineHeightPx;
                textWidth = Math.max(textWidth, lineWidth);
            }
            if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
                break;
            }
        }
        this.textHeight = fontSize;
        this.textWidth = textWidth;
    };
    Text.prototype.getStrokeScaleEnabled = function () {
        return true;
    };
    return Text;
}(Shape_1$3.Shape));
Text$1.Text = Text;
Text.prototype._fillFunc = _fillFunc$1;
Text.prototype._strokeFunc = _strokeFunc$1;
Text.prototype.className = TEXT_UPPER;
Text.prototype._attrsAffectingSize = [
    'text',
    'fontSize',
    'padding',
    'wrap',
    'lineHeight',
    'letterSpacing',
];
Global_2$2._registerNode(Text);
Factory_1$i.Factory.overWriteSetter(Text, 'width', Validators_1$i.getNumberOrAutoValidator());
Factory_1$i.Factory.overWriteSetter(Text, 'height', Validators_1$i.getNumberOrAutoValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'fontFamily', 'Arial');
Factory_1$i.Factory.addGetterSetter(Text, 'fontSize', 12, Validators_1$i.getNumberValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'fontStyle', NORMAL$1);
Factory_1$i.Factory.addGetterSetter(Text, 'fontVariant', NORMAL$1);
Factory_1$i.Factory.addGetterSetter(Text, 'padding', 0, Validators_1$i.getNumberValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'align', LEFT);
Factory_1$i.Factory.addGetterSetter(Text, 'verticalAlign', TOP);
Factory_1$i.Factory.addGetterSetter(Text, 'lineHeight', 1, Validators_1$i.getNumberValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'wrap', WORD);
Factory_1$i.Factory.addGetterSetter(Text, 'ellipsis', false, Validators_1$i.getBooleanValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'letterSpacing', 0, Validators_1$i.getNumberValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'text', '', Validators_1$i.getStringValidator());
Factory_1$i.Factory.addGetterSetter(Text, 'textDecoration', '');
Util_1$6.Collection.mapMethods(Text);

var TextPath$1 = {};

var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(TextPath$1, "__esModule", { value: true });
TextPath$1.TextPath = void 0;
var Util_1$5 = Util;
var Factory_1$h = Factory;
var Shape_1$2 = Shape;
var Path_1$1 = Path$1;
var Text_1$1 = Text$1;
var Validators_1$h = Validators;
var Global_1$2 = Global;
var EMPTY_STRING = '', NORMAL = 'normal';
function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
}
function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
}
var TextPath = (function (_super) {
    __extends$2(TextPath, _super);
    function TextPath(config) {
        var _this = _super.call(this, config) || this;
        _this.dummyCanvas = Util_1$5.Util.createCanvasElement();
        _this.dataArray = [];
        _this.dataArray = Path_1$1.Path.parsePathData(_this.attrs.data);
        _this.on('dataChange.konva', function () {
            this.dataArray = Path_1$1.Path.parsePathData(this.attrs.data);
            this._setTextData();
        });
        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);
        if (config && config['getKerning']) {
            Util_1$5.Util.warn('getKerning TextPath API is deprecated. Please use "kerningFunc" instead.');
            _this.kerningFunc(config['getKerning']);
        }
        _this._setTextData();
        return _this;
    }
    TextPath.prototype._sceneFunc = function (context) {
        context.setAttr('font', this._getContextFont());
        context.setAttr('textBaseline', this.textBaseline());
        context.setAttr('textAlign', 'left');
        context.save();
        var textDecoration = this.textDecoration();
        var fill = this.fill();
        var fontSize = this.fontSize();
        var glyphInfo = this.glyphInfo;
        if (textDecoration === 'underline') {
            context.beginPath();
        }
        for (var i = 0; i < glyphInfo.length; i++) {
            context.save();
            var p0 = glyphInfo[i].p0;
            context.translate(p0.x, p0.y);
            context.rotate(glyphInfo[i].rotation);
            this.partialText = glyphInfo[i].text;
            context.fillStrokeShape(this);
            if (textDecoration === 'underline') {
                if (i === 0) {
                    context.moveTo(0, fontSize / 2 + 1);
                }
                context.lineTo(fontSize, fontSize / 2 + 1);
            }
            context.restore();
        }
        if (textDecoration === 'underline') {
            context.strokeStyle = fill;
            context.lineWidth = fontSize / 20;
            context.stroke();
        }
        context.restore();
    };
    TextPath.prototype._hitFunc = function (context) {
        context.beginPath();
        var glyphInfo = this.glyphInfo;
        if (glyphInfo.length >= 1) {
            var p0 = glyphInfo[0].p0;
            context.moveTo(p0.x, p0.y);
        }
        for (var i = 0; i < glyphInfo.length; i++) {
            var p1 = glyphInfo[i].p1;
            context.lineTo(p1.x, p1.y);
        }
        context.setAttr('lineWidth', this.fontSize());
        context.setAttr('strokeStyle', this.colorKey);
        context.stroke();
    };
    TextPath.prototype.getTextWidth = function () {
        return this.textWidth;
    };
    TextPath.prototype.getTextHeight = function () {
        Util_1$5.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');
        return this.textHeight;
    };
    TextPath.prototype.setText = function (text) {
        return Text_1$1.Text.prototype.setText.call(this, text);
    };
    TextPath.prototype._getContextFont = function () {
        return Text_1$1.Text.prototype._getContextFont.call(this);
    };
    TextPath.prototype._getTextSize = function (text) {
        var dummyCanvas = this.dummyCanvas;
        var _context = dummyCanvas.getContext('2d');
        _context.save();
        _context.font = this._getContextFont();
        var metrics = _context.measureText(text);
        _context.restore();
        return {
            width: metrics.width,
            height: parseInt(this.attrs.fontSize, 10),
        };
    };
    TextPath.prototype._setTextData = function () {
        var that = this;
        var size = this._getTextSize(this.attrs.text);
        var letterSpacing = this.letterSpacing();
        var align = this.align();
        var kerningFunc = this.kerningFunc();
        this.textWidth = size.width;
        this.textHeight = size.height;
        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);
        this.glyphInfo = [];
        var fullPathWidth = 0;
        for (var l = 0; l < that.dataArray.length; l++) {
            if (that.dataArray[l].pathLength > 0) {
                fullPathWidth += that.dataArray[l].pathLength;
            }
        }
        var offset = 0;
        if (align === 'center') {
            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);
        }
        if (align === 'right') {
            offset = Math.max(0, fullPathWidth - textFullWidth);
        }
        var charArr = Text_1$1.stringToArray(this.text());
        var spacesNumber = this.text().split(' ').length - 1;
        var p0, p1, pathCmd;
        var pIndex = -1;
        var currentT = 0;
        var getNextPathSegment = function () {
            currentT = 0;
            var pathData = that.dataArray;
            for (var j = pIndex + 1; j < pathData.length; j++) {
                if (pathData[j].pathLength > 0) {
                    pIndex = j;
                    return pathData[j];
                }
                else if (pathData[j].command === 'M') {
                    p0 = {
                        x: pathData[j].points[0],
                        y: pathData[j].points[1],
                    };
                }
            }
            return {};
        };
        var findSegmentToFitCharacter = function (c) {
            var glyphWidth = that._getTextSize(c).width + letterSpacing;
            if (c === ' ' && align === 'justify') {
                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
            }
            var currLen = 0;
            var attempts = 0;
            p1 = undefined;
            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&
                attempts < 20) {
                attempts++;
                var cumulativePathLength = currLen;
                while (pathCmd === undefined) {
                    pathCmd = getNextPathSegment();
                    if (pathCmd &&
                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {
                        cumulativePathLength += pathCmd.pathLength;
                        pathCmd = undefined;
                    }
                }
                if (pathCmd === {} || p0 === undefined) {
                    return undefined;
                }
                var needNewSegment = false;
                switch (pathCmd.command) {
                    case 'L':
                        if (Path_1$1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
                            p1 = Path_1$1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
                        }
                        else {
                            pathCmd = undefined;
                        }
                        break;
                    case 'A':
                        var start = pathCmd.points[4];
                        var dTheta = pathCmd.points[5];
                        var end = pathCmd.points[4] + dTheta;
                        if (currentT === 0) {
                            currentT = start + 0.00000001;
                        }
                        else if (glyphWidth > currLen) {
                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);
                        }
                        else {
                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);
                        }
                        if ((dTheta < 0 && currentT < end) ||
                            (dTheta >= 0 && currentT > end)) {
                            currentT = end;
                            needNewSegment = true;
                        }
                        p1 = Path_1$1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
                        break;
                    case 'C':
                        if (currentT === 0) {
                            if (glyphWidth > pathCmd.pathLength) {
                                currentT = 0.00000001;
                            }
                            else {
                                currentT = glyphWidth / pathCmd.pathLength;
                            }
                        }
                        else if (glyphWidth > currLen) {
                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;
                        }
                        else {
                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);
                        }
                        if (currentT > 1.0) {
                            currentT = 1.0;
                            needNewSegment = true;
                        }
                        p1 = Path_1$1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
                        break;
                    case 'Q':
                        if (currentT === 0) {
                            currentT = glyphWidth / pathCmd.pathLength;
                        }
                        else if (glyphWidth > currLen) {
                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;
                        }
                        else {
                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
                        }
                        if (currentT > 1.0) {
                            currentT = 1.0;
                            needNewSegment = true;
                        }
                        p1 = Path_1$1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
                        break;
                }
                if (p1 !== undefined) {
                    currLen = Path_1$1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
                }
                if (needNewSegment) {
                    needNewSegment = false;
                    pathCmd = undefined;
                }
            }
        };
        var testChar = 'C';
        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;
        var lettersInOffset = offset / glyphWidth - 1;
        for (var k = 0; k < lettersInOffset; k++) {
            findSegmentToFitCharacter(testChar);
            if (p0 === undefined || p1 === undefined) {
                break;
            }
            p0 = p1;
        }
        for (var i = 0; i < charArr.length; i++) {
            findSegmentToFitCharacter(charArr[i]);
            if (p0 === undefined || p1 === undefined) {
                break;
            }
            var width = Path_1$1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
            var kern = 0;
            if (kerningFunc) {
                try {
                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();
                }
                catch (e) {
                    kern = 0;
                }
            }
            p0.x += kern;
            p1.x += kern;
            this.textWidth += kern;
            var midpoint = Path_1$1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);
            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
            this.glyphInfo.push({
                transposeX: midpoint.x,
                transposeY: midpoint.y,
                text: charArr[i],
                rotation: rotation,
                p0: p0,
                p1: p1,
            });
            p0 = p1;
        }
    };
    TextPath.prototype.getSelfRect = function () {
        if (!this.glyphInfo.length) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            };
        }
        var points = [];
        this.glyphInfo.forEach(function (info) {
            points.push(info.p0.x);
            points.push(info.p0.y);
            points.push(info.p1.x);
            points.push(info.p1.y);
        });
        var minX = points[0] || 0;
        var maxX = points[0] || 0;
        var minY = points[1] || 0;
        var maxY = points[1] || 0;
        var x, y;
        for (var i = 0; i < points.length / 2; i++) {
            x = points[i * 2];
            y = points[i * 2 + 1];
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }
        var fontSize = this.fontSize();
        return {
            x: minX - fontSize / 2,
            y: minY - fontSize / 2,
            width: maxX - minX + fontSize,
            height: maxY - minY + fontSize,
        };
    };
    return TextPath;
}(Shape_1$2.Shape));
TextPath$1.TextPath = TextPath;
TextPath.prototype._fillFunc = _fillFunc;
TextPath.prototype._strokeFunc = _strokeFunc;
TextPath.prototype._fillFuncHit = _fillFunc;
TextPath.prototype._strokeFuncHit = _strokeFunc;
TextPath.prototype.className = 'TextPath';
TextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];
Global_1$2._registerNode(TextPath);
Factory_1$h.Factory.addGetterSetter(TextPath, 'data');
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1$h.getNumberValidator());
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);
Factory_1$h.Factory.addGetterSetter(TextPath, 'align', 'left');
Factory_1$h.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1$h.getNumberValidator());
Factory_1$h.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');
Factory_1$h.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);
Factory_1$h.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);
Factory_1$h.Factory.addGetterSetter(TextPath, 'textDecoration', null);
Factory_1$h.Factory.addGetterSetter(TextPath, 'kerningFunc', null);
Util_1$5.Collection.mapMethods(TextPath);

var Transformer$1 = {};

var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(Transformer$1, "__esModule", { value: true });
Transformer$1.Transformer = void 0;
var Util_1$4 = Util;
var Factory_1$g = Factory;
var Node_1$f = Node;
var Shape_1$1 = Shape;
var Rect_1$1 = Rect$1;
var Group_1 = Group$1;
var Global_1$1 = Global;
var Validators_1$g = Validators;
var Global_2$1 = Global;
var EVENTS_NAME = 'tr-konva';
var ATTR_CHANGE_LIST = [
    'resizeEnabledChange',
    'rotateAnchorOffsetChange',
    'rotateEnabledChange',
    'enabledAnchorsChange',
    'anchorSizeChange',
    'borderEnabledChange',
    'borderStrokeChange',
    'borderStrokeWidthChange',
    'borderDashChange',
    'anchorStrokeChange',
    'anchorStrokeWidthChange',
    'anchorFillChange',
    'anchorCornerRadiusChange',
    'ignoreStrokeChange',
]
    .map(function (e) { return e + ("." + EVENTS_NAME); })
    .join(' ');
var NODES_RECT = 'nodesRect';
var TRANSFORM_CHANGE_STR = [
    'widthChange',
    'heightChange',
    'scaleXChange',
    'scaleYChange',
    'skewXChange',
    'skewYChange',
    'rotationChange',
    'offsetXChange',
    'offsetYChange',
    'transformsEnabledChange',
    'strokeWidthChange',
]
    .map(function (e) { return e + ("." + EVENTS_NAME); })
    .join(' ');
var ANGLES = {
    'top-left': -45,
    'top-center': 0,
    'top-right': 45,
    'middle-right': -90,
    'middle-left': 90,
    'bottom-left': -135,
    'bottom-center': 180,
    'bottom-right': 135,
};
var TOUCH_DEVICE = 'ontouchstart' in Global_1$1.Konva._global;
function getCursor(anchorName, rad) {
    if (anchorName === 'rotater') {
        return 'crosshair';
    }
    rad += Util_1$4.Util._degToRad(ANGLES[anchorName] || 0);
    var angle = ((Util_1$4.Util._radToDeg(rad) % 360) + 360) % 360;
    if (Util_1$4.Util._inRange(angle, 315 + 22.5, 360) || Util_1$4.Util._inRange(angle, 0, 22.5)) {
        return 'ns-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
        return 'nesw-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
        return 'ew-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
        return 'nwse-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
        return 'ns-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
        return 'nesw-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
        return 'ew-resize';
    }
    else if (Util_1$4.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
        return 'nwse-resize';
    }
    else {
        Util_1$4.Util.error('Transformer has unknown angle for cursor detection: ' + angle);
        return 'pointer';
    }
}
var ANCHORS_NAMES = [
    'top-left',
    'top-center',
    'top-right',
    'middle-right',
    'middle-left',
    'bottom-left',
    'bottom-center',
    'bottom-right',
];
var MAX_SAFE_INTEGER = 100000000;
function getCenter(shape) {
    return {
        x: shape.x +
            (shape.width / 2) * Math.cos(shape.rotation) +
            (shape.height / 2) * Math.sin(-shape.rotation),
        y: shape.y +
            (shape.height / 2) * Math.cos(shape.rotation) +
            (shape.width / 2) * Math.sin(shape.rotation),
    };
}
function rotateAroundPoint(shape, angleRad, point) {
    var x = point.x +
        (shape.x - point.x) * Math.cos(angleRad) -
        (shape.y - point.y) * Math.sin(angleRad);
    var y = point.y +
        (shape.x - point.x) * Math.sin(angleRad) +
        (shape.y - point.y) * Math.cos(angleRad);
    return __assign(__assign({}, shape), { rotation: shape.rotation + angleRad, x: x,
        y: y });
}
function rotateAroundCenter(shape, deltaRad) {
    var center = getCenter(shape);
    return rotateAroundPoint(shape, deltaRad, center);
}
function getSnap(snaps, newRotationRad, tol) {
    var snapped = newRotationRad;
    for (var i = 0; i < snaps.length; i++) {
        var angle = Global_1$1.Konva.getAngle(snaps[i]);
        var absDiff = Math.abs(angle - newRotationRad) % (Math.PI * 2);
        var dif = Math.min(absDiff, Math.PI * 2 - absDiff);
        if (dif < tol) {
            snapped = angle;
        }
    }
    return snapped;
}
var Transformer = (function (_super) {
    __extends$1(Transformer, _super);
    function Transformer(config) {
        var _this = _super.call(this, config) || this;
        _this._transforming = false;
        _this._createElements();
        _this._handleMouseMove = _this._handleMouseMove.bind(_this);
        _this._handleMouseUp = _this._handleMouseUp.bind(_this);
        _this.update = _this.update.bind(_this);
        _this.on(ATTR_CHANGE_LIST, _this.update);
        if (_this.getNode()) {
            _this.update();
        }
        return _this;
    }
    Transformer.prototype.attachTo = function (node) {
        this.setNode(node);
        return this;
    };
    Transformer.prototype.setNode = function (node) {
        Util_1$4.Util.warn('tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead.');
        return this.setNodes([node]);
    };
    Transformer.prototype.getNode = function () {
        return this._nodes && this._nodes[0];
    };
    Transformer.prototype.setNodes = function (nodes) {
        var _this = this;
        if (nodes === void 0) { nodes = []; }
        if (this._nodes && this._nodes.length) {
            this.detach();
        }
        this._nodes = nodes;
        if (nodes.length === 1) {
            this.rotation(nodes[0].getAbsoluteRotation());
        }
        else {
            this.rotation(0);
        }
        this._nodes.forEach(function (node) {
            var additionalEvents = node._attrsAffectingSize
                .map(function (prop) { return prop + 'Change.' + EVENTS_NAME; })
                .join(' ');
            var onChange = function () {
                if (_this.nodes().length === 1) {
                    _this.rotation(_this.nodes()[0].getAbsoluteRotation());
                }
                _this._resetTransformCache();
                if (!_this._transforming && !_this.isDragging()) {
                    _this.update();
                }
            };
            node.on(additionalEvents, onChange);
            node.on(TRANSFORM_CHANGE_STR, onChange);
            node.on("_clearTransformCache." + EVENTS_NAME, onChange);
            node.on("xChange." + EVENTS_NAME + " yChange." + EVENTS_NAME, onChange);
            _this._proxyDrag(node);
        });
        this._resetTransformCache();
        var elementsCreated = !!this.findOne('.top-left');
        if (elementsCreated) {
            this.update();
        }
        return this;
    };
    Transformer.prototype._proxyDrag = function (node) {
        var _this = this;
        var lastPos;
        node.on("dragstart." + EVENTS_NAME, function (e) {
            lastPos = node.getAbsolutePosition();
            if (!_this.isDragging() && node !== _this.findOne('.back')) {
                _this.startDrag(e, false);
            }
        });
        node.on("dragmove." + EVENTS_NAME, function (e) {
            if (!lastPos) {
                return;
            }
            var abs = node.getAbsolutePosition();
            var dx = abs.x - lastPos.x;
            var dy = abs.y - lastPos.y;
            _this.nodes().forEach(function (otherNode) {
                if (otherNode === node) {
                    return;
                }
                if (otherNode.isDragging()) {
                    return;
                }
                var otherAbs = otherNode.getAbsolutePosition();
                otherNode.setAbsolutePosition({
                    x: otherAbs.x + dx,
                    y: otherAbs.y + dy,
                });
                otherNode.startDrag(e);
            });
            lastPos = null;
        });
    };
    Transformer.prototype.getNodes = function () {
        return this._nodes || [];
    };
    Transformer.prototype.getActiveAnchor = function () {
        return this._movingAnchorName;
    };
    Transformer.prototype.detach = function () {
        if (this._nodes) {
            this._nodes.forEach(function (node) {
                node.off('.' + EVENTS_NAME);
            });
        }
        this._nodes = [];
        this._resetTransformCache();
    };
    Transformer.prototype._resetTransformCache = function () {
        this._clearCache(NODES_RECT);
        this._clearCache('transform');
        this._clearSelfAndDescendantCache('absoluteTransform');
    };
    Transformer.prototype._getNodeRect = function () {
        return this._getCache(NODES_RECT, this.__getNodeRect);
    };
    Transformer.prototype.__getNodeShape = function (node, rot, relative) {
        if (rot === void 0) { rot = this.rotation(); }
        var rect = node.getClientRect({
            skipTransform: true,
            skipShadow: true,
            skipStroke: this.ignoreStroke(),
        });
        var absScale = node.getAbsoluteScale(relative);
        var absPos = node.getAbsolutePosition(relative);
        var dx = rect.x * absScale.x - node.offsetX() * absScale.x;
        var dy = rect.y * absScale.y - node.offsetY() * absScale.y;
        var rotation = (Global_1$1.Konva.getAngle(node.getAbsoluteRotation()) + Math.PI * 2) %
            (Math.PI * 2);
        var box = {
            x: absPos.x + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
            y: absPos.y + dy * Math.cos(rotation) + dx * Math.sin(rotation),
            width: rect.width * absScale.x,
            height: rect.height * absScale.y,
            rotation: rotation,
        };
        return rotateAroundPoint(box, -Global_1$1.Konva.getAngle(rot), {
            x: 0,
            y: 0,
        });
    };
    Transformer.prototype.__getNodeRect = function () {
        var _this = this;
        var node = this.getNode();
        if (!node) {
            return {
                x: -MAX_SAFE_INTEGER,
                y: -MAX_SAFE_INTEGER,
                width: 0,
                height: 0,
                rotation: 0,
            };
        }
        var totalPoints = [];
        this.nodes().map(function (node) {
            var box = node.getClientRect({
                skipTransform: true,
                skipShadow: true,
                skipStroke: _this.ignoreStroke(),
            });
            var points = [
                { x: box.x, y: box.y },
                { x: box.x + box.width, y: box.y },
                { x: box.x + box.width, y: box.y + box.height },
                { x: box.x, y: box.y + box.height },
            ];
            var trans = node.getAbsoluteTransform();
            points.forEach(function (point) {
                var transformed = trans.point(point);
                totalPoints.push(transformed);
            });
        });
        var tr = new Util_1$4.Transform();
        tr.rotate(-Global_1$1.Konva.getAngle(this.rotation()));
        var minX, minY, maxX, maxY;
        totalPoints.forEach(function (point) {
            var transformed = tr.point(point);
            if (minX === undefined) {
                minX = maxX = transformed.x;
                minY = maxY = transformed.y;
            }
            minX = Math.min(minX, transformed.x);
            minY = Math.min(minY, transformed.y);
            maxX = Math.max(maxX, transformed.x);
            maxY = Math.max(maxY, transformed.y);
        });
        tr.invert();
        var p = tr.point({ x: minX, y: minY });
        return {
            x: p.x,
            y: p.y,
            width: maxX - minX,
            height: maxY - minY,
            rotation: Global_1$1.Konva.getAngle(this.rotation()),
        };
    };
    Transformer.prototype.getX = function () {
        return this._getNodeRect().x;
    };
    Transformer.prototype.getY = function () {
        return this._getNodeRect().y;
    };
    Transformer.prototype.getWidth = function () {
        return this._getNodeRect().width;
    };
    Transformer.prototype.getHeight = function () {
        return this._getNodeRect().height;
    };
    Transformer.prototype._createElements = function () {
        this._createBack();
        ANCHORS_NAMES.forEach(function (name) {
            this._createAnchor(name);
        }.bind(this));
        this._createAnchor('rotater');
    };
    Transformer.prototype._createAnchor = function (name) {
        var _this = this;
        var anchor = new Rect_1$1.Rect({
            stroke: 'rgb(0, 161, 255)',
            fill: 'white',
            strokeWidth: 1,
            name: name + ' _anchor',
            dragDistance: 0,
            draggable: true,
            hitStrokeWidth: TOUCH_DEVICE ? 10 : 'auto',
        });
        var self = this;
        anchor.on('mousedown touchstart', function (e) {
            self._handleMouseDown(e);
        });
        anchor.on('dragstart', function (e) {
            anchor.stopDrag();
            e.cancelBubble = true;
        });
        anchor.on('dragend', function (e) {
            e.cancelBubble = true;
        });
        anchor.on('mouseenter', function () {
            var rad = Global_1$1.Konva.getAngle(_this.rotation());
            var cursor = getCursor(name, rad);
            anchor.getStage().content.style.cursor = cursor;
            _this._cursorChange = true;
        });
        anchor.on('mouseout', function () {
            anchor.getStage().content.style.cursor = '';
            _this._cursorChange = false;
        });
        this.add(anchor);
    };
    Transformer.prototype._createBack = function () {
        var _this = this;
        var back = new Shape_1$1.Shape({
            name: 'back',
            width: 0,
            height: 0,
            draggable: true,
            sceneFunc: function (ctx) {
                var tr = this.getParent();
                var padding = tr.padding();
                ctx.beginPath();
                ctx.rect(-padding, -padding, this.width() + padding * 2, this.height() + padding * 2);
                ctx.moveTo(this.width() / 2, -padding);
                if (tr.rotateEnabled()) {
                    ctx.lineTo(this.width() / 2, -tr.rotateAnchorOffset() * Util_1$4.Util._sign(this.height()) - padding);
                }
                ctx.fillStrokeShape(this);
            },
            hitFunc: function (ctx, shape) {
                if (!_this.shouldOverdrawWholeArea()) {
                    return;
                }
                var padding = _this.padding();
                ctx.beginPath();
                ctx.rect(-padding, -padding, shape.width() + padding * 2, shape.height() + padding * 2);
                ctx.fillStrokeShape(shape);
            },
        });
        this.add(back);
        this._proxyDrag(back);
        back.on('dragstart', function (e) {
            e.cancelBubble = true;
        });
        back.on('dragmove', function (e) {
            e.cancelBubble = true;
        });
        back.on('dragend', function (e) {
            e.cancelBubble = true;
        });
    };
    Transformer.prototype._handleMouseDown = function (e) {
        this._movingAnchorName = e.target.name().split(' ')[0];
        var attrs = this._getNodeRect();
        var width = attrs.width;
        var height = attrs.height;
        var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
        this.sin = Math.abs(height / hypotenuse);
        this.cos = Math.abs(width / hypotenuse);
        window.addEventListener('mousemove', this._handleMouseMove);
        window.addEventListener('touchmove', this._handleMouseMove);
        window.addEventListener('mouseup', this._handleMouseUp, true);
        window.addEventListener('touchend', this._handleMouseUp, true);
        this._transforming = true;
        var ap = e.target.getAbsolutePosition();
        var pos = e.target.getStage().getPointerPosition();
        this._anchorDragOffset = {
            x: pos.x - ap.x,
            y: pos.y - ap.y,
        };
        this._fire('transformstart', { evt: e, target: this.getNode() });
        this._nodes.forEach(function (target) {
            target._fire('transformstart', { evt: e, target: target });
        });
    };
    Transformer.prototype._handleMouseMove = function (e) {
        var x, y, newHypotenuse;
        var anchorNode = this.findOne('.' + this._movingAnchorName);
        var stage = anchorNode.getStage();
        stage.setPointersPositions(e);
        var pp = stage.getPointerPosition();
        var newNodePos = {
            x: pp.x - this._anchorDragOffset.x,
            y: pp.y - this._anchorDragOffset.y,
        };
        var oldAbs = anchorNode.getAbsolutePosition();
        anchorNode.setAbsolutePosition(newNodePos);
        var newAbs = anchorNode.getAbsolutePosition();
        if (oldAbs.x === newAbs.x && oldAbs.y === newAbs.y) {
            return;
        }
        if (this._movingAnchorName === 'rotater') {
            var attrs = this._getNodeRect();
            x = anchorNode.x() - attrs.width / 2;
            y = -anchorNode.y() + attrs.height / 2;
            var delta = Math.atan2(-y, x) + Math.PI / 2;
            if (attrs.height < 0) {
                delta -= Math.PI;
            }
            var oldRotation = Global_1$1.Konva.getAngle(this.rotation());
            var newRotation = oldRotation + delta;
            var tol = Global_1$1.Konva.getAngle(this.rotationSnapTolerance());
            var snappedRot = getSnap(this.rotationSnaps(), newRotation, tol);
            var diff = snappedRot - attrs.rotation;
            var shape = rotateAroundCenter(attrs, diff);
            this._fitNodesInto(shape, e);
            return;
        }
        var keepProportion = this.keepRatio() || e.shiftKey;
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (this._movingAnchorName === 'top-left') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.bottom-right').x(),
                        y: this.findOne('.bottom-right').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +
                    Math.pow(comparePoint.y - anchorNode.y(), 2));
                var reverseX = this.findOne('.top-left').x() > comparePoint.x ? -1 : 1;
                var reverseY = this.findOne('.top-left').y() > comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                this.findOne('.top-left').x(comparePoint.x - x);
                this.findOne('.top-left').y(comparePoint.y - y);
            }
        }
        else if (this._movingAnchorName === 'top-center') {
            this.findOne('.top-left').y(anchorNode.y());
        }
        else if (this._movingAnchorName === 'top-right') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.bottom-left').x(),
                        y: this.findOne('.bottom-left').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +
                    Math.pow(comparePoint.y - anchorNode.y(), 2));
                var reverseX = this.findOne('.top-right').x() < comparePoint.x ? -1 : 1;
                var reverseY = this.findOne('.top-right').y() > comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                this.findOne('.top-right').x(comparePoint.x + x);
                this.findOne('.top-right').y(comparePoint.y - y);
            }
            var pos = anchorNode.position();
            this.findOne('.top-left').y(pos.y);
            this.findOne('.bottom-right').x(pos.x);
        }
        else if (this._movingAnchorName === 'middle-left') {
            this.findOne('.top-left').x(anchorNode.x());
        }
        else if (this._movingAnchorName === 'middle-right') {
            this.findOne('.bottom-right').x(anchorNode.x());
        }
        else if (this._movingAnchorName === 'bottom-left') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.top-right').x(),
                        y: this.findOne('.top-right').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(comparePoint.x - anchorNode.x(), 2) +
                    Math.pow(anchorNode.y() - comparePoint.y, 2));
                var reverseX = comparePoint.x < anchorNode.x() ? -1 : 1;
                var reverseY = anchorNode.y() < comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                anchorNode.x(comparePoint.x - x);
                anchorNode.y(comparePoint.y + y);
            }
            pos = anchorNode.position();
            this.findOne('.top-left').x(pos.x);
            this.findOne('.bottom-right').y(pos.y);
        }
        else if (this._movingAnchorName === 'bottom-center') {
            this.findOne('.bottom-right').y(anchorNode.y());
        }
        else if (this._movingAnchorName === 'bottom-right') {
            if (keepProportion) {
                var comparePoint = centeredScaling
                    ? {
                        x: this.width() / 2,
                        y: this.height() / 2,
                    }
                    : {
                        x: this.findOne('.top-left').x(),
                        y: this.findOne('.top-left').y(),
                    };
                newHypotenuse = Math.sqrt(Math.pow(anchorNode.x() - comparePoint.x, 2) +
                    Math.pow(anchorNode.y() - comparePoint.y, 2));
                var reverseX = this.findOne('.bottom-right').x() < comparePoint.x ? -1 : 1;
                var reverseY = this.findOne('.bottom-right').y() < comparePoint.y ? -1 : 1;
                x = newHypotenuse * this.cos * reverseX;
                y = newHypotenuse * this.sin * reverseY;
                this.findOne('.bottom-right').x(comparePoint.x + x);
                this.findOne('.bottom-right').y(comparePoint.y + y);
            }
        }
        else {
            console.error(new Error('Wrong position argument of selection resizer: ' +
                this._movingAnchorName));
        }
        var centeredScaling = this.centeredScaling() || e.altKey;
        if (centeredScaling) {
            var topLeft = this.findOne('.top-left');
            var bottomRight = this.findOne('.bottom-right');
            var topOffsetX = topLeft.x();
            var topOffsetY = topLeft.y();
            var bottomOffsetX = this.getWidth() - bottomRight.x();
            var bottomOffsetY = this.getHeight() - bottomRight.y();
            bottomRight.move({
                x: -topOffsetX,
                y: -topOffsetY,
            });
            topLeft.move({
                x: bottomOffsetX,
                y: bottomOffsetY,
            });
        }
        var absPos = this.findOne('.top-left').getAbsolutePosition();
        x = absPos.x;
        y = absPos.y;
        var width = this.findOne('.bottom-right').x() - this.findOne('.top-left').x();
        var height = this.findOne('.bottom-right').y() - this.findOne('.top-left').y();
        this._fitNodesInto({
            x: x,
            y: y,
            width: width,
            height: height,
            rotation: Global_1$1.Konva.getAngle(this.rotation()),
        }, e);
    };
    Transformer.prototype._handleMouseUp = function (e) {
        this._removeEvents(e);
    };
    Transformer.prototype.getAbsoluteTransform = function () {
        return this.getTransform();
    };
    Transformer.prototype._removeEvents = function (e) {
        if (this._transforming) {
            this._transforming = false;
            window.removeEventListener('mousemove', this._handleMouseMove);
            window.removeEventListener('touchmove', this._handleMouseMove);
            window.removeEventListener('mouseup', this._handleMouseUp, true);
            window.removeEventListener('touchend', this._handleMouseUp, true);
            var node = this.getNode();
            this._fire('transformend', { evt: e, target: node });
            if (node) {
                this._nodes.forEach(function (target) {
                    target._fire('transformend', { evt: e, target: target });
                });
            }
            this._movingAnchorName = null;
        }
    };
    Transformer.prototype._fitNodesInto = function (newAttrs, evt) {
        var _this = this;
        var oldAttrs = this._getNodeRect();
        var minSize = 1;
        if (Util_1$4.Util._inRange(newAttrs.width, -this.padding() * 2 - minSize, minSize)) {
            this.update();
            return;
        }
        if (Util_1$4.Util._inRange(newAttrs.height, -this.padding() * 2 - minSize, minSize)) {
            this.update();
            return;
        }
        var t = new Util_1$4.Transform();
        t.rotate(Global_1$1.Konva.getAngle(this.rotation()));
        if (this._movingAnchorName &&
            newAttrs.width < 0 &&
            this._movingAnchorName.indexOf('left') >= 0) {
            var offset = t.point({
                x: -this.padding() * 2,
                y: 0,
            });
            newAttrs.x += offset.x;
            newAttrs.y += offset.y;
            newAttrs.width += this.padding() * 2;
            this._movingAnchorName = this._movingAnchorName.replace('left', 'right');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
        }
        else if (this._movingAnchorName &&
            newAttrs.width < 0 &&
            this._movingAnchorName.indexOf('right') >= 0) {
            var offset = t.point({
                x: this.padding() * 2,
                y: 0,
            });
            this._movingAnchorName = this._movingAnchorName.replace('right', 'left');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            newAttrs.width += this.padding() * 2;
        }
        if (this._movingAnchorName &&
            newAttrs.height < 0 &&
            this._movingAnchorName.indexOf('top') >= 0) {
            var offset = t.point({
                x: 0,
                y: -this.padding() * 2,
            });
            newAttrs.x += offset.x;
            newAttrs.y += offset.y;
            this._movingAnchorName = this._movingAnchorName.replace('top', 'bottom');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            newAttrs.height += this.padding() * 2;
        }
        else if (this._movingAnchorName &&
            newAttrs.height < 0 &&
            this._movingAnchorName.indexOf('bottom') >= 0) {
            var offset = t.point({
                x: 0,
                y: this.padding() * 2,
            });
            this._movingAnchorName = this._movingAnchorName.replace('bottom', 'top');
            this._anchorDragOffset.x -= offset.x;
            this._anchorDragOffset.y -= offset.y;
            newAttrs.height += this.padding() * 2;
        }
        if (this.boundBoxFunc()) {
            var bounded = this.boundBoxFunc()(oldAttrs, newAttrs);
            if (bounded) {
                newAttrs = bounded;
            }
            else {
                Util_1$4.Util.warn('boundBoxFunc returned falsy. You should return new bound rect from it!');
            }
        }
        var baseSize = 10000000;
        var oldTr = new Util_1$4.Transform();
        oldTr.translate(oldAttrs.x, oldAttrs.y);
        oldTr.rotate(oldAttrs.rotation);
        oldTr.scale(oldAttrs.width / baseSize, oldAttrs.height / baseSize);
        var newTr = new Util_1$4.Transform();
        newTr.translate(newAttrs.x, newAttrs.y);
        newTr.rotate(newAttrs.rotation);
        newTr.scale(newAttrs.width / baseSize, newAttrs.height / baseSize);
        var delta = newTr.multiply(oldTr.invert());
        this._nodes.forEach(function (node) {
            var _a;
            var parentTransform = node.getParent().getAbsoluteTransform();
            var localTransform = node.getTransform().copy();
            localTransform.translate(node.offsetX(), node.offsetY());
            var newLocalTransform = new Util_1$4.Transform();
            newLocalTransform
                .multiply(parentTransform.copy().invert())
                .multiply(delta)
                .multiply(parentTransform)
                .multiply(localTransform);
            var attrs = newLocalTransform.decompose();
            node.setAttrs(attrs);
            _this._fire('transform', { evt: evt, target: node });
            node._fire('transform', { evt: evt, target: node });
            (_a = node.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
        });
        this.rotation(Util_1$4.Util._getRotation(newAttrs.rotation));
        this._resetTransformCache();
        this.update();
        this.getLayer().batchDraw();
    };
    Transformer.prototype.forceUpdate = function () {
        this._resetTransformCache();
        this.update();
    };
    Transformer.prototype._batchChangeChild = function (selector, attrs) {
        var anchor = this.findOne(selector);
        anchor.setAttrs(attrs);
    };
    Transformer.prototype.update = function () {
        var _this = this;
        var _a;
        var attrs = this._getNodeRect();
        this.rotation(Util_1$4.Util._getRotation(attrs.rotation));
        var width = attrs.width;
        var height = attrs.height;
        var enabledAnchors = this.enabledAnchors();
        var resizeEnabled = this.resizeEnabled();
        var padding = this.padding();
        var anchorSize = this.anchorSize();
        this.find('._anchor').each(function (node) {
            node.setAttrs({
                width: anchorSize,
                height: anchorSize,
                offsetX: anchorSize / 2,
                offsetY: anchorSize / 2,
                stroke: _this.anchorStroke(),
                strokeWidth: _this.anchorStrokeWidth(),
                fill: _this.anchorFill(),
                cornerRadius: _this.anchorCornerRadius(),
            });
        });
        this._batchChangeChild('.top-left', {
            x: 0,
            y: 0,
            offsetX: anchorSize / 2 + padding,
            offsetY: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('top-left') >= 0,
        });
        this._batchChangeChild('.top-center', {
            x: width / 2,
            y: 0,
            offsetY: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('top-center') >= 0,
        });
        this._batchChangeChild('.top-right', {
            x: width,
            y: 0,
            offsetX: anchorSize / 2 - padding,
            offsetY: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('top-right') >= 0,
        });
        this._batchChangeChild('.middle-left', {
            x: 0,
            y: height / 2,
            offsetX: anchorSize / 2 + padding,
            visible: resizeEnabled && enabledAnchors.indexOf('middle-left') >= 0,
        });
        this._batchChangeChild('.middle-right', {
            x: width,
            y: height / 2,
            offsetX: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('middle-right') >= 0,
        });
        this._batchChangeChild('.bottom-left', {
            x: 0,
            y: height,
            offsetX: anchorSize / 2 + padding,
            offsetY: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('bottom-left') >= 0,
        });
        this._batchChangeChild('.bottom-center', {
            x: width / 2,
            y: height,
            offsetY: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('bottom-center') >= 0,
        });
        this._batchChangeChild('.bottom-right', {
            x: width,
            y: height,
            offsetX: anchorSize / 2 - padding,
            offsetY: anchorSize / 2 - padding,
            visible: resizeEnabled && enabledAnchors.indexOf('bottom-right') >= 0,
        });
        this._batchChangeChild('.rotater', {
            x: width / 2,
            y: -this.rotateAnchorOffset() * Util_1$4.Util._sign(height) - padding,
            visible: this.rotateEnabled(),
        });
        this._batchChangeChild('.back', {
            width: width,
            height: height,
            visible: this.borderEnabled(),
            stroke: this.borderStroke(),
            strokeWidth: this.borderStrokeWidth(),
            dash: this.borderDash(),
            x: 0,
            y: 0,
        });
        (_a = this.getLayer()) === null || _a === void 0 ? void 0 : _a.batchDraw();
    };
    Transformer.prototype.isTransforming = function () {
        return this._transforming;
    };
    Transformer.prototype.stopTransform = function () {
        if (this._transforming) {
            this._removeEvents();
            var anchorNode = this.findOne('.' + this._movingAnchorName);
            if (anchorNode) {
                anchorNode.stopDrag();
            }
        }
    };
    Transformer.prototype.destroy = function () {
        if (this.getStage() && this._cursorChange) {
            this.getStage().content.style.cursor = '';
        }
        Group_1.Group.prototype.destroy.call(this);
        this.detach();
        this._removeEvents();
        return this;
    };
    Transformer.prototype.toObject = function () {
        return Node_1$f.Node.prototype.toObject.call(this);
    };
    return Transformer;
}(Group_1.Group));
Transformer$1.Transformer = Transformer;
function validateAnchors(val) {
    if (!(val instanceof Array)) {
        Util_1$4.Util.warn('enabledAnchors value should be an array');
    }
    if (val instanceof Array) {
        val.forEach(function (name) {
            if (ANCHORS_NAMES.indexOf(name) === -1) {
                Util_1$4.Util.warn('Unknown anchor name: ' +
                    name +
                    '. Available names are: ' +
                    ANCHORS_NAMES.join(', '));
            }
        });
    }
    return val || [];
}
Transformer.prototype.className = 'Transformer';
Global_2$1._registerNode(Transformer);
Factory_1$g.Factory.addGetterSetter(Transformer, 'enabledAnchors', ANCHORS_NAMES, validateAnchors);
Factory_1$g.Factory.addGetterSetter(Transformer, 'resizeEnabled', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorSize', 10, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotateEnabled', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotationSnaps', []);
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotateAnchorOffset', 50, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'rotationSnapTolerance', 5, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderEnabled', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorStroke', 'rgb(0, 161, 255)');
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorStrokeWidth', 1, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorFill', 'white');
Factory_1$g.Factory.addGetterSetter(Transformer, 'anchorCornerRadius', 0, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderStroke', 'rgb(0, 161, 255)');
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderStrokeWidth', 1, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'borderDash');
Factory_1$g.Factory.addGetterSetter(Transformer, 'keepRatio', true);
Factory_1$g.Factory.addGetterSetter(Transformer, 'centeredScaling', false);
Factory_1$g.Factory.addGetterSetter(Transformer, 'ignoreStroke', false);
Factory_1$g.Factory.addGetterSetter(Transformer, 'padding', 0, Validators_1$g.getNumberValidator());
Factory_1$g.Factory.addGetterSetter(Transformer, 'node');
Factory_1$g.Factory.addGetterSetter(Transformer, 'nodes');
Factory_1$g.Factory.addGetterSetter(Transformer, 'boundBoxFunc');
Factory_1$g.Factory.addGetterSetter(Transformer, 'shouldOverdrawWholeArea', false);
Factory_1$g.Factory.backCompat(Transformer, {
    lineEnabled: 'borderEnabled',
    rotateHandlerOffset: 'rotateAnchorOffset',
    enabledHandlers: 'enabledAnchors',
});
Util_1$4.Collection.mapMethods(Transformer);

var Wedge$1 = {};

var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(Wedge$1, "__esModule", { value: true });
Wedge$1.Wedge = void 0;
var Util_1$3 = Util;
var Factory_1$f = Factory;
var Shape_1 = Shape;
var Global_1 = Global;
var Validators_1$f = Validators;
var Global_2 = Global;
var Wedge = (function (_super) {
    __extends(Wedge, _super);
    function Wedge() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Wedge.prototype._sceneFunc = function (context) {
        context.beginPath();
        context.arc(0, 0, this.radius(), 0, Global_1.Konva.getAngle(this.angle()), this.clockwise());
        context.lineTo(0, 0);
        context.closePath();
        context.fillStrokeShape(this);
    };
    Wedge.prototype.getWidth = function () {
        return this.radius() * 2;
    };
    Wedge.prototype.getHeight = function () {
        return this.radius() * 2;
    };
    Wedge.prototype.setWidth = function (width) {
        this.radius(width / 2);
    };
    Wedge.prototype.setHeight = function (height) {
        this.radius(height / 2);
    };
    return Wedge;
}(Shape_1.Shape));
Wedge$1.Wedge = Wedge;
Wedge.prototype.className = 'Wedge';
Wedge.prototype._centroid = true;
Wedge.prototype._attrsAffectingSize = ['radius'];
Global_2._registerNode(Wedge);
Factory_1$f.Factory.addGetterSetter(Wedge, 'radius', 0, Validators_1$f.getNumberValidator());
Factory_1$f.Factory.addGetterSetter(Wedge, 'angle', 0, Validators_1$f.getNumberValidator());
Factory_1$f.Factory.addGetterSetter(Wedge, 'clockwise', false);
Factory_1$f.Factory.backCompat(Wedge, {
    angleDeg: 'angle',
    getAngleDeg: 'getAngle',
    setAngleDeg: 'setAngle'
});
Util_1$3.Collection.mapMethods(Wedge);

var Blur$1 = {};

Object.defineProperty(Blur$1, "__esModule", { value: true });
Blur$1.Blur = void 0;
var Factory_1$e = Factory;
var Node_1$e = Node;
var Validators_1$e = Validators;
function BlurStack() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
}
var mul_table = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259
];
var shg_table = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24
];
function filterGaussBlurRGBA(imageData, radius) {
    var pixels = imageData.data, width = imageData.width, height = imageData.height;
    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
    var div = radius + radius + 1, widthMinus1 = width - 1, heightMinus1 = height - 1, radiusPlus1 = radius + 1, sumFactor = (radiusPlus1 * (radiusPlus1 + 1)) / 2, stackStart = new BlurStack(), stackEnd = null, stack = stackStart, stackIn = null, stackOut = null, mul_sum = mul_table[radius], shg_sum = shg_table[radius];
    for (i = 1; i < div; i++) {
        stack = stack.next = new BlurStack();
        if (i === radiusPlus1) {
            stackEnd = stack;
        }
    }
    stack.next = stackStart;
    yw = yi = 0;
    for (y = 0; y < height; y++) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
        }
        for (i = 1; i < radiusPlus1; i++) {
            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        for (x = 0; x < width; x++) {
            pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
            if (pa !== 0) {
                pa = 255 / pa;
                pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
                pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
            }
            else {
                pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
            r_in_sum += stackIn.r = pixels[p];
            g_in_sum += stackIn.g = pixels[p + 1];
            b_in_sum += stackIn.b = pixels[p + 2];
            a_in_sum += stackIn.a = pixels[p + 3];
            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            a_sum += a_in_sum;
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi += 4;
        }
        yw += width;
    }
    for (x = 0; x < width; x++) {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
        }
        yp = width;
        for (i = 1; i <= radius; i++) {
            yi = (yp + x) << 2;
            r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
            r_in_sum += pr;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
            if (i < heightMinus1) {
                yp += width;
            }
        }
        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        for (y = 0; y < height; y++) {
            p = yi << 2;
            pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
            if (pa > 0) {
                pa = 255 / pa;
                pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
                pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
                pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
            }
            else {
                pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p =
                (x +
                    ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width) <<
                    2;
            r_sum += r_in_sum += stackIn.r = pixels[p];
            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
            a_sum += a_in_sum += stackIn.a = pixels[p + 3];
            stackIn = stackIn.next;
            r_out_sum += pr = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi += width;
        }
    }
}
var Blur = function Blur(imageData) {
    var radius = Math.round(this.blurRadius());
    if (radius > 0) {
        filterGaussBlurRGBA(imageData, radius);
    }
};
Blur$1.Blur = Blur;
Factory_1$e.Factory.addGetterSetter(Node_1$e.Node, 'blurRadius', 0, Validators_1$e.getNumberValidator(), Factory_1$e.Factory.afterSetFilter);

var Brighten$1 = {};

Object.defineProperty(Brighten$1, "__esModule", { value: true });
Brighten$1.Brighten = void 0;
var Factory_1$d = Factory;
var Node_1$d = Node;
var Validators_1$d = Validators;
var Brighten = function (imageData) {
    var brightness = this.brightness() * 255, data = imageData.data, len = data.length, i;
    for (i = 0; i < len; i += 4) {
        data[i] += brightness;
        data[i + 1] += brightness;
        data[i + 2] += brightness;
    }
};
Brighten$1.Brighten = Brighten;
Factory_1$d.Factory.addGetterSetter(Node_1$d.Node, 'brightness', 0, Validators_1$d.getNumberValidator(), Factory_1$d.Factory.afterSetFilter);

var Contrast$1 = {};

Object.defineProperty(Contrast$1, "__esModule", { value: true });
Contrast$1.Contrast = void 0;
var Factory_1$c = Factory;
var Node_1$c = Node;
var Validators_1$c = Validators;
var Contrast = function (imageData) {
    var adjust = Math.pow((this.contrast() + 100) / 100, 2);
    var data = imageData.data, nPixels = data.length, red = 150, green = 150, blue = 150, i;
    for (i = 0; i < nPixels; i += 4) {
        red = data[i];
        green = data[i + 1];
        blue = data[i + 2];
        red /= 255;
        red -= 0.5;
        red *= adjust;
        red += 0.5;
        red *= 255;
        green /= 255;
        green -= 0.5;
        green *= adjust;
        green += 0.5;
        green *= 255;
        blue /= 255;
        blue -= 0.5;
        blue *= adjust;
        blue += 0.5;
        blue *= 255;
        red = red < 0 ? 0 : red > 255 ? 255 : red;
        green = green < 0 ? 0 : green > 255 ? 255 : green;
        blue = blue < 0 ? 0 : blue > 255 ? 255 : blue;
        data[i] = red;
        data[i + 1] = green;
        data[i + 2] = blue;
    }
};
Contrast$1.Contrast = Contrast;
Factory_1$c.Factory.addGetterSetter(Node_1$c.Node, 'contrast', 0, Validators_1$c.getNumberValidator(), Factory_1$c.Factory.afterSetFilter);

var Emboss$1 = {};

Object.defineProperty(Emboss$1, "__esModule", { value: true });
Emboss$1.Emboss = void 0;
var Factory_1$b = Factory;
var Node_1$b = Node;
var Util_1$2 = Util;
var Validators_1$b = Validators;
var Emboss = function (imageData) {
    var strength = this.embossStrength() * 10, greyLevel = this.embossWhiteLevel() * 255, direction = this.embossDirection(), blend = this.embossBlend(), dirY = 0, dirX = 0, data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;
    switch (direction) {
        case 'top-left':
            dirY = -1;
            dirX = -1;
            break;
        case 'top':
            dirY = -1;
            dirX = 0;
            break;
        case 'top-right':
            dirY = -1;
            dirX = 1;
            break;
        case 'right':
            dirY = 0;
            dirX = 1;
            break;
        case 'bottom-right':
            dirY = 1;
            dirX = 1;
            break;
        case 'bottom':
            dirY = 1;
            dirX = 0;
            break;
        case 'bottom-left':
            dirY = 1;
            dirX = -1;
            break;
        case 'left':
            dirY = 0;
            dirX = -1;
            break;
        default:
            Util_1$2.Util.error('Unknown emboss direction: ' + direction);
    }
    do {
        var offsetY = (y - 1) * w4;
        var otherY = dirY;
        if (y + otherY < 1) {
            otherY = 0;
        }
        if (y + otherY > h) {
            otherY = 0;
        }
        var offsetYOther = (y - 1 + otherY) * w * 4;
        var x = w;
        do {
            var offset = offsetY + (x - 1) * 4;
            var otherX = dirX;
            if (x + otherX < 1) {
                otherX = 0;
            }
            if (x + otherX > w) {
                otherX = 0;
            }
            var offsetOther = offsetYOther + (x - 1 + otherX) * 4;
            var dR = data[offset] - data[offsetOther];
            var dG = data[offset + 1] - data[offsetOther + 1];
            var dB = data[offset + 2] - data[offsetOther + 2];
            var dif = dR;
            var absDif = dif > 0 ? dif : -dif;
            var absG = dG > 0 ? dG : -dG;
            var absB = dB > 0 ? dB : -dB;
            if (absG > absDif) {
                dif = dG;
            }
            if (absB > absDif) {
                dif = dB;
            }
            dif *= strength;
            if (blend) {
                var r = data[offset] + dif;
                var g = data[offset + 1] + dif;
                var b = data[offset + 2] + dif;
                data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
                data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
                data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
            }
            else {
                var grey = greyLevel - dif;
                if (grey < 0) {
                    grey = 0;
                }
                else if (grey > 255) {
                    grey = 255;
                }
                data[offset] = data[offset + 1] = data[offset + 2] = grey;
            }
        } while (--x);
    } while (--y);
};
Emboss$1.Emboss = Emboss;
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossStrength', 0.5, Validators_1$b.getNumberValidator(), Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossWhiteLevel', 0.5, Validators_1$b.getNumberValidator(), Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossDirection', 'top-left', null, Factory_1$b.Factory.afterSetFilter);
Factory_1$b.Factory.addGetterSetter(Node_1$b.Node, 'embossBlend', false, null, Factory_1$b.Factory.afterSetFilter);

var Enhance$1 = {};

Object.defineProperty(Enhance$1, "__esModule", { value: true });
Enhance$1.Enhance = void 0;
var Factory_1$a = Factory;
var Node_1$a = Node;
var Validators_1$a = Validators;
function remap(fromValue, fromMin, fromMax, toMin, toMax) {
    var fromRange = fromMax - fromMin, toRange = toMax - toMin, toValue;
    if (fromRange === 0) {
        return toMin + toRange / 2;
    }
    if (toRange === 0) {
        return toMin;
    }
    toValue = (fromValue - fromMin) / fromRange;
    toValue = toRange * toValue + toMin;
    return toValue;
}
var Enhance = function (imageData) {
    var data = imageData.data, nSubPixels = data.length, rMin = data[0], rMax = rMin, r, gMin = data[1], gMax = gMin, g, bMin = data[2], bMax = bMin, b, i;
    var enhanceAmount = this.enhance();
    if (enhanceAmount === 0) {
        return;
    }
    for (i = 0; i < nSubPixels; i += 4) {
        r = data[i + 0];
        if (r < rMin) {
            rMin = r;
        }
        else if (r > rMax) {
            rMax = r;
        }
        g = data[i + 1];
        if (g < gMin) {
            gMin = g;
        }
        else if (g > gMax) {
            gMax = g;
        }
        b = data[i + 2];
        if (b < bMin) {
            bMin = b;
        }
        else if (b > bMax) {
            bMax = b;
        }
    }
    if (rMax === rMin) {
        rMax = 255;
        rMin = 0;
    }
    if (gMax === gMin) {
        gMax = 255;
        gMin = 0;
    }
    if (bMax === bMin) {
        bMax = 255;
        bMin = 0;
    }
    var rMid, rGoalMax, rGoalMin, gMid, gGoalMax, gGoalMin, bMid, bGoalMax, bGoalMin;
    if (enhanceAmount > 0) {
        rGoalMax = rMax + enhanceAmount * (255 - rMax);
        rGoalMin = rMin - enhanceAmount * (rMin - 0);
        gGoalMax = gMax + enhanceAmount * (255 - gMax);
        gGoalMin = gMin - enhanceAmount * (gMin - 0);
        bGoalMax = bMax + enhanceAmount * (255 - bMax);
        bGoalMin = bMin - enhanceAmount * (bMin - 0);
    }
    else {
        rMid = (rMax + rMin) * 0.5;
        rGoalMax = rMax + enhanceAmount * (rMax - rMid);
        rGoalMin = rMin + enhanceAmount * (rMin - rMid);
        gMid = (gMax + gMin) * 0.5;
        gGoalMax = gMax + enhanceAmount * (gMax - gMid);
        gGoalMin = gMin + enhanceAmount * (gMin - gMid);
        bMid = (bMax + bMin) * 0.5;
        bGoalMax = bMax + enhanceAmount * (bMax - bMid);
        bGoalMin = bMin + enhanceAmount * (bMin - bMid);
    }
    for (i = 0; i < nSubPixels; i += 4) {
        data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
        data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
        data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
    }
};
Enhance$1.Enhance = Enhance;
Factory_1$a.Factory.addGetterSetter(Node_1$a.Node, 'enhance', 0, Validators_1$a.getNumberValidator(), Factory_1$a.Factory.afterSetFilter);

var Grayscale$1 = {};

Object.defineProperty(Grayscale$1, "__esModule", { value: true });
Grayscale$1.Grayscale = void 0;
var Grayscale = function (imageData) {
    var data = imageData.data, len = data.length, i, brightness;
    for (i = 0; i < len; i += 4) {
        brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
        data[i] = brightness;
        data[i + 1] = brightness;
        data[i + 2] = brightness;
    }
};
Grayscale$1.Grayscale = Grayscale;

var HSL$1 = {};

Object.defineProperty(HSL$1, "__esModule", { value: true });
HSL$1.HSL = void 0;
var Factory_1$9 = Factory;
var Node_1$9 = Node;
var Validators_1$9 = Validators;
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, 'hue', 0, Validators_1$9.getNumberValidator(), Factory_1$9.Factory.afterSetFilter);
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, 'saturation', 0, Validators_1$9.getNumberValidator(), Factory_1$9.Factory.afterSetFilter);
Factory_1$9.Factory.addGetterSetter(Node_1$9.Node, 'luminance', 0, Validators_1$9.getNumberValidator(), Factory_1$9.Factory.afterSetFilter);
var HSL = function (imageData) {
    var data = imageData.data, nPixels = data.length, v = 1, s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, l = this.luminance() * 127, i;
    var vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
    var r, g, b, a;
    for (i = 0; i < nPixels; i += 4) {
        r = data[i + 0];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];
        data[i + 0] = rr * r + rg * g + rb * b + l;
        data[i + 1] = gr * r + gg * g + gb * b + l;
        data[i + 2] = br * r + bg * g + bb * b + l;
        data[i + 3] = a;
    }
};
HSL$1.HSL = HSL;

var HSV$1 = {};

Object.defineProperty(HSV$1, "__esModule", { value: true });
HSV$1.HSV = void 0;
var Factory_1$8 = Factory;
var Node_1$8 = Node;
var Validators_1$8 = Validators;
var HSV = function (imageData) {
    var data = imageData.data, nPixels = data.length, v = Math.pow(2, this.value()), s = Math.pow(2, this.saturation()), h = Math.abs(this.hue() + 360) % 360, i;
    var vsu = v * s * Math.cos((h * Math.PI) / 180), vsw = v * s * Math.sin((h * Math.PI) / 180);
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw, rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw, rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw, gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw, gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw, bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw, bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;
    var r, g, b, a;
    for (i = 0; i < nPixels; i += 4) {
        r = data[i + 0];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];
        data[i + 0] = rr * r + rg * g + rb * b;
        data[i + 1] = gr * r + gg * g + gb * b;
        data[i + 2] = br * r + bg * g + bb * b;
        data[i + 3] = a;
    }
};
HSV$1.HSV = HSV;
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, 'hue', 0, Validators_1$8.getNumberValidator(), Factory_1$8.Factory.afterSetFilter);
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, 'saturation', 0, Validators_1$8.getNumberValidator(), Factory_1$8.Factory.afterSetFilter);
Factory_1$8.Factory.addGetterSetter(Node_1$8.Node, 'value', 0, Validators_1$8.getNumberValidator(), Factory_1$8.Factory.afterSetFilter);

var Invert$1 = {};

Object.defineProperty(Invert$1, "__esModule", { value: true });
Invert$1.Invert = void 0;
var Invert = function (imageData) {
    var data = imageData.data, len = data.length, i;
    for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
    }
};
Invert$1.Invert = Invert;

var Kaleidoscope$1 = {};

Object.defineProperty(Kaleidoscope$1, "__esModule", { value: true });
Kaleidoscope$1.Kaleidoscope = void 0;
var Factory_1$7 = Factory;
var Node_1$7 = Node;
var Util_1$1 = Util;
var Validators_1$7 = Validators;
var ToPolar = function (src, dst, opt) {
    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, r = 0, g = 0, b = 0, a = 0;
    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;
    var rSize = ySize, tSize = xSize, radius, theta;
    var conversion = ((360 / tSize) * Math.PI) / 180, sin, cos;
    for (theta = 0; theta < tSize; theta += 1) {
        sin = Math.sin(theta * conversion);
        cos = Math.cos(theta * conversion);
        for (radius = 0; radius < rSize; radius += 1) {
            x = Math.floor(xMid + ((rMax * radius) / rSize) * cos);
            y = Math.floor(yMid + ((rMax * radius) / rSize) * sin);
            i = (y * xSize + x) * 4;
            r = srcPixels[i + 0];
            g = srcPixels[i + 1];
            b = srcPixels[i + 2];
            a = srcPixels[i + 3];
            i = (theta + radius * xSize) * 4;
            dstPixels[i + 0] = r;
            dstPixels[i + 1] = g;
            dstPixels[i + 2] = b;
            dstPixels[i + 3] = a;
        }
    }
};
var FromPolar = function (src, dst, opt) {
    var srcPixels = src.data, dstPixels = dst.data, xSize = src.width, ySize = src.height, xMid = opt.polarCenterX || xSize / 2, yMid = opt.polarCenterY || ySize / 2, i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;
    var rad, rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;
    var rSize = ySize, tSize = xSize, radius, theta, phaseShift = opt.polarRotation || 0;
    var x1, y1;
    for (x = 0; x < xSize; x += 1) {
        for (y = 0; y < ySize; y += 1) {
            dx = x - xMid;
            dy = y - yMid;
            radius = (Math.sqrt(dx * dx + dy * dy) * rSize) / rMax;
            theta = ((Math.atan2(dy, dx) * 180) / Math.PI + 360 + phaseShift) % 360;
            theta = (theta * tSize) / 360;
            x1 = Math.floor(theta);
            y1 = Math.floor(radius);
            i = (y1 * xSize + x1) * 4;
            r = srcPixels[i + 0];
            g = srcPixels[i + 1];
            b = srcPixels[i + 2];
            a = srcPixels[i + 3];
            i = (y * xSize + x) * 4;
            dstPixels[i + 0] = r;
            dstPixels[i + 1] = g;
            dstPixels[i + 2] = b;
            dstPixels[i + 3] = a;
        }
    }
};
var Kaleidoscope = function (imageData) {
    var xSize = imageData.width, ySize = imageData.height;
    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
    var power = Math.round(this.kaleidoscopePower());
    var angle = Math.round(this.kaleidoscopeAngle());
    var offset = Math.floor((xSize * (angle % 360)) / 360);
    if (power < 1) {
        return;
    }
    var tempCanvas = Util_1$1.Util.createCanvasElement();
    tempCanvas.width = xSize;
    tempCanvas.height = ySize;
    var scratchData = tempCanvas
        .getContext('2d')
        .getImageData(0, 0, xSize, ySize);
    ToPolar(imageData, scratchData, {
        polarCenterX: xSize / 2,
        polarCenterY: ySize / 2
    });
    var minSectionSize = xSize / Math.pow(2, power);
    while (minSectionSize <= 8) {
        minSectionSize = minSectionSize * 2;
        power -= 1;
    }
    minSectionSize = Math.ceil(minSectionSize);
    var sectionSize = minSectionSize;
    var xStart = 0, xEnd = sectionSize, xDelta = 1;
    if (offset + minSectionSize > xSize) {
        xStart = sectionSize;
        xEnd = 0;
        xDelta = -1;
    }
    for (y = 0; y < ySize; y += 1) {
        for (x = xStart; x !== xEnd; x += xDelta) {
            xoff = Math.round(x + offset) % xSize;
            srcPos = (xSize * y + xoff) * 4;
            r = scratchData.data[srcPos + 0];
            g = scratchData.data[srcPos + 1];
            b = scratchData.data[srcPos + 2];
            a = scratchData.data[srcPos + 3];
            dstPos = (xSize * y + x) * 4;
            scratchData.data[dstPos + 0] = r;
            scratchData.data[dstPos + 1] = g;
            scratchData.data[dstPos + 2] = b;
            scratchData.data[dstPos + 3] = a;
        }
    }
    for (y = 0; y < ySize; y += 1) {
        sectionSize = Math.floor(minSectionSize);
        for (i = 0; i < power; i += 1) {
            for (x = 0; x < sectionSize + 1; x += 1) {
                srcPos = (xSize * y + x) * 4;
                r = scratchData.data[srcPos + 0];
                g = scratchData.data[srcPos + 1];
                b = scratchData.data[srcPos + 2];
                a = scratchData.data[srcPos + 3];
                dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
                scratchData.data[dstPos + 0] = r;
                scratchData.data[dstPos + 1] = g;
                scratchData.data[dstPos + 2] = b;
                scratchData.data[dstPos + 3] = a;
            }
            sectionSize *= 2;
        }
    }
    FromPolar(scratchData, imageData, { polarRotation: 0 });
};
Kaleidoscope$1.Kaleidoscope = Kaleidoscope;
Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, 'kaleidoscopePower', 2, Validators_1$7.getNumberValidator(), Factory_1$7.Factory.afterSetFilter);
Factory_1$7.Factory.addGetterSetter(Node_1$7.Node, 'kaleidoscopeAngle', 0, Validators_1$7.getNumberValidator(), Factory_1$7.Factory.afterSetFilter);

var Mask$1 = {};

Object.defineProperty(Mask$1, "__esModule", { value: true });
Mask$1.Mask = void 0;
var Factory_1$6 = Factory;
var Node_1$6 = Node;
var Validators_1$6 = Validators;
function pixelAt(idata, x, y) {
    var idx = (y * idata.width + x) * 4;
    var d = [];
    d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
    return d;
}
function rgbDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) +
        Math.pow(p1[1] - p2[1], 2) +
        Math.pow(p1[2] - p2[2], 2));
}
function rgbMean(pTab) {
    var m = [0, 0, 0];
    for (var i = 0; i < pTab.length; i++) {
        m[0] += pTab[i][0];
        m[1] += pTab[i][1];
        m[2] += pTab[i][2];
    }
    m[0] /= pTab.length;
    m[1] /= pTab.length;
    m[2] /= pTab.length;
    return m;
}
function backgroundMask(idata, threshold) {
    var rgbv_no = pixelAt(idata, 0, 0);
    var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
    var rgbv_so = pixelAt(idata, 0, idata.height - 1);
    var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
    var thres = threshold || 10;
    if (rgbDistance(rgbv_no, rgbv_ne) < thres &&
        rgbDistance(rgbv_ne, rgbv_se) < thres &&
        rgbDistance(rgbv_se, rgbv_so) < thres &&
        rgbDistance(rgbv_so, rgbv_no) < thres) {
        var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
        var mask = [];
        for (var i = 0; i < idata.width * idata.height; i++) {
            var d = rgbDistance(mean, [
                idata.data[i * 4],
                idata.data[i * 4 + 1],
                idata.data[i * 4 + 2]
            ]);
            mask[i] = d < thres ? 0 : 255;
        }
        return mask;
    }
}
function applyMask(idata, mask) {
    for (var i = 0; i < idata.width * idata.height; i++) {
        idata.data[4 * i + 3] = mask[i];
    }
}
function erodeMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);
    var maskResult = [];
    for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
            var so = y * sw + x;
            var a = 0;
            for (var cy = 0; cy < side; cy++) {
                for (var cx = 0; cx < side; cx++) {
                    var scy = y + cy - halfSide;
                    var scx = x + cx - halfSide;
                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                        var srcOff = scy * sw + scx;
                        var wt = weights[cy * side + cx];
                        a += mask[srcOff] * wt;
                    }
                }
            }
            maskResult[so] = a === 255 * 8 ? 255 : 0;
        }
    }
    return maskResult;
}
function dilateMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);
    var maskResult = [];
    for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
            var so = y * sw + x;
            var a = 0;
            for (var cy = 0; cy < side; cy++) {
                for (var cx = 0; cx < side; cx++) {
                    var scy = y + cy - halfSide;
                    var scx = x + cx - halfSide;
                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                        var srcOff = scy * sw + scx;
                        var wt = weights[cy * side + cx];
                        a += mask[srcOff] * wt;
                    }
                }
            }
            maskResult[so] = a >= 255 * 4 ? 255 : 0;
        }
    }
    return maskResult;
}
function smoothEdgeMask(mask, sw, sh) {
    var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);
    var maskResult = [];
    for (var y = 0; y < sh; y++) {
        for (var x = 0; x < sw; x++) {
            var so = y * sw + x;
            var a = 0;
            for (var cy = 0; cy < side; cy++) {
                for (var cx = 0; cx < side; cx++) {
                    var scy = y + cy - halfSide;
                    var scx = x + cx - halfSide;
                    if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                        var srcOff = scy * sw + scx;
                        var wt = weights[cy * side + cx];
                        a += mask[srcOff] * wt;
                    }
                }
            }
            maskResult[so] = a;
        }
    }
    return maskResult;
}
var Mask = function (imageData) {
    var threshold = this.threshold(), mask = backgroundMask(imageData, threshold);
    if (mask) {
        mask = erodeMask(mask, imageData.width, imageData.height);
        mask = dilateMask(mask, imageData.width, imageData.height);
        mask = smoothEdgeMask(mask, imageData.width, imageData.height);
        applyMask(imageData, mask);
    }
    return imageData;
};
Mask$1.Mask = Mask;
Factory_1$6.Factory.addGetterSetter(Node_1$6.Node, 'threshold', 0, Validators_1$6.getNumberValidator(), Factory_1$6.Factory.afterSetFilter);

var Noise$1 = {};

Object.defineProperty(Noise$1, "__esModule", { value: true });
Noise$1.Noise = void 0;
var Factory_1$5 = Factory;
var Node_1$5 = Node;
var Validators_1$5 = Validators;
var Noise = function (imageData) {
    var amount = this.noise() * 255, data = imageData.data, nPixels = data.length, half = amount / 2, i;
    for (i = 0; i < nPixels; i += 4) {
        data[i + 0] += half - 2 * half * Math.random();
        data[i + 1] += half - 2 * half * Math.random();
        data[i + 2] += half - 2 * half * Math.random();
    }
};
Noise$1.Noise = Noise;
Factory_1$5.Factory.addGetterSetter(Node_1$5.Node, 'noise', 0.2, Validators_1$5.getNumberValidator(), Factory_1$5.Factory.afterSetFilter);

var Pixelate$1 = {};

Object.defineProperty(Pixelate$1, "__esModule", { value: true });
Pixelate$1.Pixelate = void 0;
var Factory_1$4 = Factory;
var Util_1 = Util;
var Node_1$4 = Node;
var Validators_1$4 = Validators;
var Pixelate = function (imageData) {
    var pixelSize = Math.ceil(this.pixelSize()), width = imageData.width, height = imageData.height, x, y, i, red, green, blue, alpha, nBinsX = Math.ceil(width / pixelSize), nBinsY = Math.ceil(height / pixelSize), xBinStart, xBinEnd, yBinStart, yBinEnd, xBin, yBin, pixelsInBin, data = imageData.data;
    if (pixelSize <= 0) {
        Util_1.Util.error('pixelSize value can not be <= 0');
        return;
    }
    for (xBin = 0; xBin < nBinsX; xBin += 1) {
        for (yBin = 0; yBin < nBinsY; yBin += 1) {
            red = 0;
            green = 0;
            blue = 0;
            alpha = 0;
            xBinStart = xBin * pixelSize;
            xBinEnd = xBinStart + pixelSize;
            yBinStart = yBin * pixelSize;
            yBinEnd = yBinStart + pixelSize;
            pixelsInBin = 0;
            for (x = xBinStart; x < xBinEnd; x += 1) {
                if (x >= width) {
                    continue;
                }
                for (y = yBinStart; y < yBinEnd; y += 1) {
                    if (y >= height) {
                        continue;
                    }
                    i = (width * y + x) * 4;
                    red += data[i + 0];
                    green += data[i + 1];
                    blue += data[i + 2];
                    alpha += data[i + 3];
                    pixelsInBin += 1;
                }
            }
            red = red / pixelsInBin;
            green = green / pixelsInBin;
            blue = blue / pixelsInBin;
            alpha = alpha / pixelsInBin;
            for (x = xBinStart; x < xBinEnd; x += 1) {
                if (x >= width) {
                    continue;
                }
                for (y = yBinStart; y < yBinEnd; y += 1) {
                    if (y >= height) {
                        continue;
                    }
                    i = (width * y + x) * 4;
                    data[i + 0] = red;
                    data[i + 1] = green;
                    data[i + 2] = blue;
                    data[i + 3] = alpha;
                }
            }
        }
    }
};
Pixelate$1.Pixelate = Pixelate;
Factory_1$4.Factory.addGetterSetter(Node_1$4.Node, 'pixelSize', 8, Validators_1$4.getNumberValidator(), Factory_1$4.Factory.afterSetFilter);

var Posterize$1 = {};

Object.defineProperty(Posterize$1, "__esModule", { value: true });
Posterize$1.Posterize = void 0;
var Factory_1$3 = Factory;
var Node_1$3 = Node;
var Validators_1$3 = Validators;
var Posterize = function (imageData) {
    var levels = Math.round(this.levels() * 254) + 1, data = imageData.data, len = data.length, scale = 255 / levels, i;
    for (i = 0; i < len; i += 1) {
        data[i] = Math.floor(data[i] / scale) * scale;
    }
};
Posterize$1.Posterize = Posterize;
Factory_1$3.Factory.addGetterSetter(Node_1$3.Node, 'levels', 0.5, Validators_1$3.getNumberValidator(), Factory_1$3.Factory.afterSetFilter);

var RGB$1 = {};

Object.defineProperty(RGB$1, "__esModule", { value: true });
RGB$1.RGB = void 0;
var Factory_1$2 = Factory;
var Node_1$2 = Node;
var Validators_1$2 = Validators;
var RGB = function (imageData) {
    var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), i, brightness;
    for (i = 0; i < nPixels; i += 4) {
        brightness =
            (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
        data[i] = brightness * red;
        data[i + 1] = brightness * green;
        data[i + 2] = brightness * blue;
        data[i + 3] = data[i + 3];
    }
};
RGB$1.RGB = RGB;
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, 'red', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, 'green', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$2.Factory.addGetterSetter(Node_1$2.Node, 'blue', 0, Validators_1$2.RGBComponent, Factory_1$2.Factory.afterSetFilter);

var RGBA$1 = {};

Object.defineProperty(RGBA$1, "__esModule", { value: true });
RGBA$1.RGBA = void 0;
var Factory_1$1 = Factory;
var Node_1$1 = Node;
var Validators_1$1 = Validators;
var RGBA = function (imageData) {
    var data = imageData.data, nPixels = data.length, red = this.red(), green = this.green(), blue = this.blue(), alpha = this.alpha(), i, ia;
    for (i = 0; i < nPixels; i += 4) {
        ia = 1 - alpha;
        data[i] = red * alpha + data[i] * ia;
        data[i + 1] = green * alpha + data[i + 1] * ia;
        data[i + 2] = blue * alpha + data[i + 2] * ia;
    }
};
RGBA$1.RGBA = RGBA;
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'red', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'green', 0, function (val) {
    this._filterUpToDate = false;
    if (val > 255) {
        return 255;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return Math.round(val);
    }
});
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'blue', 0, Validators_1$1.RGBComponent, Factory_1$1.Factory.afterSetFilter);
Factory_1$1.Factory.addGetterSetter(Node_1$1.Node, 'alpha', 1, function (val) {
    this._filterUpToDate = false;
    if (val > 1) {
        return 1;
    }
    else if (val < 0) {
        return 0;
    }
    else {
        return val;
    }
});

var Sepia$1 = {};

Object.defineProperty(Sepia$1, "__esModule", { value: true });
Sepia$1.Sepia = void 0;
var Sepia = function (imageData) {
    var data = imageData.data, nPixels = data.length, i, r, g, b;
    for (i = 0; i < nPixels; i += 4) {
        r = data[i + 0];
        g = data[i + 1];
        b = data[i + 2];
        data[i + 0] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
    }
};
Sepia$1.Sepia = Sepia;

var Solarize$1 = {};

Object.defineProperty(Solarize$1, "__esModule", { value: true });
Solarize$1.Solarize = void 0;
var Solarize = function (imageData) {
    var data = imageData.data, w = imageData.width, h = imageData.height, w4 = w * 4, y = h;
    do {
        var offsetY = (y - 1) * w4;
        var x = w;
        do {
            var offset = offsetY + (x - 1) * 4;
            var r = data[offset];
            var g = data[offset + 1];
            var b = data[offset + 2];
            if (r > 127) {
                r = 255 - r;
            }
            if (g > 127) {
                g = 255 - g;
            }
            if (b > 127) {
                b = 255 - b;
            }
            data[offset] = r;
            data[offset + 1] = g;
            data[offset + 2] = b;
        } while (--x);
    } while (--y);
};
Solarize$1.Solarize = Solarize;

var Threshold$1 = {};

Object.defineProperty(Threshold$1, "__esModule", { value: true });
Threshold$1.Threshold = void 0;
var Factory_1 = Factory;
var Node_1 = Node;
var Validators_1 = Validators;
var Threshold = function (imageData) {
    var level = this.threshold() * 255, data = imageData.data, len = data.length, i;
    for (i = 0; i < len; i += 1) {
        data[i] = data[i] < level ? 0 : 255;
    }
};
Threshold$1.Threshold = Threshold;
Factory_1.Factory.addGetterSetter(Node_1.Node, 'threshold', 0.5, Validators_1.getNumberValidator(), Factory_1.Factory.afterSetFilter);

Object.defineProperty(_FullInternals, "__esModule", { value: true });
_FullInternals.Konva = void 0;
var _CoreInternals_1 = _CoreInternals;
var Arc_1 = Arc$1;
var Arrow_1 = Arrow$1;
var Circle_1 = Circle$1;
var Ellipse_1 = Ellipse$1;
var Image_1 = Image$1;
var Label_1 = Label$1;
var Line_1 = Line$1;
var Path_1 = Path$1;
var Rect_1 = Rect$1;
var RegularPolygon_1 = RegularPolygon$1;
var Ring_1 = Ring$1;
var Sprite_1 = Sprite$1;
var Star_1 = Star$1;
var Text_1 = Text$1;
var TextPath_1 = TextPath$1;
var Transformer_1 = Transformer$1;
var Wedge_1 = Wedge$1;
var Blur_1 = Blur$1;
var Brighten_1 = Brighten$1;
var Contrast_1 = Contrast$1;
var Emboss_1 = Emboss$1;
var Enhance_1 = Enhance$1;
var Grayscale_1 = Grayscale$1;
var HSL_1 = HSL$1;
var HSV_1 = HSV$1;
var Invert_1 = Invert$1;
var Kaleidoscope_1 = Kaleidoscope$1;
var Mask_1 = Mask$1;
var Noise_1 = Noise$1;
var Pixelate_1 = Pixelate$1;
var Posterize_1 = Posterize$1;
var RGB_1 = RGB$1;
var RGBA_1 = RGBA$1;
var Sepia_1 = Sepia$1;
var Solarize_1 = Solarize$1;
var Threshold_1 = Threshold$1;
_FullInternals.Konva = _CoreInternals_1.Konva.Util._assign(_CoreInternals_1.Konva, {
    Arc: Arc_1.Arc,
    Arrow: Arrow_1.Arrow,
    Circle: Circle_1.Circle,
    Ellipse: Ellipse_1.Ellipse,
    Image: Image_1.Image,
    Label: Label_1.Label,
    Tag: Label_1.Tag,
    Line: Line_1.Line,
    Path: Path_1.Path,
    Rect: Rect_1.Rect,
    RegularPolygon: RegularPolygon_1.RegularPolygon,
    Ring: Ring_1.Ring,
    Sprite: Sprite_1.Sprite,
    Star: Star_1.Star,
    Text: Text_1.Text,
    TextPath: TextPath_1.TextPath,
    Transformer: Transformer_1.Transformer,
    Wedge: Wedge_1.Wedge,
    Filters: {
        Blur: Blur_1.Blur,
        Brighten: Brighten_1.Brighten,
        Contrast: Contrast_1.Contrast,
        Emboss: Emboss_1.Emboss,
        Enhance: Enhance_1.Enhance,
        Grayscale: Grayscale_1.Grayscale,
        HSL: HSL_1.HSL,
        HSV: HSV_1.HSV,
        Invert: Invert_1.Invert,
        Kaleidoscope: Kaleidoscope_1.Kaleidoscope,
        Mask: Mask_1.Mask,
        Noise: Noise_1.Noise,
        Pixelate: Pixelate_1.Pixelate,
        Posterize: Posterize_1.Posterize,
        RGB: RGB_1.RGB,
        RGBA: RGBA_1.RGBA,
        Sepia: Sepia_1.Sepia,
        Solarize: Solarize_1.Solarize,
        Threshold: Threshold_1.Threshold,
    },
});

(function (module, exports) {
	var Konva = _FullInternals.Konva;
	Konva._injectGlobal(Konva);
	exports['default'] = Konva;
	module.exports = exports['default'];
} (lib, lib.exports));

var konva = lib.exports;

class OntologyBuilder {
    constructor(grapholscape) {
        this.rendererState = RendererStatesEnum.FLOATY;
        this.grapholscape = grapholscape;
    }
    addNodeElement(iriString, entityType, ownerIri, relationship, functionProperties = [], datatype = '') {
        var _a, _b;
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const iri = new Iri(iriString, this.grapholscape.ontology.namespaces);
        let entity = this.grapholscape.ontology.getEntity(iriString);
        if (!entity) {
            entity = new GrapholEntity(iri);
            this.grapholscape.ontology.addEntity(entity);
        }
        let ownerEntity;
        if (ownerIri)
            ownerEntity = this.grapholscape.ontology.getEntity(ownerIri);
        if (entityType === TypesEnum.INDIVIDUAL && ownerEntity) {
            const targetId = ownerEntity.getIdInDiagram(diagram.id, TypesEnum.CLASS, this.rendererState);
            this.diagramBuilder.addIndividual(entity);
            const sourceId = entity.getIdInDiagram(diagram.id, TypesEnum.INDIVIDUAL, this.rendererState);
            if (!sourceId || !targetId)
                return;
            this.diagramBuilder.addEdge(sourceId, targetId, TypesEnum.INSTANCE_OF);
            (_a = this.grapholscape.renderer.renderState) === null || _a === void 0 ? void 0 : _a.runLayout();
            return;
        }
        if (entityType === TypesEnum.DATA_PROPERTY && ownerEntity) {
            entity.datatype = datatype;
            if (functionProperties.includes(FunctionPropertiesEnum.FUNCTIONAL)) {
                entity.isDataPropertyFunctional = true;
            }
            this.diagramBuilder.addDataProperty(entity, ownerEntity);
        }
        else if (entityType === TypesEnum.CLASS) {
            this.diagramBuilder.addClass(entity);
            if (!ownerEntity)
                return;
            if (relationship === 'superclass') {
                const sourceId = ownerEntity.getIdInDiagram(diagram.id, TypesEnum.CLASS, this.rendererState);
                const targetId = entity.getIdInDiagram(diagram.id, TypesEnum.CLASS, this.rendererState);
                if (!sourceId || !targetId)
                    return;
                this.diagramBuilder.addEdge(sourceId, targetId, TypesEnum.INCLUSION);
            }
            else if (relationship === 'subclass') {
                const sourceId = entity.getIdInDiagram(diagram.id, TypesEnum.CLASS, this.rendererState);
                const targetId = ownerEntity.getIdInDiagram(diagram.id, TypesEnum.CLASS, this.rendererState);
                if (!sourceId || !targetId)
                    return;
                this.diagramBuilder.addEdge(sourceId, targetId, TypesEnum.INCLUSION);
            }
        }
        (_b = this.grapholscape.renderer.renderState) === null || _b === void 0 ? void 0 : _b.runLayout();
        this.grapholscape.lifecycle.trigger(LifecycleEvent.EntityAddition, entity, this.diagramBuilder.diagram.id);
    }
    addEdgeElement(iriString = null, edgeType, sourceId, targetId, nodesType, functionProperties = []) {
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const sourceEntity = this.grapholscape.ontology.getEntity(sourceId);
        const targetEntity = this.grapholscape.ontology.getEntity(targetId);
        if (!sourceEntity || !targetEntity)
            return;
        if (iriString && edgeType === TypesEnum.OBJECT_PROPERTY) {
            let entity = this.grapholscape.ontology.getEntity(iriString);
            if (!entity) {
                const iri = new Iri(iriString, this.grapholscape.ontology.namespaces);
                entity = new GrapholEntity(iri);
                this.grapholscape.ontology.addEntity(entity);
            }
            this.diagramBuilder.addObjectProperty(entity, sourceEntity, targetEntity, TypesEnum.CLASS);
            entity.functionProperties = entity === null || entity === void 0 ? void 0 : entity.functionProperties.concat(functionProperties);
            this.grapholscape.lifecycle.trigger(LifecycleEvent.EntityAddition, entity, this.diagramBuilder.diagram.id);
        }
        else if (edgeType === TypesEnum.INCLUSION) {
            const sourceID = sourceEntity.getIdInDiagram(diagram.id, nodesType, this.rendererState);
            const targetID = targetEntity.getIdInDiagram(diagram.id, nodesType, this.rendererState);
            if (!sourceID || !targetID)
                return;
            this.diagramBuilder.addEdge(sourceID, targetID, edgeType);
        }
    }
    addDiagram(name) {
        const id = this.grapholscape.ontology.diagrams.length;
        const newDiagram = new Diagram(name, id);
        newDiagram.representations.set(this.rendererState, new DiagramRepresentation(floatyOptions));
        this.grapholscape.ontology.addDiagram(newDiagram);
        this.grapholscape.showDiagram(id);
        this.grapholscape.lifecycle.trigger(LifecycleEvent.DiagramAddition, newDiagram);
    }
    addSubhierarchy(iris, ownerIri, disjoint = false, complete = false) {
        var _a;
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const hierarchyID = this.diagramBuilder.getNewId('node') + '-' + diagram.id;
        const hierarchy = disjoint ? new Hierarchy(hierarchyID, TypesEnum.DISJOINT_UNION, complete) : new Hierarchy(hierarchyID, TypesEnum.UNION, complete);
        const superClass = this.grapholscape.ontology.getEntity(ownerIri);
        if (!superClass)
            return;
        hierarchy.addSuperclass(superClass);
        for (let i of iris) {
            const iri = new Iri(i, this.grapholscape.ontology.namespaces);
            let entity = this.grapholscape.ontology.getEntity(i);
            if (!entity)
                entity = new GrapholEntity(iri);
            this.grapholscape.ontology.addEntity(entity);
            hierarchy.addInput(entity);
        }
        this.diagramBuilder.addHierarchy(hierarchy, { x: 0, y: 0 });
        let subHierarchies = this.grapholscape.ontology.hierarchiesBySuperclassMap.get(ownerIri);
        if (!subHierarchies) {
            this.grapholscape.ontology.hierarchiesBySuperclassMap.set(ownerIri, [hierarchy]);
        }
        else {
            subHierarchies.push(hierarchy);
        }
        iris.forEach(inputIri => {
            let superHierarchies = this.grapholscape.ontology.hierarchiesBySubclassMap.get(inputIri);
            if (!superHierarchies) {
                this.grapholscape.ontology.hierarchiesBySubclassMap.set(inputIri, [hierarchy]);
            }
            else {
                superHierarchies.push(hierarchy);
            }
        });
        (_a = this.grapholscape.renderer.renderState) === null || _a === void 0 ? void 0 : _a.runLayout();
    }
    removeEntity(cyOccurrence, entity) {
        var _a, _b, _c;
        const diagram = this.grapholscape.renderer.diagram;
        if (diagram) {
            this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
            const grapholElem = (_a = diagram.representations.get(this.rendererState)) === null || _a === void 0 ? void 0 : _a.grapholElements.get(cyOccurrence.id());
            if (grapholElem) {
                if (cyOccurrence.isNode() && entity.is(TypesEnum.CLASS)) {
                    (_b = this.grapholscape.ontology.hierarchiesBySubclassMap.get(entity.iri.fullIri)) === null || _b === void 0 ? void 0 : _b.forEach(hierarchy => {
                        this.removeHierarchyInput(hierarchy, entity.iri.fullIri);
                    });
                    (_c = this.grapholscape.ontology.hierarchiesBySuperclassMap.get(entity.iri.fullIri)) === null || _c === void 0 ? void 0 : _c.forEach(hierarchy => {
                        this.removeHierarchySuperclass(hierarchy, entity.iri.fullIri);
                    });
                    cyOccurrence.connectedEdges(`[ type = "${TypesEnum.OBJECT_PROPERTY}" ]`).forEach(opEdge => {
                        const entity = this.grapholscape.ontology.getEntity(opEdge.data().iri);
                        if (entity) {
                            this.removeEntity(opEdge, entity);
                        }
                    });
                    cyOccurrence.neighborhood(`node[ type = "${TypesEnum.DATA_PROPERTY}" ]`).forEach(dpNode => {
                        const entity = this.grapholscape.ontology.getEntity(dpNode.data().iri);
                        if (entity) {
                            this.removeEntity(dpNode, entity);
                        }
                    });
                }
                entity.removeOccurrence(grapholElem, this.rendererState);
                this.diagramBuilder.removeElement(cyOccurrence.id());
                const occurrences = entity.occurrences.get(this.rendererState);
                if (occurrences && occurrences.length === 0) {
                    this.grapholscape.ontology.entities.delete(entity.iri.fullIri);
                }
            }
        }
    }
    removeHierarchy(hierarchy) {
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        hierarchy.inputs.forEach(i => {
            const map = this.grapholscape.ontology.hierarchiesBySubclassMap.get(i.iri.fullIri);
            map === null || map === void 0 ? void 0 : map.splice(map.findIndex(h => h.id === hierarchy.id), 1);
        });
        hierarchy.superclasses.forEach(s => {
            const hierarchies = this.grapholscape.ontology.hierarchiesBySuperclassMap.get(s.classEntity.iri.fullIri);
            hierarchies === null || hierarchies === void 0 ? void 0 : hierarchies.splice(hierarchies.findIndex(h => h.id === hierarchy.id), 1);
        });
        if (hierarchy.id)
            this.diagramBuilder.removeHierarchy(hierarchy);
    }
    removeHierarchyInput(hierarchy, inputIri) {
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const entity = this.grapholscape.ontology.getEntity(inputIri);
        if (entity) {
            hierarchy.removeInput(entity);
            this.diagramBuilder.removeHierarchyInputEdge(hierarchy, inputIri);
        }
    }
    removeHierarchySuperclass(hierarchy, superclassIri) {
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const entity = this.grapholscape.ontology.getEntity(superclassIri);
        if (entity) {
            hierarchy.removeSuperclass(entity);
            this.diagramBuilder.removeHierarchyInclusionEdge(hierarchy, superclassIri);
        }
    }
    renameEntity(oldIri, elemID, newIri) {
        var _a;
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const grapholElem = (_a = diagram.representations.get(this.rendererState)) === null || _a === void 0 ? void 0 : _a.grapholElements.get(elemID);
        let entity = this.grapholscape.ontology.getEntity(newIri);
        let iri = entity === null || entity === void 0 ? void 0 : entity.iri;
        if (!entity || !iri) {
            iri = new Iri(newIri, this.grapholscape.ontology.namespaces);
            entity = new GrapholEntity(iri);
            this.grapholscape.ontology.addEntity(entity);
        }
        this.diagramBuilder.renameElement(elemID, iri);
        if (!grapholElem)
            return;
        entity.addOccurrence(grapholElem, this.rendererState);
        const oldEntity = this.grapholscape.ontology.getEntity(oldIri.fullIri);
        if (!oldEntity)
            return;
        if (grapholElem.is(TypesEnum.CLASS)) {
            let hierarchiesIDs = [];
            let cyElem = this.diagramBuilder.getEntityCyRepr(oldEntity, grapholElem.type);
            cyElem.neighborhood(`node[type $= ${TypesEnum.UNION}]`).forEach(un => {
                hierarchiesIDs.push(un.data('hierarchyID'));
            });
            this.reassignSuperhierarchies(hierarchiesIDs, oldIri, newIri);
            this.reassignSubhierarchies(hierarchiesIDs, oldIri, newIri);
        }
        oldEntity.removeOccurrence(grapholElem, this.rendererState);
        const occurrences = oldEntity.occurrences.get(this.rendererState);
        if (occurrences && occurrences.length === 0) {
            this.grapholscape.ontology.entities.delete(oldIri.fullIri);
        }
    }
    refactorEntity(entity, elemID, newIri) {
        var _a, _b;
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        const oldIri = entity.iri.fullIri;
        const iri = new Iri(newIri, this.grapholscape.ontology.namespaces);
        const grapholElem = (_a = diagram.representations.get(this.rendererState)) === null || _a === void 0 ? void 0 : _a.grapholElements.get(elemID);
        if (grapholElem && grapholElem.is(TypesEnum.CLASS)) {
            let hierarchiesIDs = [];
            let cyElem = this.diagramBuilder.getEntityCyRepr(entity, grapholElem.type);
            cyElem.neighborhood(`node[type $= ${TypesEnum.UNION}]`).forEach(un => {
                hierarchiesIDs.push(un.data('hierarchyID'));
            });
            this.reassignSuperhierarchies(hierarchiesIDs, oldIri, newIri);
            this.reassignSubhierarchies(hierarchiesIDs, oldIri, newIri);
        }
        entity.iri = iri;
        this.grapholscape.ontology.addEntity(entity);
        (_b = entity.occurrences.get(this.rendererState)) === null || _b === void 0 ? void 0 : _b.forEach(o => this.diagramBuilder.renameElement(o.id, iri));
        this.grapholscape.ontology.entities.delete(oldIri);
    }
    reassignSuperhierarchies(hierarchiesIDs, oldIri, newIri) {
        let superhierarchies = this.grapholscape.ontology.hierarchiesBySuperclassMap.get(oldIri.fullIri);
        if (superhierarchies) {
            let oldSuperhierarchies = superhierarchies.filter(h => {
                if (h.id) {
                    return !hierarchiesIDs.includes(h.id);
                }
            });
            let newSuperhierarchies = superhierarchies.filter(h => {
                if (h.id) {
                    return hierarchiesIDs.includes(h.id);
                }
            });
            this.grapholscape.ontology.hierarchiesBySuperclassMap.set(oldIri.fullIri, oldSuperhierarchies);
            this.grapholscape.ontology.hierarchiesBySuperclassMap.set(newIri, newSuperhierarchies);
        }
    }
    reassignSubhierarchies(hierarchiesIDs, oldIri, newIri) {
        let subhierarchies = this.grapholscape.ontology.hierarchiesBySubclassMap.get(oldIri.fullIri);
        if (subhierarchies) {
            let oldSubhierarchies = subhierarchies.filter(h => {
                if (h.id) {
                    return !hierarchiesIDs.includes(h.id);
                }
            });
            let newSubhierarchies = subhierarchies.filter(h => {
                if (h.id) {
                    return hierarchiesIDs.includes(h.id);
                }
            });
            this.grapholscape.ontology.hierarchiesBySubclassMap.set(oldIri.fullIri, oldSubhierarchies);
            this.grapholscape.ontology.hierarchiesBySubclassMap.set(newIri, newSubhierarchies);
        }
    }
    toggleFunctionality(iri) {
        const entity = this.grapholscape.ontology.getEntity(iri);
        if (entity === null || entity === void 0 ? void 0 : entity.hasFunctionProperty(FunctionPropertiesEnum.FUNCTIONAL)) {
            entity.functionProperties = [];
        }
        else {
            entity === null || entity === void 0 ? void 0 : entity.functionProperties.push(FunctionPropertiesEnum.FUNCTIONAL);
        }
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        if (entity)
            this.diagramBuilder.toggleFunctionality(entity, entity === null || entity === void 0 ? void 0 : entity.hasFunctionProperty(FunctionPropertiesEnum.FUNCTIONAL));
    }
    toggleUnion(elem) {
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        this.diagramBuilder.toggleUnion(elem);
    }
    toggleComplete(elem) {
        const diagram = this.grapholscape.renderer.diagram;
        this.diagramBuilder = new DiagramBuilder(diagram, this.rendererState);
        this.diagramBuilder.toggleComplete(elem);
    }
}

const { ModalMixin: ModalMixin$2, BaseMixin: BaseMixin$2, icons: icons$4, baseStyle: baseStyle$2, } = UI;
class GscapeAnnotationsModal extends ModalMixin$2(BaseMixin$2(s)) {
    constructor(dialogTitle, entityType, annotations) {
        super();
        this.dialogTitle = dialogTitle;
        this.entityType = entityType;
        this.annotations = annotations;
        this.onCancel = () => { };
        this.deleteAnnotation = () => { };
        this.initEditAnnotation = () => { };
        this.handleCancel = () => {
            this.onCancel();
        };
        this.handleDeleteAnnotation = (annotation) => {
            this.deleteAnnotation(annotation);
        };
        this.handleEditAnnotation = (annotation) => {
            this.initEditAnnotation(annotation);
        };
    }
    render() {
        return x `
            <div>          
                <div class="gscape-panel">
                    <div class="header" style="margin: 8px 8px 8px 8px; display:flex; justify-content:space-between; align-items: center;">
                        <span class="slotted-icon">${icons$4.entityIcons[this.entityType]}${this.dialogTitle}</span>
                        <gscape-button style = "border-radius: 50%;" size='s' id ="more" label="+" @click=${() => this.handleEditAnnotation()}></gscape-button>
                    </div>
                    <div class=area style="min-height: 200px;">
                        ${this.annotations.map((a, i) => {
            return x `<div style="margin: 8px 8px 8px 8px; display:flex; justify-content:space-between;" id=ann${i}>
                                            <div class=annotation-row style="margin: 8px 8px 8px 8px;">
                                                <b>${a.kind.charAt(0).toUpperCase() + a.kind.slice(1)}</b> 
                                                <span class="language muted-text bold-text"> @${a.language} </span>
                                                <span> ${a.lexicalForm} </span>
                                            </div>    
                                            <div>
                                                <gscape-button style = "border-radius: 50%;" size='s' id ="editAnnotation" @click=${() => this.handleEditAnnotation(a)}><span slot="icon">${icons$4.editIcon}</span></gscape-button>
                                                <gscape-button style = "border-radius: 50%;" size='s' id ="deleteAnnotation" @click=${() => this.handleDeleteAnnotation(a)}><span slot="icon">${icons$4.rubbishBin}</span></gscape-button>
                                            </div>
                                        </div>`;
        })}
                    </div>
                    <div class="buttons" style="display: flex; justify-content: center; align-items: center;" id="buttons">
                        <gscape-button size='s' id="ok" label="Ok" @click=${this.handleCancel}></gscape-button>
                    </div>
                </div>
            </div>
            `;
    }
}
GscapeAnnotationsModal.properties = {
    dialogTitle: { type: String },
    entityType: { type: String },
    annotations: { type: Array }
};
GscapeAnnotationsModal.styles = [
    baseStyle$2,
    i$1 `
        :host {
            position: absolute;
            }
        .drawing-btn {
            position: absolute;
            top: 50px;
            left: 10px;
            border-radius: var(--gscape-border-radius-btn);
            border: 1px solid var(--gscape-color-border-subtle);
            background-color: var(--gscape-color-bg-default);
        }

        .gscape-panel {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translate(-50%);
            max-width: 400px;
            min-width: 300px;
            }
    
            .header, .dialog-message {
            margin: 8px;
            font-size: 15px;
            }
    
            .dialog-message {
            padding: 8px;
            margin-bottom: 16px;
            }
    
            .buttons {
            display: flex;
            align-items: center;
            justify-content: right;
            gap: 8px;
            }

            .dropdown {
            position: relative;
            width: 78%; 
            margin: 8px 8px 8px 8px ;
            border: solid 1px var(--gscape-color-border-subtle);
            border-radius: var(--gscape-border-radius);
            }
            
            .dropdown select {
            width: 100%;
            }
            
            .dropdown > * {
            box-sizing: border-box;
            height: 100%;
            border: none;
            }
            
            .dropdown input {
            position: absolute;
            width: calc(100% - 18px);
            }

            .dropdown select:focus, .dropdown input:focus {
            border-color: inherit;
            -webkit-box-shadow: none;
            box-shadow: none;
            }
        `
];
customElements.define('gscape-annotations', GscapeAnnotationsModal);

/**
 * Apply stylesheet for edge handling during edge drawing in builder
 * @param cy cytoscape instance
 * @param theme current grapholscape's theme
 * @param creationEdgeType the kind of edge that is going to be shown
 */
function applyEdgeDrawStyle (cy, theme, creationEdgeType) {
    const ehGhostEdgeStyles = {
        [TypesEnum.INCLUSION]: {
            'target-arrow-shape': 'triangle',
        },
        [TypesEnum.OBJECT_PROPERTY]: {
            'line-color': theme.getColour(ColoursNames.object_property_contrast),
            'source-arrow-color': theme.getColour(ColoursNames.object_property_contrast),
            'target-arrow-color': theme.getColour(ColoursNames.object_property_contrast),
            'target-arrow-shape': 'triangle',
            'target-arrow-fill': 'filled',
            'source-arrow-shape': 'square',
            'source-arrow-fill': 'hollow',
            'width': 4,
        },
        [TypesEnum.INPUT]: {
            'line-style': 'solid',
            'target-arrow-shape': 'none',
        },
        [TypesEnum.INSTANCE_OF]: {
            "target-arrow-shape": 'triangle',
            'target-arrow-fill': 'filled',
            'line-color': theme.getColour(ColoursNames.individual),
            'target-arrow-color': theme.getColour(ColoursNames.individual_contrast),
            'line-opacity': 0.4,
        },
        [TypesEnum.UNION]: {
            'width': 6,
            'line-style': 'solid',
            'target-arrow-shape': 'triangle',
            'target-arrow-fill': 'hollow',
        },
        [TypesEnum.COMPLETE_UNION]: {
            'width': 6,
            'line-style': 'solid',
            'target-arrow-shape': 'triangle',
            'target-arrow-fill': 'hollow',
            'target-label': "C",
            'text-background-color': theme.getColour(ColoursNames.bg_graph),
            'text-background-opacity': 1,
            'text-background-shape': 'roundrectangle',
            'text-background-padding': '2',
            'font-size': 15,
            'target-text-offset': 20,
        },
        [TypesEnum.DISJOINT_UNION]: {
            'width': 6,
            'line-style': 'solid',
            'target-arrow-shape': 'triangle',
            'target-arrow-fill': 'filled',
        },
        [TypesEnum.COMPLETE_DISJOINT_UNION]: {
            'width': 6,
            'line-style': 'solid',
            'target-arrow-shape': 'triangle',
            'target-arrow-fill': 'filled',
            'target-label': "C",
            'text-background-color': theme.getColour(ColoursNames.bg_graph),
            'text-background-opacity': 1,
            'text-background-shape': 'roundrectangle',
            'text-background-padding': '2',
            'font-size': 15,
            'target-text-offset': 20,
        },
    };
    // Base style valid for any kind of ghost edge
    const ehGhostEdgeStyle = {
        'opacity': 0.8,
        'text-rotation': 'autorotate',
    };
    // apply styling based on ghost edge type
    if (ehGhostEdgeStyles[creationEdgeType]) {
        Object.assign(ehGhostEdgeStyle, ehGhostEdgeStyles[creationEdgeType]);
    }
    const ehStyle = [
        {
            selector: '.eh-ghost-edge',
            style: ehGhostEdgeStyle
        },
        {
            selector: '.eh-ghost-edge.eh-preview-active',
            style: {
                'opacity': 0,
            }
        },
        {
            selector: '.eh-target, .eh-source',
            style: {
                'border-width': 4,
            }
        },
        {
            selector: '.eh-presumptive-target',
            style: {
                'opacity': 1,
            }
        },
        {
            selector: '.eh-not-target',
            style: {
                'opacity': 0.4,
            }
        },
    ];
    /**
     * Update style to change ghost edge styling based on edge-creation-type.
     * Could be done assigning here the type field to the ghost edge
     * but this event is fired before the creation of such edge, should use
     * a long enough timeout but trying it results in a poor UX.
     * So just update style with new values for .eh-ghost-edge.
     */
    const previousStyle = floatyStyle(theme);
    cy.style().resetToDefault().fromJson([
        ...previousStyle,
        ...ehStyle
    ]).update();
}

var edgeHandlesDefaults = (edgeType) => {
    return {
        canConnect: function (sourceNode, targetNode) {
            const sourceType = sourceNode.data('type');
            const targetType = targetNode.data('type');
            switch (sourceType) {
                case TypesEnum.CLASS:
                    return targetType === TypesEnum.CLASS;
                case TypesEnum.CLASS:
                case TypesEnum.UNION:
                case TypesEnum.DISJOINT_UNION:
                    return targetType === TypesEnum.CLASS;
                case TypesEnum.DATA_PROPERTY:
                    return targetType === TypesEnum.DATA_PROPERTY;
                default:
                    return false;
            }
        },
        edgeParams: function (sourceNode, targetNode) {
            let temp_id = 'temp_' + sourceNode.data('iri') + '-' + targetNode.data('iri');
            if (sourceNode.data('type') === TypesEnum.UNION || sourceNode.data('type') === TypesEnum.DISJOINT_UNION) {
                temp_id = 'temp_' + sourceNode.data('id') + '-' + targetNode.data('iri');
            }
            return {
                data: {
                    id: temp_id,
                    name: temp_id,
                    source: sourceNode.id(),
                    target: targetNode.id(),
                    type: edgeType,
                    targetLabel: edgeType === TypesEnum.COMPLETE_UNION ||
                        edgeType === TypesEnum.COMPLETE_DISJOINT_UNION ? 'C' : undefined,
                }
            };
        },
        hoverDelay: 150,
        snap: true,
        snapThreshold: 50,
        snapFrequency: 15,
        noEdgeEventsInDraw: true,
        disableBrowserGestures: true, // during an edge drawing gesture, disable browser gestures such as two-finger trackpad swipe and pinch-to-zoom
    };
};

const { ModalMixin: ModalMixin$1, BaseMixin: BaseMixin$1, icons: icons$3, baseStyle: baseStyle$1, SizeEnum, } = UI;
const datatypes = ['owl:real', 'owl:rational', 'xsd:decimal', 'xsd:integer',
    'xsd:nonNegativeInteger', 'xsd:nonPositiveInteger',
    'xsd:positiveInteger', 'xsd:negativeInteger', 'xsd:long',
    'xsd:int', 'xsd:short', 'xsd:byte', 'xsd:unsignedLong',
    'xsd:unsignedInt', 'xsd:unsignedShort', 'xsd:unsignedByte',
    'xsd:double', 'xsd:float', 'xsd:string',
    'xsd:normalizedString', 'xsd:token', 'xsd:language', 'xsd:Name',
    'xsd:NCName', 'xsd:NMTOKEN', 'xsd:boolean', 'xsd:hexBinary',
    'xsd:base64Binary',
    'xsd:dateTime', 'xsd:dateTimeStamp', 'rdf:XMLLiteral',
    'rdf:PlainLiteral', 'rdfs:Literal', 'xsd:anyURI'];
var ModalTypeEnum;
(function (ModalTypeEnum) {
    ModalTypeEnum["DIAGRAM"] = "diagram";
    ModalTypeEnum["HIERARCHY"] = "hierarchy";
    ModalTypeEnum["ISA"] = "isa";
    ModalTypeEnum["RENAME_ENTITY"] = "rename";
})(ModalTypeEnum || (ModalTypeEnum = {}));
const modalIcons = {
    [ModalTypeEnum.DIAGRAM]: icons$3.diagrams,
    [ModalTypeEnum.HIERARCHY]: icons$3.subHierarchies,
    [ModalTypeEnum.ISA]: icons$3.addISAIcon,
    [ModalTypeEnum.RENAME_ENTITY]: icons$3.renameIcon,
};
class GscapeNewElementModal extends ModalMixin$1(BaseMixin$1(s)) {
    /**
     *
     * @param modalType The type of the modal, this value changes the form template.
     * it can be a TypesEnum for defining new Entities or ModalTypeEnum for other
     * types of elements to define or actions to perform
     * @param dialogTitle
     */
    constructor(modalType, dialogTitle) {
        super();
        this.modalType = modalType;
        this.dialogTitle = dialogTitle;
        this.onCancel = () => { };
        this.namespaces = [];
        this.remainderToRename = '';
        this.selectedNamespaceIndex = 0;
        this.advancedMode = false;
        this.selectedDatatype = 'xsd:string';
        this.selectedFunctionProperties = new Set();
        this.numberOfInputs = 2;
        this.isValid = false;
        this.isHierarchyComplete = false;
        this.isHierarchyDisjoint = false;
        this.isaDirection = 'subclass';
        /**
         * If the form is valid, dispatch the 'confirm' event setting
         * the `detail` field based on the modalType.
         * The form can be invalid in case the confirm is requested by
         * keyboard.
         * Can't be invalid if this is triggered by buttons cause they
         * are disabled if form is not valid.
         */
        this.handleConfirm = (evt) => __awaiter(this, void 0, void 0, function* () {
            if (this.isValid) {
                yield this.updateComplete;
                let eventDetail;
                switch (this.modalType) {
                    case TypesEnum.CLASS:
                    case TypesEnum.INDIVIDUAL:
                        if (this.selectedNamespaceValue && this.mainInputValue) {
                            eventDetail = {
                                iri: this.selectedNamespaceValue + this.mainInputValue,
                                namespace: this.selectedNamespaceValue,
                                type: this.modalType,
                            };
                        }
                        break;
                    case TypesEnum.DATA_PROPERTY:
                        if (this.selectedNamespaceValue && this.mainInputValue) {
                            eventDetail = {
                                iri: this.selectedNamespaceValue + this.mainInputValue,
                                namespace: this.selectedNamespaceValue,
                                type: this.modalType,
                                isFunctional: this.selectedFunctionProperties.has(FunctionPropertiesEnum.FUNCTIONAL),
                                datatype: this.selectedDatatype,
                            };
                        }
                        break;
                    case TypesEnum.OBJECT_PROPERTY:
                        if (this.selectedNamespaceValue && this.mainInputValue) {
                            eventDetail = {
                                iri: this.selectedNamespaceValue + this.mainInputValue,
                                namespace: this.selectedNamespaceValue,
                                type: this.modalType,
                                functionProperties: Array.from(this.selectedFunctionProperties),
                            };
                        }
                        break;
                    case ModalTypeEnum.DIAGRAM:
                        if (this.mainInputValue) {
                            eventDetail = {
                                diagramName: this.mainInputValue,
                            };
                        }
                        break;
                    case ModalTypeEnum.RENAME_ENTITY:
                        const selectedBtn = evt === null || evt === void 0 ? void 0 : evt.currentTarget;
                        eventDetail = {
                            newIri: this.selectedNamespaceValue + (this.mainInputValue || this.remainderToRename),
                            namespace: this.selectedNamespaceValue,
                            isRefactor: (selectedBtn === null || selectedBtn === void 0 ? void 0 : selectedBtn.id) === 'refactor' || false
                        };
                        break;
                    case ModalTypeEnum.HIERARCHY:
                        const newClassesNames = this.hierarchyInputValues;
                        if (this.selectedNamespaceValue && newClassesNames.length >= 2) {
                            eventDetail = {
                                inputClassesIri: newClassesNames.map(iri => this.selectedNamespaceValue + iri),
                                namespace: this.selectedNamespaceValue,
                                isComplete: this.isHierarchyComplete,
                                isDisjoint: this.isHierarchyDisjoint,
                            };
                        }
                        break;
                    case ModalTypeEnum.ISA:
                        if (this.selectedNamespaceValue && this.mainInputValue) {
                            eventDetail = {
                                iri: this.selectedNamespaceValue + this.mainInputValue,
                                namespace: this.selectedNamespaceValue,
                                type: TypesEnum.CLASS,
                                isaDirection: this.isaDirection,
                            };
                        }
                        break;
                }
                if (eventDetail) {
                    this.dispatchEvent(new CustomEvent('confirm', {
                        bubbles: true,
                        composed: true,
                        detail: eventDetail
                    }));
                }
            }
        });
        this.handleCancel = () => {
            this.onCancel();
            this.remove();
        };
        // Set the standard keyup event listener on the whole component
        // equal to <gscape-new-element-modal @keyup=${...}>...</gscape-new-element-modal>
        this.handleKeyUp = (evt) => {
            if (evt.key === 'Enter') { // keyCode deprecated
                this.handleConfirm();
            }
            else if (evt.key === 'Escape') {
                this.handleCancel();
            }
        };
    }
    validate() {
        var _a, _b;
        const mainInputLength = ((_a = this.mainInputValue) === null || _a === void 0 ? void 0 : _a.length) || 0;
        const nameSpaceInputLength = ((_b = this.selectedNamespaceValue) === null || _b === void 0 ? void 0 : _b.length) || 0;
        switch (this.modalType) {
            case TypesEnum.CLASS:
            case TypesEnum.DATA_PROPERTY:
            case TypesEnum.OBJECT_PROPERTY:
            case TypesEnum.INDIVIDUAL:
            case ModalTypeEnum.ISA:
                this.isValid = mainInputLength > 0 && nameSpaceInputLength > 0;
                break;
            case ModalTypeEnum.RENAME_ENTITY:
                if (this.advancedMode) {
                    // in advanced mode, you can rename/refactor only the namespace
                    this.isValid = nameSpaceInputLength > 0;
                }
                else {
                    // In basic mode, you must rename remainder to submit
                    this.isValid = mainInputLength > 0 && nameSpaceInputLength > 0;
                }
                break;
            case ModalTypeEnum.DIAGRAM:
                this.isValid = mainInputLength > 0;
                break;
            case ModalTypeEnum.HIERARCHY:
                this.isValid =
                    this.hierarchyInputValues.length >= 2 &&
                        nameSpaceInputLength > 0;
                break;
        }
    }
    toggleAdvanced() {
        this.advancedMode = !this.advancedMode;
    }
    handleNamespaceSelection(e) {
        var _a;
        const selectTarget = e.currentTarget;
        if (selectTarget) {
            const namespaceInput = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#newnamespace');
            const index = parseInt(selectTarget.value);
            this.selectedNamespaceIndex = !Number.isNaN(index) ? index : undefined;
            namespaceInput.value = this.selectedNamespaceIndex !== undefined
                ? this.namespaces[this.selectedNamespaceIndex].toString()
                : '';
            namespaceInput.focus();
        }
        this.validate();
    }
    handleNamespaceInput(e) {
        const inputTarget = e.currentTarget;
        if (inputTarget) {
            this.selectedNamespaceIndex = undefined;
        }
        this.validate();
    }
    handleDataTypeSelection(e) {
        const selectTarget = e.currentTarget;
        if (selectTarget) {
            this.selectedDatatype = selectTarget.value;
        }
    }
    handleFunctionPropertyClick(e) {
        const chip = e.currentTarget;
        if (chip) {
            const property = chip.id;
            if (this.selectedFunctionProperties.has(property)) {
                this.selectedFunctionProperties.delete(property);
            }
            else {
                this.selectedFunctionProperties.add(property);
            }
            this.requestUpdate();
        }
    }
    getNamespacesTemplate() {
        var _a;
        return x `
      <div class="form-item">
        <label id="namespace-label" for="newnamespace">Namespace:</label>
        <div class="dropdown">
          <input
            id="newnamespace"
            value=${this.selectedNamespaceIndex !== undefined ? this.namespaces[this.selectedNamespaceIndex] : ''}
            @input=${this.handleNamespaceInput}
            type="text"
          />
          <select id="namespace" name="namespace" value=${this.selectedNamespaceValue} @change=${this.handleNamespaceSelection} required>
            ${(_a = this.namespaces) === null || _a === void 0 ? void 0 : _a.map((n, i) => {
            return x `<option value=${i} ?selected=${i === this.selectedNamespaceIndex}>${n.toString()}</option>`;
        })}
            <option value="" ?selected=${this.selectedNamespaceIndex === undefined}></option>
          </select>
        </div>
      </div>
    `;
    }
    getMainInput() {
        return x `
      <div class="form-item">
        <label for="input">Name:</label>
        <input
          id="input"
          type="text"
          @input=${this.validate}
          required
          placeholder=${this.remainderToRename}
        />
      </div>
    `;
    }
    newDataPropertyForm() {
        return x `
      ${this.advancedMode ? this.getNamespacesTemplate() : null}
      ${this.getMainInput()}

      <div class="form-item">
        <label id="datatype-label" for="datatype">Datatype:</label>
        <select id="datatype" name="datatype" required @change=${this.handleDataTypeSelection}>
          ${datatypes.sort().map(datatype => x `
            <option value=${datatype} ?selected=${this.selectedDatatype === datatype} >${datatype}</option>
          `)}
        </select>
      </div>

      <div class="form-item" style="margin-top: 4px">
        ${this.getFunctionPropertyChip(FunctionPropertiesEnum.FUNCTIONAL)}
      </div>
    `;
    }
    newOBjectPropertyForm() {
        return x `
      ${this.advancedMode ? this.getNamespacesTemplate() : null}
      ${this.getMainInput()}
      
      <div id="function-properties" class="form-item">
        <label>Properties</label>
        <div>
          ${this.advancedMode
            ? Object.values(FunctionPropertiesEnum).map(f => this.getFunctionPropertyChip(f))
            : x `
              ${this.getFunctionPropertyChip(FunctionPropertiesEnum.FUNCTIONAL)}
              ${this.getFunctionPropertyChip(FunctionPropertiesEnum.INVERSE_FUNCTIONAL)}
            `}
        </div>
      </div>
    `;
    }
    newISAForm() {
        const toggleISADirection = () => {
            this.isaDirection = this.isaDirection === 'subclass' ? 'superclass' : 'subclass';
        };
        return x `
      ${this.advancedMode ? this.getNamespacesTemplate() : null}
      ${this.getMainInput()}

      <div class="form-item" style="align-self: center">
        <gscape-button
          label=${`As ${this.isaDirection.charAt(0).toUpperCase().concat(this.isaDirection.slice(1))}`}
          size=${SizeEnum.S}
          type='subtle'
          @click=${toggleISADirection}
        >
          <span slot="icon">
            ${this.isaDirection === 'superclass'
            ? superHierarchies
            : subHierarchies}
          </span>
        </gscape-button>
      </div>
    `;
    }
    newEntityForm() {
        return x `
      ${this.advancedMode ? this.getNamespacesTemplate() : null}
      ${this.getMainInput()}
    `;
    }
    newDiagramForm() {
        return x `
      <div class="form-item">
        <label for="input">Diagram Name:</label>
        <input id="input"
          type="text"
          @input=${this.validate}
          name="input"
          required
        >
      </div>
    `;
    }
    newSubHierarchyForm() {
        const inputs = [];
        for (let i = 0; i < this.numberOfInputs; i += 1) {
            inputs.push(x `
        <input
          class="subclass-input"
          style="margin-bottom: 8px;"
          type="text"
          @input=${this.validate}
          name="input"
        />
      `);
        }
        const onAdd = () => this.numberOfInputs += 1;
        const toggleComplete = (e) => {
            e.preventDefault();
            this.isHierarchyComplete = !this.isHierarchyComplete;
        };
        const toggleDisjoint = (e) => {
            e.preventDefault();
            this.isHierarchyDisjoint = !this.isHierarchyDisjoint;
        };
        return x `
      ${this.advancedMode ? this.getNamespacesTemplate() : null}

      <div class="form-item">
        <label>Sub Classes:</label>
        ${inputs}
      </div>

      <gscape-button style="align-self: center;" title="Add Subclass" @click=${onAdd} size=${SizeEnum.S}>
        <span slot="icon">${icons$3.plus}</span>
      </gscape-button>

      <div id ="hierarchy-toggles" class="form-item">
        <gscape-toggle
          class="actionable"
          label="Complete"
          @click=${toggleComplete}
          ?checked=${this.isHierarchyComplete}>
        </gscape-toggle>
        <gscape-toggle
          class="actionable"
          label="Disjoint"
          @click=${toggleDisjoint}
          ?checked=${this.isHierarchyDisjoint}>
        </gscape-toggle>
      </div>
    `;
    }
    getForm() {
        switch (this.modalType) {
            case TypesEnum.DATA_PROPERTY:
                return this.newDataPropertyForm();
            case TypesEnum.OBJECT_PROPERTY:
                return this.newOBjectPropertyForm();
            case TypesEnum.INDIVIDUAL:
            case TypesEnum.CLASS:
            case ModalTypeEnum.RENAME_ENTITY:
                return this.newEntityForm();
            case ModalTypeEnum.ISA:
                return this.newISAForm();
            case ModalTypeEnum.DIAGRAM:
                return this.newDiagramForm();
            case ModalTypeEnum.HIERARCHY:
                return this.newSubHierarchyForm();
            default:
                return null;
        }
    }
    getFunctionPropertyChip(property) {
        return x `
      <span
        id=${property}
        class="chip actionable"
        @click=${this.handleFunctionPropertyClick}
        ?selected=${this.selectedFunctionProperties.has(property)}
      >
        ${this.selectedFunctionProperties.has(property) ? x `&#10003; ` : null} ${property}
      </span>
    `;
    }
    get hierarchyInputValues() {
        var _a;
        const values = [];
        const inputs = (((_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('form input.subclass-input')) || []);
        for (let input of inputs) {
            if (input.value && input.value.length > 0) {
                values.push(input.value);
            }
        }
        return values;
    }
    get selectedNamespaceValue() {
        var _a, _b, _c;
        if (((_a = this.namespaces) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
            this.selectedNamespaceIndex !== undefined &&
            this.namespaces[this.selectedNamespaceIndex])
            return this.namespaces[this.selectedNamespaceIndex].toString();
        else
            return (_c = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('#newnamespace')) === null || _c === void 0 ? void 0 : _c.value;
    }
    get mainInputValue() {
        var _a, _b;
        return (_b = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#input')) === null || _b === void 0 ? void 0 : _b.value;
    }
    get isAdvanceAllowed() {
        switch (this.modalType) {
            case TypesEnum.CLASS:
            case TypesEnum.DATA_PROPERTY:
            case TypesEnum.OBJECT_PROPERTY:
            case TypesEnum.INDIVIDUAL:
            case ModalTypeEnum.HIERARCHY:
            case ModalTypeEnum.ISA:
            case ModalTypeEnum.RENAME_ENTITY:
                return true;
            default:
                return false;
        }
    }
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('keyup', this.handleKeyUp);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener('keyup', this.handleKeyUp);
    }
    render() {
        const headerIcon = icons$3.entityIcons[this.modalType] || modalIcons[this.modalType];
        return x `
      <div class="gscape-panel">
        <div class="header">
          ${headerIcon ? x `<span class="slotted-icon">${headerIcon}</span>` : null}
          <span>${this.dialogTitle}</span>
        </div>
        <form
          id="new-element-form"
          action= "javascript:void(0);"
          autocomplete="off"
        >
          ${this.getForm()}
        </form>
        <div class="buttons" id="buttons">
            ${this.isAdvanceAllowed
            ? x `
                <span
                  class="actionable muted-text"
                  @click=${this.toggleAdvanced}
                  style="margin-right: auto; text-decoration: underline; align-self: end; flex-shrink: 0;"
                >
                  ${this.advancedMode ? "Base settings" : "Advanced settings"}
                </span>
              `
            : null}
            <gscape-button label="Cancel" type="subtle" size=${SizeEnum.S} @click=${this.handleCancel}></gscape-button>
            <gscape-button
              id="ok"
              label="${this.modalType === ModalTypeEnum.RENAME_ENTITY ? 'Rename' : 'Ok'}"
              @click=${this.handleConfirm}
              ?disabled=${!this.isValid}
            ></gscape-button>

            ${this.modalType === ModalTypeEnum.RENAME_ENTITY
            ? x `
                <gscape-button
                  id="refactor"
                  label="Refactor"
                  @click=${this.handleConfirm}
                  ?disabled=${!this.isValid}
                ></gscape-button>
              `
            : null}

        </div>
      </div>
    `;
    }
}
GscapeNewElementModal.properties = {
    dialogTitle: { type: String },
    namespaces: { type: Array },
    advancedMode: { type: Boolean, state: true },
    selectedNamespaceIndex: { type: Number, state: true },
    isValid: { type: Boolean, state: true },
    isHierarchyComplete: { type: Boolean, state: true },
    isHierarchyDisjoint: { type: Boolean, state: true },
    numberOfInputs: { type: Number, state: true },
    isaDirection: { type: String, state: true },
};
GscapeNewElementModal.styles = [
    baseStyle$1,
    i$1 `
      :host {
        position: absolute;
      }
      .drawing-btn {
        position: absolute;
        top: 50px;
        left: 10px;
        border-radius: var(--gscape-border-radius-btn);
        border: 1px solid var(--gscape-color-border-subtle);
        background-color: var(--gscape-color-bg-default);
      }

      .gscape-panel {
        position: absolute;
        top: 100px;
        left: 50%;
        transform: translate(-50%);
        max-width: 30%;
        min-width: 300px;
        max-height: calc(90% - 100px);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        gap: 16px;
      }

      form {
        padding: 0 16px;
        flex-grow: 2;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow: auto;
      }

      .header {
        margin: 2px 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .form-item > label {
        display: block;
        margin-bottom: 4px
      }

      .form-item input {
        display: block;
        width: 100%;
      }

      .buttons {
        display: flex;
        align-items: center;
        justify-content: right;
        gap: 8px;
        flex-wrap: wrap;
      }

      .dropdown {
        position: relative;
        border: solid 1px var(--gscape-color-border-subtle);
        border-radius: var(--gscape-border-radius);
      }

      .dropdown select {
        width: 100%;
      }

      .dropdown > * {
        box-sizing: border-box;
        height: 100%;
        border: none;
      }

      .dropdown input {
        position: absolute;
        width: calc(100% - 18px);
      }

      .dropdown select:focus, .dropdown input:focus {
        border-color: inherit;
        -webkit-box-shadow: none;
        box-shadow: none;
      }

      .chip {
        width: fit-content;
        border: 1px solid var(--gscape-color-neutral-muted);
        color: unset;
        background: var(--gscape-color-neutral);
      }

      .chip[selected] {
        border: 1px solid var(--gscape-color-accent);
        color: var(--gscape-color-accent);
        background: var(--gscape-color-accent-subtle);
      }

      #hierarchy-toggles {
        display: flex;
        justify-content: center;
      }

      #hierarchy-toggles > * {
        width: fit-content;
      }
    `
];
customElements.define('gscape-new-element', GscapeNewElementModal);

function ontologyModelToViewData(ontologyModelData) {
    let ontologyViewData = {
        name: ontologyModelData.name,
        typeOrVersion: new Set([ontologyModelData.version]),
        iri: ontologyModelData.iri || '',
        namespaces: ontologyModelData.namespaces,
        annotations: ontologyModelData.annotations,
    };
    return ontologyViewData;
}

const { ModalMixin, BaseMixin, icons: icons$2, baseStyle, } = UI;
const languages = ['it', 'es', 'en', 'de', 'fr'];
class GscapeAnnotationModal extends ModalMixin(BaseMixin(s)) {
    constructor(annotation) {
        super();
        this.annotation = annotation;
        this.onConfirm = () => { };
        this.onCancel = () => { };
        this.handleConfirm = () => {
            var _a, _b, _c, _d, _e;
            let myform = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#new-annotation-form');
            if (myform) {
                const propertyInput = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('#newproperty');
                const lexicalFormInput = (_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.querySelector('#lexicalform');
                const datatypeInput = (_d = this.shadowRoot) === null || _d === void 0 ? void 0 : _d.querySelector('#datatype');
                const languageInput = (_e = this.shadowRoot) === null || _e === void 0 ? void 0 : _e.querySelector('#newlan');
                this.onConfirm(this.annotation, propertyInput.value, lexicalFormInput.value, datatypeInput.value, languageInput.value);
                this.resetForm();
            }
        };
        this.handleCancel = () => {
            this.onCancel();
            this.resetForm();
        };
        this.resetForm = () => {
            var _a, _b, _c;
            let myform = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('#new-annotation-form');
            this.annotation = undefined;
            if (myform) {
                myform.reset();
            }
            (_c = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('#ok')) === null || _c === void 0 ? void 0 : _c.setAttribute('disabled', 'true');
        };
    }
    render() {
        var _a, _b, _c, _d;
        return x `
            <div>          
                <div class="gscape-panel">
                    <div class="header">
                    Edit Annotation
                    </div>
                    <form id= "new-annotation-form" action= "javascript:void(0);" onkeyup="if (event.keyCode === 13 && !this.offsetParent.querySelector('#ok').disabled) this.offsetParent.querySelector('#ok').click();">
                        <label style = "width: 95%; margin: 8px 8px 8px 8px ;" id="property-label" for="property"><b>Property:</b></label><br>
                        <div class="dropdown">
                            <input id="newproperty" value="${(_a = this.annotation) === null || _a === void 0 ? void 0 : _a.property}" type="text" oninput="if(this.value.length > 0 && this.offsetParent.offsetParent.querySelector('#lexicalform').value.length > 0) {this.offsetParent.offsetParent.querySelector('#ok').disabled = false;} else {this.offsetParent.offsetParent.querySelector('#ok').disabled = true;}"/>
                            <select 
                              id="property" onchange="this.offsetParent.querySelector('#newproperty').value=this.value; this.offsetParent.querySelector('#newproperty').focus(); if(this.offsetParent.offsetParent.querySelector('#lexicalform').value.length > 0){this.offsetParent.offsetParent.querySelector('#ok').disabled = false;} " name="property" value="${(_b = this.annotation) === null || _b === void 0 ? void 0 : _b.property}" required>
                                ${Object.values(AnnotationProperty).sort().map((property, i) => {
            return x `
                                    <option 
                                      value="${property.fullIri}"; 
                                      ?selected=${this.annotation && property.equals(this.annotation.property)}
                                    >
                                      ${property.prefixed}
                                    </option>
                                  `;
        })}
                                <option value=""></option>
                            </select>
                        </div>
                        <label style = "width: 95%; margin: 8px 8px 8px 8px ;" id="lexicalform-label" for="lexicalform"><b>Lexical Form:</b></label><br>
                        <textarea class="area" style="width: 78%; margin: 8px 8px 8px 8px ;resize: none;" id = "lexicalform" rows="4" cols="40" oninput="if(this.value.length > 0 && this.offsetParent.querySelector('#newproperty').value.length > 0) {this.offsetParent.querySelector('#ok').disabled = false;} else {this.offsetParent.querySelector('#ok').disabled = true;}"> ${(_c = this.annotation) === null || _c === void 0 ? void 0 : _c.lexicalForm} </textarea>
                        <label style = "width: 95%; margin: 8px 8px 8px 8px ;" id="datatype-label" for="datatype"><b>Datatype:</b></label><br>
                        <select style = "width: 78%; margin: 8px 8px 8px 8px ;" id="datatype" name="datatype" onchange="if(this.offsetParent.querySelector('#lexicalform').value.length > 0){this.offsetParent.querySelector('#ok').disabled = false;}" required>
                            ${datatypes.sort().map((n, i) => {
            if (this.annotation && n.toString() === this.annotation.datatype) {
                return x `<option value="${n.toString()}"; selected>${n.toString()}</option>`;
            }
            else {
                return x `<option value="${n.toString()}"; >${n.toString()}</option>`;
            }
        })}
                            <option value=""></option>
                        </select>
                        <label style = "width: 95%; margin: 8px 8px 8px 8px ;" id="language-label" for="language"><b>Language:</b></label>
                        <div class="dropdown" style = "width: 30%; margin: 8px 8px 8px 8px ;">
                            <input id="newlan" value="${(_d = this.annotation) === null || _d === void 0 ? void 0 : _d.language}" type="text"/>
                            <select id="language" onchange="this.offsetParent.querySelector('#newlan').value=this.value; this.offsetParent.querySelector('#newlan').focus(); if(this.offsetParent.offsetParent.querySelector('#lexicalform').value.length > 0){this.offsetParent.offsetParent.querySelector('#ok').disabled = false;} "name="language" required>
                                ${languages.sort().map((n, i) => {
            if (this.annotation && n.toString() === this.annotation.language) {
                return x `<option value="${n.toString()}"; selected>${n.toString()}</option>`;
            }
            else {
                return x `<option value="${n.toString()}"; >${n.toString()}</option>`;
            }
        })}
                                <option value=""></option>
                            </select>
                        </div>
                    </form>
                    <div class="buttons" id="buttons">
                        <gscape-button label="Cancel" type="subtle" @click=${this.handleCancel}></gscape-button>
                        <gscape-button id="ok" label="Ok" @click=${this.handleConfirm} disabled></gscape-button>
                    </div>
                </div>
            </div>
            `;
    }
}
GscapeAnnotationModal.properties = {
    annotation: { type: Annotation }
};
GscapeAnnotationModal.styles = [
    baseStyle,
    i$1 `
            :host {
                position: absolute;
                }
            .drawing-btn {
                position: absolute;
                top: 50px;
                left: 10px;
                border-radius: var(--gscape-border-radius-btn);
                border: 1px solid var(--gscape-color-border-subtle);
                background-color: var(--gscape-color-bg-default);
            }
    
            .gscape-panel {
                position: absolute;
                top: 100px;
                left: 50%;
                transform: translate(-50%);
                max-width: 400px;
                min-width: 300px;
                }
        
                .header, .dialog-message {
                margin: 8px;
                font-size: 15px;
                }
        
                .dialog-message {
                padding: 8px;
                margin-bottom: 16px;
                }
        
                .buttons {
                display: flex;
                align-items: center;
                justify-content: right;
                gap: 8px;
                }
    
                .dropdown {
                position: relative;
                width: 78%; 
                margin: 8px 8px 8px 8px ;
                border: solid 1px var(--gscape-color-border-subtle);
                border-radius: var(--gscape-border-radius);
                }
                
                .dropdown select {
                width: 100%;
                }
                
                .dropdown > * {
                box-sizing: border-box;
                height: 100%;
                border: none;
                }
                
                .dropdown input {
                position: absolute;
                width: calc(100% - 18px);
                }
    
                .dropdown select:focus, .dropdown input:focus {
                border-color: inherit;
                -webkit-box-shadow: none;
                box-shadow: none;
                }
            `
];
customElements.define('gscape-annotation', GscapeAnnotationModal);

function initNewDiagramUI(grapholscape) {
    getModal(grapholscape, ModalTypeEnum.DIAGRAM, 'Add New Diagram', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        ontologyBuilder.addDiagram(confirmDetail.diagramName);
    });
}
// #####################################
// ## SINGLE ENTITIES                 ##
// #####################################
function initNewEntityUI(grapholscape, entityType) {
    getModal(grapholscape, entityType, `Add New ${getEntityTypeInTitle(entityType)}`, (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        ontologyBuilder.addNodeElement(confirmDetail.iri, confirmDetail.type);
    });
}
function initNewDataPropertyUI(grapholscape, ownerClassIri) {
    getModal(grapholscape, TypesEnum.DATA_PROPERTY, 'Add New Data Property', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        const functionProperties = confirmDetail.isFunctional ? [FunctionPropertiesEnum.FUNCTIONAL] : [];
        ontologyBuilder.addNodeElement(confirmDetail.iri, TypesEnum.DATA_PROPERTY, ownerClassIri, undefined, functionProperties, confirmDetail.datatype);
    });
}
function initNewObjectPropertyUI(grapholscape, sourceClassIri, targetClassIri) {
    getModal(grapholscape, TypesEnum.OBJECT_PROPERTY, 'Add New Object Property', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        ontologyBuilder.addEdgeElement(confirmDetail.iri, TypesEnum.OBJECT_PROPERTY, sourceClassIri, targetClassIri, TypesEnum.CLASS, confirmDetail.functionProperties);
    });
}
function initNewIndividualUI(grapholscape, ownerClassIri) {
    getModal(grapholscape, TypesEnum.INDIVIDUAL, 'Add New Individual', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        ontologyBuilder.addNodeElement(confirmDetail.iri, TypesEnum.INDIVIDUAL, ownerClassIri);
    });
}
// #####################################
// ## ISA(s)                          ##
// #####################################
function initNewIsaUI(grapholscape, sourceIri) {
    getModal(grapholscape, ModalTypeEnum.ISA, 'Add New Class', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        ontologyBuilder.addNodeElement(confirmDetail.iri, TypesEnum.CLASS, sourceIri, confirmDetail.isaDirection);
    });
}
function initNewSubHierarchyUI(grapholscape, sourceIri) {
    getModal(grapholscape, ModalTypeEnum.HIERARCHY, 'Add New Set of SubClasses', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        ontologyBuilder.addSubhierarchy(confirmDetail.inputClassesIri, sourceIri, confirmDetail.isDisjoint, confirmDetail.isComplete);
    });
}
// #####################################
// ## MISC                            ##
// #####################################
function initRenameEntityUI(grapholscape, entity, elemId) {
    const modal = getModal(grapholscape, ModalTypeEnum.RENAME_ENTITY, 'Rename Entity', (confirmDetail) => {
        const ontologyBuilder = new OntologyBuilder(grapholscape);
        if (confirmDetail.isRefactor) {
            ontologyBuilder.refactorEntity(entity, elemId, confirmDetail.newIri);
        }
        else {
            ontologyBuilder.renameEntity(entity.iri, elemId, confirmDetail.newIri);
        }
    });
    modal.remainderToRename = entity.iri.remainder;
    if (entity.iri.namespace)
        modal.selectedNamespaceIndex = modal.namespaces.indexOf(entity.iri.namespace);
}
// #####################################
// ## ANNOTATIONS                     ##
// #####################################
function initAnnotationsModal(grapholscape, modal, entity, entityType) {
    modal.dialogTitle = entity.iri.remainder;
    modal.entityType = entityType;
    modal.annotations = entity.getAnnotations();
    modal.show();
    const editAnnotationModal = new GscapeAnnotationModal();
    editAnnotationModal.ontology = ontologyModelToViewData(grapholscape.ontology);
    modal.initEditAnnotation = (annotation) => {
        var _a;
        modal.hide();
        (_a = grapholscape.uiContainer) === null || _a === void 0 ? void 0 : _a.appendChild(editAnnotationModal);
        editAnnotationModal.annotation = annotation;
        editAnnotationModal.show();
        editAnnotationModal.onConfirm = (oldAnnotation, property, lexicalForm, datatype, language) => {
            editAnnotationModal.hide();
            const propertyIri = new Iri(property, grapholscape.ontology.namespaces);
            const newAnnotation = new Annotation(propertyIri, lexicalForm, language, datatype);
            if (oldAnnotation && !oldAnnotation.equals(newAnnotation)) {
                entity.removeAnnotation(oldAnnotation);
            }
            entity.addAnnotation(newAnnotation);
            modal.annotations = entity.getAnnotations();
            modal.show();
        };
        editAnnotationModal.onCancel = () => {
            editAnnotationModal.hide();
            modal.show();
        };
    };
    modal.deleteAnnotation = (annotation) => {
        entity.removeAnnotation(annotation);
        modal.annotations = entity.getAnnotations();
    };
    modal.onCancel = () => {
        modal.hide();
    };
}
function getModal(grapholscape, type, title, onConfirm) {
    const modal = new GscapeNewElementModal(type, title);
    modal.namespaces = grapholscape.ontology.namespaces;
    modal.addEventListener('confirm', (evt) => {
        const ns = evt.detail.namespace;
        if (ns) {
            checkNamespace(grapholscape, ns);
        }
        onConfirm(evt.detail);
        modal.remove();
    });
    if (grapholscape.uiContainer)
        grapholscape.uiContainer.appendChild(modal);
    modal.show();
    return modal;
}
function getEntityTypeInTitle(entityType) {
    return (entityType.charAt(0).toUpperCase() + entityType.slice(1)).replace('-', ' ');
}
function checkNamespace(grapholscape, namespace) {
    if (!grapholscape.ontology.getNamespace(namespace)) {
        const ns = new Namespace([], namespace);
        grapholscape.ontology.addNamespace(ns);
    }
}

const { icons: icons$1, } = UI;
/**
 * Get a map storing for each element type (TypesEnum) an array of Command[].
 * Entities have common commands, their key in the map is 'Entity'.
 * The commands are actually functions taking grapholscape instance and the
 * selected elem, that are the two info needed by any command for builder.
 * @returns a Map of functions yielding a command by element's type
 */
function getCommandsByType() {
    const commandsMap = new Map();
    commandsMap.set('Entity', [
        rename,
        editAnnotations,
        removeEntity
    ]);
    commandsMap.set(TypesEnum.CLASS, [
        addDataProperty,
        addObjectProperty,
        addIndividual,
        addISA,
        addSubhierarchy,
        addSubclassEdge,
    ]);
    commandsMap.set(TypesEnum.DATA_PROPERTY, [addInclusionEdge]);
    commandsMap.set(TypesEnum.INDIVIDUAL, []);
    commandsMap.set(TypesEnum.INCLUSION, [removeElement]);
    commandsMap.set(TypesEnum.INSTANCE_OF, [removeElement]);
    commandsMap.set(TypesEnum.ATTRIBUTE_EDGE, [removeAttributeEdge]);
    return commandsMap;
}
const addDataProperty = (grapholscape, elem) => {
    return {
        content: 'Add Data Property',
        icon: icons$1.addDataPropertyIcon,
        select: () => {
            initNewDataPropertyUI(grapholscape, elem.data().iri);
        }
    };
};
const addObjectProperty = (grapholscape, elem) => {
    return {
        content: 'Add Object Property',
        icon: icons$1.addObjectPropertyIcon,
        select: () => {
            let currentCy = grapholscape.renderer.cy;
            applyEdgeDrawStyle(currentCy, grapholscape.theme, TypesEnum.OBJECT_PROPERTY);
            let edgehandles = currentCy.edgehandles(edgeHandlesDefaults(TypesEnum.OBJECT_PROPERTY));
            edgehandles.start(elem);
            currentCy.scratch('edge-creation-type', TypesEnum.OBJECT_PROPERTY);
        }
    };
};
const addISA = (grapholscape, elem) => {
    return {
        content: 'Add Class in IS-A',
        icon: icons$1.addISAIcon,
        select: () => {
            initNewIsaUI(grapholscape, elem.data().iri);
        }
    };
};
const addSubclassEdge = (grapholscape, elem) => {
    return {
        content: 'Add Subclass Edge',
        icon: icons$1.addISAIcon,
        select: () => {
            let currentCy = grapholscape.renderer.cy;
            applyEdgeDrawStyle(currentCy, grapholscape.theme, TypesEnum.INCLUSION);
            let edgehandles = currentCy.edgehandles(edgeHandlesDefaults(TypesEnum.INCLUSION));
            edgehandles.start(elem);
            currentCy.scratch('edge-creation-type', TypesEnum.INCLUSION);
        }
    };
};
const addIndividual = (grapholscape, elem) => {
    return {
        content: 'Add Individual',
        icon: icons$1.addClassInstanceIcon,
        select: () => {
            initNewIndividualUI(grapholscape, elem.data().iri);
        }
    };
};
const addSubhierarchy = (grapholscape, elem) => {
    return {
        content: 'Add Subhierarchy',
        icon: icons$1.addSubhierarchyIcon,
        select: () => {
            initNewSubHierarchyUI(grapholscape, elem.data().iri);
        }
    };
};
const rename = (grapholscape, elem) => {
    return {
        content: 'Rename',
        icon: icons$1.renameIcon,
        select: () => {
            const entity = grapholscape.ontology.getEntity(elem.data('iri'));
            if (entity) {
                initRenameEntityUI(grapholscape, entity, elem.id());
            }
        }
    };
};
const editAnnotations = (grapholscape, elem) => {
    return {
        content: 'Edit Annotations',
        icon: icons$1.editIcon,
        select: () => {
            var _a;
            const annotationsModal = new GscapeAnnotationsModal();
            (_a = grapholscape.uiContainer) === null || _a === void 0 ? void 0 : _a.appendChild(annotationsModal);
            const entity = grapholscape.ontology.getEntity(elem.data('iri'));
            entity === null || entity === void 0 ? void 0 : entity.getAnnotations();
            if (entity)
                initAnnotationsModal(grapholscape, annotationsModal, entity, elem.data('type'));
        }
    };
};
const removeEntity = (grapholscape, elem) => {
    return {
        content: 'Remove',
        icon: icons$1.rubbishBin,
        select: () => {
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            const entity = grapholscape.ontology.getEntity(elem.data().iri);
            if (entity) {
                ontologyBuilder.removeEntity(elem, entity);
            }
        }
    };
};
const removeAttributeEdge = (grapholscape, elem) => {
    return {
        content: 'Remove',
        icon: icons$1.rubbishBin,
        select: () => {
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            const dpNode = elem.target();
            const entity = grapholscape.ontology.getEntity(dpNode.data().iri);
            if (entity) {
                ontologyBuilder.removeEntity(dpNode, entity);
            }
        }
    };
};
const removeElement = (grapholscape, elem) => {
    return {
        content: 'Remove',
        icon: icons$1.rubbishBin,
        select: () => {
            const diagram = grapholscape.renderer.diagram;
            if (diagram) {
                const diagramBuilder = new DiagramBuilder(diagram, RendererStatesEnum.FLOATY);
                diagramBuilder.removeElement(elem.id());
            }
        }
    };
};
const removeHierarchyByNode = (grapholscape, elem) => {
    return {
        content: 'Remove',
        icon: icons$1.rubbishBin,
        select: () => {
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            if (elem.edges().nonempty()) {
                elem.edgesWith(`[ type = "${TypesEnum.CLASS}" ]`).forEach(e => {
                    var _a, _b;
                    const classNode = e.connectedNodes(`[ type = "${TypesEnum.CLASS}" ]`).first();
                    let hierarchy = (_a = grapholscape.ontology.hierarchiesBySuperclassMap.get(classNode.data('iri'))) === null || _a === void 0 ? void 0 : _a.find(h => h.id === `${elem.data('hierarchyID')}`);
                    if (hierarchy) {
                        ontologyBuilder.removeHierarchy(hierarchy);
                    }
                    else {
                        hierarchy = (_b = grapholscape.ontology.hierarchiesBySubclassMap.get(classNode.data('iri'))) === null || _b === void 0 ? void 0 : _b.find(h => h.id === `${elem.data('hierarchyID')}`);
                        if (hierarchy) {
                            ontologyBuilder.removeHierarchy(hierarchy);
                        }
                    }
                });
            }
            else {
                const diagram = grapholscape.renderer.diagram;
                if (diagram) {
                    const diagramBuilder = new DiagramBuilder(diagram, RendererStatesEnum.FLOATY);
                    diagramBuilder.removeElement(elem.id());
                }
            }
        }
    };
};
const addHierarchySuperClassEdge = (grapholscape, elem) => {
    return {
        content: 'Add Inclusion Edge',
        icon: icons$1.addISAIcon,
        select: () => {
            let currentCy = grapholscape.renderer.cy;
            let edgeType = elem.data().type;
            if (elem.data().hierarchyForcedComplete) {
                if (elem.data().type === TypesEnum.UNION) {
                    edgeType = TypesEnum.COMPLETE_UNION;
                }
                else {
                    edgeType = TypesEnum.COMPLETE_DISJOINT_UNION;
                }
            }
            console.log(edgeType);
            applyEdgeDrawStyle(currentCy, grapholscape.theme, edgeType);
            let edgehandles = currentCy.edgehandles(edgeHandlesDefaults(edgeType));
            edgehandles.start(elem);
            currentCy.scratch('edge-creation-type', edgeType);
        }
    };
};
const removeHierarchySuperClassEdge = (grapholscape, elem) => {
    return {
        content: 'Remove',
        icon: icons$1.rubbishBin,
        select: () => {
            var _a;
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            const hierarchyID = elem.connectedNodes(`[type = "${elem.data('type')}"]`).first().data('hierarchyID');
            const superclassIri = elem.target().data('iri');
            const hierarchy = (_a = grapholscape.ontology.hierarchiesBySuperclassMap.get(superclassIri)) === null || _a === void 0 ? void 0 : _a.find(h => h.id === hierarchyID);
            if (hierarchy)
                ontologyBuilder.removeHierarchySuperclass(hierarchy, superclassIri);
        }
    };
};
const removeHierarchyInputEdge = (grapholscape, elem) => {
    return {
        content: 'Remove',
        icon: icons$1.rubbishBin,
        select: () => {
            var _a;
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            const hierarchyID = elem.connectedNodes(`[type $= "${TypesEnum.UNION}"]`).first().data('hierarchyID');
            const inputclassIri = elem.connectedNodes(`[type = "${TypesEnum.CLASS}"]`).first().data('iri');
            const hierarchy = (_a = grapholscape.ontology.hierarchiesBySubclassMap.get(inputclassIri)) === null || _a === void 0 ? void 0 : _a.find(h => h.id === hierarchyID);
            if (hierarchy)
                ontologyBuilder.removeHierarchyInput(hierarchy, inputclassIri);
        }
    };
};
const addInputEdge = (grapholscape, elem) => {
    return {
        content: 'Add Input Edge',
        icon: icons$1.addInputIcon,
        select: () => {
            let currentCy = grapholscape.renderer.cy;
            applyEdgeDrawStyle(currentCy, grapholscape.theme, TypesEnum.INPUT);
            let edgehandles = currentCy.edgehandles(edgeHandlesDefaults(TypesEnum.INPUT));
            edgehandles.start(elem);
            currentCy.scratch('edge-creation-type', TypesEnum.INPUT);
        }
    };
};
const addInclusionEdge = (grapholscape, elem) => {
    return {
        content: 'Add Inclusion Edge',
        icon: icons$1.addISAIcon,
        select: () => {
            let currentCy = grapholscape.renderer.cy;
            applyEdgeDrawStyle(currentCy, grapholscape.theme, TypesEnum.INCLUSION);
            let edgehandles = currentCy.edgehandles(edgeHandlesDefaults(TypesEnum.INCLUSION));
            edgehandles.start(elem);
            currentCy.scratch('edge-creation-type', TypesEnum.INCLUSION);
        }
    };
};

const { GscapeContextMenu, GscapeButton, getIconSlot, icons, WidgetEnum, } = UI;
edgeEditing(cytoscape, $$1, konva);
window['$'] = window['jQuery'] = $$1;
function initBuilderUI(grapholscape) {
    var _a, _b;
    const commandsWidget = new GscapeContextMenu();
    const addClassBtn = new GscapeButton();
    const classIcon = getIconSlot('icon', icons.addEntityIcon);
    addClassBtn.appendChild(classIcon);
    addClassBtn.style.top = '90px';
    addClassBtn.style.left = '10px';
    addClassBtn.style.position = 'absolute';
    addClassBtn.title = 'Add Class';
    addClassBtn.onclick = () => initNewEntityUI(grapholscape, TypesEnum.CLASS);
    const addDiagramBtn = new GscapeButton();
    const diagramIcon = getIconSlot('icon', icons.addDiagramIcon);
    addDiagramBtn.appendChild(diagramIcon);
    addDiagramBtn.style.top = '50px';
    addDiagramBtn.style.left = '10px';
    addDiagramBtn.style.position = 'absolute';
    addDiagramBtn.title = 'Add Diagram';
    addDiagramBtn.onclick = () => initNewDiagramUI(grapholscape);
    if (grapholscape.renderState === RendererStatesEnum.FLOATY) {
        (_a = grapholscape.uiContainer) === null || _a === void 0 ? void 0 : _a.appendChild(addDiagramBtn);
        (_b = grapholscape.uiContainer) === null || _b === void 0 ? void 0 : _b.appendChild(addClassBtn);
    }
    grapholscape.on(LifecycleEvent.RendererChange, (renderer) => {
        var _a, _b;
        if (renderer === RendererStatesEnum.FLOATY) {
            (_a = grapholscape.uiContainer) === null || _a === void 0 ? void 0 : _a.appendChild(addDiagramBtn);
            (_b = grapholscape.uiContainer) === null || _b === void 0 ? void 0 : _b.appendChild(addClassBtn);
        }
        else {
            addDiagramBtn.remove();
            addClassBtn.remove();
        }
    });
    grapholscape.on(LifecycleEvent.DiagramChange, () => {
        var _a;
        let currentCy = grapholscape.renderer.cy;
        if (currentCy.edgeEditing('get') === undefined) {
            currentCy.edgeEditing({
                initAnchorsAutomatically: false,
                undoable: true,
                validateEdge: function (edge, newSource, newTarget) {
                    const edgeType = edge.data('type');
                    const sourceType = newSource.data('type');
                    const targetType = newTarget.data('type');
                    switch (edgeType) {
                        case TypesEnum.ATTRIBUTE_EDGE:
                            if (sourceType === TypesEnum.CLASS && newTarget.id() === edge.data('target')) {
                                return 'valid';
                            }
                            return 'invalid';
                        case TypesEnum.INCLUSION:
                            if (sourceType === targetType && (sourceType === TypesEnum.CLASS || sourceType === TypesEnum.DATA_PROPERTY)) {
                                return 'valid';
                            }
                            return 'invalid';
                        case TypesEnum.OBJECT_PROPERTY:
                            if (sourceType === targetType && sourceType === TypesEnum.CLASS) {
                                return 'valid';
                            }
                            return 'invalid';
                        case TypesEnum.UNION:
                            if (sourceType === TypesEnum.UNION && targetType === TypesEnum.CLASS) {
                                return 'valid';
                            }
                            return 'invalid';
                        case TypesEnum.DISJOINT_UNION:
                            if (sourceType === TypesEnum.DISJOINT_UNION && targetType === TypesEnum.CLASS) {
                                return 'valid';
                            }
                            return 'invalid';
                        case TypesEnum.INPUT:
                            if (sourceType === TypesEnum.CLASS && (targetType === TypesEnum.DISJOINT_UNION || targetType === TypesEnum.UNION)) {
                                return 'valid';
                            }
                            return 'invalid';
                        default:
                            return 'valid';
                    }
                }
            });
            // avoid konvajs to put div over grapholscape's UI
            (_a = document.getElementById('cy-node-edge-editing-stage0')) === null || _a === void 0 ? void 0 : _a.remove();
        }
        currentCy.on('ehcomplete', (event, sourceNode, targetNode, addedEdge) => {
            if (addedEdge.data('type') === TypesEnum.OBJECT_PROPERTY) {
                addedEdge.remove();
                initNewObjectPropertyUI(grapholscape, sourceNode.data().iri, targetNode.data().iri);
                // grapholscape.uiContainer?.appendChild(newElementComponent)
                // initNewElementModal(newElementComponent, 'Add New Object Property', TypesEnum.OBJECT_PROPERTY, sourceNode.data('iri'), targetNode.data('iri'))
            }
            currentCy.removeScratch('edge-creation-type');
        });
    });
    grapholscape.on(LifecycleEvent.DoubleTap, (evt) => {
        const elem = evt.target;
        if (grapholscape.renderState === RendererStatesEnum.FLOATY && elem.data('type') === TypesEnum.DATA_PROPERTY) {
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            ontologyBuilder.toggleFunctionality(elem.data('iri'));
        }
        else if (grapholscape.renderState === RendererStatesEnum.FLOATY && !(elem.group() === 'edges') && (elem.data('type') === TypesEnum.DISJOINT_UNION || elem.data('type') === TypesEnum.UNION)) {
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            ontologyBuilder.toggleUnion(elem);
        }
        else if (grapholscape.renderState === RendererStatesEnum.FLOATY && (elem.group() === 'edges') && (elem.data('type') === TypesEnum.DISJOINT_UNION || elem.data('type') === TypesEnum.UNION)) {
            const ontologyBuilder = new OntologyBuilder(grapholscape);
            ontologyBuilder.toggleComplete(elem);
        }
    });
    grapholscape.on(LifecycleEvent.ContextClick, (evt) => {
        var _a, _b;
        const elem = evt.target;
        if (grapholscape.renderState === RendererStatesEnum.FLOATY) {
            const commandsByType = getCommandsByType();
            // get commands for this elem type
            let commandsFunctions = commandsByType.get(elem.data('type')) || [];
            if (elem.data().iri) {
                const entity = grapholscape.ontology.getEntity(elem.data().iri);
                if (entity) {
                    commandsFunctions.push(...(commandsByType.get('Entity') || []));
                }
            }
            else {
                const grapholElement = (_b = (_a = grapholscape.renderer.diagram) === null || _a === void 0 ? void 0 : _a.representations.get(RendererStatesEnum.FLOATY)) === null || _b === void 0 ? void 0 : _b.grapholElements.get(elem.id());
                if (grapholElement && grapholElement.isHierarchy()) {
                    // For hierarchies there can be edges or nodes, manually add specific commands
                    if (elem.isNode()) {
                        commandsFunctions.push(addHierarchySuperClassEdge);
                        commandsFunctions.push(addInputEdge);
                        commandsFunctions.push(removeHierarchyByNode);
                    }
                    else {
                        commandsFunctions.push(removeHierarchySuperClassEdge);
                    }
                }
                else if (elem.data('type') === TypesEnum.INPUT && (elem.connectedNodes(`[type = "${TypesEnum.UNION}"]`).nonempty() || elem.connectedNodes(`[type = "${TypesEnum.DISJOINT_UNION}"]`).nonempty())) {
                    commandsFunctions.push(removeHierarchyInputEdge);
                }
            }
            try {
                const htmlNodeReference = elem.popperRef();
                if (htmlNodeReference && commandsFunctions.length > 0) {
                    // each command function is a function taking grapholscape and the selected element
                    // use map to get array of commands calling the command function
                    const commands = commandsFunctions.map(cf => cf(grapholscape, elem));
                    commandsWidget.attachTo(htmlNodeReference, commands);
                }
            }
            catch (e) {
                console.error(e);
            }
        }
    });
    grapholscape.widgets.set(WidgetEnum.NEW_CLASS, addClassBtn);
    grapholscape.widgets.set(WidgetEnum.NEW_DIAGRAM, addDiagramBtn);
}

cytoscape.use(popper);
cytoscape.use(cola);
cytoscape.warnings("production" !== 'production');
cytoscape.use(edgehandles);
cytoscape.use(undoredo);
cytoscape.use(klay);
/**
 * Create a full instance of Grapholscape with diagrams and widgets
 *
 * @remarks
 * Once the promise is fulfilled, you get a {@link !core.Grapholscape}.
 * Hence the API you will most likely want to use will be the one of the {@link !core.Grapholscape} class.
 * You can change diagram, zoom, focus elements, select them, filter them and so on with that class.
 *
 * @param file the ontology, can be an object of the
 * [Web API interface File](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * or a String representing the .graphol file to be displayed
 * @param container a DOM element in which the ontology will be rendered in
 * @param config a config object, please read more about [settings](https://github.com/obdasystems/grapholscape/wiki/Settings)
 * @returns a promise that will be fulfilled with a {@link !core.Grapholscape} object
 * @see [Getting started](https://obdasystems.github.io/grapholscape/pages/getting-started.html)
 * @see [Configuration](https://obdasystems.github.io/grapholscape/pages/configuration.html)
 */
function fullGrapholscape(file, container, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const grapholscape = yield getGrapholscape(file, container, config);
        if (grapholscape) {
            init(grapholscape);
            if ((config === null || config === void 0 ? void 0 : config.initialRendererSelection) === false) {
                grapholscape.widgets.get(WidgetEnum$1.INITIAL_RENDERER_SELECTOR).hide();
            }
            if (grapholscape.renderers.includes(RendererStatesEnum.INCREMENTAL)) {
                initIncremental(grapholscape);
            }
        }
        return grapholscape;
    });
}
/**
 * Create a bare instance of Grapholscape, only diagrams, no widgets
 *
 * @remarks
 * Once the promise is fulfilled, you get a {@link !core.Grapholscape}.
 * Hence the API you will most likely want to use will be the one of the {@link !core.Grapholscape} class.
 * You can change diagram, zoom, focus elements, select them, filter them and so on with that class.
 *
 * @param file the ontology, can be an object of the
 * [Web API interface File](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * or a String representing the .graphol file to be displayed
 * @param container a DOM element in which the ontology will be rendered in
 * @param config a config object, please read more about [settings](https://github.com/obdasystems/grapholscape/wiki/Settings)
 * @returns a promise that will be fulfilled with a {@link !core.Grapholscape} object
 * @see [Getting started](https://obdasystems.github.io/grapholscape/pages/getting-started.html)
 * @see [Configuration](https://obdasystems.github.io/grapholscape/pages/configuration.html)
 */
function bareGrapholscape(file, container, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const grapholscape = yield getGrapholscape(file, container, config);
        if (grapholscape === null || grapholscape === void 0 ? void 0 : grapholscape.renderers.includes(RendererStatesEnum.INCREMENTAL)) {
            initIncremental(grapholscape);
        }
        return grapholscape;
    });
}
function loadRDFGraph(rdfGraph, container, mastroConnection) {
    var _a;
    const loadingSpinner = showLoadingSpinner(container, { selectedTheme: (_a = rdfGraph.config) === null || _a === void 0 ? void 0 : _a.selectedTheme });
    let grapholscape;
    if (rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY) {
        grapholscape = parseRDFGraph(rdfGraph, container);
    }
    else {
        grapholscape = new Grapholscape(getOntology(rdfGraph), container, getConfig(rdfGraph));
        grapholscape.ontology.entities = getEntities(rdfGraph, grapholscape.ontology.namespaces);
    }
    if (grapholscape) {
        init(grapholscape);
        if (grapholscape.renderers.includes(RendererStatesEnum.INCREMENTAL)) {
            initIncremental(grapholscape);
        }
        // if (grapholscape.renderState) {
        //   (grapholscape.widgets.get(UI.WidgetEnum.INITIAL_RENDERER_SELECTOR) as any).hide()
        // }
        // Stop layout, use positions from rdfGraph, for floaty/incremental
        if (grapholscape.renderer.renderState) {
            grapholscape.renderer.renderState.layoutRunning = false;
            grapholscape.renderer.renderState.stopLayout();
        }
        if (rdfGraph.selectedDiagramId !== undefined && rdfGraph.modelType === RDFGraphModelTypeEnum.ONTOLOGY) {
            const diagram = grapholscape.ontology.getDiagram(rdfGraph.selectedDiagramId);
            if (diagram) {
                /**
                 * showDiagram won't set event handlers on this diagram cause it results already
                 * been rendered once, but in previous session, not yet in the current one.
                 * Force setting them here.
                 */
                setGraphEventHandlers(diagram, grapholscape.lifecycle, grapholscape.ontology);
                grapholscape.showDiagram(rdfGraph.selectedDiagramId);
            }
        }
        else {
            if (grapholscape.incremental) {
                if (mastroConnection)
                    grapholscape.incremental.setMastroConnection(mastroConnection);
                grapholscape.incremental.showDiagram();
                grapholscape.incremental.addRDFGraph(rdfGraph);
            }
        }
    }
    loadingSpinner.remove();
    return grapholscape;
}
function builder(rdfGraph, container, mastroConnection) {
    return __awaiter(this, void 0, void 0, function* () {
        const grapholscape = loadRDFGraph(rdfGraph, container);
        initBuilderUI(grapholscape);
        return grapholscape;
    });
}
function buildFromScratch(name, iri, container, mastroConnection) {
    return __awaiter(this, void 0, void 0, function* () {
        const ontology = new Ontology(name, '', iri);
        ontology.addNamespace(new Namespace([''], iri));
        ontology.addDiagram(new Diagram(name, 0));
        const grapholscape = new Grapholscape(ontology, container, {
            renderers: [RendererStatesEnum.FLOATY],
        });
        init(grapholscape);
        initBuilderUI(grapholscape);
        grapholscape.showDiagram(0);
        return grapholscape;
    });
}
function getGrapholscape(file, container, config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!file || !container) {
            console.error('Please specify an ontology and a container for Grapholscape');
            return undefined;
        }
        const savedConfig = loadConfig();
        // copy savedConfig over config
        config = Object.assign(config || {}, savedConfig);
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let ontology;
            let timeout;
            const loadingSpinner = showLoadingSpinner(container, config);
            if (typeof (file) === 'object') {
                let reader = new FileReader();
                reader.onloadend = () => __awaiter(this, void 0, void 0, function* () {
                    try {
                        ontology = yield getResult(reader.result);
                        init();
                    }
                    catch (error) {
                        reject(error);
                    }
                });
                reader.readAsText(file);
                setTimeout(() => {
                    reject('Error: timeout expired');
                }, 10000);
            }
            else if (typeof (file) === 'string') {
                ontology = yield getResult(file);
                init();
            }
            else {
                reject('Err: Grapholscape needs a Graphol File or the corresponding string to be initialized');
            }
            function init() {
                try {
                    if (!ontology) {
                        throw new Error("Error in graphol file");
                    }
                    clearTimeout(timeout);
                    loadingSpinner.remove();
                    const gscape = new Grapholscape(ontology, container, config);
                    resolve(gscape);
                }
                catch (e) {
                    console.error(e);
                }
            }
        }));
        function getResult(file) {
            return new GrapholParser(file).parseGraphol();
        }
    });
}
function showLoadingSpinner(container, config) {
    const spinner = new ContentSpinner();
    spinner.style.position = 'absolute';
    spinner.style.zIndex = '10';
    let themeConfig;
    let theme;
    if (config === null || config === void 0 ? void 0 : config.selectedTheme) {
        if (DefaultThemes[config.selectedTheme] !== undefined) {
            theme = DefaultThemes[config.selectedTheme];
        }
        else if (config === null || config === void 0 ? void 0 : config.themes) {
            themeConfig = config.themes.find(theme => theme === (config === null || config === void 0 ? void 0 : config.selectedTheme) || theme.id === (config === null || config === void 0 ? void 0 : config.selectedTheme));
            if (themeConfig) {
                theme = typeof (themeConfig) === 'string' ? DefaultThemes[themeConfig] : themeConfig;
            }
        }
    }
    if (!theme) {
        theme = DefaultThemes.grapholscape;
    }
    spinner.setColor(theme.getColour(ColoursNames.accent) || '#000');
    container.appendChild(spinner);
    return spinner;
}

export { AnnotatedElement, Annotation, AnnotationProperty, BaseFilterManager, BaseRenderer, Breakpoint, CSS_PROPERTY_NAMESPACE, ClassInstanceEntity, ColoursNames, RDFGraphConfigFiltersEnum as DefaultFilterKeyEnum, DefaultNamespaces, DefaultThemes, DefaultThemesEnum, Diagram, DiagramRepresentation, RDFGraphConfigEntityNameTypeEnum as EntityNameType, Filter, FloatyRendererState, FunctionPropertiesEnum as FunctionalityEnum, GrapholEdge, GrapholElement, GrapholEntity, GrapholNode, GrapholNodesEnum, GrapholRendererState, Grapholscape, GrapholscapeTheme, Hierarchy, IncrementalController, IncrementalDiagram, IncrementalRendererState, Iri, Language, Lifecycle, LifecycleEvent, LiteRendererState, Namespace, Ontology, POLYGON_POINTS, Renderer, RendererStatesEnum, Shape$1 as Shape, index$2 as SwaggerModel, TypesEnum, bareGrapholscape, buildFromScratch, builder, classicColourMap, clearLocalStorage, darkColourMap, floatyOptions, fullGrapholscape, getDefaultFilters, cytoscapeDefaultConfig as grapholOptions, gscapeColourMap, initIncremental, isGrapholEdge, isGrapholNode, liteOptions, loadConfig, loadRDFGraph, setGraphEventHandlers, storeConfigEntry, toPNG, toSVG, UI as ui, index as util };
