/// <reference types="cytoscape" />
import * as cytoscape$1 from 'cytoscape';
import cytoscape__default, { ElementDefinition, EventObject, EdgeSingular, Stylesheet, SingularElementReturnValue, NodeSingular, CytoscapeOptions, Core as Core$1 } from 'cytoscape';
import * as lit from 'lit';
import { SVGTemplateResult, LitElement, TemplateResult, PropertyDeclarations, CSSResultArray, CSSResultGroup } from 'lit';
import { Props, Instance } from 'tippy.js';
import * as lit_html from 'lit-html';

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
declare const BASE_PATH: string;
interface ConfigurationParameters {
    basePath?: string;
    fetchApi?: FetchAPI;
    middleware?: Middleware[];
    queryParamsStringify?: (params: HTTPQuery) => string;
    username?: string;
    password?: string;
    apiKey?: string | ((name: string) => string);
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>);
    headers?: HTTPHeaders;
    credentials?: RequestCredentials;
}
declare class Configuration {
    private configuration;
    constructor(configuration?: ConfigurationParameters);
    set config(configuration: Configuration);
    get basePath(): string;
    get fetchApi(): FetchAPI | undefined;
    get middleware(): Middleware[];
    get queryParamsStringify(): (params: HTTPQuery) => string;
    get username(): string | undefined;
    get password(): string | undefined;
    get apiKey(): ((name: string) => string) | undefined;
    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined;
    get headers(): HTTPHeaders | undefined;
    get credentials(): RequestCredentials | undefined;
}
declare const DefaultConfig: Configuration;
/**
 * This is the base class for all generated API classes.
 */
declare class BaseAPI {
    protected configuration: Configuration;
    private static readonly jsonRegex;
    private middleware;
    constructor(configuration?: Configuration);
    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]): T;
    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>): T;
    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>): T;
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    protected isJsonMime(mime: string | null | undefined): boolean;
    protected request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response>;
    private createFetchParams;
    private fetchApi;
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone;
}
declare class ResponseError extends Error {
    response: Response;
    name: "ResponseError";
    constructor(response: Response, msg?: string);
}
declare class FetchError extends Error {
    cause: Error;
    name: "FetchError";
    constructor(cause: Error, msg?: string);
}
declare class RequiredError extends Error {
    field: string;
    name: "RequiredError";
    constructor(field: string, msg?: string);
}
declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
type FetchAPI = WindowOrWorkerGlobalScope['fetch'];
type Json = any;
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
type HTTPHeaders = {
    [key: string]: string;
};
type HTTPQuery = {
    [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery;
};
type HTTPBody = Json | FormData | URLSearchParams;
type HTTPRequestInit = {
    headers?: HTTPHeaders;
    method: HTTPMethod;
    credentials?: RequestCredentials;
    body?: HTTPBody;
};
type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';
type InitOverrideFunction = (requestContext: {
    init: HTTPRequestInit;
    context: RequestOpts;
}) => Promise<RequestInit>;
interface FetchParams {
    url: string;
    init: RequestInit;
}
interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}
declare function exists(json: any, key: string): boolean;
declare function querystring(params: HTTPQuery, prefix?: string): string;
declare function mapValues(data: any, fn: (item: any) => any): {};
declare function canConsumeForm(consumes: Consume[]): boolean;
interface Consume {
    contentType: string;
}
interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}
interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}
interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}
interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}
interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}
interface ResponseTransformer<T> {
    (json: any): T;
}
declare class JSONApiResponse<T> {
    raw: Response;
    private transformer;
    constructor(raw: Response, transformer?: ResponseTransformer<T>);
    value(): Promise<T>;
}
declare class VoidApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<void>;
}
declare class BlobApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<Blob>;
}
declare class TextApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<string>;
}

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Position
 */
interface Position {
    /**
     *
     * @type {number}
     * @memberof Position
     */
    x: number;
    /**
     *
     * @type {number}
     * @memberof Position
     */
    y: number;
}
/**
 * Check if a given object implements the Position interface.
 */
declare function instanceOfPosition(value: object): boolean;
declare function PositionFromJSON(json: any): Position;
declare function PositionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Position;
declare function PositionToJSON(value?: Position | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Contiene tutti i tipi di nodi/archi orginirari dal Graphol per evitare di duplicare gli enumeratori. Nella rappresentazione Floaty/vkg vengono usati questi valori.
 * NODI class data-property class-instance (vkg) individual (floaty) union disjoint-union iri (floaty iri range di annotazioni che non sono entit√†)
 * ARCHI object-property annotation-property instance-of input inclusion equivalence attribute-edge union disjoint-union complete-union complete-disjoint-union
 * @export
 * @enum {string}
 */
declare enum TypesEnum {
    CLASS = "class",
    OBJECT_PROPERTY = "object-property",
    DATA_PROPERTY = "data-property",
    ANNOTATION_PROPERTY = "annotation-property",
    INDIVIDUAL = "individual",
    CLASS_INSTANCE = "class-instance",
    DOMAIN_RESTRICTION = "domain-restriction",
    RANGE_RESTRICTION = "range-restriction",
    UNION = "union",
    COMPLETE_UNION = "complete-union",
    DISJOINT_UNION = "disjoint-union",
    COMPLETE_DISJOINT_UNION = "complete-disjoint-union",
    COMPLEMENT = "complement",
    INTERSECTION = "intersection",
    ENUMERATION = "enumeration",
    HAS_KEY = "has-key",
    ROLE_INVERSE = "role-inverse",
    ROLE_CHAIN = "role-chain",
    DATATYPE_RESTRICTION = "datatype-restriction",
    VALUE_DOMAIN = "value-domain",
    PROPERTY_ASSERTION = "property-assertion",
    LITERAL = "literal",
    FACET = "facet",
    NEUTRAL = "neutral",
    VALUE = "value",
    INCLUSION = "inclusion",
    EQUIVALENCE = "equivalence",
    INSTANCE_OF = "instance-of",
    INPUT = "input",
    SAME = "same",
    DIFFERENT = "different",
    MEMBERSHIP = "membership",
    ATTRIBUTE_EDGE = "attribute-edge",
    IRI = "iri"
}
declare function TypesEnumFromJSON(json: any): TypesEnum;
declare function TypesEnumFromJSONTyped(json: any, ignoreDiscriminator: boolean): TypesEnum;
declare function TypesEnumToJSON(value?: TypesEnum | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Edge
 */
interface Edge {
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    id: string;
    /**
     * In case of replicated elements, this is the ID of the original element replicated in multiple occurrences, all of them with different IDs
     * @type {string}
     * @memberof Edge
     */
    originalId?: string;
    /**
     *
     * @type {number}
     * @memberof Edge
     */
    diagramId?: number;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    displayedName?: string;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    iri?: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Edge
     */
    type: TypesEnum;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    sourceId: string;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    targetId: string;
    /**
     *
     * @type {Array<Position>}
     * @memberof Edge
     */
    breakpoints?: Array<Position>;
    /**
     *
     * @type {boolean}
     * @memberof Edge
     */
    domainTyped?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Edge
     */
    rangeTyped?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Edge
     */
    domainMandatory?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Edge
     */
    rangeMandatory?: boolean;
}
/**
 * Check if a given object implements the Edge interface.
 */
declare function instanceOfEdge(value: object): boolean;
declare function EdgeFromJSON(json: any): Edge;
declare function EdgeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Edge;
declare function EdgeToJSON(value?: Edge | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Annotation
 */
interface Annotation$1 {
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    lexicalForm: string;
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    property: string;
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    language?: string;
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    datatype?: string;
}
/**
 * Check if a given object implements the Annotation interface.
 */
declare function instanceOfAnnotation(value: object): boolean;
declare function AnnotationFromJSON(json: any): Annotation$1;
declare function AnnotationFromJSONTyped(json: any, ignoreDiscriminator: boolean): Annotation$1;
declare function AnnotationToJSON(value?: Annotation$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare enum FunctionPropertiesEnum {
    FUNCTIONAL = "functional",
    INVERSE_FUNCTIONAL = "inverseFunctional",
    TRANSITIVE = "transitive",
    SYMMETRIC = "symmetric",
    ASYMMETRIC = "asymmetric",
    REFLEXIVE = "reflexive",
    IRREFLEXIVE = "irreflexive"
}
declare function FunctionPropertiesEnumFromJSON(json: any): FunctionPropertiesEnum;
declare function FunctionPropertiesEnumFromJSONTyped(json: any, ignoreDiscriminator: boolean): FunctionPropertiesEnum;
declare function FunctionPropertiesEnumToJSON(value?: FunctionPropertiesEnum | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Entity
 */
interface Entity {
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    fullIri: string;
    /**
     *
     * @type {Array<Annotation>}
     * @memberof Entity
     */
    annotations?: Array<Annotation$1>;
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    datatype?: string;
    /**
     *
     * @type {boolean}
     * @memberof Entity
     */
    isDataPropertyFunctional?: boolean;
    /**
     *
     * @type {Array<FunctionPropertiesEnum>}
     * @memberof Entity
     */
    functionProperties?: Array<FunctionPropertiesEnum>;
}
/**
 * Check if a given object implements the Entity interface.
 */
declare function instanceOfEntity(value: object): boolean;
declare function EntityFromJSON(json: any): Entity;
declare function EntityFromJSONTyped(json: any, ignoreDiscriminator: boolean): Entity;
declare function EntityToJSON(value?: Entity | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface HierarchySuperclassesInner
 */
interface HierarchySuperclassesInner {
    /**
     *
     * @type {Entity}
     * @memberof HierarchySuperclassesInner
     */
    classEntity: Entity;
    /**
     *
     * @type {boolean}
     * @memberof HierarchySuperclassesInner
     */
    complete: boolean;
}
/**
 * Check if a given object implements the HierarchySuperclassesInner interface.
 */
declare function instanceOfHierarchySuperclassesInner(value: object): boolean;
declare function HierarchySuperclassesInnerFromJSON(json: any): HierarchySuperclassesInner;
declare function HierarchySuperclassesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): HierarchySuperclassesInner;
declare function HierarchySuperclassesInnerToJSON(value?: HierarchySuperclassesInner | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Hierarchy
 */
interface Hierarchy$1 {
    /**
     *
     * @type {string}
     * @memberof Hierarchy
     */
    id: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Hierarchy
     */
    type: TypesEnum;
    /**
     *
     * @type {Array<Entity>}
     * @memberof Hierarchy
     */
    inputs: Array<Entity>;
    /**
     *
     * @type {Array<HierarchySuperclassesInner>}
     * @memberof Hierarchy
     */
    superclasses: Array<HierarchySuperclassesInner>;
}
/**
 * Check if a given object implements the Hierarchy interface.
 */
declare function instanceOfHierarchy(value: object): boolean;
declare function HierarchyFromJSON(json: any): Hierarchy$1;
declare function HierarchyFromJSONTyped(json: any, ignoreDiscriminator: boolean): Hierarchy$1;
declare function HierarchyToJSON(value?: Hierarchy$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Node
 */
interface Node {
    /**
     *
     * @type {string}
     * @memberof Node
     */
    id: string;
    /**
     * In case of replicated elements, this is the ID of the original element replicated in multiple occurrences, all of them with different IDs
     * @type {string}
     * @memberof Node
     */
    originalId?: string;
    /**
     *
     * @type {number}
     * @memberof Node
     */
    diagramId?: number;
    /**
     *
     * @type {string}
     * @memberof Node
     */
    displayedName?: string;
    /**
     *
     * @type {string}
     * @memberof Node
     */
    iri?: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Node
     */
    type: TypesEnum;
    /**
     *
     * @type {Position}
     * @memberof Node
     */
    position?: Position;
    /**
     *
     * @type {Position}
     * @memberof Node
     */
    labelPosition?: Position;
}
/**
 * Check if a given object implements the Node interface.
 */
declare function instanceOfNode(value: object): boolean;
declare function NodeFromJSON(json: any): Node;
declare function NodeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Node;
declare function NodeToJSON(value?: Node | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Other elements involved in an action. Only for Remove actions. The remove action on an Entity might involve other elements. i.e. object properties on removed classes
 * @export
 * @interface ActionInvolvedElements
 */
interface ActionInvolvedElements {
    /**
     *
     * @type {Array<Node>}
     * @memberof ActionInvolvedElements
     */
    nodes?: Array<Node>;
    /**
     *
     * @type {Array<Edge>}
     * @memberof ActionInvolvedElements
     */
    edges?: Array<Edge>;
    /**
     *
     * @type {Array<Hierarchy>}
     * @memberof ActionInvolvedElements
     */
    hierarchies?: Array<Hierarchy$1>;
}
/**
 * Check if a given object implements the ActionInvolvedElements interface.
 */
declare function instanceOfActionInvolvedElements(value: object): boolean;
declare function ActionInvolvedElementsFromJSON(json: any): ActionInvolvedElements;
declare function ActionInvolvedElementsFromJSONTyped(json: any, ignoreDiscriminator: boolean): ActionInvolvedElements;
declare function ActionInvolvedElementsToJSON(value?: ActionInvolvedElements | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface ActionUser
 */
interface ActionUser {
    /**
     *
     * @type {string}
     * @memberof ActionUser
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof ActionUser
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ActionUser
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof ActionUser
     */
    email?: string;
}
/**
 * Check if a given object implements the ActionUser interface.
 */
declare function instanceOfActionUser(value: object): boolean;
declare function ActionUserFromJSON(json: any): ActionUser;
declare function ActionUserFromJSONTyped(json: any, ignoreDiscriminator: boolean): ActionUser;
declare function ActionUserToJSON(value?: ActionUser | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Actions describes what user has done on a single element or element's metadata. The user can add, edit or remove something. The "something" is described by the operation involved in the action, it can be an operation over an entity, a diagram, a hierarchy and so on.
 * Reverting an action means reverting the operation that has been done and it depends on the type of the action. - Add => Remove - Remove => Add - Edit => restore the previous state of the subject of the operation made
 * @export
 * @interface Action
 */
interface Action {
    /**
     *
     * @type {string}
     * @memberof Action
     */
    operationType: ActionOperationTypeEnum;
    /**
     *
     * @type {object}
     * @memberof Action
     */
    subject: object;
    /**
     *
     * @type {object}
     * @memberof Action
     */
    previousState?: object;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof Action
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof Action
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof Action
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof Action
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum ActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the Action interface.
 */
declare function instanceOfAction(value: object): boolean;
declare function ActionFromJSON(json: any): Action;
declare function ActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Action;
declare function ActionToJSON(value?: Action | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AnnotationAction
 */
interface AnnotationAction {
    /**
     *
     * @type {Annotation}
     * @memberof AnnotationAction
     */
    subject?: Annotation$1;
    /**
     *
     * @type {Annotation}
     * @memberof AnnotationAction
     */
    previousState?: Annotation$1;
    /**
     *
     * @type {Entity}
     * @memberof AnnotationAction
     */
    entity?: Entity;
    /**
     *
     * @type {boolean}
     * @memberof AnnotationAction
     */
    onOntology?: boolean;
    /**
     *
     * @type {string}
     * @memberof AnnotationAction
     */
    operationType: AnnotationActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof AnnotationAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof AnnotationAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof AnnotationAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof AnnotationAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum AnnotationActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the AnnotationAction interface.
 */
declare function instanceOfAnnotationAction(value: object): boolean;
declare function AnnotationActionFromJSON(json: any): AnnotationAction;
declare function AnnotationActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): AnnotationAction;
declare function AnnotationActionToJSON(value?: AnnotationAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface DataPropertyValue
 */
interface DataPropertyValue {
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    iri: string;
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    language?: string;
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    datatype?: string;
}
/**
 * Check if a given object implements the DataPropertyValue interface.
 */
declare function instanceOfDataPropertyValue(value: object): boolean;
declare function DataPropertyValueFromJSON(json: any): DataPropertyValue;
declare function DataPropertyValueFromJSONTyped(json: any, ignoreDiscriminator: boolean): DataPropertyValue;
declare function DataPropertyValueToJSON(value?: DataPropertyValue | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ClassInstanceEntity
 */
interface ClassInstanceEntity$1 {
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntity
     */
    fullIri: string;
    /**
     *
     * @type {Array<Annotation>}
     * @memberof ClassInstanceEntity
     */
    annotations?: Array<Annotation$1>;
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntity
     */
    datatype?: string;
    /**
     *
     * @type {boolean}
     * @memberof ClassInstanceEntity
     */
    isDataPropertyFunctional?: boolean;
    /**
     *
     * @type {Array<FunctionPropertiesEnum>}
     * @memberof ClassInstanceEntity
     */
    functionProperties?: Array<FunctionPropertiesEnum>;
    /**
     *
     * @type {Array<string>}
     * @memberof ClassInstanceEntity
     */
    parentClasses?: Array<string>;
    /**
     *
     * @type {Array<DataPropertyValue>}
     * @memberof ClassInstanceEntity
     */
    dataProperties?: Array<DataPropertyValue>;
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntity
     */
    shortIri?: string;
}
/**
 * Check if a given object implements the ClassInstanceEntity interface.
 */
declare function instanceOfClassInstanceEntity(value: object): boolean;
declare function ClassInstanceEntityFromJSON(json: any): ClassInstanceEntity$1;
declare function ClassInstanceEntityFromJSONTyped(json: any, ignoreDiscriminator: boolean): ClassInstanceEntity$1;
declare function ClassInstanceEntityToJSON(value?: ClassInstanceEntity$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ClassInstanceEntityAllOf
 */
interface ClassInstanceEntityAllOf {
    /**
     *
     * @type {Array<string>}
     * @memberof ClassInstanceEntityAllOf
     */
    parentClasses?: Array<string>;
    /**
     *
     * @type {Array<DataPropertyValue>}
     * @memberof ClassInstanceEntityAllOf
     */
    dataProperties?: Array<DataPropertyValue>;
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntityAllOf
     */
    shortIri?: string;
}
/**
 * Check if a given object implements the ClassInstanceEntityAllOf interface.
 */
declare function instanceOfClassInstanceEntityAllOf(value: object): boolean;
declare function ClassInstanceEntityAllOfFromJSON(json: any): ClassInstanceEntityAllOf;
declare function ClassInstanceEntityAllOfFromJSONTyped(json: any, ignoreDiscriminator: boolean): ClassInstanceEntityAllOf;
declare function ClassInstanceEntityAllOfToJSON(value?: ClassInstanceEntityAllOf | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Viewport
 */
interface Viewport {
    /**
     *
     * @type {Position}
     * @memberof Viewport
     */
    pan: Position;
    /**
     *
     * @type {number}
     * @memberof Viewport
     */
    zoom: number;
}
/**
 * Check if a given object implements the Viewport interface.
 */
declare function instanceOfViewport(value: object): boolean;
declare function ViewportFromJSON(json: any): Viewport;
declare function ViewportFromJSONTyped(json: any, ignoreDiscriminator: boolean): Viewport;
declare function ViewportToJSON(value?: Viewport | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Diagram
 */
interface Diagram$1 {
    /**
     *
     * @type {number}
     * @memberof Diagram
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof Diagram
     */
    name: string;
    /**
     *
     * @type {Array<Node>}
     * @memberof Diagram
     */
    nodes?: Array<Node>;
    /**
     *
     * @type {Array<Edge>}
     * @memberof Diagram
     */
    edges?: Array<Edge>;
    /**
     *
     * @type {Viewport}
     * @memberof Diagram
     */
    lastViewportState?: Viewport;
}
/**
 * Check if a given object implements the Diagram interface.
 */
declare function instanceOfDiagram(value: object): boolean;
declare function DiagramFromJSON(json: any): Diagram$1;
declare function DiagramFromJSONTyped(json: any, ignoreDiscriminator: boolean): Diagram$1;
declare function DiagramToJSON(value?: Diagram$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface DiagramAction
 */
interface DiagramAction {
    /**
     *
     * @type {Diagram}
     * @memberof DiagramAction
     */
    subject?: Diagram$1;
    /**
     *
     * @type {Diagram}
     * @memberof DiagramAction
     */
    previousState?: Diagram$1;
    /**
     *
     * @type {string}
     * @memberof DiagramAction
     */
    operationType: DiagramActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof DiagramAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof DiagramAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof DiagramAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof DiagramAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum DiagramActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the DiagramAction interface.
 */
declare function instanceOfDiagramAction(value: object): boolean;
declare function DiagramActionFromJSON(json: any): DiagramAction;
declare function DiagramActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): DiagramAction;
declare function DiagramActionToJSON(value?: DiagramAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EdgeAction
 */
interface EdgeAction {
    /**
     *
     * @type {Edge}
     * @memberof EdgeAction
     */
    subject: Edge;
    /**
     *
     * @type {Edge}
     * @memberof EdgeAction
     */
    previousState?: Edge;
    /**
     *
     * @type {string}
     * @memberof EdgeAction
     */
    operationType: EdgeActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof EdgeAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof EdgeAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof EdgeAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof EdgeAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum EdgeActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the EdgeAction interface.
 */
declare function instanceOfEdgeAction(value: object): boolean;
declare function EdgeActionFromJSON(json: any): EdgeAction;
declare function EdgeActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): EdgeAction;
declare function EdgeActionToJSON(value?: EdgeAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EdgeAllOf
 */
interface EdgeAllOf {
    /**
     *
     * @type {string}
     * @memberof EdgeAllOf
     */
    sourceId: string;
    /**
     *
     * @type {string}
     * @memberof EdgeAllOf
     */
    targetId: string;
    /**
     *
     * @type {Array<Position>}
     * @memberof EdgeAllOf
     */
    breakpoints?: Array<Position>;
    /**
     *
     * @type {boolean}
     * @memberof EdgeAllOf
     */
    domainTyped?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof EdgeAllOf
     */
    rangeTyped?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof EdgeAllOf
     */
    domainMandatory?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof EdgeAllOf
     */
    rangeMandatory?: boolean;
}
/**
 * Check if a given object implements the EdgeAllOf interface.
 */
declare function instanceOfEdgeAllOf(value: object): boolean;
declare function EdgeAllOfFromJSON(json: any): EdgeAllOf;
declare function EdgeAllOfFromJSONTyped(json: any, ignoreDiscriminator: boolean): EdgeAllOf;
declare function EdgeAllOfToJSON(value?: EdgeAllOf | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Element
 */
interface Element$1 {
    /**
     *
     * @type {string}
     * @memberof Element
     */
    id: string;
    /**
     * In case of replicated elements, this is the ID of the original element replicated in multiple occurrences, all of them with different IDs
     * @type {string}
     * @memberof Element
     */
    originalId?: string;
    /**
     *
     * @type {number}
     * @memberof Element
     */
    diagramId?: number;
    /**
     *
     * @type {string}
     * @memberof Element
     */
    displayedName?: string;
    /**
     *
     * @type {string}
     * @memberof Element
     */
    iri?: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Element
     */
    type: TypesEnum;
}
/**
 * Check if a given object implements the Element interface.
 */
declare function instanceOfElement(value: object): boolean;
declare function ElementFromJSON(json: any): Element$1;
declare function ElementFromJSONTyped(json: any, ignoreDiscriminator: boolean): Element$1;
declare function ElementToJSON(value?: Element$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EntityAction
 */
interface EntityAction {
    /**
     *
     * @type {Entity}
     * @memberof EntityAction
     */
    subject?: Entity;
    /**
     *
     * @type {Entity}
     * @memberof EntityAction
     */
    previousState?: Entity;
    /**
     *
     * @type {string}
     * @memberof EntityAction
     */
    operationType: EntityActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof EntityAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof EntityAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof EntityAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof EntityAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum EntityActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the EntityAction interface.
 */
declare function instanceOfEntityAction(value: object): boolean;
declare function EntityActionFromJSON(json: any): EntityAction;
declare function EntityActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): EntityAction;
declare function EntityActionToJSON(value?: EntityAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface HierarchyAction
 */
interface HierarchyAction {
    /**
     *
     * @type {Hierarchy}
     * @memberof HierarchyAction
     */
    subject?: Hierarchy$1;
    /**
     *
     * @type {string}
     * @memberof HierarchyAction
     */
    diagramId: string;
    /**
     *
     * @type {Hierarchy}
     * @memberof HierarchyAction
     */
    previousState?: Hierarchy$1;
}
/**
 * Check if a given object implements the HierarchyAction interface.
 */
declare function instanceOfHierarchyAction(value: object): boolean;
declare function HierarchyActionFromJSON(json: any): HierarchyAction;
declare function HierarchyActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): HierarchyAction;
declare function HierarchyActionToJSON(value?: HierarchyAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Namespace
 */
interface Namespace$1 {
    /**
     *
     * @type {string}
     * @memberof Namespace
     */
    value: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Namespace
     */
    prefixes: Array<string>;
}
/**
 * Check if a given object implements the Namespace interface.
 */
declare function instanceOfNamespace(value: object): boolean;
declare function NamespaceFromJSON(json: any): Namespace$1;
declare function NamespaceFromJSONTyped(json: any, ignoreDiscriminator: boolean): Namespace$1;
declare function NamespaceToJSON(value?: Namespace$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NamespaceAction
 */
interface NamespaceAction {
    /**
     *
     * @type {Namespace}
     * @memberof NamespaceAction
     */
    subject: Namespace$1;
    /**
     *
     * @type {Namespace}
     * @memberof NamespaceAction
     */
    previousState?: Namespace$1;
    /**
     *
     * @type {string}
     * @memberof NamespaceAction
     */
    operationType: NamespaceActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof NamespaceAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof NamespaceAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof NamespaceAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof NamespaceAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum NamespaceActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the NamespaceAction interface.
 */
declare function instanceOfNamespaceAction(value: object): boolean;
declare function NamespaceActionFromJSON(json: any): NamespaceAction;
declare function NamespaceActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): NamespaceAction;
declare function NamespaceActionToJSON(value?: NamespaceAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NodeAction
 */
interface NodeAction {
    /**
     *
     * @type {Node}
     * @memberof NodeAction
     */
    subject: Node;
    /**
     *
     * @type {Node}
     * @memberof NodeAction
     */
    previousState?: Node;
    /**
     *
     * @type {string}
     * @memberof NodeAction
     */
    operationType: NodeActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof NodeAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof NodeAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof NodeAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof NodeAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum NodeActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the NodeAction interface.
 */
declare function instanceOfNodeAction(value: object): boolean;
declare function NodeActionFromJSON(json: any): NodeAction;
declare function NodeActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): NodeAction;
declare function NodeActionToJSON(value?: NodeAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NodeAllOf
 */
interface NodeAllOf {
    /**
     *
     * @type {Position}
     * @memberof NodeAllOf
     */
    position?: Position;
    /**
     *
     * @type {Position}
     * @memberof NodeAllOf
     */
    labelPosition?: Position;
}
/**
 * Check if a given object implements the NodeAllOf interface.
 */
declare function instanceOfNodeAllOf(value: object): boolean;
declare function NodeAllOfFromJSON(json: any): NodeAllOf;
declare function NodeAllOfFromJSONTyped(json: any, ignoreDiscriminator: boolean): NodeAllOf;
declare function NodeAllOfToJSON(value?: NodeAllOf | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface OntologyDraftInfo
 */
interface OntologyDraftInfo {
    /**
     *
     * @type {string}
     * @memberof OntologyDraftInfo
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof OntologyDraftInfo
     */
    iri?: string;
    /**
     *
     * @type {string}
     * @memberof OntologyDraftInfo
     */
    version?: string;
    /**
     *
     * @type {number}
     * @memberof OntologyDraftInfo
     */
    lastModification?: number;
}
/**
 * Check if a given object implements the OntologyDraftInfo interface.
 */
declare function instanceOfOntologyDraftInfo(value: object): boolean;
declare function OntologyDraftInfoFromJSON(json: any): OntologyDraftInfo;
declare function OntologyDraftInfoFromJSONTyped(json: any, ignoreDiscriminator: boolean): OntologyDraftInfo;
declare function OntologyDraftInfoToJSON(value?: OntologyDraftInfo | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface PropertyAction
 */
interface PropertyAction {
    /**
     *
     * @type {Entity}
     * @memberof PropertyAction
     */
    subject?: Entity;
    /**
     *
     * @type {Entity}
     * @memberof PropertyAction
     */
    previousState?: Entity;
    /**
     *
     * @type {string}
     * @memberof PropertyAction
     */
    operationType: PropertyActionOperationTypeEnum;
    /**
     *
     * @type {ActionInvolvedElements}
     * @memberof PropertyAction
     */
    involvedElements?: ActionInvolvedElements;
    /**
     *
     * @type {Array<Action>}
     * @memberof PropertyAction
     */
    subactions?: Array<Action>;
    /**
     *
     * @type {ActionUser}
     * @memberof PropertyAction
     */
    user: ActionUser;
    /**
     *
     * @type {number}
     * @memberof PropertyAction
     */
    timestamp: number;
}
/**
* @export
* @enum {string}
*/
declare enum PropertyActionOperationTypeEnum {
    ADD = "add",
    EDIT = "edit",
    REMOVE = "remove"
}
/**
 * Check if a given object implements the PropertyAction interface.
 */
declare function instanceOfPropertyAction(value: object): boolean;
declare function PropertyActionFromJSON(json: any): PropertyAction;
declare function PropertyActionFromJSONTyped(json: any, ignoreDiscriminator: boolean): PropertyAction;
declare function PropertyActionToJSON(value?: PropertyAction | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Theme
 */
interface Theme {
    /**
     *
     * @type {string}
     * @memberof Theme
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Theme
     */
    name?: string;
    /**
     *
     * @type {object}
     * @memberof Theme
     */
    colours?: object;
}
/**
 * Check if a given object implements the Theme interface.
 */
declare function instanceOfTheme(value: object): boolean;
declare function ThemeFromJSON(json: any): Theme;
declare function ThemeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Theme;
declare function ThemeToJSON(value?: Theme | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RDFGraphConfig
 */
interface RDFGraphConfig {
    /**
     *
     * @type {Array<Theme>}
     * @memberof RDFGraphConfig
     */
    themes?: Array<Theme>;
    /**
     *
     * @type {string}
     * @memberof RDFGraphConfig
     */
    selectedTheme?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphConfig
     */
    language?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphConfig
     */
    entityNameType?: RDFGraphConfigEntityNameTypeEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphConfig
     */
    renderers?: Array<string>;
    /**
     *
     * @type {object}
     * @memberof RDFGraphConfig
     */
    widgets?: object;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphConfig
     */
    filters?: Array<RDFGraphConfigFiltersEnum>;
}
/**
* @export
* @enum {string}
*/
declare enum RDFGraphConfigEntityNameTypeEnum {
    LABEL = "label",
    PREFIXED_IRI = "prefixed_iri",
    FULL_IRI = "full_iri"
}
/**
* @export
* @enum {string}
*/
declare enum RDFGraphConfigFiltersEnum {
    ALL = "all",
    DATA_PROPERTY = "data-property",
    VALUE_DOMAIN = "value-domain",
    INDIVIDUAL = "individual",
    ANNOTATION_PROPERTY = "annotation-property",
    UNIVERSAL_QUANTIFIER = "universal_quantifier",
    COMPLEMENT = "complement",
    HAS_KEY = "has-key"
}
/**
 * Check if a given object implements the RDFGraphConfig interface.
 */
declare function instanceOfRDFGraphConfig(value: object): boolean;
declare function RDFGraphConfigFromJSON(json: any): RDFGraphConfig;
declare function RDFGraphConfigFromJSONTyped(json: any, ignoreDiscriminator: boolean): RDFGraphConfig;
declare function RDFGraphConfigToJSON(value?: RDFGraphConfig | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RDFGraphMetadata
 */
interface RDFGraphMetadata {
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    iri?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    version?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphMetadata
     */
    languages?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    defaultLanguage?: string;
    /**
     *
     * @type {Array<Namespace>}
     * @memberof RDFGraphMetadata
     */
    namespaces: Array<Namespace$1>;
    /**
     *
     * @type {Array<Annotation>}
     * @memberof RDFGraphMetadata
     */
    annotations?: Array<Annotation$1>;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphMetadata
     */
    annotationProperties?: Array<string>;
}
/**
 * Check if a given object implements the RDFGraphMetadata interface.
 */
declare function instanceOfRDFGraphMetadata(value: object): boolean;
declare function RDFGraphMetadataFromJSON(json: any): RDFGraphMetadata;
declare function RDFGraphMetadataFromJSONTyped(json: any, ignoreDiscriminator: boolean): RDFGraphMetadata;
declare function RDFGraphMetadataToJSON(value?: RDFGraphMetadata | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RDFGraph
 */
interface RDFGraph {
    /**
     *
     * @type {Array<Diagram>}
     * @memberof RDFGraph
     */
    diagrams: Array<Diagram$1>;
    /**
     *
     * @type {Array<Entity>}
     * @memberof RDFGraph
     */
    entities: Array<Entity>;
    /**
     *
     * @type {Array<ClassInstanceEntity>}
     * @memberof RDFGraph
     */
    classInstanceEntities?: Array<ClassInstanceEntity$1>;
    /**
     *
     * @type {RDFGraphMetadata}
     * @memberof RDFGraph
     */
    metadata: RDFGraphMetadata;
    /**
     *
     * @type {RDFGraphConfig}
     * @memberof RDFGraph
     */
    config?: RDFGraphConfig;
    /**
     *
     * @type {number}
     * @memberof RDFGraph
     */
    selectedDiagramId?: number;
    /**
     *
     * @type {string}
     * @memberof RDFGraph
     */
    modelType: RDFGraphModelTypeEnum;
    /**
     *
     * @type {Array<Action>}
     * @memberof RDFGraph
     */
    actions?: Array<Action>;
    /**
     *
     * @type {string}
     * @memberof RDFGraph
     */
    creator?: string;
}
/**
* @export
* @enum {string}
*/
declare enum RDFGraphModelTypeEnum {
    ONTOLOGY = "ontology",
    VKG = "vkg",
    RDF = "rdf"
}
/**
 * Check if a given object implements the RDFGraph interface.
 */
declare function instanceOfRDFGraph(value: object): boolean;
declare function RDFGraphFromJSON(json: any): RDFGraph;
declare function RDFGraphFromJSONTyped(json: any, ignoreDiscriminator: boolean): RDFGraph;
declare function RDFGraphToJSON(value?: RDFGraph | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface VKGSnapshot
 */
interface VKGSnapshot {
    /**
     *
     * @type {string}
     * @memberof VKGSnapshot
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof VKGSnapshot
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof VKGSnapshot
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof VKGSnapshot
     */
    lastModification?: number;
    /**
     *
     * @type {RDFGraph}
     * @memberof VKGSnapshot
     */
    rdfGraph?: RDFGraph;
}
/**
 * Check if a given object implements the VKGSnapshot interface.
 */
declare function instanceOfVKGSnapshot(value: object): boolean;
declare function VKGSnapshotFromJSON(json: any): VKGSnapshot;
declare function VKGSnapshotFromJSONTyped(json: any, ignoreDiscriminator: boolean): VKGSnapshot;
declare function VKGSnapshotToJSON(value?: VKGSnapshot | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

interface DeleteOntologyDraftRequest {
    ontologyName: string;
}
interface DownloadOntologyDraftRequest {
    rDFGraph?: RDFGraph;
}
interface GetOntologyDraftRequest {
    ontologyName: string;
}
interface PostOntologyDraftsRequest {
    ontologyName: string;
    rDFGraph?: RDFGraph;
}
interface PutOntologyDraftRequest {
    ontologyName: string;
    rDFGraph?: RDFGraph;
}
/**
 *
 */
declare class OntologyDesignerApi extends BaseAPI {
    /**
     * Delete the ontology draft {ontologyName}
     */
    deleteOntologyDraftRaw(requestParameters: DeleteOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<RDFGraph>>>;
    /**
     * Delete the ontology draft {ontologyName}
     */
    deleteOntologyDraft(requestParameters: DeleteOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<RDFGraph>>;
    /**
     * Download the ontology draft in the body converted in OWL2
     */
    downloadOntologyDraftRaw(requestParameters: DownloadOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<string>>;
    /**
     * Download the ontology draft in the body converted in OWL2
     */
    downloadOntologyDraft(requestParameters?: DownloadOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<string>;
    /**
     * Returns the ontology draft {ontologyName}
     */
    getOntologyDraftRaw(requestParameters: GetOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<RDFGraph>>;
    /**
     * Returns the ontology draft {ontologyName}
     */
    getOntologyDraft(requestParameters: GetOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<RDFGraph>;
    /**
     * Returns the list of all ontology drafts made by the user
     */
    getOntologyDraftsRaw(initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<OntologyDraftInfo>>>;
    /**
     * Returns the list of all ontology drafts made by the user
     */
    getOntologyDrafts(initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<OntologyDraftInfo>>;
    /**
     * Add to the list of all ontology drafts a new draft
     */
    postOntologyDraftsRaw(requestParameters: PostOntologyDraftsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<RDFGraph>>>;
    /**
     * Add to the list of all ontology drafts a new draft
     */
    postOntologyDrafts(requestParameters: PostOntologyDraftsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<RDFGraph>>;
    /**
     * Modify the ontology draft {ontologyName} (called when using the ontology builder to save the draft)
     */
    putOntologyDraftRaw(requestParameters: PutOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<RDFGraph>>>;
    /**
     * Modify the ontology draft {ontologyName} (called when using the ontology builder to save the draft)
     */
    putOntologyDraft(requestParameters: PutOntologyDraftRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<RDFGraph>>;
}

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

interface GetRDFGraphConstructRequest {
    name: string;
    queryID: string;
    pageSize: number;
    pageNumber: number;
}
interface OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest {
    ontologyName: string;
    version: string;
}
interface OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest {
    ontologyName: string;
    version: string;
}
interface OwlOntologyOntologyNameVersionVkgCatalogGetRequest {
    ontologyName: string;
    version: string;
}
interface OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest {
    ontologyName: string;
    version: string;
    additive?: boolean;
    body?: string;
}
interface OwlOntologyOntologyNameVersionVkgCatalogPostRequest {
    ontologyName: string;
    version: string;
    vKGSnapshot?: VKGSnapshot;
}
interface OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest {
    ontologyName: string;
    version: string;
    snapshotId: number;
}
interface OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest {
    ontologyName: string;
    version: string;
    snapshotId: number;
    vKGSnapshot?: VKGSnapshot;
}
/**
 *
 */
declare class VKGApi extends BaseAPI {
    /**
     * Returns RDFGraph for CONSTRUCT visualization
     */
    getRDFGraphConstructRaw(requestParameters: GetRDFGraphConstructRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<RDFGraph>>;
    /**
     * Returns RDFGraph for CONSTRUCT visualization
     */
    getRDFGraphConstruct(requestParameters: GetRDFGraphConstructRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<RDFGraph>;
    /**
     * Delete all the saved RDFGraph for VKGs exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogDeleteRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<VKGSnapshot>>>;
    /**
     * Delete all the saved RDFGraph for VKGs exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogDelete(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<VKGSnapshot>>;
    /**
     * Returns the catalog as a FileInfo
     */
    owlOntologyOntologyNameVersionVkgCatalogExportGetRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<string>>;
    /**
     * Returns the catalog as a FileInfo
     */
    owlOntologyOntologyNameVersionVkgCatalogExportGet(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<string>;
    /**
     * Returns the saved RDFGraph for VKGs exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogGetRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogGetRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<VKGSnapshot>>>;
    /**
     * Returns the saved RDFGraph for VKGs exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogGet(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogGetRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<VKGSnapshot>>;
    /**
     * Import a FileInfo in the ontology VKG\'s catalog
     */
    owlOntologyOntologyNameVersionVkgCatalogImportPostRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<VKGSnapshot>>>;
    /**
     * Import a FileInfo in the ontology VKG\'s catalog
     */
    owlOntologyOntologyNameVersionVkgCatalogImportPost(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<VKGSnapshot>>;
    /**
     * Save a new VKG exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogPostRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogPostRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<VKGSnapshot>>>;
    /**
     * Save a new VKG exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogPost(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogPostRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<VKGSnapshot>>;
    /**
     * Delete the VKG exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<VKGSnapshot>>>;
    /**
     * Delete the VKG exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDelete(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<VKGSnapshot>>;
    /**
     * Modify a VKG exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<VKGSnapshot>>>;
    /**
     * Modify a VKG exploration
     */
    owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPut(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<VKGSnapshot>>;
}

type index_d$4_Action = Action;
declare const index_d$4_ActionFromJSON: typeof ActionFromJSON;
declare const index_d$4_ActionFromJSONTyped: typeof ActionFromJSONTyped;
type index_d$4_ActionInvolvedElements = ActionInvolvedElements;
declare const index_d$4_ActionInvolvedElementsFromJSON: typeof ActionInvolvedElementsFromJSON;
declare const index_d$4_ActionInvolvedElementsFromJSONTyped: typeof ActionInvolvedElementsFromJSONTyped;
declare const index_d$4_ActionInvolvedElementsToJSON: typeof ActionInvolvedElementsToJSON;
type index_d$4_ActionOperationTypeEnum = ActionOperationTypeEnum;
declare const index_d$4_ActionOperationTypeEnum: typeof ActionOperationTypeEnum;
declare const index_d$4_ActionToJSON: typeof ActionToJSON;
type index_d$4_ActionUser = ActionUser;
declare const index_d$4_ActionUserFromJSON: typeof ActionUserFromJSON;
declare const index_d$4_ActionUserFromJSONTyped: typeof ActionUserFromJSONTyped;
declare const index_d$4_ActionUserToJSON: typeof ActionUserToJSON;
type index_d$4_AnnotationAction = AnnotationAction;
declare const index_d$4_AnnotationActionFromJSON: typeof AnnotationActionFromJSON;
declare const index_d$4_AnnotationActionFromJSONTyped: typeof AnnotationActionFromJSONTyped;
type index_d$4_AnnotationActionOperationTypeEnum = AnnotationActionOperationTypeEnum;
declare const index_d$4_AnnotationActionOperationTypeEnum: typeof AnnotationActionOperationTypeEnum;
declare const index_d$4_AnnotationActionToJSON: typeof AnnotationActionToJSON;
declare const index_d$4_AnnotationFromJSON: typeof AnnotationFromJSON;
declare const index_d$4_AnnotationFromJSONTyped: typeof AnnotationFromJSONTyped;
declare const index_d$4_AnnotationToJSON: typeof AnnotationToJSON;
type index_d$4_ApiResponse<T> = ApiResponse<T>;
declare const index_d$4_BASE_PATH: typeof BASE_PATH;
type index_d$4_BaseAPI = BaseAPI;
declare const index_d$4_BaseAPI: typeof BaseAPI;
type index_d$4_BlobApiResponse = BlobApiResponse;
declare const index_d$4_BlobApiResponse: typeof BlobApiResponse;
declare const index_d$4_COLLECTION_FORMATS: typeof COLLECTION_FORMATS;
type index_d$4_ClassInstanceEntityAllOf = ClassInstanceEntityAllOf;
declare const index_d$4_ClassInstanceEntityAllOfFromJSON: typeof ClassInstanceEntityAllOfFromJSON;
declare const index_d$4_ClassInstanceEntityAllOfFromJSONTyped: typeof ClassInstanceEntityAllOfFromJSONTyped;
declare const index_d$4_ClassInstanceEntityAllOfToJSON: typeof ClassInstanceEntityAllOfToJSON;
declare const index_d$4_ClassInstanceEntityFromJSON: typeof ClassInstanceEntityFromJSON;
declare const index_d$4_ClassInstanceEntityFromJSONTyped: typeof ClassInstanceEntityFromJSONTyped;
declare const index_d$4_ClassInstanceEntityToJSON: typeof ClassInstanceEntityToJSON;
type index_d$4_Configuration = Configuration;
declare const index_d$4_Configuration: typeof Configuration;
type index_d$4_ConfigurationParameters = ConfigurationParameters;
type index_d$4_Consume = Consume;
type index_d$4_DataPropertyValue = DataPropertyValue;
declare const index_d$4_DataPropertyValueFromJSON: typeof DataPropertyValueFromJSON;
declare const index_d$4_DataPropertyValueFromJSONTyped: typeof DataPropertyValueFromJSONTyped;
declare const index_d$4_DataPropertyValueToJSON: typeof DataPropertyValueToJSON;
declare const index_d$4_DefaultConfig: typeof DefaultConfig;
type index_d$4_DeleteOntologyDraftRequest = DeleteOntologyDraftRequest;
type index_d$4_DiagramAction = DiagramAction;
declare const index_d$4_DiagramActionFromJSON: typeof DiagramActionFromJSON;
declare const index_d$4_DiagramActionFromJSONTyped: typeof DiagramActionFromJSONTyped;
type index_d$4_DiagramActionOperationTypeEnum = DiagramActionOperationTypeEnum;
declare const index_d$4_DiagramActionOperationTypeEnum: typeof DiagramActionOperationTypeEnum;
declare const index_d$4_DiagramActionToJSON: typeof DiagramActionToJSON;
declare const index_d$4_DiagramFromJSON: typeof DiagramFromJSON;
declare const index_d$4_DiagramFromJSONTyped: typeof DiagramFromJSONTyped;
declare const index_d$4_DiagramToJSON: typeof DiagramToJSON;
type index_d$4_DownloadOntologyDraftRequest = DownloadOntologyDraftRequest;
type index_d$4_Edge = Edge;
type index_d$4_EdgeAction = EdgeAction;
declare const index_d$4_EdgeActionFromJSON: typeof EdgeActionFromJSON;
declare const index_d$4_EdgeActionFromJSONTyped: typeof EdgeActionFromJSONTyped;
type index_d$4_EdgeActionOperationTypeEnum = EdgeActionOperationTypeEnum;
declare const index_d$4_EdgeActionOperationTypeEnum: typeof EdgeActionOperationTypeEnum;
declare const index_d$4_EdgeActionToJSON: typeof EdgeActionToJSON;
type index_d$4_EdgeAllOf = EdgeAllOf;
declare const index_d$4_EdgeAllOfFromJSON: typeof EdgeAllOfFromJSON;
declare const index_d$4_EdgeAllOfFromJSONTyped: typeof EdgeAllOfFromJSONTyped;
declare const index_d$4_EdgeAllOfToJSON: typeof EdgeAllOfToJSON;
declare const index_d$4_EdgeFromJSON: typeof EdgeFromJSON;
declare const index_d$4_EdgeFromJSONTyped: typeof EdgeFromJSONTyped;
declare const index_d$4_EdgeToJSON: typeof EdgeToJSON;
declare const index_d$4_ElementFromJSON: typeof ElementFromJSON;
declare const index_d$4_ElementFromJSONTyped: typeof ElementFromJSONTyped;
declare const index_d$4_ElementToJSON: typeof ElementToJSON;
type index_d$4_Entity = Entity;
type index_d$4_EntityAction = EntityAction;
declare const index_d$4_EntityActionFromJSON: typeof EntityActionFromJSON;
declare const index_d$4_EntityActionFromJSONTyped: typeof EntityActionFromJSONTyped;
type index_d$4_EntityActionOperationTypeEnum = EntityActionOperationTypeEnum;
declare const index_d$4_EntityActionOperationTypeEnum: typeof EntityActionOperationTypeEnum;
declare const index_d$4_EntityActionToJSON: typeof EntityActionToJSON;
declare const index_d$4_EntityFromJSON: typeof EntityFromJSON;
declare const index_d$4_EntityFromJSONTyped: typeof EntityFromJSONTyped;
declare const index_d$4_EntityToJSON: typeof EntityToJSON;
type index_d$4_ErrorContext = ErrorContext;
type index_d$4_FetchAPI = FetchAPI;
type index_d$4_FetchError = FetchError;
declare const index_d$4_FetchError: typeof FetchError;
type index_d$4_FetchParams = FetchParams;
type index_d$4_FunctionPropertiesEnum = FunctionPropertiesEnum;
declare const index_d$4_FunctionPropertiesEnum: typeof FunctionPropertiesEnum;
declare const index_d$4_FunctionPropertiesEnumFromJSON: typeof FunctionPropertiesEnumFromJSON;
declare const index_d$4_FunctionPropertiesEnumFromJSONTyped: typeof FunctionPropertiesEnumFromJSONTyped;
declare const index_d$4_FunctionPropertiesEnumToJSON: typeof FunctionPropertiesEnumToJSON;
type index_d$4_GetOntologyDraftRequest = GetOntologyDraftRequest;
type index_d$4_GetRDFGraphConstructRequest = GetRDFGraphConstructRequest;
type index_d$4_HTTPBody = HTTPBody;
type index_d$4_HTTPHeaders = HTTPHeaders;
type index_d$4_HTTPMethod = HTTPMethod;
type index_d$4_HTTPQuery = HTTPQuery;
type index_d$4_HTTPRequestInit = HTTPRequestInit;
type index_d$4_HierarchyAction = HierarchyAction;
declare const index_d$4_HierarchyActionFromJSON: typeof HierarchyActionFromJSON;
declare const index_d$4_HierarchyActionFromJSONTyped: typeof HierarchyActionFromJSONTyped;
declare const index_d$4_HierarchyActionToJSON: typeof HierarchyActionToJSON;
declare const index_d$4_HierarchyFromJSON: typeof HierarchyFromJSON;
declare const index_d$4_HierarchyFromJSONTyped: typeof HierarchyFromJSONTyped;
type index_d$4_HierarchySuperclassesInner = HierarchySuperclassesInner;
declare const index_d$4_HierarchySuperclassesInnerFromJSON: typeof HierarchySuperclassesInnerFromJSON;
declare const index_d$4_HierarchySuperclassesInnerFromJSONTyped: typeof HierarchySuperclassesInnerFromJSONTyped;
declare const index_d$4_HierarchySuperclassesInnerToJSON: typeof HierarchySuperclassesInnerToJSON;
declare const index_d$4_HierarchyToJSON: typeof HierarchyToJSON;
type index_d$4_InitOverrideFunction = InitOverrideFunction;
type index_d$4_JSONApiResponse<T> = JSONApiResponse<T>;
declare const index_d$4_JSONApiResponse: typeof JSONApiResponse;
type index_d$4_Json = Json;
type index_d$4_Middleware = Middleware;
type index_d$4_ModelPropertyNaming = ModelPropertyNaming;
type index_d$4_NamespaceAction = NamespaceAction;
declare const index_d$4_NamespaceActionFromJSON: typeof NamespaceActionFromJSON;
declare const index_d$4_NamespaceActionFromJSONTyped: typeof NamespaceActionFromJSONTyped;
type index_d$4_NamespaceActionOperationTypeEnum = NamespaceActionOperationTypeEnum;
declare const index_d$4_NamespaceActionOperationTypeEnum: typeof NamespaceActionOperationTypeEnum;
declare const index_d$4_NamespaceActionToJSON: typeof NamespaceActionToJSON;
declare const index_d$4_NamespaceFromJSON: typeof NamespaceFromJSON;
declare const index_d$4_NamespaceFromJSONTyped: typeof NamespaceFromJSONTyped;
declare const index_d$4_NamespaceToJSON: typeof NamespaceToJSON;
type index_d$4_Node = Node;
type index_d$4_NodeAction = NodeAction;
declare const index_d$4_NodeActionFromJSON: typeof NodeActionFromJSON;
declare const index_d$4_NodeActionFromJSONTyped: typeof NodeActionFromJSONTyped;
type index_d$4_NodeActionOperationTypeEnum = NodeActionOperationTypeEnum;
declare const index_d$4_NodeActionOperationTypeEnum: typeof NodeActionOperationTypeEnum;
declare const index_d$4_NodeActionToJSON: typeof NodeActionToJSON;
type index_d$4_NodeAllOf = NodeAllOf;
declare const index_d$4_NodeAllOfFromJSON: typeof NodeAllOfFromJSON;
declare const index_d$4_NodeAllOfFromJSONTyped: typeof NodeAllOfFromJSONTyped;
declare const index_d$4_NodeAllOfToJSON: typeof NodeAllOfToJSON;
declare const index_d$4_NodeFromJSON: typeof NodeFromJSON;
declare const index_d$4_NodeFromJSONTyped: typeof NodeFromJSONTyped;
declare const index_d$4_NodeToJSON: typeof NodeToJSON;
type index_d$4_OntologyDesignerApi = OntologyDesignerApi;
declare const index_d$4_OntologyDesignerApi: typeof OntologyDesignerApi;
type index_d$4_OntologyDraftInfo = OntologyDraftInfo;
declare const index_d$4_OntologyDraftInfoFromJSON: typeof OntologyDraftInfoFromJSON;
declare const index_d$4_OntologyDraftInfoFromJSONTyped: typeof OntologyDraftInfoFromJSONTyped;
declare const index_d$4_OntologyDraftInfoToJSON: typeof OntologyDraftInfoToJSON;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest = OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest = OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogGetRequest = OwlOntologyOntologyNameVersionVkgCatalogGetRequest;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest = OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogPostRequest = OwlOntologyOntologyNameVersionVkgCatalogPostRequest;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest = OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest;
type index_d$4_OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest = OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest;
type index_d$4_Position = Position;
declare const index_d$4_PositionFromJSON: typeof PositionFromJSON;
declare const index_d$4_PositionFromJSONTyped: typeof PositionFromJSONTyped;
declare const index_d$4_PositionToJSON: typeof PositionToJSON;
type index_d$4_PostOntologyDraftsRequest = PostOntologyDraftsRequest;
type index_d$4_PropertyAction = PropertyAction;
declare const index_d$4_PropertyActionFromJSON: typeof PropertyActionFromJSON;
declare const index_d$4_PropertyActionFromJSONTyped: typeof PropertyActionFromJSONTyped;
type index_d$4_PropertyActionOperationTypeEnum = PropertyActionOperationTypeEnum;
declare const index_d$4_PropertyActionOperationTypeEnum: typeof PropertyActionOperationTypeEnum;
declare const index_d$4_PropertyActionToJSON: typeof PropertyActionToJSON;
type index_d$4_PutOntologyDraftRequest = PutOntologyDraftRequest;
type index_d$4_RDFGraph = RDFGraph;
type index_d$4_RDFGraphConfig = RDFGraphConfig;
type index_d$4_RDFGraphConfigEntityNameTypeEnum = RDFGraphConfigEntityNameTypeEnum;
declare const index_d$4_RDFGraphConfigEntityNameTypeEnum: typeof RDFGraphConfigEntityNameTypeEnum;
type index_d$4_RDFGraphConfigFiltersEnum = RDFGraphConfigFiltersEnum;
declare const index_d$4_RDFGraphConfigFiltersEnum: typeof RDFGraphConfigFiltersEnum;
declare const index_d$4_RDFGraphConfigFromJSON: typeof RDFGraphConfigFromJSON;
declare const index_d$4_RDFGraphConfigFromJSONTyped: typeof RDFGraphConfigFromJSONTyped;
declare const index_d$4_RDFGraphConfigToJSON: typeof RDFGraphConfigToJSON;
declare const index_d$4_RDFGraphFromJSON: typeof RDFGraphFromJSON;
declare const index_d$4_RDFGraphFromJSONTyped: typeof RDFGraphFromJSONTyped;
type index_d$4_RDFGraphMetadata = RDFGraphMetadata;
declare const index_d$4_RDFGraphMetadataFromJSON: typeof RDFGraphMetadataFromJSON;
declare const index_d$4_RDFGraphMetadataFromJSONTyped: typeof RDFGraphMetadataFromJSONTyped;
declare const index_d$4_RDFGraphMetadataToJSON: typeof RDFGraphMetadataToJSON;
type index_d$4_RDFGraphModelTypeEnum = RDFGraphModelTypeEnum;
declare const index_d$4_RDFGraphModelTypeEnum: typeof RDFGraphModelTypeEnum;
declare const index_d$4_RDFGraphToJSON: typeof RDFGraphToJSON;
type index_d$4_RequestContext = RequestContext;
type index_d$4_RequestOpts = RequestOpts;
type index_d$4_RequiredError = RequiredError;
declare const index_d$4_RequiredError: typeof RequiredError;
type index_d$4_ResponseContext = ResponseContext;
type index_d$4_ResponseError = ResponseError;
declare const index_d$4_ResponseError: typeof ResponseError;
type index_d$4_ResponseTransformer<T> = ResponseTransformer<T>;
type index_d$4_TextApiResponse = TextApiResponse;
declare const index_d$4_TextApiResponse: typeof TextApiResponse;
type index_d$4_Theme = Theme;
declare const index_d$4_ThemeFromJSON: typeof ThemeFromJSON;
declare const index_d$4_ThemeFromJSONTyped: typeof ThemeFromJSONTyped;
declare const index_d$4_ThemeToJSON: typeof ThemeToJSON;
type index_d$4_TypesEnum = TypesEnum;
declare const index_d$4_TypesEnum: typeof TypesEnum;
declare const index_d$4_TypesEnumFromJSON: typeof TypesEnumFromJSON;
declare const index_d$4_TypesEnumFromJSONTyped: typeof TypesEnumFromJSONTyped;
declare const index_d$4_TypesEnumToJSON: typeof TypesEnumToJSON;
type index_d$4_VKGApi = VKGApi;
declare const index_d$4_VKGApi: typeof VKGApi;
type index_d$4_VKGSnapshot = VKGSnapshot;
declare const index_d$4_VKGSnapshotFromJSON: typeof VKGSnapshotFromJSON;
declare const index_d$4_VKGSnapshotFromJSONTyped: typeof VKGSnapshotFromJSONTyped;
declare const index_d$4_VKGSnapshotToJSON: typeof VKGSnapshotToJSON;
type index_d$4_Viewport = Viewport;
declare const index_d$4_ViewportFromJSON: typeof ViewportFromJSON;
declare const index_d$4_ViewportFromJSONTyped: typeof ViewportFromJSONTyped;
declare const index_d$4_ViewportToJSON: typeof ViewportToJSON;
type index_d$4_VoidApiResponse = VoidApiResponse;
declare const index_d$4_VoidApiResponse: typeof VoidApiResponse;
declare const index_d$4_canConsumeForm: typeof canConsumeForm;
declare const index_d$4_exists: typeof exists;
declare const index_d$4_instanceOfAction: typeof instanceOfAction;
declare const index_d$4_instanceOfActionInvolvedElements: typeof instanceOfActionInvolvedElements;
declare const index_d$4_instanceOfActionUser: typeof instanceOfActionUser;
declare const index_d$4_instanceOfAnnotation: typeof instanceOfAnnotation;
declare const index_d$4_instanceOfAnnotationAction: typeof instanceOfAnnotationAction;
declare const index_d$4_instanceOfClassInstanceEntity: typeof instanceOfClassInstanceEntity;
declare const index_d$4_instanceOfClassInstanceEntityAllOf: typeof instanceOfClassInstanceEntityAllOf;
declare const index_d$4_instanceOfDataPropertyValue: typeof instanceOfDataPropertyValue;
declare const index_d$4_instanceOfDiagram: typeof instanceOfDiagram;
declare const index_d$4_instanceOfDiagramAction: typeof instanceOfDiagramAction;
declare const index_d$4_instanceOfEdge: typeof instanceOfEdge;
declare const index_d$4_instanceOfEdgeAction: typeof instanceOfEdgeAction;
declare const index_d$4_instanceOfEdgeAllOf: typeof instanceOfEdgeAllOf;
declare const index_d$4_instanceOfElement: typeof instanceOfElement;
declare const index_d$4_instanceOfEntity: typeof instanceOfEntity;
declare const index_d$4_instanceOfEntityAction: typeof instanceOfEntityAction;
declare const index_d$4_instanceOfHierarchy: typeof instanceOfHierarchy;
declare const index_d$4_instanceOfHierarchyAction: typeof instanceOfHierarchyAction;
declare const index_d$4_instanceOfHierarchySuperclassesInner: typeof instanceOfHierarchySuperclassesInner;
declare const index_d$4_instanceOfNamespace: typeof instanceOfNamespace;
declare const index_d$4_instanceOfNamespaceAction: typeof instanceOfNamespaceAction;
declare const index_d$4_instanceOfNode: typeof instanceOfNode;
declare const index_d$4_instanceOfNodeAction: typeof instanceOfNodeAction;
declare const index_d$4_instanceOfNodeAllOf: typeof instanceOfNodeAllOf;
declare const index_d$4_instanceOfOntologyDraftInfo: typeof instanceOfOntologyDraftInfo;
declare const index_d$4_instanceOfPosition: typeof instanceOfPosition;
declare const index_d$4_instanceOfPropertyAction: typeof instanceOfPropertyAction;
declare const index_d$4_instanceOfRDFGraph: typeof instanceOfRDFGraph;
declare const index_d$4_instanceOfRDFGraphConfig: typeof instanceOfRDFGraphConfig;
declare const index_d$4_instanceOfRDFGraphMetadata: typeof instanceOfRDFGraphMetadata;
declare const index_d$4_instanceOfTheme: typeof instanceOfTheme;
declare const index_d$4_instanceOfVKGSnapshot: typeof instanceOfVKGSnapshot;
declare const index_d$4_instanceOfViewport: typeof instanceOfViewport;
declare const index_d$4_mapValues: typeof mapValues;
declare const index_d$4_querystring: typeof querystring;
declare namespace index_d$4 {
  export {
    index_d$4_Action as Action,
    index_d$4_ActionFromJSON as ActionFromJSON,
    index_d$4_ActionFromJSONTyped as ActionFromJSONTyped,
    index_d$4_ActionInvolvedElements as ActionInvolvedElements,
    index_d$4_ActionInvolvedElementsFromJSON as ActionInvolvedElementsFromJSON,
    index_d$4_ActionInvolvedElementsFromJSONTyped as ActionInvolvedElementsFromJSONTyped,
    index_d$4_ActionInvolvedElementsToJSON as ActionInvolvedElementsToJSON,
    index_d$4_ActionOperationTypeEnum as ActionOperationTypeEnum,
    index_d$4_ActionToJSON as ActionToJSON,
    index_d$4_ActionUser as ActionUser,
    index_d$4_ActionUserFromJSON as ActionUserFromJSON,
    index_d$4_ActionUserFromJSONTyped as ActionUserFromJSONTyped,
    index_d$4_ActionUserToJSON as ActionUserToJSON,
    Annotation$1 as Annotation,
    index_d$4_AnnotationAction as AnnotationAction,
    index_d$4_AnnotationActionFromJSON as AnnotationActionFromJSON,
    index_d$4_AnnotationActionFromJSONTyped as AnnotationActionFromJSONTyped,
    index_d$4_AnnotationActionOperationTypeEnum as AnnotationActionOperationTypeEnum,
    index_d$4_AnnotationActionToJSON as AnnotationActionToJSON,
    index_d$4_AnnotationFromJSON as AnnotationFromJSON,
    index_d$4_AnnotationFromJSONTyped as AnnotationFromJSONTyped,
    index_d$4_AnnotationToJSON as AnnotationToJSON,
    index_d$4_ApiResponse as ApiResponse,
    index_d$4_BASE_PATH as BASE_PATH,
    index_d$4_BaseAPI as BaseAPI,
    index_d$4_BlobApiResponse as BlobApiResponse,
    index_d$4_COLLECTION_FORMATS as COLLECTION_FORMATS,
    ClassInstanceEntity$1 as ClassInstanceEntity,
    index_d$4_ClassInstanceEntityAllOf as ClassInstanceEntityAllOf,
    index_d$4_ClassInstanceEntityAllOfFromJSON as ClassInstanceEntityAllOfFromJSON,
    index_d$4_ClassInstanceEntityAllOfFromJSONTyped as ClassInstanceEntityAllOfFromJSONTyped,
    index_d$4_ClassInstanceEntityAllOfToJSON as ClassInstanceEntityAllOfToJSON,
    index_d$4_ClassInstanceEntityFromJSON as ClassInstanceEntityFromJSON,
    index_d$4_ClassInstanceEntityFromJSONTyped as ClassInstanceEntityFromJSONTyped,
    index_d$4_ClassInstanceEntityToJSON as ClassInstanceEntityToJSON,
    index_d$4_Configuration as Configuration,
    index_d$4_ConfigurationParameters as ConfigurationParameters,
    index_d$4_Consume as Consume,
    index_d$4_DataPropertyValue as DataPropertyValue,
    index_d$4_DataPropertyValueFromJSON as DataPropertyValueFromJSON,
    index_d$4_DataPropertyValueFromJSONTyped as DataPropertyValueFromJSONTyped,
    index_d$4_DataPropertyValueToJSON as DataPropertyValueToJSON,
    index_d$4_DefaultConfig as DefaultConfig,
    index_d$4_DeleteOntologyDraftRequest as DeleteOntologyDraftRequest,
    Diagram$1 as Diagram,
    index_d$4_DiagramAction as DiagramAction,
    index_d$4_DiagramActionFromJSON as DiagramActionFromJSON,
    index_d$4_DiagramActionFromJSONTyped as DiagramActionFromJSONTyped,
    index_d$4_DiagramActionOperationTypeEnum as DiagramActionOperationTypeEnum,
    index_d$4_DiagramActionToJSON as DiagramActionToJSON,
    index_d$4_DiagramFromJSON as DiagramFromJSON,
    index_d$4_DiagramFromJSONTyped as DiagramFromJSONTyped,
    index_d$4_DiagramToJSON as DiagramToJSON,
    index_d$4_DownloadOntologyDraftRequest as DownloadOntologyDraftRequest,
    index_d$4_Edge as Edge,
    index_d$4_EdgeAction as EdgeAction,
    index_d$4_EdgeActionFromJSON as EdgeActionFromJSON,
    index_d$4_EdgeActionFromJSONTyped as EdgeActionFromJSONTyped,
    index_d$4_EdgeActionOperationTypeEnum as EdgeActionOperationTypeEnum,
    index_d$4_EdgeActionToJSON as EdgeActionToJSON,
    index_d$4_EdgeAllOf as EdgeAllOf,
    index_d$4_EdgeAllOfFromJSON as EdgeAllOfFromJSON,
    index_d$4_EdgeAllOfFromJSONTyped as EdgeAllOfFromJSONTyped,
    index_d$4_EdgeAllOfToJSON as EdgeAllOfToJSON,
    index_d$4_EdgeFromJSON as EdgeFromJSON,
    index_d$4_EdgeFromJSONTyped as EdgeFromJSONTyped,
    index_d$4_EdgeToJSON as EdgeToJSON,
    Element$1 as Element,
    index_d$4_ElementFromJSON as ElementFromJSON,
    index_d$4_ElementFromJSONTyped as ElementFromJSONTyped,
    index_d$4_ElementToJSON as ElementToJSON,
    index_d$4_Entity as Entity,
    index_d$4_EntityAction as EntityAction,
    index_d$4_EntityActionFromJSON as EntityActionFromJSON,
    index_d$4_EntityActionFromJSONTyped as EntityActionFromJSONTyped,
    index_d$4_EntityActionOperationTypeEnum as EntityActionOperationTypeEnum,
    index_d$4_EntityActionToJSON as EntityActionToJSON,
    index_d$4_EntityFromJSON as EntityFromJSON,
    index_d$4_EntityFromJSONTyped as EntityFromJSONTyped,
    index_d$4_EntityToJSON as EntityToJSON,
    index_d$4_ErrorContext as ErrorContext,
    index_d$4_FetchAPI as FetchAPI,
    index_d$4_FetchError as FetchError,
    index_d$4_FetchParams as FetchParams,
    index_d$4_FunctionPropertiesEnum as FunctionPropertiesEnum,
    index_d$4_FunctionPropertiesEnumFromJSON as FunctionPropertiesEnumFromJSON,
    index_d$4_FunctionPropertiesEnumFromJSONTyped as FunctionPropertiesEnumFromJSONTyped,
    index_d$4_FunctionPropertiesEnumToJSON as FunctionPropertiesEnumToJSON,
    index_d$4_GetOntologyDraftRequest as GetOntologyDraftRequest,
    index_d$4_GetRDFGraphConstructRequest as GetRDFGraphConstructRequest,
    index_d$4_HTTPBody as HTTPBody,
    index_d$4_HTTPHeaders as HTTPHeaders,
    index_d$4_HTTPMethod as HTTPMethod,
    index_d$4_HTTPQuery as HTTPQuery,
    index_d$4_HTTPRequestInit as HTTPRequestInit,
    Hierarchy$1 as Hierarchy,
    index_d$4_HierarchyAction as HierarchyAction,
    index_d$4_HierarchyActionFromJSON as HierarchyActionFromJSON,
    index_d$4_HierarchyActionFromJSONTyped as HierarchyActionFromJSONTyped,
    index_d$4_HierarchyActionToJSON as HierarchyActionToJSON,
    index_d$4_HierarchyFromJSON as HierarchyFromJSON,
    index_d$4_HierarchyFromJSONTyped as HierarchyFromJSONTyped,
    index_d$4_HierarchySuperclassesInner as HierarchySuperclassesInner,
    index_d$4_HierarchySuperclassesInnerFromJSON as HierarchySuperclassesInnerFromJSON,
    index_d$4_HierarchySuperclassesInnerFromJSONTyped as HierarchySuperclassesInnerFromJSONTyped,
    index_d$4_HierarchySuperclassesInnerToJSON as HierarchySuperclassesInnerToJSON,
    index_d$4_HierarchyToJSON as HierarchyToJSON,
    index_d$4_InitOverrideFunction as InitOverrideFunction,
    index_d$4_JSONApiResponse as JSONApiResponse,
    index_d$4_Json as Json,
    index_d$4_Middleware as Middleware,
    index_d$4_ModelPropertyNaming as ModelPropertyNaming,
    Namespace$1 as Namespace,
    index_d$4_NamespaceAction as NamespaceAction,
    index_d$4_NamespaceActionFromJSON as NamespaceActionFromJSON,
    index_d$4_NamespaceActionFromJSONTyped as NamespaceActionFromJSONTyped,
    index_d$4_NamespaceActionOperationTypeEnum as NamespaceActionOperationTypeEnum,
    index_d$4_NamespaceActionToJSON as NamespaceActionToJSON,
    index_d$4_NamespaceFromJSON as NamespaceFromJSON,
    index_d$4_NamespaceFromJSONTyped as NamespaceFromJSONTyped,
    index_d$4_NamespaceToJSON as NamespaceToJSON,
    index_d$4_Node as Node,
    index_d$4_NodeAction as NodeAction,
    index_d$4_NodeActionFromJSON as NodeActionFromJSON,
    index_d$4_NodeActionFromJSONTyped as NodeActionFromJSONTyped,
    index_d$4_NodeActionOperationTypeEnum as NodeActionOperationTypeEnum,
    index_d$4_NodeActionToJSON as NodeActionToJSON,
    index_d$4_NodeAllOf as NodeAllOf,
    index_d$4_NodeAllOfFromJSON as NodeAllOfFromJSON,
    index_d$4_NodeAllOfFromJSONTyped as NodeAllOfFromJSONTyped,
    index_d$4_NodeAllOfToJSON as NodeAllOfToJSON,
    index_d$4_NodeFromJSON as NodeFromJSON,
    index_d$4_NodeFromJSONTyped as NodeFromJSONTyped,
    index_d$4_NodeToJSON as NodeToJSON,
    index_d$4_OntologyDesignerApi as OntologyDesignerApi,
    index_d$4_OntologyDraftInfo as OntologyDraftInfo,
    index_d$4_OntologyDraftInfoFromJSON as OntologyDraftInfoFromJSON,
    index_d$4_OntologyDraftInfoFromJSONTyped as OntologyDraftInfoFromJSONTyped,
    index_d$4_OntologyDraftInfoToJSON as OntologyDraftInfoToJSON,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest as OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest as OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogGetRequest as OwlOntologyOntologyNameVersionVkgCatalogGetRequest,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest as OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogPostRequest as OwlOntologyOntologyNameVersionVkgCatalogPostRequest,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest as OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest,
    index_d$4_OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest as OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest,
    index_d$4_Position as Position,
    index_d$4_PositionFromJSON as PositionFromJSON,
    index_d$4_PositionFromJSONTyped as PositionFromJSONTyped,
    index_d$4_PositionToJSON as PositionToJSON,
    index_d$4_PostOntologyDraftsRequest as PostOntologyDraftsRequest,
    index_d$4_PropertyAction as PropertyAction,
    index_d$4_PropertyActionFromJSON as PropertyActionFromJSON,
    index_d$4_PropertyActionFromJSONTyped as PropertyActionFromJSONTyped,
    index_d$4_PropertyActionOperationTypeEnum as PropertyActionOperationTypeEnum,
    index_d$4_PropertyActionToJSON as PropertyActionToJSON,
    index_d$4_PutOntologyDraftRequest as PutOntologyDraftRequest,
    index_d$4_RDFGraph as RDFGraph,
    index_d$4_RDFGraphConfig as RDFGraphConfig,
    index_d$4_RDFGraphConfigEntityNameTypeEnum as RDFGraphConfigEntityNameTypeEnum,
    index_d$4_RDFGraphConfigFiltersEnum as RDFGraphConfigFiltersEnum,
    index_d$4_RDFGraphConfigFromJSON as RDFGraphConfigFromJSON,
    index_d$4_RDFGraphConfigFromJSONTyped as RDFGraphConfigFromJSONTyped,
    index_d$4_RDFGraphConfigToJSON as RDFGraphConfigToJSON,
    index_d$4_RDFGraphFromJSON as RDFGraphFromJSON,
    index_d$4_RDFGraphFromJSONTyped as RDFGraphFromJSONTyped,
    index_d$4_RDFGraphMetadata as RDFGraphMetadata,
    index_d$4_RDFGraphMetadataFromJSON as RDFGraphMetadataFromJSON,
    index_d$4_RDFGraphMetadataFromJSONTyped as RDFGraphMetadataFromJSONTyped,
    index_d$4_RDFGraphMetadataToJSON as RDFGraphMetadataToJSON,
    index_d$4_RDFGraphModelTypeEnum as RDFGraphModelTypeEnum,
    index_d$4_RDFGraphToJSON as RDFGraphToJSON,
    index_d$4_RequestContext as RequestContext,
    index_d$4_RequestOpts as RequestOpts,
    index_d$4_RequiredError as RequiredError,
    index_d$4_ResponseContext as ResponseContext,
    index_d$4_ResponseError as ResponseError,
    index_d$4_ResponseTransformer as ResponseTransformer,
    index_d$4_TextApiResponse as TextApiResponse,
    index_d$4_Theme as Theme,
    index_d$4_ThemeFromJSON as ThemeFromJSON,
    index_d$4_ThemeFromJSONTyped as ThemeFromJSONTyped,
    index_d$4_ThemeToJSON as ThemeToJSON,
    index_d$4_TypesEnum as TypesEnum,
    index_d$4_TypesEnumFromJSON as TypesEnumFromJSON,
    index_d$4_TypesEnumFromJSONTyped as TypesEnumFromJSONTyped,
    index_d$4_TypesEnumToJSON as TypesEnumToJSON,
    index_d$4_VKGApi as VKGApi,
    index_d$4_VKGSnapshot as VKGSnapshot,
    index_d$4_VKGSnapshotFromJSON as VKGSnapshotFromJSON,
    index_d$4_VKGSnapshotFromJSONTyped as VKGSnapshotFromJSONTyped,
    index_d$4_VKGSnapshotToJSON as VKGSnapshotToJSON,
    index_d$4_Viewport as Viewport,
    index_d$4_ViewportFromJSON as ViewportFromJSON,
    index_d$4_ViewportFromJSONTyped as ViewportFromJSONTyped,
    index_d$4_ViewportToJSON as ViewportToJSON,
    index_d$4_VoidApiResponse as VoidApiResponse,
    index_d$4_canConsumeForm as canConsumeForm,
    index_d$4_exists as exists,
    index_d$4_instanceOfAction as instanceOfAction,
    index_d$4_instanceOfActionInvolvedElements as instanceOfActionInvolvedElements,
    index_d$4_instanceOfActionUser as instanceOfActionUser,
    index_d$4_instanceOfAnnotation as instanceOfAnnotation,
    index_d$4_instanceOfAnnotationAction as instanceOfAnnotationAction,
    index_d$4_instanceOfClassInstanceEntity as instanceOfClassInstanceEntity,
    index_d$4_instanceOfClassInstanceEntityAllOf as instanceOfClassInstanceEntityAllOf,
    index_d$4_instanceOfDataPropertyValue as instanceOfDataPropertyValue,
    index_d$4_instanceOfDiagram as instanceOfDiagram,
    index_d$4_instanceOfDiagramAction as instanceOfDiagramAction,
    index_d$4_instanceOfEdge as instanceOfEdge,
    index_d$4_instanceOfEdgeAction as instanceOfEdgeAction,
    index_d$4_instanceOfEdgeAllOf as instanceOfEdgeAllOf,
    index_d$4_instanceOfElement as instanceOfElement,
    index_d$4_instanceOfEntity as instanceOfEntity,
    index_d$4_instanceOfEntityAction as instanceOfEntityAction,
    index_d$4_instanceOfHierarchy as instanceOfHierarchy,
    index_d$4_instanceOfHierarchyAction as instanceOfHierarchyAction,
    index_d$4_instanceOfHierarchySuperclassesInner as instanceOfHierarchySuperclassesInner,
    index_d$4_instanceOfNamespace as instanceOfNamespace,
    index_d$4_instanceOfNamespaceAction as instanceOfNamespaceAction,
    index_d$4_instanceOfNode as instanceOfNode,
    index_d$4_instanceOfNodeAction as instanceOfNodeAction,
    index_d$4_instanceOfNodeAllOf as instanceOfNodeAllOf,
    index_d$4_instanceOfOntologyDraftInfo as instanceOfOntologyDraftInfo,
    index_d$4_instanceOfPosition as instanceOfPosition,
    index_d$4_instanceOfPropertyAction as instanceOfPropertyAction,
    index_d$4_instanceOfRDFGraph as instanceOfRDFGraph,
    index_d$4_instanceOfRDFGraphConfig as instanceOfRDFGraphConfig,
    index_d$4_instanceOfRDFGraphMetadata as instanceOfRDFGraphMetadata,
    index_d$4_instanceOfTheme as instanceOfTheme,
    index_d$4_instanceOfVKGSnapshot as instanceOfVKGSnapshot,
    index_d$4_instanceOfViewport as instanceOfViewport,
    index_d$4_mapValues as mapValues,
    index_d$4_querystring as querystring,
  };
}

/**
 * Class representing a namespace
 * @property {string[]} prefixes - array of prefixes
 * @property {string} value - namespace lexical form
 * @property {boolean} standard - bool saying if the namespace is standard or user defined
 */
declare class Namespace implements Namespace$1 {
    private _prefixes;
    private _value;
    private _standard;
    constructor(prefixes: string[], value: string, standard?: boolean);
    get prefixes(): string[];
    set prefixes(value: string[]);
    private set value(value);
    get value(): string;
    toString(): string;
    private set standard(value);
    /**
     * Wether the namespace is standard (`true`) or user defined (`false`)
     */
    isStandard(): boolean;
    /**
     * Check if the passed prefix is assigned to this namespace
     * @param prefix the prefix to check
     */
    hasPrefix(prefix: string): boolean;
    addPrefix(newPrefix: string): void;
}

declare const DefaultNamespaces: {
    RDFS: Namespace;
    OWL: Namespace;
};

declare class Iri {
    private _namespace?;
    private _remainder;
    fullIri: string;
    constructor(iri: string, namespaces: Namespace[], remainder?: string);
    set remainder(value: string);
    get remainder(): string;
    private set namespace(value);
    get namespace(): Namespace | undefined;
    get prefix(): string | undefined;
    get prefixed(): string;
    equals(iriToCheck: string | Iri): boolean;
    hasPrefix(prefixToCheck: string): boolean;
    toString(): string;
}

declare const DefaultAnnotationProperties: {
    [x: string]: Iri;
};
declare class AnnotationProperty extends Iri {
}

declare class Annotation implements Annotation$1 {
    private _property;
    private _range;
    language?: string;
    datatype?: string;
    constructor(property: Iri, range: string | Iri, language?: string, datatype?: string);
    equals(annotation: Annotation): boolean;
    hasIriRange(): boolean;
    get property(): string;
    get propertyIri(): AnnotationProperty;
    get kind(): string;
    get lexicalForm(): string;
    /**
     * If the range is a Iri, return such a Iri, undefined otherwise
     */
    get rangeIri(): Iri | undefined;
}

declare class AnnotatedElement {
    private _annotations;
    constructor();
    set annotations(annotations: Annotation[]);
    addAnnotation(newAnnotation: Annotation): void;
    removeAnnotation(annotation: Annotation): void;
    getAnnotations(language?: string, annotationProperty?: Iri): Annotation[];
    getLabels(language?: string): Annotation[];
    getComments(language?: string): Annotation[];
}

declare class Breakpoint implements Position {
    x: number;
    y: number;
    distance: number;
    weight: number;
    private deltaX;
    private deltaY;
    private angularCoefficient;
    private intersectionPoint;
    private distanceSourceTarget;
    private distanceIntersectionSource;
    private breakpointRelativeToSource;
    constructor(x?: number, y?: number);
    /**
     * Date le posizioni di source, target e del breakpoint,
     * la funzione calcola i due parametri peso e distanza del breakpoint
     * @param source posizione del nodo source
     * @param target posizione del nodo target
     */
    setSourceTarget(source: Position, target: Position): void;
    private setWeight;
    private setDistance;
}

/**
 * Shapes assigned to Graphol nodes. These are [Cytoscape.js shapes](https =//js.cytoscape.org/#style/node-body)
 * @enum {string}
 * @property {string} RECTANGLE rectangle
 * @property {string} DIAMOND diamond
 * @property {string} ELLIPSE ellipse
 * @property {string} HEXAGON hexagon
 * @property {string} ROUND_RECTANGLE roundrectangle
 * @property {string} OCTAGON octagon
 * @property {string} POLYGON polygon
 */
declare enum Shape {
    /** @type {"rectangle"} */
    RECTANGLE = "rectangle",
    /** @type {"diamond"} */
    DIAMOND = "diamond",
    /** @type {"ellipse"} */
    ELLIPSE = "ellipse",
    /** @type {"hexagon"} */
    HEXAGON = "hexagon",
    /** @type {"roundrectangle"} */
    ROUND_RECTANGLE = "roundrectangle",
    /** @type {"octagon"} */
    OCTAGON = "octagon",
    /** @type {"polygon"} */
    POLYGON = "polygon"
}
declare const POLYGON_POINTS = "-0.9 -1 1 -1 0.9 1 -1 1";
/**
 * Enumeration having `type`, `shape` and `identity` for each Graphol node
 */
type GrapholNodeInfo = {
    TYPE: TypesEnum;
    SHAPE: Shape;
    IDENTITY: TypesEnum;
    LABEL?: string;
    SHAPE_POINTS?: string;
};
declare const GrapholNodesEnum: {
    [x in TypesEnum]?: GrapholNodeInfo;
};

declare class GrapholNode extends GrapholElement implements Node {
    static newFromSwagger(n: Node): GrapholNode;
    private _x;
    private _y;
    private _renderedX?;
    private _renderedY?;
    private _shape;
    private _identity;
    private _height;
    private _width;
    private _fillColor;
    private _labelHeight;
    private _hierarchyID?;
    private _hierarchyForcedComplete?;
    private _labelXpos?;
    private _labelXcentered?;
    private _labelYpos?;
    private _labelYcentered?;
    private _fontSize?;
    protected _fakeNodes: GrapholNode[];
    private _inputs?;
    private _shapePoints?;
    icon: string | undefined;
    get position(): Position;
    set position(pos: Position);
    get renderedPosition(): Position | undefined;
    set renderedPosition(pos: Position | undefined);
    get x(): number;
    set x(valX: number);
    get y(): number;
    set y(valY: number);
    get shape(): Shape;
    set shape(shape: Shape);
    get hierarchyID(): string | undefined;
    set hierarchyID(hierarchyID: string | undefined);
    get hierarchyForcedComplete(): boolean | undefined;
    set hierarchyForcedComplete(complete: boolean | undefined);
    get identity(): TypesEnum;
    set identity(identity: TypesEnum);
    get width(): number;
    set width(width: number);
    get height(): number;
    set height(height: number);
    get fillColor(): string;
    set fillColor(fillColor: string);
    get labelXpos(): number | undefined;
    set labelXpos(labelXpos: number | undefined);
    setLabelXposFromXML(labelXpos: number): void;
    get labelHeight(): number;
    set labelHeight(value: number);
    get labelYpos(): number | undefined;
    set labelYpos(labelYpos: number | undefined);
    setLabelYposFromXML(labelYpos: number): void;
    get isLabelXcentered(): boolean | undefined;
    get isLabelYcentered(): boolean | undefined;
    get fontSize(): number | undefined;
    set fontSize(value: number | undefined);
    get inputs(): string[] | undefined;
    set inputs(inputs: string[] | undefined);
    get shapePoints(): string | undefined;
    set shapePoints(shapePoints: string | undefined);
    get fakeNodes(): GrapholNode[];
    isHierarchy: () => boolean;
    addFakeNode(newFakeNode: GrapholNode): void;
    getCytoscapeRepr(grapholEntity?: GrapholEntity): ElementDefinition[];
    clone(): GrapholNode;
    json(): Node;
}
declare function isGrapholNode(elem: GrapholElement): elem is GrapholNode;

declare class GrapholElement implements Element$1 {
    private _id;
    private _type;
    private _displayedName?;
    private _originalId?;
    private _iri?;
    private _diagramId;
    constructor(_id: string, _type: TypesEnum);
    get id(): string;
    set id(value: string);
    get type(): TypesEnum;
    set type(type: TypesEnum);
    get displayedName(): string | undefined;
    set displayedName(displayedName: string | undefined);
    get originalId(): string | undefined;
    set originalId(id: string | undefined);
    get iri(): string | undefined;
    set iri(iri: string | undefined);
    get diagramId(): number;
    set diagramId(newdiagramId: number);
    /**
     * Check if element is of a certain type
     * @param type
     */
    is(type: TypesEnum): boolean;
    isHierarchy: () => boolean;
    /**
     *
     * @returns whether node is an entity
     */
    isEntity(): boolean;
    getCytoscapeRepr(grapholEntity?: GrapholEntity): ElementDefinition[];
    clone(): GrapholElement;
    json(): Element$1;
    equals(grapholElement: GrapholElement): boolean;
    isNode(): this is GrapholNode;
    isEdge(): this is GrapholEdge;
}

declare class GrapholEdge extends GrapholElement implements Edge {
    static newFromSwagger(n: Edge): GrapholEdge;
    private _sourceId;
    private _targetId;
    private _breakpoints;
    private _targetLabel?;
    private _sourceLabel?;
    private _sourceEndpoint?;
    private _targetEndpoint?;
    domainTyped?: boolean;
    rangeTyped?: boolean;
    domainMandatory?: boolean;
    rangeMandatory?: boolean;
    constructor(id: string, type: TypesEnum);
    addBreakPoint(breakpoint: Breakpoint): void;
    computeBreakpointsDistancesWeights(sourcePosition: Position, targetPosition: Position): void;
    get sourceEndpoint(): Position | undefined;
    set sourceEndpoint(endpoint: Position | undefined);
    get targetEndpoint(): Position | undefined;
    set targetEndpoint(endpoint: Position | undefined);
    /**
     * Returns an array of mid-edge breakpoints (without source/target endpoints)
     */
    get breakpoints(): Breakpoint[];
    /**
     * Returns an array of all the breakpoints (including source/target endpoints)
     */
    get controlpoints(): Breakpoint[];
    set controlpoints(newControlPoints: Breakpoint[]);
    get sourceId(): string;
    set sourceId(sourceId: string);
    get targetId(): string;
    set targetId(targetId: string);
    get targetLabel(): string | undefined;
    set targetLabel(targetLabel: string | undefined);
    get sourceLabel(): string | undefined;
    set sourceLabel(sourceLabel: string | undefined);
    get type(): TypesEnum;
    set type(newType: TypesEnum);
    isHierarchy: () => boolean;
    getCytoscapeRepr(grapholEntity?: GrapholEntity): cytoscape$1.ElementDefinition[];
    clone(): GrapholEdge;
    json(): Edge;
}
declare function isGrapholEdge(elem: GrapholElement): elem is GrapholEdge;

/**
 * @typedef {object} Filter
 * @property {string} Filter.selector Cytoscape selector identifying the elements to filter out
 * [cytoscape selectors](https://js.cytoscape.org/#selectors)
 * @property {boolean} Filter.active whether the filter is currently active or not
 * @property {boolean} Filter.activable whether the filter is currently activable
 * @property {string} Filter.class the class to add to filtered elems to easily retrieve them later on
 * @property {string} Filter.key unique key to identify a filter
 */
declare class Filter {
    private _key;
    private _compareFn;
    active: boolean;
    private _locked;
    /**
     *
     * @param key Unique identifier
     * @param compareFn Function receiving a GrapholElement and returning true if the element should be filtered, false otherwise
     */
    constructor(key: string, compareFn: (grapholElement: GrapholElement) => boolean);
    get key(): string;
    get filterTag(): string;
    get locked(): boolean;
    lock(): void;
    unlock(): void;
    shouldFilter(grapholElement: GrapholElement): boolean;
}
declare const annotationPropertyFilter: () => Filter;
declare const getDefaultFilters: () => {
    readonly DATA_PROPERTY: Filter;
    readonly VALUE_DOMAIN: Filter;
    readonly INDIVIDUAL: Filter;
    readonly ANNOTATION_PROPERTY: Filter;
    readonly UNIVERSAL_QUANTIFIER: Filter;
    readonly COMPLEMENT: Filter;
    readonly HAS_KEY: Filter;
};

declare enum ColoursNames {
    /** Foreground color, used for main texts */
    fg_default = "fg-default",
    /** Foreground muted, should be darker than default. Used for secondary text */
    fg_muted = "fg-muted",
    /** Foreground muted, should be lighter and softer than default.
     * Used for placeholders, tips and text used for clarifying UI objects
     */
    fg_subtle = "fg-subtle",
    /** Foreground text colour placed on a surface of a emphasy color such as accent, danger, success and so on */
    fg_on_emphasis = "fg-on-emphasis",
    /** Main background surface colours used in UI widgets */
    bg_default = "bg-default",
    /** Background color to create a higher or lower level with respect to bg_default color */
    bg_inset = "bg-inset",
    /** Borders main color */
    border_default = "border-default",
    /** Softer than default, used for creating softer separations between UI objects */
    border_subtle = "border-subtle",
    shadow = "shadow",
    /** Used to emphasize secondary elements or texts. Like active elements */
    neutral = "neutral",
    /** Emphasize secondary elements, should be darker than default */
    neutral_muted = "neutral-muted",
    /** Emphasize secondary elements, used for active elements borders */
    neutral_subtle = "neutral-subtle",
    /** Primary color for selected/active elements in diagram or activable elemnts like toggles */
    accent = "accent",
    /** Primary color in darker tone, used for decorations like surfaces or borders */
    accent_muted = "accent-muted",
    /** Primary color in lighter tone, used for decorations like toggle's background color */
    accent_subtle = "accent-subtle",
    /** Color for denoting a successful action */
    success = "success",
    /** Denote successful action in darker tone, used for texts or borders */
    success_muted = "success-muted",
    /** Denote successful action in lighter tone, used for backgrounds or surfaces */
    success_subtle = "success-subtle",
    /** Color for denoting warnings */
    attention = "attention",
    /** Color for denoting warnings in darker tone, used for texts or borders */
    attention_muted = "attention-muted",
    /** Color for denoting warnings in lighter tone, used for backgrounds or surfaces */
    attention_subtle = "attention-subtle",
    /** Color for denoting errors */
    danger = "danger",
    /** Color for denoting errors in darker tone, used for texts or borders */
    danger_muted = "danger-muted",
    /** Color for denoting errors in lighter tone, used for backgrounds or surfaces */
    danger_subtle = "danger-subtle",
    /** Color used for classes' nodes bodies */
    class = "class",
    /** Color used for classes' nodes borders */
    class_contrast = "class-contrast",
    /** Color used for object properties' nodes bodies */
    object_property = "object-property",
    /** Color used for object properties' nodes borders */
    object_property_contrast = "object-property-contrast",
    /** Color used for data properties' nodes bodies */
    data_property = "data-property",
    /** Color used for data properties' nodes borders */
    data_property_contrast = "data-property-contrast",
    /** Color used for annotation properties' edges */
    annotation_property = "annotation-property",
    /** Color used for annotation properties' edges contrast */
    annotation_property_contrast = "annotation-property-contrast",
    /** Color used for individual's nodes bodies */
    individual = "individual",
    /** Color used for individual's nodes borders */
    individual_contrast = "individual-contrast",
    /** Background color used in the diagram canvas */
    bg_graph = "bg-graph",
    /** Body color for nodes that are white in plain Graphol */
    bg_node_light = "bg-node-light",
    /** Body color for nodes that are black in plain Graphol */
    bg_node_dark = "bg-node-dark",
    /** Body border color */
    border_node = "border-node",
    /** Nodes/Edges label color */
    label = "label",
    /** Opposite color of label */
    label_contrast = "label-contrast",
    /** Edges lines color */
    edge = "edge",
    class_instance = "class-instance",
    class_instance_contrast = "class-instance-contrast"
}
type ColourMap = {
    [key in ColoursNames]?: string;
};

declare class GrapholscapeTheme implements Theme {
    private _id;
    private _name;
    colours: ColourMap;
    useComputedColours: boolean;
    constructor(id: string, colours?: ColourMap, name?: string);
    get id(): string;
    get name(): string;
    set name(newName: string);
    getColour(name: ColoursNames): string | undefined;
    setColour(name: ColoursNames, colourValue: string): void;
}

declare enum LifecycleEvent {
    DiagramChange = "diagramChange",
    RendererChange = "rendererChange",
    ThemeChange = "themeChange",
    EntitySelection = "entitySelection",
    NodeSelection = "nodeSelection",
    EdgeSelection = "edgeSelection",
    LanguageChange = "languageChange",
    EntityNameTypeChange = "entityNameTypeChange",
    Filter = "filter",
    Unfilter = "unfilter",
    FilterRequest = "filterRequest",
    UnfilterRequest = "unfilterRequest",
    BackgroundClick = "backgroundClick",
    ContextClick = "contextClick",
    DoubleTap = "doubleTap",
    EntityWikiLinkClick = "entityWikiLinkClick",
    MouseOver = "mouseOver",
    MouseOut = "mouseOut"
}
interface IonEvent {
    (event: LifecycleEvent.EntitySelection, callback: (entity: GrapholEntity, instance: GrapholElement) => void): void;
    (event: LifecycleEvent.NodeSelection, callback: (node: GrapholNode) => void): void;
    (event: LifecycleEvent.EdgeSelection, callback: (edge: GrapholEdge) => void): void;
    (event: LifecycleEvent.ThemeChange, callback: (theme: GrapholscapeTheme) => void): void;
    (event: LifecycleEvent.DiagramChange, callback: (diagram: Diagram) => void): void;
    (event: LifecycleEvent.RendererChange, callback: (renderer: RendererStatesEnum) => void): void;
    (event: LifecycleEvent.LanguageChange, callback: (language: string) => void): void;
    (event: LifecycleEvent.EntityNameTypeChange, callback: (nameType: RDFGraphConfigEntityNameTypeEnum) => void): void;
    (event: LifecycleEvent.Filter, callback: (filter: Filter) => void): void;
    (event: LifecycleEvent.Unfilter, callback: (filter: Filter) => void): void;
    (event: LifecycleEvent.FilterRequest, callback: (filter: Filter) => boolean): void;
    (event: LifecycleEvent.UnfilterRequest, callback: (filter: Filter) => boolean): void;
    (event: LifecycleEvent.BackgroundClick, callback: () => void): void;
    (event: LifecycleEvent.ContextClick, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.DoubleTap, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.MouseOver, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.MouseOut, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.EntityWikiLinkClick, callback: (iri: string) => void): void;
}
interface IEventTriggers {
    (event: LifecycleEvent.EntitySelection, entity: GrapholEntity, instance: GrapholElement): void;
    (event: LifecycleEvent.NodeSelection, node: GrapholNode): void;
    (event: LifecycleEvent.EdgeSelection, edge: GrapholEdge): void;
    (event: LifecycleEvent.ThemeChange, theme: GrapholscapeTheme): void;
    (event: LifecycleEvent.DiagramChange, diagram: Diagram): void;
    (event: LifecycleEvent.RendererChange, renderer: RendererStatesEnum): void;
    (event: LifecycleEvent.LanguageChange, language: string): void;
    (event: LifecycleEvent.EntityNameTypeChange, nameType: RDFGraphConfigEntityNameTypeEnum): void;
    (event: LifecycleEvent.Filter, filter: Filter): void;
    (event: LifecycleEvent.Unfilter, filter: Filter): void;
    (event: LifecycleEvent.FilterRequest, filter: Filter): boolean;
    (event: LifecycleEvent.UnfilterRequest, filter: Filter): boolean;
    (event: LifecycleEvent.BackgroundClick): void;
    (event: LifecycleEvent.ContextClick, eventObject: EventObject): void;
    (event: LifecycleEvent.DoubleTap, eventObject: EventObject): void;
    (event: LifecycleEvent.MouseOver, eventObject: EventObject): void;
    (event: LifecycleEvent.MouseOut, eventObject: EventObject): void;
    (event: LifecycleEvent.EntityWikiLinkClick, iri: string): void;
}
declare class Lifecycle {
    private diagramChange;
    private rendererChange;
    private themeChange;
    private entitySelection;
    private nodeSelection;
    private edgeSelection;
    private languageChange;
    private entityNameTypeChange;
    private filter;
    private unfilter;
    private filterRequest;
    private unfilterRequest;
    private backgroundClick;
    private contextClick;
    private doubleTap;
    private mouseOver;
    private mouseOut;
    entityWikiLinkClick: ((iri: string) => void)[];
    trigger: IEventTriggers;
    on: IonEvent;
}

declare class Renderer {
    private _container;
    cy?: cytoscape__default.Core;
    private _renderState?;
    filters: Map<string, Filter>;
    diagram?: Diagram;
    private _theme;
    private _lifecycle;
    FOCUS_ZOOM_LEVEL: number;
    renderStateData: {
        [x: string]: any;
    };
    constructor(renderState?: RenderState);
    set lifecycle(lc: Lifecycle);
    set renderState(rs: RenderState | undefined);
    get renderState(): RenderState | undefined;
    get theme(): GrapholscapeTheme;
    render(diagram: Diagram): void;
    mount(): void;
    addElement(element: ElementDefinition): void;
    /**
     * Filter elements on the diagram.
     * It will be actually applied only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be applied.
     * @param filter Can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    filter: (filter: Filter | RDFGraphConfigFiltersEnum | string) => void;
    private performFilter;
    /**
     * Unfilter elements on the diagram.
     * It will be actually deactivated only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be deactivated.
     * @param filter Can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    unfilter: (filter: Filter | RDFGraphConfigFiltersEnum | string) => void;
    private getFilter;
    private applyActiveFilters;
    private performAllFilters;
    stopRendering(): void;
    /**
     * Select a node or an edge in the current diagram given its unique id
     * @param {string} elementId elem id (node or edge)
     */
    selectElement(elementId: string): void;
    /**
     * Unselect every selected element in this diagram
     */
    unselect(): void;
    /**
     * Fit viewport to diagram
     */
    fit(): void;
    /**
     * Put a set of elements (nodes and/or edges) at the center of the viewport.
     * If just one element then the element will be at the center.
     * @param elementId the element's ID
     * @param zoom the zoom level to apply, if not passed, zoom level won't be changed
     */
    centerOnElementById(elementId: string, zoom?: number | undefined, select?: boolean): void;
    centerOnElement(element: GrapholElement, zoom?: number, select?: boolean): void;
    centerOnModelPosition(xPos: number, yPos: number, zoom?: number): void;
    centerOnRenderedPosition(xPos: number, yPos: number, zoom?: number): void;
    zoom(zoomValue: number): void;
    zoomIn(zoomValue: number): void;
    zoomOut(zoomValue: number): void;
    setTheme(theme: GrapholscapeTheme): void;
    applyTheme(): void;
    updateElement(grapholElement: GrapholElement): void;
    get isThemeApplied(): cytoscape__default.ElementStylesheetStyle | cytoscape__default.ElementStylesheetCSS | undefined;
    get grapholElements(): Map<string, GrapholElement> | undefined;
    get selectedElement(): GrapholElement | undefined;
    get viewportState(): {
        zoom: number;
        pan: cytoscape__default.Position;
    } | undefined;
    set container(container: HTMLElement);
    get container(): HTMLElement;
    /**
     * Getter
     */
    get nodes(): string[] | undefined;
    /**
     * Getter
     */
    get edges(): string[] | undefined;
}

/**
 * @internal
 */
declare class DisplayedNamesManager {
    private _grapholscape;
    private _entityNameType;
    private _language;
    constructor(grapholscape: Grapholscape);
    get entityNameType(): RDFGraphConfigEntityNameTypeEnum;
    get language(): Language;
    setEntityNameType(newEntityNameType: RDFGraphConfigEntityNameTypeEnum): void;
    setLanguage(language: string | Language): void;
    private setDisplayedNames;
}

/**
 * @internal
 */
declare class EntityNavigator {
    private _grapholscape;
    constructor(grapholscape: Grapholscape);
    centerOnEntity(iri: string, diagramId?: number, zoom?: number): void;
    selectEntity(iri: string, diagramId?: number, zoom?: number): void;
    private _centerSelectEntity;
    private _performCenterSelect;
    getEntityOccurrenceInDiagram(iri: string, diagramId: number): GrapholElement | undefined;
    updateEntitiesOccurrences(): void;
    private updateEntitiesOccurrencesFromDiagram;
}

/**
 * @internal
 */
declare class ThemeManager {
    private _grapholscape;
    theme: GrapholscapeTheme;
    themes: Set<GrapholscapeTheme>;
    constructor(grapholscape: Grapholscape);
    setTheme(newThemeId: string): void;
    addTheme(newTheme: GrapholscapeTheme): void;
    removeTheme(theme: GrapholscapeTheme): void;
    removeThemes(): void;
    private setMissingColours;
}

declare class DiagramBuilder {
    diagram: Diagram;
    private rendererState;
    constructor(diagram: Diagram, rendererState: RendererStatesEnum);
    addClass(classEntity: GrapholEntity, classNode?: GrapholNode): GrapholNode;
    addClass(classEntity: GrapholEntity, position?: Position): GrapholNode;
    addClass(classEntity: GrapholEntity): GrapholNode;
    addDataProperty(dataPropertyEntity: GrapholEntity, ownerEntity?: GrapholEntity): GrapholElement | undefined;
    /**
     * Add an object property between two entities.
     * If the source and/or target entities are already present in graph, they won't be added again.
     * If there already exists an object property between them with the same IRI, the
     * edge won't be added.
     * @param objectPropertyEntity the object property entity
     * @param sourceEntity the source entity
     * @param targetEntity the target entity
     * @param nodesType the type of source and target
     * @param objectPropertyElement [optional] to use your own GrapholEdge for the object property occurrence.
     * if you don't pass this, a new GrapholEdge will be created from scratch
     * @returns
     */
    addObjectProperty(objectPropertyEntity: GrapholEntity, sourceEntity: GrapholEntity, targetEntity: GrapholEntity, nodesType: TypesEnum[], objectPropertyElement?: GrapholEdge): GrapholElement | undefined;
    /**
     * Add an annotation property between two entities.
     * If the source and/or target entities are already present in graph, they won't be added again.
     * If there already exists an annotation property between them with the same IRI, the
     * edge won't be added.
     * @param annotationPropertyEdge the object property entity
     * @param sourceEntity the source entity
     * @param targetEntity the target entity
     * @param nodesType the type of source and target
     * @param annotationPropertyElement [optional] to use your own GrapholEdge for the object property occurrence.
     * if you don't pass this, a new GrapholEdge will be created from scratch
     * @returns
     */
    addAnnotationProperty(annotationPropertyEdge: GrapholEntity, sourceEntity: GrapholEntity, targetEntity: GrapholEntity, nodesType: TypesEnum[], annotationPropertyElement?: GrapholEdge): GrapholElement | undefined;
    private addPropertyEdge;
    addIndividual(individualEntity: GrapholEntity, position?: Position): GrapholElement | undefined;
    addHierarchy(hierarchy: Hierarchy, position?: Position): GrapholElement | undefined;
    addEdge(sourceId: string, targetId: string, edgeType: TypesEnum.INCLUSION | TypesEnum.EQUIVALENCE | TypesEnum.INSTANCE_OF | TypesEnum.INPUT | TypesEnum.UNION | TypesEnum.DISJOINT_UNION | TypesEnum.COMPLETE_UNION | TypesEnum.COMPLETE_DISJOINT_UNION | TypesEnum.ATTRIBUTE_EDGE): GrapholElement | undefined;
    get diagramRepresentation(): DiagramRepresentation | undefined;
    toggleFunctionality(entity: GrapholEntity, functional: boolean): void;
    toggleUnion(node: any): void;
    toggleComplete(edge: any): void;
    swapEdge(elem: EdgeSingular): void;
    removeHierarchy(hierarchy: Hierarchy): void;
    removeHierarchyInputEdge(hierarchy: Hierarchy, inputIri: string): void;
    removeHierarchyInclusionEdge(hierarchy: Hierarchy, superclassIri: string): void;
    removeElement(id: string): void;
    renameElement(elemId: string, newIri: Iri): void;
    /**
     * Get cytoscape representation of an entity given the type needed
     * @param entity
     * @param type
     * @returns
     */
    getEntityCyRepr(entity: GrapholEntity, type: TypesEnum): cytoscape__default.CollectionReturnValue;
    getNewId(nodeOrEdge: 'node' | 'edge'): string;
    private getCurrentCenterPos;
}

declare function export_default$7(theme: GrapholscapeTheme): Stylesheet[];

declare function computeHierarchies(ontology: Ontology): void;

declare abstract class ColorManager {
    protected abstract setClassColor(classEntity: any, overwrite: boolean): void;
    protected abstract getTopSuperClass(classEntity: any): any;
    protected abstract getAllChildren(classEntity: any, result: any): any;
    private static readonly brewerSequentialPalettes;
    protected getColors(numberOfColors: number): string[];
}
declare class OntologyColorManager extends ColorManager {
    private ontology;
    private diagramRepresentation;
    private _classForest;
    constructor(ontology: Ontology, diagramRepresentation: DiagramRepresentation);
    /** @internal */
    setInstanceColor(classInstance: ClassInstanceEntity, overwrite?: boolean): this;
    setClassColor(classEntity: GrapholEntity, overwrite?: boolean): this;
    colorEntities(entities?: Map<string, GrapholEntity>, overwrite?: boolean): Promise<void>;
    protected getTopSuperClass(classEntity: GrapholEntity): GrapholEntity;
    protected getAllChildren(classEntity: GrapholEntity, result?: Set<GrapholEntity>): Set<GrapholEntity>;
}
declare class DiagramColorManager extends ColorManager {
    private diagramRepresentation;
    private _classForest;
    constructor(diagramRepresentation: DiagramRepresentation);
    colorDiagram(overwrite?: boolean): void;
    setClassColor(classNode: SingularElementReturnValue, overwrite?: boolean): void;
    protected getTopSuperClass(classNode: NodeSingular): any;
    protected getAllChildren(classNode: SingularElementReturnValue | NodeSingular, result?: cytoscape$1.CollectionReturnValue): cytoscape$1.CollectionReturnValue;
}

declare const diagrams: lit_html.TemplateResult<2>;
declare const triangle_up: lit_html.TemplateResult<2>;
declare const triangle_down: lit_html.TemplateResult<2>;
declare const arrow_right: lit_html.TemplateResult<2>;
declare const arrowDown: lit_html.TemplateResult<2>;
declare const explore: lit_html.TemplateResult<2>;
declare const info_outline: lit_html.TemplateResult<2>;
declare const enterFullscreen: lit_html.TemplateResult<2>;
declare const exitFullscreen: lit_html.TemplateResult<2>;
declare const centerDiagram: lit_html.TemplateResult<2>;
declare const filter: lit_html.TemplateResult<2>;
declare const bubbles: lit_html.TemplateResult<2>;
declare const lite: lit_html.TemplateResult<2>;
declare const settings_icon: lit_html.TemplateResult<2>;
declare const infoFilled: lit_html.TemplateResult<2>;
declare const plus: lit_html.TemplateResult<2>;
declare const minus: lit_html.TemplateResult<2>;
declare const save: lit_html.TemplateResult<2>;
declare const close: lit_html.TemplateResult<2>;
declare const blankSlateDiagrams: lit_html.TemplateResult<2>;
declare const check: lit_html.TemplateResult<2>;
declare const searchOff: lit_html.TemplateResult<2>;
/**
 * Author: Simran
 * Source: https://github.com/Templarian/MaterialDesign/blob/master/svg/checkbox-multiple-blank-circle.svg
 */
declare const move_bubbles: lit_html.TemplateResult<2>;
/**
 * Author: Simran
 * Source: https://github.com/Templarian/MaterialDesign/blob/master/svg/owl.svg
 */
declare const owl_icon: lit_html.TemplateResult<2>;
declare const graphol_icon: lit_html.TemplateResult<2>;
declare const tune: lit_html.TemplateResult<2>;
declare const settings_play: lit_html.TemplateResult<2>;
declare const filterOff: lit_html.TemplateResult<2>;
declare const incremental: lit_html.TemplateResult<2>;
declare const refresh: lit_html.TemplateResult<2>;
declare const instancesIcon: lit_html.TemplateResult<2>;
declare const superHierarchies: lit_html.TemplateResult<2>;
declare const subHierarchies: lit_html.TemplateResult<2>;
declare const rubbishBin: lit_html.TemplateResult<2>;
declare const mastroEndpointIcon: lit_html.TemplateResult<2>;
declare const stopCircle: lit_html.TemplateResult<2>;
declare const equivalentClasses: lit_html.TemplateResult<2>;
declare const search$1: lit_html.TemplateResult<2>;
declare const insertInGraph: lit_html.TemplateResult<2>;
declare const cross: lit_html.TemplateResult<2>;
declare const counter: lit_html.TemplateResult<2>;
declare const labelIcon: lit_html.TemplateResult<2>;
declare const commentIcon: lit_html.TemplateResult<2>;
declare const authorIcon: lit_html.TemplateResult<2>;
declare const addDiagramIcon: lit_html.TemplateResult<2>;
declare const addClassIcon: lit_html.TemplateResult<2>;
declare const addDataPropertyIcon: lit_html.TemplateResult<2>;
declare const addIndividualIcon: lit_html.TemplateResult<2>;
declare const addObjectPropertyIcon: lit_html.TemplateResult<2>;
declare const addISAIcon: lit_html.TemplateResult<2>;
declare const addInstanceIcon: lit_html.TemplateResult<2>;
declare const addParentClassIcon: lit_html.TemplateResult<2>;
declare const addChildClassIcon: lit_html.TemplateResult<2>;
declare const addSubhierarchyIcon: lit_html.TemplateResult<2>;
declare const addInputIcon: lit_html.TemplateResult<2>;
declare const renameIcon: lit_html.TemplateResult<2>;
declare const editIcon: lit_html.TemplateResult<2>;
declare const sankey: lit_html.TemplateResult<2>;
declare const pathIcon: lit_html.TemplateResult<2>;
declare const tools: lit_html.TemplateResult<2>;
declare const undo: lit_html.TemplateResult<2>;
declare const redo: lit_html.TemplateResult<2>;
declare const addPack: lit_html.TemplateResult<2>;
declare const protocol: lit_html.TemplateResult<2>;
declare const notes: lit_html.TemplateResult<2>;
declare const colorPalette: lit_html.TemplateResult<2>;
declare const warning: lit_html.TemplateResult<2>;
declare const error: lit_html.TemplateResult<2>;
declare const toggleCatalog: lit_html.TemplateResult<2>;
declare const domain: lit_html.TemplateResult<2>;
declare const range: lit_html.TemplateResult<2>;
declare const entityIcons: {
    [x in TypesEnum.CLASS | TypesEnum.OBJECT_PROPERTY | TypesEnum.DATA_PROPERTY | TypesEnum.INDIVIDUAL | TypesEnum.ANNOTATION_PROPERTY]: SVGTemplateResult;
};
declare const annotationIcons: {
    [x: string]: SVGTemplateResult | undefined;
};

declare const _default$a: lit_html.TemplateResult<2>;

declare const _default$9: lit_html.TemplateResult<2>;

declare const _default$8: lit_html.TemplateResult<2>;

declare const _default$7: lit_html.TemplateResult<2>;

declare const _default$6: lit_html.TemplateResult<1>;

declare const index_d$3_addChildClassIcon: typeof addChildClassIcon;
declare const index_d$3_addClassIcon: typeof addClassIcon;
declare const index_d$3_addDataPropertyIcon: typeof addDataPropertyIcon;
declare const index_d$3_addDiagramIcon: typeof addDiagramIcon;
declare const index_d$3_addISAIcon: typeof addISAIcon;
declare const index_d$3_addIndividualIcon: typeof addIndividualIcon;
declare const index_d$3_addInputIcon: typeof addInputIcon;
declare const index_d$3_addInstanceIcon: typeof addInstanceIcon;
declare const index_d$3_addObjectPropertyIcon: typeof addObjectPropertyIcon;
declare const index_d$3_addPack: typeof addPack;
declare const index_d$3_addParentClassIcon: typeof addParentClassIcon;
declare const index_d$3_addSubhierarchyIcon: typeof addSubhierarchyIcon;
declare const index_d$3_annotationIcons: typeof annotationIcons;
declare const index_d$3_arrowDown: typeof arrowDown;
declare const index_d$3_arrow_right: typeof arrow_right;
declare const index_d$3_authorIcon: typeof authorIcon;
declare const index_d$3_blankSlateDiagrams: typeof blankSlateDiagrams;
declare const index_d$3_bubbles: typeof bubbles;
declare const index_d$3_centerDiagram: typeof centerDiagram;
declare const index_d$3_check: typeof check;
declare const index_d$3_close: typeof close;
declare const index_d$3_colorPalette: typeof colorPalette;
declare const index_d$3_commentIcon: typeof commentIcon;
declare const index_d$3_counter: typeof counter;
declare const index_d$3_cross: typeof cross;
declare const index_d$3_diagrams: typeof diagrams;
declare const index_d$3_domain: typeof domain;
declare const index_d$3_editIcon: typeof editIcon;
declare const index_d$3_enterFullscreen: typeof enterFullscreen;
declare const index_d$3_entityIcons: typeof entityIcons;
declare const index_d$3_equivalentClasses: typeof equivalentClasses;
declare const index_d$3_error: typeof error;
declare const index_d$3_exitFullscreen: typeof exitFullscreen;
declare const index_d$3_explore: typeof explore;
declare const index_d$3_filter: typeof filter;
declare const index_d$3_filterOff: typeof filterOff;
declare const index_d$3_graphol_icon: typeof graphol_icon;
declare const index_d$3_incremental: typeof incremental;
declare const index_d$3_infoFilled: typeof infoFilled;
declare const index_d$3_info_outline: typeof info_outline;
declare const index_d$3_insertInGraph: typeof insertInGraph;
declare const index_d$3_instancesIcon: typeof instancesIcon;
declare const index_d$3_labelIcon: typeof labelIcon;
declare const index_d$3_lite: typeof lite;
declare const index_d$3_mastroEndpointIcon: typeof mastroEndpointIcon;
declare const index_d$3_minus: typeof minus;
declare const index_d$3_move_bubbles: typeof move_bubbles;
declare const index_d$3_notes: typeof notes;
declare const index_d$3_owl_icon: typeof owl_icon;
declare const index_d$3_pathIcon: typeof pathIcon;
declare const index_d$3_plus: typeof plus;
declare const index_d$3_protocol: typeof protocol;
declare const index_d$3_range: typeof range;
declare const index_d$3_redo: typeof redo;
declare const index_d$3_refresh: typeof refresh;
declare const index_d$3_renameIcon: typeof renameIcon;
declare const index_d$3_rubbishBin: typeof rubbishBin;
declare const index_d$3_sankey: typeof sankey;
declare const index_d$3_save: typeof save;
declare const index_d$3_searchOff: typeof searchOff;
declare const index_d$3_settings_icon: typeof settings_icon;
declare const index_d$3_settings_play: typeof settings_play;
declare const index_d$3_stopCircle: typeof stopCircle;
declare const index_d$3_subHierarchies: typeof subHierarchies;
declare const index_d$3_superHierarchies: typeof superHierarchies;
declare const index_d$3_toggleCatalog: typeof toggleCatalog;
declare const index_d$3_tools: typeof tools;
declare const index_d$3_triangle_down: typeof triangle_down;
declare const index_d$3_triangle_up: typeof triangle_up;
declare const index_d$3_tune: typeof tune;
declare const index_d$3_undo: typeof undo;
declare const index_d$3_warning: typeof warning;
declare namespace index_d$3 {
  export {
    index_d$3_addChildClassIcon as addChildClassIcon,
    index_d$3_addClassIcon as addClassIcon,
    index_d$3_addDataPropertyIcon as addDataPropertyIcon,
    index_d$3_addDiagramIcon as addDiagramIcon,
    index_d$3_addISAIcon as addISAIcon,
    index_d$3_addIndividualIcon as addIndividualIcon,
    index_d$3_addInputIcon as addInputIcon,
    index_d$3_addInstanceIcon as addInstanceIcon,
    index_d$3_addObjectPropertyIcon as addObjectPropertyIcon,
    index_d$3_addPack as addPack,
    index_d$3_addParentClassIcon as addParentClassIcon,
    index_d$3_addSubhierarchyIcon as addSubhierarchyIcon,
    index_d$3_annotationIcons as annotationIcons,
    index_d$3_arrowDown as arrowDown,
    index_d$3_arrow_right as arrow_right,
    index_d$3_authorIcon as authorIcon,
    index_d$3_blankSlateDiagrams as blankSlateDiagrams,
    index_d$3_bubbles as bubbles,
    index_d$3_centerDiagram as centerDiagram,
    index_d$3_check as check,
    _default$a as classIcon,
    index_d$3_close as close,
    index_d$3_colorPalette as colorPalette,
    index_d$3_commentIcon as commentIcon,
    index_d$3_counter as counter,
    index_d$3_cross as cross,
    _default$8 as dataPropertyIcon,
    index_d$3_diagrams as diagrams,
    index_d$3_domain as domain,
    index_d$3_editIcon as editIcon,
    index_d$3_enterFullscreen as enterFullscreen,
    index_d$3_entityIcons as entityIcons,
    index_d$3_equivalentClasses as equivalentClasses,
    index_d$3_error as error,
    index_d$3_exitFullscreen as exitFullscreen,
    index_d$3_explore as explore,
    index_d$3_filter as filter,
    index_d$3_filterOff as filterOff,
    index_d$3_graphol_icon as graphol_icon,
    _default$6 as grapholscapeLogo,
    index_d$3_incremental as incremental,
    _default$7 as individualIcon,
    index_d$3_infoFilled as infoFilled,
    index_d$3_info_outline as info_outline,
    index_d$3_insertInGraph as insertInGraph,
    index_d$3_instancesIcon as instancesIcon,
    index_d$3_labelIcon as labelIcon,
    index_d$3_lite as lite,
    index_d$3_mastroEndpointIcon as mastroEndpointIcon,
    index_d$3_minus as minus,
    index_d$3_move_bubbles as move_bubbles,
    index_d$3_notes as notes,
    _default$9 as objectPropertyIcon,
    index_d$3_owl_icon as owl_icon,
    index_d$3_pathIcon as pathIcon,
    index_d$3_plus as plus,
    index_d$3_protocol as protocol,
    index_d$3_range as range,
    index_d$3_redo as redo,
    index_d$3_refresh as refresh,
    index_d$3_renameIcon as renameIcon,
    index_d$3_rubbishBin as rubbishBin,
    index_d$3_sankey as sankey,
    index_d$3_save as save,
    search$1 as search,
    index_d$3_searchOff as searchOff,
    index_d$3_settings_icon as settings_icon,
    index_d$3_settings_play as settings_play,
    index_d$3_stopCircle as stopCircle,
    index_d$3_subHierarchies as subHierarchies,
    index_d$3_superHierarchies as superHierarchies,
    index_d$3_toggleCatalog as toggleCatalog,
    index_d$3_tools as tools,
    index_d$3_triangle_down as triangle_down,
    index_d$3_triangle_up as triangle_up,
    index_d$3_tune as tune,
    index_d$3_undo as undo,
    index_d$3_warning as warning,
  };
}

type Constructor$3<T = {}> = new (...args: any[]) => T;
declare class IBaseMixin {
    hide(): void;
    show(): void;
    showInPosition(position?: {
        x: number;
        y: number;
    }): void;
    enable(): void;
    disable(): void;
    onStateChange(): void;
    isVisible: boolean;
    enabled: boolean;
}
declare const BaseMixin: <T extends Constructor$3<LitElement>>(superClass: T) => Constructor$3<IBaseMixin> & T;

type Constructor$2<T = {}> = new (...args: any[]) => T;
declare class IDropPanelMixin {
    protected isDefaultClosed: boolean;
    togglePanel(): void;
    openPanel(): void;
    closePanel(): void;
    protected get panel(): HTMLElement | undefined | null;
    onTogglePanel(): void;
    isPanelClosed(): boolean;
}
declare const DropPanelMixin: <T extends Constructor$2<LitElement>>(superClass: T) => Constructor$2<IDropPanelMixin> & T;
declare function hasDropPanel(element: any): element is IDropPanelMixin;

type Constructor$1<T = {}> = new (...args: any[]) => T;
declare class IModalMixin {
    hide(): void;
    show(): void;
    protected modalBackground: HTMLDivElement;
}
declare const ModalMixin: <T extends Constructor$1<LitElement & IBaseMixin>>(superClass: T) => Constructor$1<IModalMixin> & T;

type Constructor<T = {}> = new (...args: any[]) => T;
declare class IContextualWidgetMixin {
    hide(): void;
    /**
     * Attach cxt widget and show it
     * @param element the target html elment
     */
    attachTo(element: HTMLElement): void;
    /**
     * Attach cxt widget and do not show it, if it was visible it stays visible
     * @param element the target html element
     */
    attachToSilently(element: HTMLElement): void;
    cxtWidgetProps: Partial<Props>;
    tippyWidget: Instance<Props>;
}
declare const ContextualWidgetMixin: <T extends Constructor<LitElement>>(superClass: T) => Constructor<IContextualWidgetMixin> & T;

declare enum SizeEnum {
    S = "s",
    M = "m",
    L = "l"
}
declare const GscapeButton_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeButton extends GscapeButton_base {
    disabled: boolean;
    asSwitch: boolean;
    active: boolean;
    label: string;
    size: SizeEnum;
    type: string;
    fullWidth: string;
    private toggled;
    static properties: {
        active: {
            type: BooleanConstructor;
            reflect: boolean;
        };
        label: {
            type: StringConstructor;
            reflect: boolean;
        };
        title: {
            type: StringConstructor;
            reflect: boolean;
        };
        disabled: {
            type: BooleanConstructor;
            reflect: boolean;
        };
        asSwitch: {
            type: BooleanConstructor;
            attribute: string;
            reflect: boolean;
        };
        size: {
            type: StringConstructor;
            reflect: boolean;
        };
        type: {
            type: StringConstructor;
            reflect: boolean;
        };
        fullWidth: {
            type: StringConstructor;
            attribute: string;
            reflect: boolean;
        };
        toggled: {
            type: BooleanConstructor;
            state: boolean;
        };
    };
    static styles: lit.CSSResult[];
    constructor();
    render(): lit_html.TemplateResult<1>;
    private clickHandler;
    private get altIcon();
}

declare const NodeButton_base: (new (...args: any[]) => IContextualWidgetMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class NodeButton extends NodeButton_base {
    content: TemplateResult | SVGTemplateResult | string | number;
    contentType: 'icon' | 'template';
    node?: NodeSingular;
    highlighted?: boolean;
    cxtWidgetProps: Partial<Props>;
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    constructor(content: TemplateResult | SVGTemplateResult | string | number, contentType?: 'icon' | 'template');
    render(): TemplateResult<1>;
}

declare const _default$5: lit.CSSResult;

/**
 * A command for the context menu
 */
interface Command {
    /** the string to show */
    content: string;
    /** optional icon */
    icon?: SVGTemplateResult;
    /** callback to execute on selection */
    select: () => void;
}
declare const GscapeContextMenu_base: (new (...args: any[]) => IContextualWidgetMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeContextMenu extends GscapeContextMenu_base {
    commands: Command[];
    customElements: (LitElement | HTMLElement | TemplateResult)[];
    showFirst: 'commands' | 'elements';
    onCommandRun: () => void;
    static properties: PropertyDeclarations;
    static styles: CSSResultArray;
    render(): TemplateResult<1>;
    attachTo(element: HTMLElement, commands?: Command[], elements?: (LitElement | HTMLElement | TemplateResult)[]): void;
    attachToPosition(position: {
        x: number;
        y: number;
    }, container: Element, commands?: Command[], elements?: (LitElement | HTMLElement | TemplateResult)[]): void;
    private handleCommandClick;
    private get commandsTemplate();
    private get customElementsTemplate();
}

declare class GscapeActionListItem extends LitElement {
    label: string;
    selected: boolean;
    private expanded;
    subtle: boolean;
    disabled: boolean;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    constructor();
    render(): lit_html.TemplateResult<1>;
    private clickHandler;
    private get hiddenContent();
}

declare const _default$4: lit.CSSResult;

declare class GscapeEntityListItem extends LitElement {
    private _types;
    private _color?;
    displayedName: string;
    iri: string;
    actionable: boolean;
    asAccordion: boolean;
    disabled: boolean;
    private isAccordionOpen;
    static properties: PropertyDeclarations;
    static styles: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private iconNameSlotTemplate;
    private handleDetailsClick;
    openAccordion(): void;
    closeAccordion(): void;
    set types(newTypes: TypesEnum[] | undefined);
    get types(): TypesEnum[] | undefined;
    set color(newColor: string | undefined);
    get color(): string | undefined;
}

declare const textSpinner: () => lit_html.TemplateResult<1>;
declare const textSpinnerStyle: lit.CSSResult;

declare function getContentSpinner(): lit_html.TemplateResult<1>;
declare const contentSpinnerStyle: lit.CSSResult;
declare class ContentSpinner extends LitElement {
    color: string;
    static styles: lit.CSSResult[];
    static properties: PropertyDeclarations;
    render: typeof getContentSpinner;
    setColor(newColor: string): void;
}

declare class GscapeTextSearch extends LitElement {
    private _onSearchCallback;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    onSearch(callback: (e: KeyboardEvent) => void): void;
}

type ViewObjectProperty = EntityViewData & {
    connectedClasses: EntityViewData[];
    direct: boolean;
};
type EntityViewData = {
    displayedName: string;
    value: {
        iri: Iri;
        types: TypesEnum[];
    } & AnnotatedElement;
    viewOccurrences?: Map<DiagramViewData, OccurrenceIdViewData[]>;
    disabled?: boolean;
    loading?: boolean;
};
interface IEntityFilters {
    [TypesEnum.CLASS]?: number;
    [TypesEnum.DATA_PROPERTY]?: number;
    [TypesEnum.OBJECT_PROPERTY]?: number;
    [TypesEnum.INDIVIDUAL]?: number;
    areAllFiltersDisabled: boolean;
}

declare const GscapeEntitySearch_base: (new (...args: any[]) => IDropPanelMixin) & typeof LitElement;
declare class GscapeEntitySearch extends GscapeEntitySearch_base implements IEntityFilters {
    areAllFiltersDisabled: boolean;
    [TypesEnum.CLASS]?: number;
    [TypesEnum.DATA_PROPERTY]?: number;
    [TypesEnum.OBJECT_PROPERTY]?: number;
    [TypesEnum.INDIVIDUAL]?: number;
    private isSearchTextEmpty;
    private searchTimeout;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private handleKeyPress;
    private handleSearch;
    clearSearch(): void;
    private get atLeastTwoFilters();
    private get input();
}
type SearchEvent = CustomEvent<{
    searchText: string;
}>;

declare const GscapeEntityTypeFilters_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeEntityTypeFilters extends GscapeEntityTypeFilters_base implements IEntityFilters {
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    _class?: number;
    _dataproperty?: number;
    _objectproperty?: number;
    _individual?: number;
    _classInstance?: number;
    render(): lit_html.TemplateResult<1>;
    private getChipTemplate;
    private _handleFilterStateChange;
    get areAllFiltersDisabled(): boolean;
    set [TypesEnum.CLASS](v: number | undefined);
    get [TypesEnum.CLASS](): number | undefined;
    set [TypesEnum.DATA_PROPERTY](v: number | undefined);
    get [TypesEnum.DATA_PROPERTY](): number | undefined;
    set [TypesEnum.OBJECT_PROPERTY](v: number | undefined);
    get [TypesEnum.OBJECT_PROPERTY](): number | undefined;
    set [TypesEnum.INDIVIDUAL](v: number | undefined);
    get [TypesEnum.INDIVIDUAL](): number | undefined;
}
type EntityFilterEvent = CustomEvent<IEntityFilters>;

declare enum ToggleLabelPosition {
    LEFT = "left",
    RIGHT = "right"
}
declare class GscapeToggle extends LitElement {
    key: string;
    checked: boolean;
    disabled: boolean;
    label: string;
    labelPosition: ToggleLabelPosition;
    static ToggleLabelPosition: typeof ToggleLabelPosition;
    static get properties(): {
        disabled: {
            type: BooleanConstructor;
            reflect: boolean;
        };
        label: {
            type: StringConstructor;
            reflect: boolean;
        };
        labelPosition: {
            type: StringConstructor;
            reflect: boolean;
            attribute: string;
        };
        key: {
            type: StringConstructor;
            reflect: boolean;
        };
        checked: {
            type: BooleanConstructor;
            reflect: boolean;
        };
    };
    static styles: lit.CSSResult[];
    render(): lit_html.TemplateResult<1>;
}

declare const GscapeConfirmDialog_base: (new (...args: any[]) => IModalMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeConfirmDialog extends GscapeConfirmDialog_base {
    message?: string | undefined;
    dialogTitle: string;
    type: 'neutral' | 'warning' | 'error';
    protected _onConfirm?: (...args: any[]) => void;
    protected _onCancel?: () => void;
    constructor(message?: string | undefined, dialogTitle?: string, type?: 'neutral' | 'warning' | 'error');
    static properties: PropertyDeclarations;
    static styles: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    protected get headerIcon(): lit_html.TemplateResult<2>;
    protected handleConfirm(): void;
    protected handleCancel(): void;
    onConfirm(callback: () => void): GscapeConfirmDialog;
    onCancel(callback: () => void): GscapeConfirmDialog;
}
declare function showMessage(message: string, title: string, container: any, type?: "neutral" | 'warning' | 'error'): GscapeConfirmDialog;

type SelectOption = {
    id: string;
    text: string;
    trailingIcon?: SVGTemplateResult;
    leadingIcon?: SVGTemplateResult;
    disabled?: boolean;
};
declare const GscapeSelect_base: (new (...args: any[]) => IDropPanelMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeSelect extends GscapeSelect_base {
    private readonly PLACEHOLDER_ID;
    defaultIcon: SVGTemplateResult;
    selectedOptionsId: Set<string>;
    defaultOptionId?: string;
    options: SelectOption[];
    size: SizeEnum;
    clearable: boolean;
    multipleSelection: boolean;
    private _placeholder;
    onSelection: (optionId: string) => void;
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    render(): lit_html.TemplateResult<1>;
    private handleSelection;
    private getButton;
    clear(): void;
    private isSelectionEmpty;
    private isIdSelected;
    get selectedOptions(): SelectOption[];
    get defaultOption(): SelectOption;
    get placeholder(): SelectOption;
    set placeholder(placeHolder: SelectOption);
}

interface IEntitySelector {
    onClassSelection(callback: (iri: string) => void): void;
}
declare const GscapeEntitySelector_base: (new (...args: any[]) => IDropPanelMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeEntitySelector extends GscapeEntitySelector_base {
    title: string;
    private fullEntityList;
    private _entityList;
    private onClassSelectionCallback;
    private isSearchTextEmpty;
    private loading;
    static get properties(): {
        entityList: {
            type: ObjectConstructor;
            attribute: boolean;
        };
        isSearchTextEmpty: {
            type: BooleanConstructor;
            state: boolean;
        };
        loading: {
            type: BooleanConstructor;
            state: boolean;
        };
        onClassSelection: {
            type: ObjectConstructor;
        };
    };
    static styles: lit.CSSResult[];
    constructor();
    render(): lit_html.TemplateResult<1>;
    blur(): void;
    focusInputSearch(): Promise<void>;
    private handleEntitySelection;
    private handleKeyPressOnEntry;
    private handleSearch;
    clearSearch(): void;
    get onClassSelection(): (iri: string) => void;
    set onClassSelection(callback: (iri: string) => void);
    set entityList(newEntityList: EntityViewData[]);
    get entityList(): EntityViewData[];
    private get input();
}

type UiOption = {
    name: string;
    id: string;
    icon: SVGTemplateResult;
    description?: string;
};

declare const GscapeFullPageSelector_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeFullPageSelector extends GscapeFullPageSelector_base {
    options: (UiOption | undefined)[];
    title: string;
    onOptionSelection: (optionId: string) => void;
    static properties: PropertyDeclarations;
    static styles: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private handleRendererSelection;
}

declare function initInitialRendererSelector(grapholscape: Grapholscape): void;

/**
 * Initialize the UI
 */
declare function export_default$6(grapholscape: Grapholscape): void;

declare const _default$3: lit.CSSResult;

declare const BOTTOM_RIGHT_WIDGET: lit.CSSResult;
declare const _default$2: lit.CSSResult;

declare const _default$1: lit_html.TemplateResult<1>;

type DiagramViewData = {
    id: number;
    name: string;
};
type OccurrenceIdViewData = {
    originalId: string;
    realId: string;
};
declare function getEntityOccurrencesTemplate(occurrences: Map<DiagramViewData, OccurrenceIdViewData[]>, onNodeNavigation: (elementId: string, diagramId: number) => void): lit_html.TemplateResult<1>;

declare function createEntitiesList(grapholscape: Grapholscape, entityFilters?: IEntityFilters): EntityViewData[];
declare function search(searchValue: string, entities: EntityViewData[]): Promise<EntityViewData[]>;

declare function export_default$5(slotName: string, icon: SVGTemplateResult): HTMLSpanElement;

declare enum WidgetEnum {
    DIAGRAM_SELECTOR = "diagram-selector",
    ENTITY_DETAILS = "details",
    ENTITY_SELECTOR = "entity-selector",
    FILTERS = "filters",
    FIT_BUTTON = "fit-button",
    FULLSCREEN_BUTTON = "fullscreen-button",
    ONTOLOGY_EXPLORER = "ontology-explorer",
    ONTOLOGY_INFO = "ontology-info",
    OWL_VISUALIZER = "owl-visualizer",
    RENDERER_SELECTOR = "renderer-selector",
    LAYOUT_SETTINGS = "layout-settings",
    SETTINGS = "settings",
    ZOOM_TOOLS = "zoom-tools",
    INITIAL_RENDERER_SELECTOR = "initial-renderer-selector",
    ENTITY_COLOR_LEGEND = "entity-color-legend",
    COLOR_BUTTON = "color-button",
    /** @internal */
    INCREMENTAL_ENTITY_DETAILS = "class-instance-details",
    /** @internal */
    INSTANCES_EXPLORER = "instances-explorer",
    /** @internal */
    NAVIGATION_MENU = "naviagtion-menu",
    /** @internal */
    VKG_PREFERENCES = "vkg-preferences",
    INCREMENTAL_INITIAL_MENU = "incremental-initial-menu",
    DESIGNER_TOOLBOX = "designer-toolbox"
}

type TabProps = {
    id: number;
    icon?: SVGTemplateResult;
    label: string;
};

declare const GscapeDiagramSelector_base: (new (...args: any[]) => IDropPanelMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeDiagramSelector extends GscapeDiagramSelector_base {
    title: string;
    diagrams: Diagram[];
    currentDiagramId: number;
    currentDiagramName: string;
    onDiagramSelection: (diagramId: number) => void;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private diagramSelectionHandler;
    private get currentDiagram();
}

declare const IncrementalInitialMenu_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class IncrementalInitialMenu extends IncrementalInitialMenu_base {
    classes?: EntityViewData[];
    shortestPathEnabled: boolean;
    sideMenuMode: boolean;
    static properties: {
        classes: {
            type: ArrayConstructor;
        };
        sideMenuMode: {
            type: BooleanConstructor;
        };
        shortestPathEnabled: {
            type: BooleanConstructor;
        };
    };
    static styles: lit.CSSResult[];
    constructor(grapholscape?: Grapholscape);
    render: () => lit_html.TemplateResult<1>;
    focusInputSearch(): void;
    closePanel(): void;
    openPanel(): void;
    private handleShortestPathBtnClick;
    private handleClassSelection;
}

/** @internal */
declare class ShortestPathDialog extends GscapeConfirmDialog {
    classes?: EntityViewData[];
    class1EditEnabled: boolean;
    private _class1?;
    class2EditEnabled: boolean;
    private _class2?;
    protected _onConfirm?: (sourceClassIri: string, targetClassIri: string) => void;
    static properties: {
        classes: {
            type: ArrayConstructor;
        };
        _class1: {
            type: StringConstructor;
            attribute: string;
        };
        _class2: {
            type: StringConstructor;
            attribute: string;
        };
        class1EditEnabled: {
            type: BooleanConstructor;
        };
        class2EditEnabled: {
            type: BooleanConstructor;
        };
    };
    static styles: lit.CSSResultGroup[];
    constructor(grapholscape?: Grapholscape);
    render: () => lit_html.TemplateResult<1>;
    closePanel(): void;
    openPanel(): void;
    onConfirm(callback: (sourceClassIri: string, targetClassIri: string) => void): GscapeConfirmDialog;
    private getClassSelectorTemplate;
    private handleClassSelection;
    protected handleConfirm(): void;
    set class1(newClassIri: string | undefined);
    get class1(): string | undefined;
    set class2(newClassIri: string | undefined);
    get class2(): string | undefined;
}

type ClassWithColor = {
    id: string;
    displayedName: string;
    iri: string;
    color?: string;
    filtered: boolean;
};
declare const GscapeEntityColorLegend_base: (new (...args: any[]) => IDropPanelMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeEntityColorLegend extends GscapeEntityColorLegend_base {
    title: string;
    elements: ClassWithColor[];
    protected isDefaultClosed: boolean;
    onElementSelection: (classWithColor: ClassWithColor) => void;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup | undefined;
    private handleElemClick;
    blur(): void;
    render(): lit_html.TemplateResult<1>;
}

declare function setColorList(entityColorLegend: GscapeEntityColorLegend, grapholscape: Grapholscape): void;

declare function a11yClick(event: any): boolean | undefined;

/** @module UI */

declare const index_d$2_BaseMixin: typeof BaseMixin;
type index_d$2_ClassWithColor = ClassWithColor;
type index_d$2_Command = Command;
type index_d$2_ContentSpinner = ContentSpinner;
declare const index_d$2_ContentSpinner: typeof ContentSpinner;
declare const index_d$2_ContextualWidgetMixin: typeof ContextualWidgetMixin;
type index_d$2_DiagramViewData = DiagramViewData;
declare const index_d$2_DropPanelMixin: typeof DropPanelMixin;
type index_d$2_EntityFilterEvent = EntityFilterEvent;
type index_d$2_EntityViewData = EntityViewData;
type index_d$2_GscapeActionListItem = GscapeActionListItem;
declare const index_d$2_GscapeActionListItem: typeof GscapeActionListItem;
type index_d$2_GscapeButton = GscapeButton;
declare const index_d$2_GscapeButton: typeof GscapeButton;
type index_d$2_GscapeConfirmDialog = GscapeConfirmDialog;
declare const index_d$2_GscapeConfirmDialog: typeof GscapeConfirmDialog;
type index_d$2_GscapeContextMenu = GscapeContextMenu;
declare const index_d$2_GscapeContextMenu: typeof GscapeContextMenu;
type index_d$2_GscapeDiagramSelector = GscapeDiagramSelector;
declare const index_d$2_GscapeDiagramSelector: typeof GscapeDiagramSelector;
type index_d$2_GscapeEntityColorLegend = GscapeEntityColorLegend;
declare const index_d$2_GscapeEntityColorLegend: typeof GscapeEntityColorLegend;
type index_d$2_GscapeEntityListItem = GscapeEntityListItem;
declare const index_d$2_GscapeEntityListItem: typeof GscapeEntityListItem;
type index_d$2_GscapeEntitySearch = GscapeEntitySearch;
declare const index_d$2_GscapeEntitySearch: typeof GscapeEntitySearch;
type index_d$2_GscapeEntitySelector = GscapeEntitySelector;
declare const index_d$2_GscapeEntitySelector: typeof GscapeEntitySelector;
type index_d$2_GscapeEntityTypeFilters = GscapeEntityTypeFilters;
declare const index_d$2_GscapeEntityTypeFilters: typeof GscapeEntityTypeFilters;
type index_d$2_GscapeFullPageSelector = GscapeFullPageSelector;
declare const index_d$2_GscapeFullPageSelector: typeof GscapeFullPageSelector;
type index_d$2_GscapeSelect = GscapeSelect;
declare const index_d$2_GscapeSelect: typeof GscapeSelect;
type index_d$2_GscapeTextSearch = GscapeTextSearch;
declare const index_d$2_GscapeTextSearch: typeof GscapeTextSearch;
type index_d$2_GscapeToggle = GscapeToggle;
declare const index_d$2_GscapeToggle: typeof GscapeToggle;
type index_d$2_IBaseMixin = IBaseMixin;
declare const index_d$2_IBaseMixin: typeof IBaseMixin;
type index_d$2_IContextualWidgetMixin = IContextualWidgetMixin;
declare const index_d$2_IContextualWidgetMixin: typeof IContextualWidgetMixin;
type index_d$2_IDropPanelMixin = IDropPanelMixin;
declare const index_d$2_IDropPanelMixin: typeof IDropPanelMixin;
type index_d$2_IEntityFilters = IEntityFilters;
type index_d$2_IEntitySelector = IEntitySelector;
type index_d$2_IModalMixin = IModalMixin;
declare const index_d$2_IModalMixin: typeof IModalMixin;
type index_d$2_IncrementalInitialMenu = IncrementalInitialMenu;
declare const index_d$2_IncrementalInitialMenu: typeof IncrementalInitialMenu;
declare const index_d$2_ModalMixin: typeof ModalMixin;
type index_d$2_NodeButton = NodeButton;
declare const index_d$2_NodeButton: typeof NodeButton;
type index_d$2_OccurrenceIdViewData = OccurrenceIdViewData;
type index_d$2_SearchEvent = SearchEvent;
type index_d$2_SelectOption = SelectOption;
type index_d$2_ShortestPathDialog = ShortestPathDialog;
declare const index_d$2_ShortestPathDialog: typeof ShortestPathDialog;
type index_d$2_SizeEnum = SizeEnum;
declare const index_d$2_SizeEnum: typeof SizeEnum;
type index_d$2_TabProps = TabProps;
type index_d$2_ToggleLabelPosition = ToggleLabelPosition;
declare const index_d$2_ToggleLabelPosition: typeof ToggleLabelPosition;
type index_d$2_UiOption = UiOption;
type index_d$2_ViewObjectProperty = ViewObjectProperty;
type index_d$2_WidgetEnum = WidgetEnum;
declare const index_d$2_WidgetEnum: typeof WidgetEnum;
declare const index_d$2_a11yClick: typeof a11yClick;
declare const index_d$2_contentSpinnerStyle: typeof contentSpinnerStyle;
declare const index_d$2_createEntitiesList: typeof createEntitiesList;
declare const index_d$2_getContentSpinner: typeof getContentSpinner;
declare const index_d$2_getEntityOccurrencesTemplate: typeof getEntityOccurrencesTemplate;
declare const index_d$2_hasDropPanel: typeof hasDropPanel;
declare const index_d$2_initInitialRendererSelector: typeof initInitialRendererSelector;
declare const index_d$2_search: typeof search;
declare const index_d$2_setColorList: typeof setColorList;
declare const index_d$2_showMessage: typeof showMessage;
declare const index_d$2_textSpinner: typeof textSpinner;
declare const index_d$2_textSpinnerStyle: typeof textSpinnerStyle;
declare namespace index_d$2 {
  export {
    BOTTOM_RIGHT_WIDGET as BOTTOM_RIGHT_WIDGET_CLASS,
    index_d$2_BaseMixin as BaseMixin,
    index_d$2_ClassWithColor as ClassWithColor,
    index_d$2_Command as Command,
    index_d$2_ContentSpinner as ContentSpinner,
    index_d$2_ContextualWidgetMixin as ContextualWidgetMixin,
    index_d$2_DiagramViewData as DiagramViewData,
    index_d$2_DropPanelMixin as DropPanelMixin,
    index_d$2_EntityFilterEvent as EntityFilterEvent,
    index_d$2_EntityViewData as EntityViewData,
    index_d$2_GscapeActionListItem as GscapeActionListItem,
    _default$4 as GscapeActionListStyle,
    index_d$2_GscapeButton as GscapeButton,
    _default$5 as GscapeButtonStyle,
    index_d$2_GscapeConfirmDialog as GscapeConfirmDialog,
    index_d$2_GscapeContextMenu as GscapeContextMenu,
    index_d$2_GscapeDiagramSelector as GscapeDiagramSelector,
    index_d$2_GscapeEntityColorLegend as GscapeEntityColorLegend,
    index_d$2_GscapeEntityListItem as GscapeEntityListItem,
    index_d$2_GscapeEntitySearch as GscapeEntitySearch,
    index_d$2_GscapeEntitySelector as GscapeEntitySelector,
    index_d$2_GscapeEntityTypeFilters as GscapeEntityTypeFilters,
    index_d$2_GscapeFullPageSelector as GscapeFullPageSelector,
    index_d$2_GscapeSelect as GscapeSelect,
    index_d$2_GscapeTextSearch as GscapeTextSearch,
    index_d$2_GscapeToggle as GscapeToggle,
    index_d$2_IBaseMixin as IBaseMixin,
    index_d$2_IContextualWidgetMixin as IContextualWidgetMixin,
    index_d$2_IDropPanelMixin as IDropPanelMixin,
    index_d$2_IEntityFilters as IEntityFilters,
    index_d$2_IEntitySelector as IEntitySelector,
    index_d$2_IModalMixin as IModalMixin,
    index_d$2_IncrementalInitialMenu as IncrementalInitialMenu,
    index_d$2_ModalMixin as ModalMixin,
    index_d$2_NodeButton as NodeButton,
    index_d$2_OccurrenceIdViewData as OccurrenceIdViewData,
    index_d$2_SearchEvent as SearchEvent,
    index_d$2_SelectOption as SelectOption,
    index_d$2_ShortestPathDialog as ShortestPathDialog,
    index_d$2_SizeEnum as SizeEnum,
    index_d$2_TabProps as TabProps,
    index_d$2_ToggleLabelPosition as ToggleLabelPosition,
    index_d$2_UiOption as UiOption,
    index_d$2_ViewObjectProperty as ViewObjectProperty,
    index_d$2_WidgetEnum as WidgetEnum,
    index_d$2_a11yClick as a11yClick,
    _default$2 as baseStyle,
    index_d$2_contentSpinnerStyle as contentSpinnerStyle,
    index_d$2_createEntitiesList as createEntitiesList,
    _default$1 as emptySearchBlankState,
    _default$3 as entityListItemStyle,
    index_d$2_getContentSpinner as getContentSpinner,
    index_d$2_getEntityOccurrencesTemplate as getEntityOccurrencesTemplate,
    export_default$5 as getIconSlot,
    index_d$2_hasDropPanel as hasDropPanel,
    index_d$3 as icons,
    index_d$2_initInitialRendererSelector as initInitialRendererSelector,
    export_default$6 as initUI,
    index_d$2_search as search,
    index_d$2_setColorList as setColorList,
    index_d$2_showMessage as showMessage,
    index_d$2_textSpinner as textSpinner,
    index_d$2_textSpinnerStyle as textSpinnerStyle,
  };
}

type ObjectPropertyConnectedClasses = {
    list: GrapholEntity[];
    direct: boolean;
    available: boolean;
};
declare class NeighbourhoodFinder {
    private ontology;
    constructor(ontology: Ontology);
    getDataProperties(classIriString: string): GrapholEntity[];
    getObjectProperties(classIriString: string): Map<GrapholEntity, ObjectPropertyConnectedClasses>;
    /**
     * Given a class and an object property, get all classes connected to the given class through such an
     * object property.
     * @param sourceClassIriString the class' iri involved in the object property
     * either as domain or range
     * @param objectPropertyIriString the object property's iri for which to retrieve the connected classes' iris
     * @returns an array of entities
     */
    getClassesConnectedToObjectProperty(sourceClassIriString: string, objectPropertyIriString: string): GrapholEntity[];
    private getConnectedClassesIrisByType;
    getSubclassesIris(classIri: string): string[];
    getEquivalentClassesIris(classIri: string): string[];
    getSuperclassesIris(classIri: string): string[];
    private getIriObject;
}

/** @internal */
declare class ClassInstanceEntity extends GrapholEntity implements ClassInstanceEntity$1 {
    private _parentClassIris;
    private _dataProperties;
    protected _manualTypes?: Set<TypesEnum> | undefined;
    constructor(iri: Iri, parentClassIris?: Iri[]);
    /**
     * Set the instance to be instance of a particular Class.
     * If it is already instance of such a class, no changes will be made.
     * @param parentClassIri the IRI of the Class
     */
    addParentClass(parentClassIri: Iri): void;
    /**
     * Check if the instance is instance of a class with such an IRI
     * @param parentClassIri
     * @returns
     */
    hasParentClassIri(parentClassIri: string | Iri): boolean;
    get isRDFTypeUnknown(): boolean;
    get parentClassIris(): Iri[];
    get dataProperties(): DataPropertyValue[];
    set dataProperties(newProperties: DataPropertyValue[]);
    json(): ClassInstanceEntity$1;
}

/** @internal */
declare enum IncrementalEvent {
    RequestStopped = "requestStopped",
    NewInstances = "newInstances",
    InstancesSearchFinished = "instancesSearchFinished",
    LimitChange = "limitChange",
    EndpointChange = "endpointChange",
    Reset = "reset",
    ClassInstanceSelection = "classInstanceSselection",
    ClassSelection = "classSelection",
    ContextClick = "contextClick",
    DoubleTap = "doubleTap",
    DiagramUpdated = "diagramUpdated",
    ReasonerSet = "reasonerSet",
    NewDataPropertyValues = "newDataPropertyValues",
    DataPropertyValuesLoadingFinished = "dpvaluesloadfinish"
}
/** @internal */
interface IonIncrementalEvent {
    (event: IncrementalEvent.RequestStopped, callback: () => void): void;
    (event: IncrementalEvent.InstancesSearchFinished, callback: () => void): void;
    (event: IncrementalEvent.LimitChange, callback: (limit: number) => void): void;
    (event: IncrementalEvent.Reset, callback: () => void): void;
    (event: IncrementalEvent.ClassInstanceSelection, callback: (classInstanceEntity: ClassInstanceEntity) => void): void;
    (event: IncrementalEvent.ClassSelection, callback: (classEntity: GrapholEntity) => void): void;
    (event: IncrementalEvent.DiagramUpdated, callback: () => void): void;
    (event: IncrementalEvent.ReasonerSet, callback: () => void): void;
    (event: IncrementalEvent.NewDataPropertyValues, callback: (instanceIri: string, dataPropertyIri: string, newValues: string[]) => void): void;
    (event: IncrementalEvent.DataPropertyValuesLoadingFinished, callback: (instanceIri: string, dataPropertyIri: string) => void): void;
}
/** @internal */
declare class IncrementalLifecycle {
    private requestStopped;
    private instancesSearchFinished;
    private limitChange;
    private reset;
    private classInstanceSselection;
    private classSelection;
    private diagramUpdated;
    private reasonerSet;
    private newDataPropertyValues;
    private dpvaluesloadfinish;
    constructor();
    trigger(event: IncrementalEvent.RequestStopped): void;
    trigger(event: IncrementalEvent.InstancesSearchFinished): void;
    trigger(event: IncrementalEvent.LimitChange, limit: number): void;
    trigger(event: IncrementalEvent.Reset): void;
    trigger(event: IncrementalEvent.ClassInstanceSelection, classInstanceEntity: ClassInstanceEntity): void;
    trigger(event: IncrementalEvent.ClassSelection, classEntity: GrapholEntity): void;
    trigger(event: IncrementalEvent.DiagramUpdated): void;
    trigger(event: IncrementalEvent.ReasonerSet): void;
    trigger(event: IncrementalEvent.NewDataPropertyValues, instanceIri: string, dataPropertyIri: string, newValues: string[]): void;
    trigger(event: IncrementalEvent.DataPropertyValuesLoadingFinished, instanceIri: string, dataPropertyIri: string): void;
    on: IonIncrementalEvent;
}

type IncrementalHighlights = {
    classes: GrapholEntity[];
    dataProperties: GrapholEntity[];
    objectProperties: Map<GrapholEntity, ObjectPropertyConnectedClasses>;
};
interface IIncremental {
    diagram: IncrementalDiagram;
    grapholscape: Grapholscape;
    lifecycle: IncrementalLifecycle;
    init(...args: any[]): void;
    reset(...args: any[]): void;
    on: IonIncrementalEvent;
    setIncrementalEventHandlers(...args: any[]): void;
    showDiagram(viewportState?: Viewport): void;
    performActionWithBlockedGraph(action: () => void | Promise<void>, customLayoutOptions?: any): Promise<void>;
    getHighlights(iris: string[], isInstance: boolean): Promise<IncrementalHighlights>;
    getDataPropertiesHighlights(iris: string[], isInstance: boolean): Promise<GrapholEntity[]>;
    getObjectPropertiesHighlights(iris: string[], isInstance: boolean): Promise<Map<GrapholEntity, ObjectPropertyConnectedClasses>>;
    getAnnotations(iri: string): Promise<Annotation[]>;
    getSuperClasses(classIri: string): Promise<GrapholEntity[]>;
    getSubClasses(classIri: string): Promise<GrapholEntity[]>;
    addIndividual(individual: GrapholEntity, parentClassesIris?: string[], position?: Position): void;
    addClass(iri: string, centerOnIt?: boolean, position?: Position): void;
    addEdge(sourceId: string, targetId: string, edgeType: TypesEnum.INCLUSION | TypesEnum.INPUT | TypesEnum.EQUIVALENCE | TypesEnum.INSTANCE_OF): GrapholElement | undefined;
    getContextMenuCommands(grapholElement: GrapholElement, cyElement: SingularElementReturnValue): Command[];
    getNodeButtons(grapholElement: GrapholElement, cyElement: SingularElementReturnValue): NodeButton[];
    getIDByIRI(iri: string, type: TypesEnum): string | undefined;
}
declare abstract class IncrementalBase implements IIncremental {
    protected actionsWithBlockedGraph: number;
    diagramBuilder: DiagramBuilder;
    classFilterMap: Map<string, Filter>;
    diagram: IncrementalDiagram;
    grapholscape: Grapholscape;
    lifecycle: IncrementalLifecycle;
    on: IonIncrementalEvent;
    constructor(grapholscape: Grapholscape);
    abstract getHighlights(iris: string[], isInstance: boolean): Promise<IncrementalHighlights>;
    abstract getDataPropertiesHighlights(iris: string[], isInstance: boolean): Promise<GrapholEntity[]>;
    abstract getObjectPropertiesHighlights(iris: string[], isInstance: boolean): Promise<Map<GrapholEntity, ObjectPropertyConnectedClasses>>;
    abstract getAnnotations(iri: string): Promise<Annotation[]>;
    abstract getSuperClasses(classIri: string): Promise<GrapholEntity[]>;
    abstract getSubClasses(classIri: string): Promise<GrapholEntity[]>;
    abstract getContextMenuCommands(grapholElement: GrapholElement, cyElement: SingularElementReturnValue): Command[];
    abstract getNodeButtons(grapholElement: GrapholElement, cyElement: SingularElementReturnValue): NodeButton[];
    abstract init(...args: any[]): void;
    abstract reset(...args: any[]): void;
    abstract setIncrementalEventHandlers(...args: any[]): void;
    performActionWithBlockedGraph(action: () => void | Promise<void>, customLayoutOptions?: any): Promise<void>;
    addEdge: (sourceId: string, targetId: string, edgeType: TypesEnum.INCLUSION | TypesEnum.INPUT | TypesEnum.EQUIVALENCE | TypesEnum.INSTANCE_OF) => GrapholElement | undefined;
    showDiagram(viewportState?: Viewport): void;
    addClass(iri: string, centerOnIt?: boolean, position?: Position): GrapholNode | undefined;
    addIndividual(individual: GrapholEntity, parentClassesIris?: string[], position?: Position): GrapholElement | undefined;
    /**
     * Add object property edge between two classes.
     * @param objectPropertyIri the object property iri to add
     * @param sourceClassIri
     * @param targetClassIri
     */
    addIntensionalObjectProperty(objectPropertyIri: string, sourceClassIri: string, targetClassIri: string): GrapholEdge | undefined;
    showClassesInIsa(sourceIri: string, targetsIris: string[], isaType: TypesEnum.INCLUSION | TypesEnum.EQUIVALENCE, subOrSuper?: 'sub' | 'super'): void;
    /**
     * Show hierarchies for which the specified class is a subclass.
     * @param classIri
     */
    showSuperHierarchiesOf(classIri: string): void;
    /**
     * Show hierarchies for which the specified class is a superclass.
     * @param classIri
     */
    showSubHierarchiesOf(classIri: string): void;
    protected showOrHideHierarchies(classIri: string, hierarchyType: 'super' | 'sub' | 'any', showORHide: 'show' | 'hide'): void;
    removeHierarchy(hierarchy: Hierarchy, entitiesTokeep?: string[]): void;
    /**
     * Remove a class, an instance or a data property node from the diagram.
     * Entities left with no other connections are recurisvely removed too.
     * Called when the user click on the remove button on a entity node
     * @param entity
     */
    removeEntity(entity: GrapholEntity, entitiesIrisToKeep?: string[]): void;
    postDiagramEdit(oldElemsNumber: number, customLayoutOptions?: any): void;
    protected isHierarchyNodeInDiagram(hierarchy: Hierarchy): boolean | undefined;
    getIDByIRI(iri: string, type: TypesEnum): string | undefined;
    private get incrementalRenderer();
    get numberOfElements(): number;
}

declare abstract class Grapholscape {
    renderer: Renderer;
    protected abstract availableRenderers: RendererStatesEnum[];
    container: HTMLElement;
    readonly lifecycle: Lifecycle;
    ontology: Ontology;
    protected abstract entityNavigator: EntityNavigator;
    protected abstract displayedNamesManager: DisplayedNamesManager;
    protected abstract themesManager: ThemeManager;
    protected _incremental: IIncremental;
    widgets: Map<string, HTMLElement>;
    widgetsInitialStates: WidgetsConfig;
    /**
     * Show a certain diagram by its ID
     * @param diagramId the diagram's id to display
     * @param viewportState set a custom {@link !model.Viewport}, if not set, last one available will be used
     */
    showDiagram(diagramId: number, viewportState?: Viewport): void;
    /**
     * Change the current renderer (Graphol - Lite - Floaty).
     *
     * @remarks
     * A RendererState is an implementation for the {@link !model.iRenderState} interface
     * that changes the way the {@link Renderer} performs the main operations on a
     * {@link !model.Diagram} such as rendering it and filtering elements in it.
     * The renderer states included in Grapholscape are: {@link GrapholRendererState},
     * {@link LiteRendererState} and {@link FloatyRendererState}.
     *
     * @param newRenderState the renderer state instance to set, if you want to reuse
     * these instances it's totally up to you.
     *
     *
     * @example
     * ```ts
     * // Setting the floaty renderer state
     * import { FloatyRendererState } from 'grapholscape'
     *
     * grapholscape.setRenderer(new FloatyRendererState())
     * ```
     */
    setRenderer(newRenderState: RenderState): void;
    /**
     * Center the viewport on a single element.
     * @remarks
     * If you specify a different diagram from the current one, it will be displayed
     * @param elementId the element's id (can be a node or an edge)
     * @param diagramId the diagram's id (**default**: the current one)
     * @param zoom the level zoom to apply, do not pass it if you don't want zoom to change
     */
    centerOnElement(elementId: string, diagramId?: number, zoom?: number): void;
    /**
     * Select an element in a diagram.
     * @remarks
     * If you specify a different diagram from the current one, it will be displayed
     * @param elementId the element's id (can be a node or an edge)
     * @param diagramId the diagram's id (**default**: the current one)
     */
    selectElement(elementId: string, diagramId?: number): void;
    /** Unselect any selected element in the current diagram */
    unselect(): void;
    /** Fit viewport to diagram */
    fit(): void;
    /**
     * Apply a certain level of zoom
     * @param value level of zoom to set
     */
    zoom(value: number): void;
    /**
     * Increase the zooom level by a certain amount
     * @param amount the amount of zoom to add
     */
    zoomIn(amount: number): void;
    /**
     * Decrease the zooom level by a certain amount
     * @param amount the amount of zoom to remove
     */
    zoomOut(amount: number): void;
    /**
     * Filter elements on the diagram.
     * @remarks
     * It will be currently applied only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be applied.
     * @param filter the filter to apply, can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    filter(filter: string | Filter | RDFGraphConfigFiltersEnum): void;
    /**
     * Unfilter elements on the diagram.
     * @remarks
     * It will be currently deactivated only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be deactivated.
     * @param filter the filter to disable, can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    unfilter(filter: string | Filter | RDFGraphConfigFiltersEnum): void;
    /** The current diagram's id */
    get diagramId(): number | undefined;
    /** The current renderer state */
    get renderState(): RendererStatesEnum | undefined;
    /** The current selected Entity */
    get selectedEntity(): GrapholEntity | undefined;
    /** An array of available renderer's state for this Grapholscape instance */
    get renderers(): RendererStatesEnum[];
    /**
     * Center viewport on a single entity occurrence given its IRI
     * @param iri the iri of the entity to find and center on
     * @param diagramId the diagram containing the entity.
     * If not specified, the first entity occurrence in any diagram will be used.
     * @param zoom the level of zoom to apply.
     * If not specified, zoom level won't be changed.
     */
    centerOnEntity(iri: string, diagramId?: number, zoom?: number): void;
    /**
     * Center viewport on a single entity occurrence and selects it given its IRI
     * @param iri the iri of the entity to find and center on
     * @param diagramId the diagram containing the entity.
     * If not specified, the first entity occurrence in any diagram will be used.
     * @param zoom the level of zoom to apply.
     * If not specified, zoom level won't be changed.
     */
    selectEntity(iri: string, diagramId?: number, zoom?: number): void;
    /**
     * Change the displayed entity's names.
     * @param newEntityNametype the entity name type to set
     */
    setEntityNameType(newEntityNametype: RDFGraphConfigEntityNameTypeEnum): void;
    /**
     * Change the language used for the labels and comments
     * @remarks The language must be supported by the ontology or the first available
     * language for a given label/comment wil be used as fallback
     * @param newLanguage the language to set {@link !config.Language}
     */
    setLanguage(newLanguage: string): void;
    /** The current selected language */
    get language(): Language;
    /** The current selected entity name type (label, full iri or prefixed iri) */
    get entityNameType(): RDFGraphConfigEntityNameTypeEnum;
    /**
     * Apply a given theme
     * @param themeId the theme's ID
     */
    setTheme(themeId: string): void;
    /**
     * @ignore
     * // TODO: make this method update settings widget before publishing in docs
     * Add a new theme in the list of available themes
     * @param newTheme the new theme
     * @experimental
     */
    addTheme(newTheme: GrapholscapeTheme): void;
    /**
     * @ignore
     * // TODO: make this method update settings widget before publishing in docs
     * Remove a theme in the list of available themes
     * @param newTheme the new theme
     * @experimental
     */
    removeTheme(newTheme: GrapholscapeTheme): void;
    /** The current theme used by Grapholscape */
    get theme(): GrapholscapeTheme;
    /** The available themes for this Grapholscape instance */
    get themeList(): GrapholscapeTheme[];
    /**
     * Register a callback for a given event.
     * @remarks
     * Check {@link !model.LifecycleEvent} and {@link !model.IonEvent} for the
     * full list of events/callbacks types
     * @param event The event for which register a callback.
     * @param callback Function to call when the specified event occurs
     *
     * @example reacting to a node selection
     * ```js
     *  import { LifecycleEvent } from 'grapholscape'
     *
     *  // ...init grapholscape
     *
     * grapholscape.on(LifecycleEvent.NodeSelection, (selectedNode) => {
     *  // here you can do whatever you want with selectedNode, like printing its shape
     *  console.log(selectedNode.shape)
     * })
     * ```
     */
    on: IonEvent;
    /**
     * The container in which Grapholscape places the UI components.
     * You can use this container to add new widgets or dialogs if you want to.
     */
    get uiContainer(): Element | null;
    /**
     * The container in which the bottom-right buttons are placed.
     * You can use this container to add your own Buttons if you want to.
     */
    get buttonsTray(): Element | null | undefined;
    /**
     * @ignore
     * @privateRemarks // TODO: Be sure this method reflects on UI before publishing it in to the docs
     * Apply a new custom configuration
     * @param newConfig the config object to apply
     * @experimental
     */
    setConfig(newConfig: GrapholscapeConfig): void;
    /**
     * Export current diagram and download it as a PNG image.
     * @param fileName custom file name. Defaults to {@link exportFileName}
     */
    exportToPng(fileName?: string): void;
    /**
     * Export current diagram and download it as an SVG.
     * @param fileName custom file name. Defaults to {@link exportFileName}
     */
    exportToSvg(fileName?: string): void;
    /**
     * Export current ontology as an RDFGraph.
     * RDFGraph is a JSON serialization of grapholscape's model.
     * Useful to resume a previous state.
     * @returns RDFGraph representation of this grapholscape instance's model.
     */
    exportToRdfGraph(): RDFGraph;
    resume(rdfGraph: RDFGraph): void;
    /**
     * Filename for exports.
     * String in the form: "[ontology name]-[diagram name]-v[ontology version]"
     */
    get exportFileName(): string;
    get incremental(): IIncremental;
    set incremental(incrementalController: IIncremental);
}
declare class Core extends Grapholscape {
    protected availableRenderers: RendererStatesEnum[];
    renderer: Renderer;
    container: HTMLElement;
    lifecycle: Lifecycle;
    ontology: Ontology;
    protected entityNavigator: EntityNavigator;
    protected displayedNamesManager: DisplayedNamesManager;
    protected themesManager: ThemeManager;
    widgets: Map<string, HTMLElement>;
    widgetsInitialStates: WidgetsConfig;
    constructor(ontology: Ontology, container: HTMLElement, config?: GrapholscapeConfig);
}

declare class GrapholRendererState extends BaseRenderer {
    layout: cytoscape.Layouts;
    id: RendererStatesEnum;
    cyConfig: cytoscape.CytoscapeOptions;
    filterManager: FilterManager;
    render(): void;
    stopRendering(): void;
    runLayout(): void;
    stopLayout(): void;
    getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    transformOntology(ontology: Ontology): void;
    postOntologyTransform(grapholscape: Grapholscape): void;
}

declare class LiteRendererState extends BaseRenderer {
    readonly id: RendererStatesEnum;
    filterManager: FilterManager;
    cyConfig: CytoscapeOptions;
    private _layout;
    runLayout(): void;
    render(): void;
    stopRendering(): void;
    stopLayout(): void;
    getGraphStyle(theme: GrapholscapeTheme): cytoscape$1.Stylesheet[];
    transformOntology(ontology: Ontology): void;
    postOntologyTransform(grapholscape: Grapholscape): void;
    get layout(): cytoscape$1.Layouts;
    set layout(newLayout: cytoscape$1.Layouts);
}

declare class FloatyRendererState extends BaseRenderer {
    readonly id: RendererStatesEnum;
    filterManager: FilterManager;
    protected _layout: cytoscape__default.Layouts;
    private centeringOnElem;
    set renderer(newRenderer: Renderer);
    get renderer(): Renderer;
    transformOntology(ontology: Ontology): void;
    postOntologyTransform(grapholscape: Grapholscape): void;
    runLayout(): void;
    render(): void;
    stopRendering(): void;
    getGraphStyle(theme: GrapholscapeTheme): cytoscape__default.Stylesheet[];
    stopLayout(): void;
    runLayoutInfinitely(): void;
    pinNode(nodeOrId: NodeSingular | string): void;
    unpinAll(): void;
    private setPopperStyle;
    private updatePopper;
    unpinNode(nodeOrId: string | NodeSingular): void;
    private removeUnlockButton;
    protected setDragAndPinEventHandlers(): void;
    private grabHandler;
    private freeHandler;
    protected get defaultLayoutOptions(): {
        name: string;
        avoidOverlap: boolean;
        edgeLength: (edge: any) => any;
        fit: boolean;
        maxSimulationTime: number;
        infinite: boolean;
        handleDisconnected: boolean;
        centerGraph: boolean;
    };
    centerOnElementById(elementId: string, zoom?: number, select?: boolean): void;
    get floatyLayoutOptions(): any;
    set floatyLayoutOptions(newOptions: any);
    protected automoveOptions: {
        nodesMatching: (node: NodeSingular) => boolean | undefined;
        reposition: string;
        dragWith: string;
    };
    get isLayoutInfinite(): boolean;
    get dragAndPin(): boolean;
    set dragAndPin(isActive: boolean);
    protected get popperContainer(): HTMLDivElement | undefined;
    protected get popperContainers(): Map<number, HTMLDivElement>;
    get layout(): cytoscape__default.Layouts;
}

/**
 * The incremental renderer state is a kind of floaty renderer state in which
 * ontology's diagrams are used only to compute what to show.
 * There is only a single empty diagram and any render() call just render the same diagram
 * no matter what was the input diagram.
 *
 * This renderer state is logic agnostic, meaning that it does not control what to show and when.
 * You can decide what to show/hide outside, based on lifecycle and/or other custom developed widgets.
 */
declare class IncrementalRendererState extends FloatyRendererState {
    readonly id = RendererStatesEnum.INCREMENTAL;
    filterManager: FilterManager;
    private previousDiagram;
    render(): void;
    runLayout(): void;
    runCustomLayout(cyLayoutOptions: any): void;
    /** lock all nodes */
    freezeGraph(): void;
    /** unlock all nodes that are not pinned (pinned can be unlocked only with unpin) */
    unFreezeGraph(): void;
    stopRendering(): void;
    transformOntology(ontology: Ontology): void;
    getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    reset(): void;
    filter(elementId: string, filter: Filter): void;
    unfilter(elementId: string, filter: Filter): void;
    protected get popperContainer(): HTMLDivElement | undefined;
    set renderer(newRenderer: Renderer);
    get renderer(): Renderer;
    protected get defaultLayoutOptions(): {
        name: string;
        avoidOverlap: boolean;
        edgeLength: (edge: EdgeSingular) => number;
        fit: boolean;
        maxSimulationTime: number;
        infinite: boolean;
        handleDisconnected: boolean;
        centerGraph: boolean;
    };
}

interface FilterManager {
    filters: Map<string, Filter>;
    filterActivation: (filter: Filter) => boolean;
    filterDeactivation: (filter: Filter) => boolean;
}
declare abstract class BaseFilterManager implements FilterManager {
    protected _filters: Map<string, Filter>;
    protected lockedFilters: RDFGraphConfigFiltersEnum[];
    filterActivation(filter: Filter): boolean;
    filterDeactivation(filter: Filter): boolean;
    get filters(): Map<string, Filter>;
    set filters(filters: Map<string, Filter>);
}

declare enum RendererStatesEnum {
    GRAPHOL = "graphol",
    GRAPHOL_LITE = "lite",
    FLOATY = "floaty",
    INCREMENTAL = "incremental"
}
interface RenderState {
    id: RendererStatesEnum;
    renderer: Renderer;
    filterManager: FilterManager;
    layout: cytoscape.Layouts;
    layoutRunning: boolean;
    render(): void;
    stopRendering(): void;
    filter(elementId: string, filter: Filter): void;
    unfilter(elementId: string, filter: Filter): void;
    runLayout(): void;
    stopLayout(): void;
    getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    transformOntology(ontology: Ontology): void;
    postOntologyTransform(ontology: Grapholscape): void;
    centerOnElementById(elementId: string, zoom?: number, select?: boolean): void;
}

declare class GrapholEntity extends AnnotatedElement implements Entity {
    static newFromSwagger(iri: Iri, e: Entity): GrapholEntity;
    private _iri;
    private _occurrences;
    private _datatype;
    private _isDataPropertyFunctional;
    private _functionProperties;
    private _color?;
    protected _manualTypes?: Set<TypesEnum>;
    constructor(iri: Iri);
    addOccurrence(newGrapholElement: GrapholElement, representationKind?: RendererStatesEnum): void;
    removeOccurrence(grapholElement: GrapholElement, representationKind: RendererStatesEnum): void;
    /**
     * Get all occurrences of the entity in a given diagram
     * @param diagramId the diagram in which the entity must occurr
     * @param representationKind the diagram representation identifier ({@link RendererStatesEnum})
     * if not set, all representations will be considered
     * @returns A map with the occurrences in the original Graphol representation and other
     * replicated occurrences in other diagram representations
     */
    getOccurrencesByDiagramId(diagramId: number, representationKind?: RendererStatesEnum): Map<RendererStatesEnum, GrapholElement[]>;
    get types(): TypesEnum[];
    set manualTypes(newTypes: Set<TypesEnum>);
    /**
     * Check if entity is of a certain type
     * @param type
     */
    is(type: TypesEnum): boolean;
    get occurrences(): Map<RendererStatesEnum, GrapholElement[]>;
    set iri(val: Iri);
    get iri(): Iri;
    get fullIri(): string;
    get functionProperties(): FunctionPropertiesEnum[];
    set functionProperties(properties: FunctionPropertiesEnum[]);
    get isDataPropertyFunctional(): boolean;
    set isDataPropertyFunctional(value: boolean);
    get datatype(): string;
    set datatype(datatype: string);
    get color(): string | undefined;
    set color(color: string | undefined);
    getOccurrenceByType(type: TypesEnum, rendererState: RendererStatesEnum): GrapholElement | undefined;
    getOccurrencesByType(type: TypesEnum, rendererState: RendererStatesEnum): GrapholElement[] | undefined;
    hasFunctionProperty(property: FunctionPropertiesEnum): boolean;
    hasOccurrenceInDiagram(diagramId: number, representationKind: RendererStatesEnum): boolean;
    getDisplayedName(nameType: RDFGraphConfigEntityNameTypeEnum, currentLanguage?: string): string;
    getEntityOriginalNodeId(): string | undefined;
    getIdInDiagram(diagramId: number, type: TypesEnum, rendererState: RendererStatesEnum): string | undefined;
    json(): Entity;
}

declare class DiagramRepresentation {
    private _cy;
    private _grapholElements;
    private _hasEverBeenRendered;
    lastViewportState?: Viewport;
    constructor(cyConfig?: cytoscape__default.CytoscapeOptions);
    get cy(): cytoscape__default.Core;
    set cy(newCy: cytoscape__default.Core);
    get hasEverBeenRendered(): boolean;
    set hasEverBeenRendered(value: boolean);
    /**
     * Add a new element (node or edge) to the diagram
     * @param newElement the GrapholElement to add to the diagram
     */
    addElement(newElement: GrapholElement, grapholEntity?: GrapholEntity): cytoscape__default.CollectionReturnValue;
    removeElement(elementId: string): void;
    clear(): void;
    updateElement(element: GrapholElement, grapholEntity?: GrapholEntity, updatePosition?: boolean): void;
    updateElement(elementId: string, grapholEntity?: GrapholEntity, updatePosition?: boolean): void;
    containsEntity(iriOrGrapholEntity: Iri | GrapholEntity | string): boolean;
    filter(elementId: string, filterTag: string): void;
    unfilter(elementId: string, filterTag: string): void;
    getNewId(nodeOrEdge: 'node' | 'edge'): string;
    get grapholElements(): Map<string, GrapholElement>;
    set grapholElements(newElementMap: Map<string, GrapholElement>);
    /**
     * Getter
     */
    get nodes(): string[];
    /**
     * Getter
     */
    get edges(): string[];
    get nodesCounter(): number;
    get edgesCounter(): number;
}

/**
 * @property {string} name - diagram's name
 * @property {string | number} id - diagram's identifier
 */
declare class Diagram implements Diagram$1 {
    name: string;
    id: number;
    representations: Map<RendererStatesEnum, DiagramRepresentation>;
    lastViewportState: Viewport;
    /**
     * @param {string} name
     * @param {number} id
     */
    constructor(name: string, id: number);
    /**
     * Add a new element (node or edge) to the diagram's representation
     * @param newElement the GrapholElement to add to the diagram
     */
    addElement(newElement: GrapholElement, grapholEntity?: GrapholEntity): void;
    /**
     * Delete every element from a diagram
     * @param rendererState optional, if you pass a particular rendererState, only its representation will be cleared.
     * If you don't pass any rendererState, all representations will be cleared
     */
    clear(rendererState?: RendererStatesEnum): void;
    removeElement(elementId: string, rendererState: RendererStatesEnum): void;
    containsEntity(iriOrGrapholEntity: Iri | GrapholEntity, rendererState: RendererStatesEnum): boolean | undefined;
}

declare class Hierarchy implements Hierarchy$1 {
    type: TypesEnum.UNION | TypesEnum.DISJOINT_UNION;
    forcedComplete: boolean;
    private _id;
    private _inputs;
    private _superclasses;
    /**
     *
     * @param id
     * @param type
     * @param forcedComplete if the hierarchy is forced to be complete, any superclass edge
     * will have type COMPLETE_UNION / COMPLETE_DISJOINT_UNION, regardless if they are created
     * as complete or not.
     */
    constructor(id: string, type: TypesEnum.UNION | TypesEnum.DISJOINT_UNION, forcedComplete?: boolean);
    addInput(classEntity: GrapholEntity): void;
    removeInput(classEntity: GrapholEntity): void;
    addSuperclass(classEntity: GrapholEntity, complete?: boolean): void;
    removeSuperclass(classEntity: GrapholEntity): void;
    get inputs(): GrapholEntity[];
    get superclasses(): {
        classEntity: GrapholEntity;
        complete: boolean;
    }[];
    set id(newId: string);
    get id(): string;
    getUnionGrapholNode(nodeId: string, position?: Position): GrapholNode | undefined;
    getInputGrapholEdges(diagramId: number, rendererState: RendererStatesEnum): GrapholEdge[] | undefined;
    getInclusionEdges(diagramId: number, rendererState: RendererStatesEnum): GrapholEdge[] | undefined;
    isDisjoint(): boolean;
    isValid(): boolean | "";
}

/**
 * ### Ontology
 * Class used as the Model of the whole app.
 */
declare class Ontology extends AnnotatedElement implements RDFGraphMetadata {
    name: string;
    version: string;
    namespaces: Namespace[];
    annProperties: AnnotationProperty[];
    diagrams: Diagram[];
    languages: string[];
    defaultLanguage?: string;
    iri?: string;
    constructor(name: string, version: string, iri?: string, namespaces?: Namespace[], annProperties?: AnnotationProperty[], diagrams?: Diagram[]);
    private _entities;
    private _hierarchies;
    private _subHierarchiesMap;
    private _superHierarchiesMap;
    private _inclusions;
    addHierarchy(hierarchy: Hierarchy): void;
    removeHierarchy(hiearchyId: string): void;
    removeHierarchy(hiearchyId: Hierarchy): void;
    getHierarchy(hierarchyId: string): Hierarchy | undefined;
    getHierarchiesOf(classIri: string | Iri): Hierarchy[];
    /**
     * @param superClassIri the superclass iri
     * @returns The arrary of hiearchies for which a class appear as superclass
     */
    getSubHierarchiesOf(superClassIri: string | Iri): Hierarchy[];
    /**
     *
     * @param subClassIri
     * @returns The arrary of hiearchies for which a class appear as subclass
     */
    getSuperHierarchiesOf(subClassIri: string | Iri): Hierarchy[];
    getSubclassesOf(superClassIri: string | Iri): Set<GrapholEntity>;
    getSuperclassesOf(superClassIri: string | Iri): Set<GrapholEntity>;
    addSubclassOf(subclassIri: string | Iri, superclassIri: string | Iri): void;
    addSubclassOf(subclass: GrapholEntity, superclass: GrapholEntity): void;
    removeSubclassOf(subclassIri: string | Iri, superclassIri: string | Iri): void;
    removeSubclassOf(subclass: GrapholEntity, superclass: GrapholEntity): void;
    /** @param {Namespace} namespace */
    addNamespace(namespace: Namespace): void;
    /**
     * Get the Namspace object given its IRI string
     * @param {string} iriValue the IRI assigned to the namespace
     * @returns {Namespace}
     */
    getNamespace(iriValue: string): Namespace | undefined;
    /**
     * Get the Namespace given one of its prefixes
     * @param {string} prefix
     * @returns {Namespace}
     */
    getNamespaceFromPrefix(prefix: string): Namespace | undefined;
    getNamespaces(): Namespace[];
    /** @param {AnnotationProperty} annProperty */
    addAnnotationProperty(annProperty: AnnotationProperty): void;
    /**
     * Get the Namspace object given its IRI string
     * @param {string} iriValue the IRI assigned to the namespace
     * @returns {AnnotationProperty}
     */
    getAnnotationProperty(iriValue: string): AnnotationProperty | undefined;
    getAnnotationProperties(): AnnotationProperty[];
    /** @param {Diagram} diagram */
    addDiagram(diagram: Diagram): void;
    /**
     * Get the diagram with the given id
     */
    getDiagram(diagramId: number): Diagram | undefined;
    getDiagramByName(name: string): Diagram | undefined;
    addEntity(entity: GrapholEntity): void;
    getEntity(iri: string | Iri): GrapholEntity | undefined;
    getEntitiesByType(entityType: TypesEnum): GrapholEntity[];
    getEntityFromOccurrence(entityOccurrence: GrapholElement): GrapholEntity | undefined;
    getGrapholElement(elementId: string, diagramId?: number, renderState?: RendererStatesEnum): GrapholElement | undefined;
    getGrapholNode(nodeId: string, diagramId?: number, renderState?: RendererStatesEnum): GrapholNode | undefined;
    getGrapholEdge(edgeId: string, diagramId?: number, renderState?: RendererStatesEnum): GrapholNode | undefined;
    /**
     * Retrieve an entity by its IRI.
     * @param {string} iri - The IRI in full or prefixed form.
     * i.e. : `grapholscape:world` or `https://examples/grapholscape/world`
     * @returns {cytoscape.CollectionReturnValue} The cytoscape object representation.
     */
    /**
     * Retrieve all occurrences of an entity by its IRI.
     * @param {string} iri - The IRI in full or prefixed form.
     * i.e. : `grapholscape:world` or `https://examples/grapholscape/world`
     * @returns An array of EntityOccurrence objects
     */
    getEntityOccurrences(iri: string, diagramId?: number, renderState?: RendererStatesEnum): Map<RendererStatesEnum, GrapholElement[]> | undefined;
    /**
     * Get the entities in the ontology
     * @returns {Object.<string, cytoscape.CollectionReturnValue[]>} a map of IRIs, with an array of entity occurrences (object[iri].occurrences)
     */
    /**
     * Check if entity has the specified iri in full or prefixed form
     * @param {Entity} entity
     * @param {string} iri
     * @returns {boolean}
     */
    /**
     * Retrieve the full IRI given a prefixed IRI
     * @param {string} prefixedIri a prefixed IRI
     * @returns {string} full IRI
     */
    prefixedToFullIri(prefixedIri: string): string | undefined;
    computeDatatypesOnDataProperties(): void;
    get isEntitiesEmpty(): boolean;
    get entities(): Map<string, GrapholEntity>;
    set entities(newEntities: Map<string, GrapholEntity>);
}

declare class IncrementalDiagram extends Diagram {
    static ID: number;
    /** @internal */
    classInstances?: Map<string, ClassInstanceEntity>;
    constructor();
    addElement(newElement: GrapholElement, grapholEntity?: GrapholEntity): void;
    removeElement(elementId: string): void;
    containsEntity(iriOrGrapholEntity: Iri | GrapholEntity | string): boolean | undefined;
    isHierarchyVisible(hierarchy: Hierarchy): boolean;
    get representation(): DiagramRepresentation | undefined;
}

declare enum DefaultThemesEnum {
    GRAPHOLSCAPE = "grapholscape",
    GRAPHOL = "graphol",
    DARK = "dark",
    COLORFUL_LIGHT = "colorful-light",
    COLORFUL_DARK = "colorful-dark"
}
declare const gscapeColourMap: ColourMap;
declare const classicColourMap: ColourMap;
declare const darkColourMap: ColourMap;
declare const DefaultThemes: {
    [key in DefaultThemesEnum]?: GrapholscapeTheme;
};

declare const CSS_PROPERTY_NAMESPACE = "--gscape-color";

declare abstract class BaseRenderer implements RenderState {
    protected _renderer: Renderer;
    abstract id: RendererStatesEnum;
    abstract filterManager: FilterManager;
    abstract layout: cytoscape.Layouts;
    abstract render(): void;
    abstract stopRendering(): void;
    abstract runLayout(): void;
    abstract stopLayout(): void;
    abstract getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    abstract transformOntology(ontology: Ontology): void;
    abstract postOntologyTransform(ontology: Grapholscape): void;
    layoutRunning: boolean;
    constructor(renderer?: Renderer);
    centerOnElementById(elementId: string, zoom?: number, select?: boolean): void;
    set renderer(newRenderer: Renderer);
    get renderer(): Renderer;
    filter(elementId: string, filter: Filter): void;
    unfilter(elementId: string, filter: Filter): void;
}

declare enum Language {
    DE = "de",
    EN = "en",
    ES = "es",
    FR = "fr",
    IT = "it"
}
type WidgetsConfig = {
    [key in WidgetEnum]?: boolean;
};
type ThemeConfig = GrapholscapeTheme | DefaultThemesEnum;
type GrapholscapeConfig = {
    themes?: ThemeConfig[];
    selectedTheme?: string;
    language?: Language | string;
    entityNameType?: RDFGraphConfigEntityNameTypeEnum;
    renderers?: RendererStatesEnum[];
    selectedRenderer?: RendererStatesEnum;
    widgets?: WidgetsConfig;
    initialRendererSelection?: boolean;
    useCustomIncrementalController?: boolean;
};

/**
 * Load config from local storage
 */
declare function loadConfig(): GrapholscapeConfig;
/**
 * Store a single setting in local storage
 * @param {string} k the key of the setting to store
 * @param {any} value the value of the setting to store
 */
declare function storeConfigEntry(k: string, value: any): void;
declare function clearLocalStorage(): void;

declare const _default: CytoscapeOptions;

declare const liteOptions: {
    layout: {
        name: string;
    };
    autoungrabify: boolean;
    maxZoom: number;
    minZoom: number;
    wheelSensitivity: number;
};
declare const floatyOptions: {
    layout: {
        name: string;
    };
    autoungrabify: boolean;
    maxZoom: number;
    minZoom: number;
    wheelSensitivity: number;
};

declare function parseRDFGraph(rdfGraph: RDFGraph): Ontology;
declare function updateEntityOccurrences(ontology: Ontology): void;
declare function getOntology(rdfGraph: RDFGraph): Ontology;
declare function getEntities(rdfGraph: RDFGraph, namespaces: Namespace[]): Map<string, GrapholEntity>;
/** @internal */
declare function getClassInstances(rdfGraph: RDFGraph, namespaces: Namespace[]): Map<string, ClassInstanceEntity>;
declare function getDiagrams(rdfGraph: RDFGraph, rendererState: RendererStatesEnum | undefined, entities: Map<string, GrapholEntity>, namespaces?: Namespace[]): Diagram[];
declare function getConfig(rdfGraph: RDFGraph): GrapholscapeConfig;

declare const rdfGraphParser_d_getClassInstances: typeof getClassInstances;
declare const rdfGraphParser_d_getConfig: typeof getConfig;
declare const rdfGraphParser_d_getDiagrams: typeof getDiagrams;
declare const rdfGraphParser_d_getEntities: typeof getEntities;
declare const rdfGraphParser_d_getOntology: typeof getOntology;
declare const rdfGraphParser_d_updateEntityOccurrences: typeof updateEntityOccurrences;
declare namespace rdfGraphParser_d {
  export {
    parseRDFGraph as default,
    rdfGraphParser_d_getClassInstances as getClassInstances,
    rdfGraphParser_d_getConfig as getConfig,
    rdfGraphParser_d_getDiagrams as getDiagrams,
    rdfGraphParser_d_getEntities as getEntities,
    rdfGraphParser_d_getOntology as getOntology,
    rdfGraphParser_d_updateEntityOccurrences as updateEntityOccurrences,
  };
}

declare function setGraphEventHandlers(diagram: Diagram, lifecycle: Lifecycle, ontology: Ontology): void;

declare function toPNG(fileName: string, cy?: Core$1, backgroundColor?: string): void;
declare function toSVG(fileName: string, cy?: Core$1, backgroundColor?: string): void;

declare class IncrementalController extends IncrementalBase {
    private neighbourhoodFinder;
    private individualsButton;
    private objectPropertyButton;
    constructor(grapholscape: Grapholscape);
    getHighlights(iris: string[], isInstance: boolean): Promise<IncrementalHighlights>;
    getDataPropertiesHighlights(iris: string[], _isInstance: boolean): Promise<GrapholEntity[]>;
    getObjectPropertiesHighlights(iris: string[], isInstance: boolean): Promise<Map<GrapholEntity, ObjectPropertyConnectedClasses>>;
    getAnnotations(iri: string): Promise<Annotation[]>;
    getSuperClasses(classIri: string): Promise<GrapholEntity[]>;
    getSubClasses(classIri: string): Promise<GrapholEntity[]>;
    getContextMenuCommands(grapholElement: GrapholElement, cyElement: SingularElementReturnValue): Command[];
    init(): void;
    private initNodeButtons;
    getNodeButtons(grapholElement: GrapholElement): NodeButton[];
    setIncrementalEventHandlers(): void;
    reset(): void;
}

declare function showHideSuperHierarchies(hide: boolean, callback: () => void): Command;
declare function showHideSuperClasses(hide: boolean, callback: () => void): Command;
declare function showHideSubHierarchies(hide: boolean, callback: () => void): Command;
declare function showHideSubClasses(hide: boolean, callback: () => void): Command;
declare function showHideEquivalentClasses(hide: boolean, callback: () => void): Command;
declare function remove(callback: () => void): Command;
declare function showParentClass(callback: () => void): Command;
declare function performInstanceChecking(callback: () => void): Command;
declare function focusInstance(callback: () => void): Command;
declare function getInstances(callback: () => void): Command;

declare function CommandsWidgetFactory(ic: IncrementalBase): void;

declare const IncrementalEntityDetails_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class IncrementalEntityDetails extends IncrementalEntityDetails_base {
    private _dataProperties;
    entity?: GrapholEntity;
    onComputeCount: (entity: GrapholEntity) => void;
    static properties: PropertyDeclarations;
    static notAvailableText: string;
    static styles: lit.CSSResult[];
    render(): lit_html.TemplateResult<1>;
    show(): void;
    reset(): void;
    addDataPropertyValue(dataPropertyIri: string, value: string): void;
    get dataProperties(): EntityViewData[];
    set dataProperties(newDataProperties: EntityViewData[]);
}

declare function IncrementalEntityDetailsFactory(ic: IncrementalBase): IncrementalEntityDetails;

declare function moveUpLeft(widget: HTMLElement): void;
declare function restorePosition(widget: HTMLElement): void;

declare const GscapeNavigationMenu_base: (new (...args: any[]) => IContextualWidgetMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeNavigationMenu extends GscapeNavigationMenu_base {
    popperRef?: HTMLElement;
    /** @internal */
    private _objectProperties;
    /** @internal */
    objectPropertiesRanges?: Map<string, Map<string, {
        values: EntityViewData[];
        loading?: boolean;
    }>>;
    /** @internal */
    canShowObjectPropertiesRanges: boolean;
    /** @internal */
    referenceEntity?: EntityViewData;
    /** @internal */
    referenceEntityType?: TypesEnum;
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    constructor();
    render: () => lit_html.TemplateResult<1>;
    private handleObjPropertySelection;
    private handleInsertInGraphClick;
    private handleSearchInstancesRange;
    hide(): void;
    attachTo(element: HTMLElement): void;
    get objectProperties(): ViewObjectProperty[];
    set objectProperties(newObjectProperties: ViewObjectProperty[]);
    updated(): void;
}

declare function NavigationMenuFactory(incrementalController: IncrementalController): GscapeNavigationMenu;

declare function showButtons(targetNode: NodeSingular, nodeButtons: NodeButton[]): void;
declare function hideButtons(targetNode: NodeSingular): void;
declare function getButtonOffset(info: {
    popper: {
        height: number;
        width: number;
    };
}, buttonIndex?: number, numberOfButtons?: number): [number, number];

declare function NodeButtonsFactory(ic: IIncremental): void;

declare function onIncrementalStartup(ic: IncrementalBase): void;
declare function manageWidgetsOnActivation(widgets: Map<WidgetEnum, IBaseMixin & HTMLElement>, isCanvasEmpty?: boolean): void;
declare function manageWidgetsOnDeactivation(widgets: Map<WidgetEnum, IBaseMixin & HTMLElement>): void;
declare function onEmptyDiagram(grapholscape: Grapholscape): void;

declare function showMenu(menu: IContextualWidgetMixin & IBaseMixin & {
    referenceEntity?: EntityViewData;
    referenceEntityType?: TypesEnum;
}, ic: IIncremental): void;

declare function initIncrementalUI(ic: IncrementalController): void;

declare const index_d$1_CommandsWidgetFactory: typeof CommandsWidgetFactory;
declare const index_d$1_IncrementalEntityDetailsFactory: typeof IncrementalEntityDetailsFactory;
declare const index_d$1_NavigationMenuFactory: typeof NavigationMenuFactory;
declare const index_d$1_NodeButtonsFactory: typeof NodeButtonsFactory;
declare const index_d$1_focusInstance: typeof focusInstance;
declare const index_d$1_getButtonOffset: typeof getButtonOffset;
declare const index_d$1_getInstances: typeof getInstances;
declare const index_d$1_hideButtons: typeof hideButtons;
declare const index_d$1_initIncrementalUI: typeof initIncrementalUI;
declare const index_d$1_manageWidgetsOnActivation: typeof manageWidgetsOnActivation;
declare const index_d$1_manageWidgetsOnDeactivation: typeof manageWidgetsOnDeactivation;
declare const index_d$1_moveUpLeft: typeof moveUpLeft;
declare const index_d$1_onEmptyDiagram: typeof onEmptyDiagram;
declare const index_d$1_onIncrementalStartup: typeof onIncrementalStartup;
declare const index_d$1_performInstanceChecking: typeof performInstanceChecking;
declare const index_d$1_remove: typeof remove;
declare const index_d$1_restorePosition: typeof restorePosition;
declare const index_d$1_showButtons: typeof showButtons;
declare const index_d$1_showHideEquivalentClasses: typeof showHideEquivalentClasses;
declare const index_d$1_showHideSubClasses: typeof showHideSubClasses;
declare const index_d$1_showHideSubHierarchies: typeof showHideSubHierarchies;
declare const index_d$1_showHideSuperClasses: typeof showHideSuperClasses;
declare const index_d$1_showHideSuperHierarchies: typeof showHideSuperHierarchies;
declare const index_d$1_showMenu: typeof showMenu;
declare const index_d$1_showParentClass: typeof showParentClass;
declare namespace index_d$1 {
  export {
    index_d$1_CommandsWidgetFactory as CommandsWidgetFactory,
    index_d$1_IncrementalEntityDetailsFactory as IncrementalEntityDetailsFactory,
    index_d$1_NavigationMenuFactory as NavigationMenuFactory,
    index_d$1_NodeButtonsFactory as NodeButtonsFactory,
    index_d$1_focusInstance as focusInstance,
    index_d$1_getButtonOffset as getButtonOffset,
    index_d$1_getInstances as getInstances,
    index_d$1_hideButtons as hideButtons,
    index_d$1_initIncrementalUI as initIncrementalUI,
    index_d$1_manageWidgetsOnActivation as manageWidgetsOnActivation,
    index_d$1_manageWidgetsOnDeactivation as manageWidgetsOnDeactivation,
    index_d$1_moveUpLeft as moveUpLeft,
    index_d$1_onEmptyDiagram as onEmptyDiagram,
    index_d$1_onIncrementalStartup as onIncrementalStartup,
    index_d$1_performInstanceChecking as performInstanceChecking,
    index_d$1_remove as remove,
    index_d$1_restorePosition as restorePosition,
    index_d$1_showButtons as showButtons,
    index_d$1_showHideEquivalentClasses as showHideEquivalentClasses,
    index_d$1_showHideSubClasses as showHideSubClasses,
    index_d$1_showHideSubHierarchies as showHideSubHierarchies,
    index_d$1_showHideSuperClasses as showHideSuperClasses,
    index_d$1_showHideSuperHierarchies as showHideSuperHierarchies,
    index_d$1_showMenu as showMenu,
    index_d$1_showParentClass as showParentClass,
  };
}

interface IGscape {
    ontology: Ontology;
    diagramId?: number;
    renderer: {
        cy?: {
            pan: () => Position;
            zoom: () => number;
        };
        viewportState?: Viewport;
    };
    themeList: GrapholscapeTheme[];
    theme: GrapholscapeTheme;
    language: string | Language;
    entityNameType: RDFGraphConfigEntityNameTypeEnum;
    renderers: RendererStatesEnum[];
    renderState?: RendererStatesEnum;
    incremental?: IIncremental;
}
/** @internal */
declare function export_default$4(grapholscape: IGscape, modelType?: RDFGraphModelTypeEnum): RDFGraph;

declare function export_default$3(text: string): string;

declare function grapholEntityToEntityViewData(grapholEntity: GrapholEntity, grapholscape: Grapholscape): EntityViewData;

declare const index_d_grapholEntityToEntityViewData: typeof grapholEntityToEntityViewData;
declare namespace index_d {
  export {
    export_default$3 as capitalizeFirstChar,
    index_d_grapholEntityToEntityViewData as grapholEntityToEntityViewData,
  };
}

declare function export_default$2(theme: GrapholscapeTheme): Stylesheet[];

declare function export_default$1(theme: GrapholscapeTheme): Stylesheet[];

declare function export_default(theme: GrapholscapeTheme): Stylesheet[];

/**
 * Create a full instance of Grapholscape with diagrams and widgets
 *
 * @remarks
 * Once the promise is fulfilled, you get a {@link !core.Grapholscape}.
 * Hence the API you will most likely want to use will be the one of the {@link !core.Grapholscape} class.
 * You can change diagram, zoom, focus elements, select them, filter them and so on with that class.
 *
 * @param file the ontology, can be an object of the
 * [Web API interface File](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * or a String representing the .graphol file to be displayed
 * @param container a DOM element in which the ontology will be rendered in
 * @param config a config object, please read more about [settings](https://github.com/obdasystems/grapholscape/wiki/Settings)
 * @returns a promise that will be fulfilled with a {@link !core.Grapholscape} object
 * @see [Getting started](../pages/getting-started.html)
 * @see [Configuration](../pages/configuration.html)
 */
declare function fullGrapholscape(file: string | File, container: HTMLElement, config?: GrapholscapeConfig): Promise<Grapholscape | undefined>;
/**
 * Create a bare instance of Grapholscape, only diagrams, no widgets
 *
 * @remarks
 * Once the promise is fulfilled, you get a {@link !core.Grapholscape}.
 * Hence the API you will most likely want to use will be the one of the {@link !core.Grapholscape} class.
 * You can change diagram, zoom, focus elements, select them, filter them and so on with that class.
 *
 * @param file the ontology, can be an object of the
 * [Web API interface File](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * or a String representing the .graphol file to be displayed
 * @param container a DOM element in which the ontology will be rendered in
 * @param config a config object, please read more about [settings](https://github.com/obdasystems/grapholscape/wiki/Settings)
 * @returns a promise that will be fulfilled with a {@link !core.Grapholscape} object
 * @see [Getting started](../pages/getting-started.html)
 * @see [Configuration](../pages/configuration.html)
 */
declare function bareGrapholscape(file: string | File, container: HTMLElement, config?: GrapholscapeConfig): Promise<Grapholscape | undefined>;
declare function incrementalGrapholscape(ontology: string | File | RDFGraph, container: HTMLElement, rdfGraphToResume?: RDFGraph, config?: GrapholscapeConfig): Promise<Grapholscape | undefined>;
/** @internal */
declare function resume(rdfGraph: RDFGraph, container: HTMLElement, config?: GrapholscapeConfig): Core;
/**
 * @internal
 * @deprecated please use grapholscape.resume(rdfGraph)
 */
declare function initFromResume(grapholscape: Grapholscape, rdfGraph: RDFGraph, forceInit?: boolean, useCustomIncrementalController?: boolean): void;

export { AnnotatedElement, Annotation, AnnotationProperty, BaseFilterManager, BaseRenderer, Breakpoint, CSS_PROPERTY_NAMESPACE, ClassInstanceEntity, ColourMap, ColoursNames, Core, DefaultAnnotationProperties, RDFGraphConfigFiltersEnum as DefaultFilterKeyEnum, DefaultNamespaces, DefaultThemes, DefaultThemesEnum, Diagram, DiagramBuilder, DiagramColorManager, DiagramRepresentation, DisplayedNamesManager, RDFGraphConfigEntityNameTypeEnum as EntityNameType, EntityNavigator, Filter, FloatyRendererState, FunctionPropertiesEnum as FunctionalityEnum, GrapholEdge, GrapholElement, GrapholEntity, GrapholNode, GrapholNodeInfo, GrapholNodesEnum, GrapholRendererState, Grapholscape, GrapholscapeConfig, GrapholscapeTheme, Hierarchy, IEventTriggers, IncrementalBase, IncrementalController, IncrementalDiagram, IncrementalEvent, IncrementalRendererState, index_d$1 as IncrementalUI, IonEvent, IonIncrementalEvent, Iri, Language, Lifecycle, LifecycleEvent, LiteRendererState, Namespace, NeighbourhoodFinder, Ontology, OntologyColorManager, POLYGON_POINTS, Position, rdfGraphParser_d as RDFGraphParser, Renderer, RendererStatesEnum, Shape, index_d$4 as SwaggerModel, ThemeConfig, ThemeManager, TypesEnum, Viewport, WidgetsConfig, annotationPropertyFilter, bareGrapholscape, classicColourMap, clearLocalStorage, computeHierarchies, darkColourMap, export_default$7 as floatyGraphStyle, floatyOptions, fullGrapholscape, getDefaultFilters, export_default$7 as getFloatyStyle, export_default as grapholGraphStyle, _default as grapholOptions, gscapeColourMap, FilterManager as iFilterManager, RenderState as iRenderState, export_default$2 as incrementalGraphStyle, incrementalGrapholscape, initFromResume, isGrapholEdge, isGrapholNode, export_default$1 as liteGraphStyle, liteOptions, loadConfig, parseRDFGraph, export_default$4 as rdfgraphSerializer, resume, setGraphEventHandlers, storeConfigEntry, toPNG, toSVG, index_d$2 as ui, index_d as util };
