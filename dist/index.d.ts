/// <reference types="cytoscape" />
import * as cytoscape$1 from 'cytoscape';
import cytoscape__default, { ElementDefinition, EventObject, Stylesheet, CytoscapeOptions, NodeSingular, EdgeSingular, Position as Position$1, Core } from 'cytoscape';
import * as lit_html from 'lit-html';
import * as lit from 'lit';
import { SVGTemplateResult, LitElement, TemplateResult, PropertyDeclarations, CSSResultArray, CSSResultGroup } from 'lit';
import { Props, Instance } from 'tippy.js';

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
declare const BASE_PATH: string;
interface ConfigurationParameters {
    basePath?: string;
    fetchApi?: FetchAPI;
    middleware?: Middleware[];
    queryParamsStringify?: (params: HTTPQuery) => string;
    username?: string;
    password?: string;
    apiKey?: string | ((name: string) => string);
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>);
    headers?: HTTPHeaders;
    credentials?: RequestCredentials;
}
declare class Configuration {
    private configuration;
    constructor(configuration?: ConfigurationParameters);
    set config(configuration: Configuration);
    get basePath(): string;
    get fetchApi(): FetchAPI | undefined;
    get middleware(): Middleware[];
    get queryParamsStringify(): (params: HTTPQuery) => string;
    get username(): string | undefined;
    get password(): string | undefined;
    get apiKey(): ((name: string) => string) | undefined;
    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined;
    get headers(): HTTPHeaders | undefined;
    get credentials(): RequestCredentials | undefined;
}
declare const DefaultConfig: Configuration;
/**
 * This is the base class for all generated API classes.
 */
declare class BaseAPI {
    protected configuration: Configuration;
    private static readonly jsonRegex;
    private middleware;
    constructor(configuration?: Configuration);
    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]): T;
    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>): T;
    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>): T;
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    protected isJsonMime(mime: string | null | undefined): boolean;
    protected request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response>;
    private createFetchParams;
    private fetchApi;
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone;
}
declare class ResponseError extends Error {
    response: Response;
    name: "ResponseError";
    constructor(response: Response, msg?: string);
}
declare class FetchError extends Error {
    cause: Error;
    name: "FetchError";
    constructor(cause: Error, msg?: string);
}
declare class RequiredError extends Error {
    field: string;
    name: "RequiredError";
    constructor(field: string, msg?: string);
}
declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
type FetchAPI = WindowOrWorkerGlobalScope['fetch'];
type Json = any;
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
type HTTPHeaders = {
    [key: string]: string;
};
type HTTPQuery = {
    [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery;
};
type HTTPBody = Json | FormData | URLSearchParams;
type HTTPRequestInit = {
    headers?: HTTPHeaders;
    method: HTTPMethod;
    credentials?: RequestCredentials;
    body?: HTTPBody;
};
type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';
type InitOverrideFunction = (requestContext: {
    init: HTTPRequestInit;
    context: RequestOpts;
}) => Promise<RequestInit>;
interface FetchParams {
    url: string;
    init: RequestInit;
}
interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}
declare function exists(json: any, key: string): boolean;
declare function querystring(params: HTTPQuery, prefix?: string): string;
declare function mapValues(data: any, fn: (item: any) => any): {};
declare function canConsumeForm(consumes: Consume[]): boolean;
interface Consume {
    contentType: string;
}
interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}
interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}
interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}
interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}
interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}
interface ResponseTransformer<T> {
    (json: any): T;
}
declare class JSONApiResponse<T> {
    raw: Response;
    private transformer;
    constructor(raw: Response, transformer?: ResponseTransformer<T>);
    value(): Promise<T>;
}
declare class VoidApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<void>;
}
declare class BlobApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<Blob>;
}
declare class TextApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<string>;
}

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Annotation
 */
interface Annotation$1 {
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    lexicalForm: string;
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    property: string;
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    language?: string;
    /**
     *
     * @type {string}
     * @memberof Annotation
     */
    datatype?: string;
}
/**
 * Check if a given object implements the Annotation interface.
 */
declare function instanceOfAnnotation(value: object): boolean;
declare function AnnotationFromJSON(json: any): Annotation$1;
declare function AnnotationFromJSONTyped(json: any, ignoreDiscriminator: boolean): Annotation$1;
declare function AnnotationToJSON(value?: Annotation$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @enum {string}
 */
declare enum FunctionPropertiesEnum {
    FUNCTIONAL = "functional",
    INVERSE_FUNCTIONAL = "inverseFunctional",
    TRANSITIVE = "transitive",
    SYMMETRIC = "symmetric",
    ASYMMETRIC = "asymmetric",
    REFLEXIVE = "reflexive",
    IRREFLEXIVE = "irreflexive"
}
declare function FunctionPropertiesEnumFromJSON(json: any): FunctionPropertiesEnum;
declare function FunctionPropertiesEnumFromJSONTyped(json: any, ignoreDiscriminator: boolean): FunctionPropertiesEnum;
declare function FunctionPropertiesEnumToJSON(value?: FunctionPropertiesEnum | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Entity
 */
interface Entity$1 {
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    fullIri: string;
    /**
     *
     * @type {Array<Annotation>}
     * @memberof Entity
     */
    annotations?: Array<Annotation$1>;
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    datatype?: string;
    /**
     *
     * @type {boolean}
     * @memberof Entity
     */
    isDataPropertyFunctional?: boolean;
    /**
     *
     * @type {Array<FunctionPropertiesEnum>}
     * @memberof Entity
     */
    functionProperties?: Array<FunctionPropertiesEnum>;
}
/**
 * Check if a given object implements the Entity interface.
 */
declare function instanceOfEntity(value: object): boolean;
declare function EntityFromJSON(json: any): Entity$1;
declare function EntityFromJSONTyped(json: any, ignoreDiscriminator: boolean): Entity$1;
declare function EntityToJSON(value?: Entity$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface AnnotationOp
 */
interface AnnotationOp {
    /**
     *
     * @type {Annotation}
     * @memberof AnnotationOp
     */
    subject: Annotation$1;
    /**
     *
     * @type {Annotation}
     * @memberof AnnotationOp
     */
    previousState?: Annotation$1;
    /**
     *
     * @type {Entity}
     * @memberof AnnotationOp
     */
    entity?: Entity$1;
}
/**
 * Check if a given object implements the AnnotationOp interface.
 */
declare function instanceOfAnnotationOp(value: object): boolean;
declare function AnnotationOpFromJSON(json: any): AnnotationOp;
declare function AnnotationOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): AnnotationOp;
declare function AnnotationOpToJSON(value?: AnnotationOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface DataPropertyValue
 */
interface DataPropertyValue {
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    value: string;
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    iri: string;
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    language?: string;
    /**
     *
     * @type {string}
     * @memberof DataPropertyValue
     */
    datatype?: string;
}
/**
 * Check if a given object implements the DataPropertyValue interface.
 */
declare function instanceOfDataPropertyValue(value: object): boolean;
declare function DataPropertyValueFromJSON(json: any): DataPropertyValue;
declare function DataPropertyValueFromJSONTyped(json: any, ignoreDiscriminator: boolean): DataPropertyValue;
declare function DataPropertyValueToJSON(value?: DataPropertyValue | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ClassInstanceEntity
 */
interface ClassInstanceEntity$1 {
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntity
     */
    fullIri: string;
    /**
     *
     * @type {Array<Annotation>}
     * @memberof ClassInstanceEntity
     */
    annotations?: Array<Annotation$1>;
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntity
     */
    datatype?: string;
    /**
     *
     * @type {boolean}
     * @memberof ClassInstanceEntity
     */
    isDataPropertyFunctional?: boolean;
    /**
     *
     * @type {Array<FunctionPropertiesEnum>}
     * @memberof ClassInstanceEntity
     */
    functionProperties?: Array<FunctionPropertiesEnum>;
    /**
     *
     * @type {Array<string>}
     * @memberof ClassInstanceEntity
     */
    parentClasses?: Array<string>;
    /**
     *
     * @type {Array<DataPropertyValue>}
     * @memberof ClassInstanceEntity
     */
    dataProperties?: Array<DataPropertyValue>;
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntity
     */
    shortIri?: string;
}
/**
 * Check if a given object implements the ClassInstanceEntity interface.
 */
declare function instanceOfClassInstanceEntity(value: object): boolean;
declare function ClassInstanceEntityFromJSON(json: any): ClassInstanceEntity$1;
declare function ClassInstanceEntityFromJSONTyped(json: any, ignoreDiscriminator: boolean): ClassInstanceEntity$1;
declare function ClassInstanceEntityToJSON(value?: ClassInstanceEntity$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ClassInstanceEntityAllOf
 */
interface ClassInstanceEntityAllOf {
    /**
     *
     * @type {Array<string>}
     * @memberof ClassInstanceEntityAllOf
     */
    parentClasses?: Array<string>;
    /**
     *
     * @type {Array<DataPropertyValue>}
     * @memberof ClassInstanceEntityAllOf
     */
    dataProperties?: Array<DataPropertyValue>;
    /**
     *
     * @type {string}
     * @memberof ClassInstanceEntityAllOf
     */
    shortIri?: string;
}
/**
 * Check if a given object implements the ClassInstanceEntityAllOf interface.
 */
declare function instanceOfClassInstanceEntityAllOf(value: object): boolean;
declare function ClassInstanceEntityAllOfFromJSON(json: any): ClassInstanceEntityAllOf;
declare function ClassInstanceEntityAllOfFromJSONTyped(json: any, ignoreDiscriminator: boolean): ClassInstanceEntityAllOf;
declare function ClassInstanceEntityAllOfToJSON(value?: ClassInstanceEntityAllOf | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Position
 */
interface Position {
    /**
     *
     * @type {number}
     * @memberof Position
     */
    x: number;
    /**
     *
     * @type {number}
     * @memberof Position
     */
    y: number;
}
/**
 * Check if a given object implements the Position interface.
 */
declare function instanceOfPosition(value: object): boolean;
declare function PositionFromJSON(json: any): Position;
declare function PositionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Position;
declare function PositionToJSON(value?: Position | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * Contiene tutti i tipi di nodi/archi orginirari dal Graphol per evitare di duplicare gli enumeratori. Nella rappresentazione Floaty/vkg vengono usati questi valori.
 * NODI class data-property class-instance (vkg) individual (floaty) union disjoint-union
 * ARCHI object-property instance-of input inclusion equivalence attribute-edge complete-union complete-disjoint-union
 * @export
 * @enum {string}
 */
declare enum TypesEnum {
    CLASS = "class",
    OBJECT_PROPERTY = "object-property",
    DATA_PROPERTY = "data-property",
    INDIVIDUAL = "individual",
    CLASS_INSTANCE = "class-instance",
    DOMAIN_RESTRICTION = "domain-restriction",
    RANGE_RESTRICTION = "range-restriction",
    UNION = "union",
    COMPLETE_UNION = "complete-union",
    DISJOINT_UNION = "disjoint-union",
    COMPLETE_DISJOINT_UNION = "complete-disjoint-union",
    COMPLEMENT = "complement",
    INTERSECTION = "intersection",
    ENUMERATION = "enumeration",
    HAS_KEY = "has-key",
    ROLE_INVERSE = "role-inverse",
    ROLE_CHAIN = "role-chain",
    DATATYPE_RESTRICTION = "datatype-restriction",
    VALUE_DOMAIN = "value-domain",
    PROPERTY_ASSERTION = "property-assertion",
    LITERAL = "literal",
    FACET = "facet",
    NEUTRAL = "neutral",
    VALUE = "value",
    INCLUSION = "inclusion",
    EQUIVALENCE = "equivalence",
    INSTANCE_OF = "instance-of",
    INPUT = "input",
    SAME = "same",
    DIFFERENT = "different",
    MEMBERSHIP = "membership",
    ATTRIBUTE_EDGE = "attribute-edge"
}
declare function TypesEnumFromJSON(json: any): TypesEnum;
declare function TypesEnumFromJSONTyped(json: any, ignoreDiscriminator: boolean): TypesEnum;
declare function TypesEnumToJSON(value?: TypesEnum | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Edge
 */
interface Edge {
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    id: string;
    /**
     * In case of replicated elements, this is the ID of the original element replicated in multiple occurrences, all of them with different IDs
     * @type {string}
     * @memberof Edge
     */
    originalId?: string;
    /**
     *
     * @type {number}
     * @memberof Edge
     */
    diagramId?: number;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    displayedName?: string;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    iri?: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Edge
     */
    type: TypesEnum;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    sourceId: string;
    /**
     *
     * @type {string}
     * @memberof Edge
     */
    targetId: string;
    /**
     *
     * @type {Array<Position>}
     * @memberof Edge
     */
    breakpoints?: Array<Position>;
}
/**
 * Check if a given object implements the Edge interface.
 */
declare function instanceOfEdge(value: object): boolean;
declare function EdgeFromJSON(json: any): Edge;
declare function EdgeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Edge;
declare function EdgeToJSON(value?: Edge | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Node
 */
interface Node {
    /**
     *
     * @type {string}
     * @memberof Node
     */
    id: string;
    /**
     * In case of replicated elements, this is the ID of the original element replicated in multiple occurrences, all of them with different IDs
     * @type {string}
     * @memberof Node
     */
    originalId?: string;
    /**
     *
     * @type {number}
     * @memberof Node
     */
    diagramId?: number;
    /**
     *
     * @type {string}
     * @memberof Node
     */
    displayedName?: string;
    /**
     *
     * @type {string}
     * @memberof Node
     */
    iri?: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Node
     */
    type: TypesEnum;
    /**
     *
     * @type {Position}
     * @memberof Node
     */
    position?: Position;
    /**
     *
     * @type {Position}
     * @memberof Node
     */
    labelPosition?: Position;
}
/**
 * Check if a given object implements the Node interface.
 */
declare function instanceOfNode(value: object): boolean;
declare function NodeFromJSON(json: any): Node;
declare function NodeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Node;
declare function NodeToJSON(value?: Node | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Viewport
 */
interface Viewport {
    /**
     *
     * @type {Position}
     * @memberof Viewport
     */
    pan: Position;
    /**
     *
     * @type {number}
     * @memberof Viewport
     */
    zoom: number;
}
/**
 * Check if a given object implements the Viewport interface.
 */
declare function instanceOfViewport(value: object): boolean;
declare function ViewportFromJSON(json: any): Viewport;
declare function ViewportFromJSONTyped(json: any, ignoreDiscriminator: boolean): Viewport;
declare function ViewportToJSON(value?: Viewport | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Diagram
 */
interface Diagram$1 {
    /**
     *
     * @type {number}
     * @memberof Diagram
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof Diagram
     */
    name: string;
    /**
     *
     * @type {Array<Node>}
     * @memberof Diagram
     */
    nodes?: Array<Node>;
    /**
     *
     * @type {Array<Edge>}
     * @memberof Diagram
     */
    edges?: Array<Edge>;
    /**
     *
     * @type {Viewport}
     * @memberof Diagram
     */
    lastViewportState?: Viewport;
}
/**
 * Check if a given object implements the Diagram interface.
 */
declare function instanceOfDiagram(value: object): boolean;
declare function DiagramFromJSON(json: any): Diagram$1;
declare function DiagramFromJSONTyped(json: any, ignoreDiscriminator: boolean): Diagram$1;
declare function DiagramToJSON(value?: Diagram$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface DiagramOp
 */
interface DiagramOp {
    /**
     *
     * @type {Diagram}
     * @memberof DiagramOp
     */
    subject: Diagram$1;
    /**
     *
     * @type {Diagram}
     * @memberof DiagramOp
     */
    previousState?: Diagram$1;
}
/**
 * Check if a given object implements the DiagramOp interface.
 */
declare function instanceOfDiagramOp(value: object): boolean;
declare function DiagramOpFromJSON(json: any): DiagramOp;
declare function DiagramOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): DiagramOp;
declare function DiagramOpToJSON(value?: DiagramOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EdgeAllOf
 */
interface EdgeAllOf {
    /**
     *
     * @type {string}
     * @memberof EdgeAllOf
     */
    sourceId: string;
    /**
     *
     * @type {string}
     * @memberof EdgeAllOf
     */
    targetId: string;
    /**
     *
     * @type {Array<Position>}
     * @memberof EdgeAllOf
     */
    breakpoints?: Array<Position>;
}
/**
 * Check if a given object implements the EdgeAllOf interface.
 */
declare function instanceOfEdgeAllOf(value: object): boolean;
declare function EdgeAllOfFromJSON(json: any): EdgeAllOf;
declare function EdgeAllOfFromJSONTyped(json: any, ignoreDiscriminator: boolean): EdgeAllOf;
declare function EdgeAllOfToJSON(value?: EdgeAllOf | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Element
 */
interface Element$1 {
    /**
     *
     * @type {string}
     * @memberof Element
     */
    id: string;
    /**
     * In case of replicated elements, this is the ID of the original element replicated in multiple occurrences, all of them with different IDs
     * @type {string}
     * @memberof Element
     */
    originalId?: string;
    /**
     *
     * @type {number}
     * @memberof Element
     */
    diagramId?: number;
    /**
     *
     * @type {string}
     * @memberof Element
     */
    displayedName?: string;
    /**
     *
     * @type {string}
     * @memberof Element
     */
    iri?: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Element
     */
    type: TypesEnum;
}
/**
 * Check if a given object implements the Element interface.
 */
declare function instanceOfElement(value: object): boolean;
declare function ElementFromJSON(json: any): Element$1;
declare function ElementFromJSONTyped(json: any, ignoreDiscriminator: boolean): Element$1;
declare function ElementToJSON(value?: Element$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type ElementOpPreviousState
 *
 * @export
 */
type ElementOpPreviousState = Edge | Node;
declare function ElementOpPreviousStateFromJSON(json: any): ElementOpPreviousState;
declare function ElementOpPreviousStateFromJSONTyped(json: any, ignoreDiscriminator: boolean): ElementOpPreviousState;
declare function ElementOpPreviousStateToJSON(value?: ElementOpPreviousState | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface HierarchySuperclassesInner
 */
interface HierarchySuperclassesInner {
    /**
     *
     * @type {Entity}
     * @memberof HierarchySuperclassesInner
     */
    classEntity: Entity$1;
    /**
     *
     * @type {boolean}
     * @memberof HierarchySuperclassesInner
     */
    complete: boolean;
}
/**
 * Check if a given object implements the HierarchySuperclassesInner interface.
 */
declare function instanceOfHierarchySuperclassesInner(value: object): boolean;
declare function HierarchySuperclassesInnerFromJSON(json: any): HierarchySuperclassesInner;
declare function HierarchySuperclassesInnerFromJSONTyped(json: any, ignoreDiscriminator: boolean): HierarchySuperclassesInner;
declare function HierarchySuperclassesInnerToJSON(value?: HierarchySuperclassesInner | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Hierarchy
 */
interface Hierarchy$1 {
    /**
     *
     * @type {string}
     * @memberof Hierarchy
     */
    id: string;
    /**
     *
     * @type {TypesEnum}
     * @memberof Hierarchy
     */
    type: TypesEnum;
    /**
     *
     * @type {Array<Entity>}
     * @memberof Hierarchy
     */
    inputs: Array<Entity$1>;
    /**
     *
     * @type {Array<HierarchySuperclassesInner>}
     * @memberof Hierarchy
     */
    superclasses: Array<HierarchySuperclassesInner>;
}
/**
 * Check if a given object implements the Hierarchy interface.
 */
declare function instanceOfHierarchy(value: object): boolean;
declare function HierarchyFromJSON(json: any): Hierarchy$1;
declare function HierarchyFromJSONTyped(json: any, ignoreDiscriminator: boolean): Hierarchy$1;
declare function HierarchyToJSON(value?: Hierarchy$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * @type ElementOpSubject
 *
 * @export
 */
type ElementOpSubject = Edge | Hierarchy$1 | Node;
declare function ElementOpSubjectFromJSON(json: any): ElementOpSubject;
declare function ElementOpSubjectFromJSONTyped(json: any, ignoreDiscriminator: boolean): ElementOpSubject;
declare function ElementOpSubjectToJSON(value?: ElementOpSubject | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface ElementOp
 */
interface ElementOp {
    /**
     *
     * @type {ElementOpSubject}
     * @memberof ElementOp
     */
    subject: ElementOpSubject;
    /**
     *
     * @type {ElementOpPreviousState}
     * @memberof ElementOp
     */
    previousState?: ElementOpPreviousState;
    /**
     * Array of other elements involved in the operation. Only for Remove actions. The remove action on an Entity might involve other elements. i.e. if the class removed was the superclass of a hierarchy, the whole hierarchy might become not valid"
     * @type {Array<ElementOpSubject>}
     * @memberof ElementOp
     */
    involvedElements?: Array<ElementOpSubject>;
}
/**
 * Check if a given object implements the ElementOp interface.
 */
declare function instanceOfElementOp(value: object): boolean;
declare function ElementOpFromJSON(json: any): ElementOp;
declare function ElementOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): ElementOp;
declare function ElementOpToJSON(value?: ElementOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface EntityOp
 */
interface EntityOp {
    /**
     *
     * @type {Entity}
     * @memberof EntityOp
     */
    subject: Entity$1;
    /**
     *
     * @type {Entity}
     * @memberof EntityOp
     */
    previousState?: Entity$1;
    /**
     * Array of other elements involved in the operation. Only for Remove actions. The remove action on an Entity might involve other elements. i.e. if the class removed was the superclass of a hierarchy, the whole hierarchy might become not valid"
     * @type {Array<ElementOpSubject>}
     * @memberof EntityOp
     */
    involvedElements?: Array<ElementOpSubject>;
}
/**
 * Check if a given object implements the EntityOp interface.
 */
declare function instanceOfEntityOp(value: object): boolean;
declare function EntityOpFromJSON(json: any): EntityOp;
declare function EntityOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): EntityOp;
declare function EntityOpToJSON(value?: EntityOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface HierarchyOp
 */
interface HierarchyOp {
    /**
     *
     * @type {Hierarchy}
     * @memberof HierarchyOp
     */
    subject: Hierarchy$1;
    /**
     *
     * @type {string}
     * @memberof HierarchyOp
     */
    diagramId: string;
    /**
     *
     * @type {Hierarchy}
     * @memberof HierarchyOp
     */
    previousState?: Hierarchy$1;
}
/**
 * Check if a given object implements the HierarchyOp interface.
 */
declare function instanceOfHierarchyOp(value: object): boolean;
declare function HierarchyOpFromJSON(json: any): HierarchyOp;
declare function HierarchyOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): HierarchyOp;
declare function HierarchyOpToJSON(value?: HierarchyOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Namespace
 */
interface Namespace$1 {
    /**
     *
     * @type {string}
     * @memberof Namespace
     */
    value: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Namespace
     */
    prefixes: Array<string>;
}
/**
 * Check if a given object implements the Namespace interface.
 */
declare function instanceOfNamespace(value: object): boolean;
declare function NamespaceFromJSON(json: any): Namespace$1;
declare function NamespaceFromJSONTyped(json: any, ignoreDiscriminator: boolean): Namespace$1;
declare function NamespaceToJSON(value?: Namespace$1 | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NamespaceOp
 */
interface NamespaceOp {
    /**
     *
     * @type {Namespace}
     * @memberof NamespaceOp
     */
    subject: Namespace$1;
    /**
     *
     * @type {Namespace}
     * @memberof NamespaceOp
     */
    previousState?: Namespace$1;
}
/**
 * Check if a given object implements the NamespaceOp interface.
 */
declare function instanceOfNamespaceOp(value: object): boolean;
declare function NamespaceOpFromJSON(json: any): NamespaceOp;
declare function NamespaceOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): NamespaceOp;
declare function NamespaceOpToJSON(value?: NamespaceOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface NodeAllOf
 */
interface NodeAllOf {
    /**
     *
     * @type {Position}
     * @memberof NodeAllOf
     */
    position?: Position;
    /**
     *
     * @type {Position}
     * @memberof NodeAllOf
     */
    labelPosition?: Position;
}
/**
 * Check if a given object implements the NodeAllOf interface.
 */
declare function instanceOfNodeAllOf(value: object): boolean;
declare function NodeAllOfFromJSON(json: any): NodeAllOf;
declare function NodeAllOfFromJSONTyped(json: any, ignoreDiscriminator: boolean): NodeAllOf;
declare function NodeAllOfToJSON(value?: NodeAllOf | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface PropertyOp
 */
interface PropertyOp {
    /**
     *
     * @type {Entity}
     * @memberof PropertyOp
     */
    subject: Entity$1;
    /**
     *
     * @type {Entity}
     * @memberof PropertyOp
     */
    previousState?: Entity$1;
}
/**
 * Check if a given object implements the PropertyOp interface.
 */
declare function instanceOfPropertyOp(value: object): boolean;
declare function PropertyOpFromJSON(json: any): PropertyOp;
declare function PropertyOpFromJSONTyped(json: any, ignoreDiscriminator: boolean): PropertyOp;
declare function PropertyOpToJSON(value?: PropertyOp | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Theme
 */
interface Theme {
    /**
     *
     * @type {string}
     * @memberof Theme
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Theme
     */
    name?: string;
    /**
     *
     * @type {object}
     * @memberof Theme
     */
    colours?: object;
}
/**
 * Check if a given object implements the Theme interface.
 */
declare function instanceOfTheme(value: object): boolean;
declare function ThemeFromJSON(json: any): Theme;
declare function ThemeFromJSONTyped(json: any, ignoreDiscriminator: boolean): Theme;
declare function ThemeToJSON(value?: Theme | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RDFGraphConfig
 */
interface RDFGraphConfig {
    /**
     *
     * @type {Array<Theme>}
     * @memberof RDFGraphConfig
     */
    themes?: Array<Theme>;
    /**
     *
     * @type {string}
     * @memberof RDFGraphConfig
     */
    selectedTheme?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphConfig
     */
    language?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphConfig
     */
    entityNameType?: RDFGraphConfigEntityNameTypeEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphConfig
     */
    renderers?: Array<string>;
    /**
     *
     * @type {object}
     * @memberof RDFGraphConfig
     */
    widgets?: object;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphConfig
     */
    filters?: Array<RDFGraphConfigFiltersEnum>;
}
/**
* @export
* @enum {string}
*/
declare enum RDFGraphConfigEntityNameTypeEnum {
    LABEL = "label",
    PREFIXED_IRI = "prefixed_iri",
    FULL_IRI = "full_iri"
}
/**
* @export
* @enum {string}
*/
declare enum RDFGraphConfigFiltersEnum {
    ALL = "all",
    DATA_PROPERTY = "data-property",
    VALUE_DOMAIN = "value-domain",
    INDIVIDUAL = "individual",
    UNIVERSAL_QUANTIFIER = "universal_quantifier",
    COMPLEMENT = "complement",
    HAS_KEY = "has-key"
}
/**
 * Check if a given object implements the RDFGraphConfig interface.
 */
declare function instanceOfRDFGraphConfig(value: object): boolean;
declare function RDFGraphConfigFromJSON(json: any): RDFGraphConfig;
declare function RDFGraphConfigFromJSONTyped(json: any, ignoreDiscriminator: boolean): RDFGraphConfig;
declare function RDFGraphConfigToJSON(value?: RDFGraphConfig | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RDFGraphMetadata
 */
interface RDFGraphMetadata {
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    iri?: string;
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    version?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RDFGraphMetadata
     */
    languages?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof RDFGraphMetadata
     */
    defaultLanguage?: string;
    /**
     *
     * @type {Array<Namespace>}
     * @memberof RDFGraphMetadata
     */
    namespaces: Array<Namespace$1>;
    /**
     *
     * @type {Array<Annotation>}
     * @memberof RDFGraphMetadata
     */
    annotations?: Array<Annotation$1>;
}
/**
 * Check if a given object implements the RDFGraphMetadata interface.
 */
declare function instanceOfRDFGraphMetadata(value: object): boolean;
declare function RDFGraphMetadataFromJSON(json: any): RDFGraphMetadata;
declare function RDFGraphMetadataFromJSONTyped(json: any, ignoreDiscriminator: boolean): RDFGraphMetadata;
declare function RDFGraphMetadataToJSON(value?: RDFGraphMetadata | null): any;

/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RDFGraph
 */
interface RDFGraph {
    /**
     *
     * @type {Array<Diagram>}
     * @memberof RDFGraph
     */
    diagrams: Array<Diagram$1>;
    /**
     *
     * @type {Array<Entity>}
     * @memberof RDFGraph
     */
    entities: Array<Entity$1>;
    /**
     *
     * @type {Array<ClassInstanceEntity>}
     * @memberof RDFGraph
     */
    classInstanceEntities?: Array<ClassInstanceEntity$1>;
    /**
     *
     * @type {RDFGraphMetadata}
     * @memberof RDFGraph
     */
    metadata: RDFGraphMetadata;
    /**
     *
     * @type {RDFGraphConfig}
     * @memberof RDFGraph
     */
    config?: RDFGraphConfig;
    /**
     *
     * @type {number}
     * @memberof RDFGraph
     */
    selectedDiagramId?: number;
    /**
     *
     * @type {string}
     * @memberof RDFGraph
     */
    modelType: RDFGraphModelTypeEnum;
}
/**
* @export
* @enum {string}
*/
declare enum RDFGraphModelTypeEnum {
    ONTOLOGY = "ontology",
    VKG = "vkg",
    RDF = "rdf"
}
/**
 * Check if a given object implements the RDFGraph interface.
 */
declare function instanceOfRDFGraph(value: object): boolean;
declare function RDFGraphFromJSON(json: any): RDFGraph;
declare function RDFGraphFromJSONTyped(json: any, ignoreDiscriminator: boolean): RDFGraph;
declare function RDFGraphToJSON(value?: RDFGraph | null): any;

declare const index_d$3_AnnotationFromJSON: typeof AnnotationFromJSON;
declare const index_d$3_AnnotationFromJSONTyped: typeof AnnotationFromJSONTyped;
type index_d$3_AnnotationOp = AnnotationOp;
declare const index_d$3_AnnotationOpFromJSON: typeof AnnotationOpFromJSON;
declare const index_d$3_AnnotationOpFromJSONTyped: typeof AnnotationOpFromJSONTyped;
declare const index_d$3_AnnotationOpToJSON: typeof AnnotationOpToJSON;
declare const index_d$3_AnnotationToJSON: typeof AnnotationToJSON;
type index_d$3_ApiResponse<T> = ApiResponse<T>;
declare const index_d$3_BASE_PATH: typeof BASE_PATH;
type index_d$3_BaseAPI = BaseAPI;
declare const index_d$3_BaseAPI: typeof BaseAPI;
type index_d$3_BlobApiResponse = BlobApiResponse;
declare const index_d$3_BlobApiResponse: typeof BlobApiResponse;
declare const index_d$3_COLLECTION_FORMATS: typeof COLLECTION_FORMATS;
type index_d$3_ClassInstanceEntityAllOf = ClassInstanceEntityAllOf;
declare const index_d$3_ClassInstanceEntityAllOfFromJSON: typeof ClassInstanceEntityAllOfFromJSON;
declare const index_d$3_ClassInstanceEntityAllOfFromJSONTyped: typeof ClassInstanceEntityAllOfFromJSONTyped;
declare const index_d$3_ClassInstanceEntityAllOfToJSON: typeof ClassInstanceEntityAllOfToJSON;
declare const index_d$3_ClassInstanceEntityFromJSON: typeof ClassInstanceEntityFromJSON;
declare const index_d$3_ClassInstanceEntityFromJSONTyped: typeof ClassInstanceEntityFromJSONTyped;
declare const index_d$3_ClassInstanceEntityToJSON: typeof ClassInstanceEntityToJSON;
type index_d$3_Configuration = Configuration;
declare const index_d$3_Configuration: typeof Configuration;
type index_d$3_ConfigurationParameters = ConfigurationParameters;
type index_d$3_Consume = Consume;
type index_d$3_DataPropertyValue = DataPropertyValue;
declare const index_d$3_DataPropertyValueFromJSON: typeof DataPropertyValueFromJSON;
declare const index_d$3_DataPropertyValueFromJSONTyped: typeof DataPropertyValueFromJSONTyped;
declare const index_d$3_DataPropertyValueToJSON: typeof DataPropertyValueToJSON;
declare const index_d$3_DefaultConfig: typeof DefaultConfig;
declare const index_d$3_DiagramFromJSON: typeof DiagramFromJSON;
declare const index_d$3_DiagramFromJSONTyped: typeof DiagramFromJSONTyped;
type index_d$3_DiagramOp = DiagramOp;
declare const index_d$3_DiagramOpFromJSON: typeof DiagramOpFromJSON;
declare const index_d$3_DiagramOpFromJSONTyped: typeof DiagramOpFromJSONTyped;
declare const index_d$3_DiagramOpToJSON: typeof DiagramOpToJSON;
declare const index_d$3_DiagramToJSON: typeof DiagramToJSON;
type index_d$3_Edge = Edge;
type index_d$3_EdgeAllOf = EdgeAllOf;
declare const index_d$3_EdgeAllOfFromJSON: typeof EdgeAllOfFromJSON;
declare const index_d$3_EdgeAllOfFromJSONTyped: typeof EdgeAllOfFromJSONTyped;
declare const index_d$3_EdgeAllOfToJSON: typeof EdgeAllOfToJSON;
declare const index_d$3_EdgeFromJSON: typeof EdgeFromJSON;
declare const index_d$3_EdgeFromJSONTyped: typeof EdgeFromJSONTyped;
declare const index_d$3_EdgeToJSON: typeof EdgeToJSON;
declare const index_d$3_ElementFromJSON: typeof ElementFromJSON;
declare const index_d$3_ElementFromJSONTyped: typeof ElementFromJSONTyped;
type index_d$3_ElementOp = ElementOp;
declare const index_d$3_ElementOpFromJSON: typeof ElementOpFromJSON;
declare const index_d$3_ElementOpFromJSONTyped: typeof ElementOpFromJSONTyped;
type index_d$3_ElementOpPreviousState = ElementOpPreviousState;
declare const index_d$3_ElementOpPreviousStateFromJSON: typeof ElementOpPreviousStateFromJSON;
declare const index_d$3_ElementOpPreviousStateFromJSONTyped: typeof ElementOpPreviousStateFromJSONTyped;
declare const index_d$3_ElementOpPreviousStateToJSON: typeof ElementOpPreviousStateToJSON;
type index_d$3_ElementOpSubject = ElementOpSubject;
declare const index_d$3_ElementOpSubjectFromJSON: typeof ElementOpSubjectFromJSON;
declare const index_d$3_ElementOpSubjectFromJSONTyped: typeof ElementOpSubjectFromJSONTyped;
declare const index_d$3_ElementOpSubjectToJSON: typeof ElementOpSubjectToJSON;
declare const index_d$3_ElementOpToJSON: typeof ElementOpToJSON;
declare const index_d$3_ElementToJSON: typeof ElementToJSON;
declare const index_d$3_EntityFromJSON: typeof EntityFromJSON;
declare const index_d$3_EntityFromJSONTyped: typeof EntityFromJSONTyped;
type index_d$3_EntityOp = EntityOp;
declare const index_d$3_EntityOpFromJSON: typeof EntityOpFromJSON;
declare const index_d$3_EntityOpFromJSONTyped: typeof EntityOpFromJSONTyped;
declare const index_d$3_EntityOpToJSON: typeof EntityOpToJSON;
declare const index_d$3_EntityToJSON: typeof EntityToJSON;
type index_d$3_ErrorContext = ErrorContext;
type index_d$3_FetchAPI = FetchAPI;
type index_d$3_FetchError = FetchError;
declare const index_d$3_FetchError: typeof FetchError;
type index_d$3_FetchParams = FetchParams;
type index_d$3_FunctionPropertiesEnum = FunctionPropertiesEnum;
declare const index_d$3_FunctionPropertiesEnum: typeof FunctionPropertiesEnum;
declare const index_d$3_FunctionPropertiesEnumFromJSON: typeof FunctionPropertiesEnumFromJSON;
declare const index_d$3_FunctionPropertiesEnumFromJSONTyped: typeof FunctionPropertiesEnumFromJSONTyped;
declare const index_d$3_FunctionPropertiesEnumToJSON: typeof FunctionPropertiesEnumToJSON;
type index_d$3_HTTPBody = HTTPBody;
type index_d$3_HTTPHeaders = HTTPHeaders;
type index_d$3_HTTPMethod = HTTPMethod;
type index_d$3_HTTPQuery = HTTPQuery;
type index_d$3_HTTPRequestInit = HTTPRequestInit;
declare const index_d$3_HierarchyFromJSON: typeof HierarchyFromJSON;
declare const index_d$3_HierarchyFromJSONTyped: typeof HierarchyFromJSONTyped;
type index_d$3_HierarchyOp = HierarchyOp;
declare const index_d$3_HierarchyOpFromJSON: typeof HierarchyOpFromJSON;
declare const index_d$3_HierarchyOpFromJSONTyped: typeof HierarchyOpFromJSONTyped;
declare const index_d$3_HierarchyOpToJSON: typeof HierarchyOpToJSON;
type index_d$3_HierarchySuperclassesInner = HierarchySuperclassesInner;
declare const index_d$3_HierarchySuperclassesInnerFromJSON: typeof HierarchySuperclassesInnerFromJSON;
declare const index_d$3_HierarchySuperclassesInnerFromJSONTyped: typeof HierarchySuperclassesInnerFromJSONTyped;
declare const index_d$3_HierarchySuperclassesInnerToJSON: typeof HierarchySuperclassesInnerToJSON;
declare const index_d$3_HierarchyToJSON: typeof HierarchyToJSON;
type index_d$3_InitOverrideFunction = InitOverrideFunction;
type index_d$3_JSONApiResponse<T> = JSONApiResponse<T>;
declare const index_d$3_JSONApiResponse: typeof JSONApiResponse;
type index_d$3_Json = Json;
type index_d$3_Middleware = Middleware;
type index_d$3_ModelPropertyNaming = ModelPropertyNaming;
declare const index_d$3_NamespaceFromJSON: typeof NamespaceFromJSON;
declare const index_d$3_NamespaceFromJSONTyped: typeof NamespaceFromJSONTyped;
type index_d$3_NamespaceOp = NamespaceOp;
declare const index_d$3_NamespaceOpFromJSON: typeof NamespaceOpFromJSON;
declare const index_d$3_NamespaceOpFromJSONTyped: typeof NamespaceOpFromJSONTyped;
declare const index_d$3_NamespaceOpToJSON: typeof NamespaceOpToJSON;
declare const index_d$3_NamespaceToJSON: typeof NamespaceToJSON;
type index_d$3_Node = Node;
type index_d$3_NodeAllOf = NodeAllOf;
declare const index_d$3_NodeAllOfFromJSON: typeof NodeAllOfFromJSON;
declare const index_d$3_NodeAllOfFromJSONTyped: typeof NodeAllOfFromJSONTyped;
declare const index_d$3_NodeAllOfToJSON: typeof NodeAllOfToJSON;
declare const index_d$3_NodeFromJSON: typeof NodeFromJSON;
declare const index_d$3_NodeFromJSONTyped: typeof NodeFromJSONTyped;
declare const index_d$3_NodeToJSON: typeof NodeToJSON;
type index_d$3_Position = Position;
declare const index_d$3_PositionFromJSON: typeof PositionFromJSON;
declare const index_d$3_PositionFromJSONTyped: typeof PositionFromJSONTyped;
declare const index_d$3_PositionToJSON: typeof PositionToJSON;
type index_d$3_PropertyOp = PropertyOp;
declare const index_d$3_PropertyOpFromJSON: typeof PropertyOpFromJSON;
declare const index_d$3_PropertyOpFromJSONTyped: typeof PropertyOpFromJSONTyped;
declare const index_d$3_PropertyOpToJSON: typeof PropertyOpToJSON;
type index_d$3_RDFGraph = RDFGraph;
type index_d$3_RDFGraphConfig = RDFGraphConfig;
type index_d$3_RDFGraphConfigEntityNameTypeEnum = RDFGraphConfigEntityNameTypeEnum;
declare const index_d$3_RDFGraphConfigEntityNameTypeEnum: typeof RDFGraphConfigEntityNameTypeEnum;
type index_d$3_RDFGraphConfigFiltersEnum = RDFGraphConfigFiltersEnum;
declare const index_d$3_RDFGraphConfigFiltersEnum: typeof RDFGraphConfigFiltersEnum;
declare const index_d$3_RDFGraphConfigFromJSON: typeof RDFGraphConfigFromJSON;
declare const index_d$3_RDFGraphConfigFromJSONTyped: typeof RDFGraphConfigFromJSONTyped;
declare const index_d$3_RDFGraphConfigToJSON: typeof RDFGraphConfigToJSON;
declare const index_d$3_RDFGraphFromJSON: typeof RDFGraphFromJSON;
declare const index_d$3_RDFGraphFromJSONTyped: typeof RDFGraphFromJSONTyped;
type index_d$3_RDFGraphMetadata = RDFGraphMetadata;
declare const index_d$3_RDFGraphMetadataFromJSON: typeof RDFGraphMetadataFromJSON;
declare const index_d$3_RDFGraphMetadataFromJSONTyped: typeof RDFGraphMetadataFromJSONTyped;
declare const index_d$3_RDFGraphMetadataToJSON: typeof RDFGraphMetadataToJSON;
type index_d$3_RDFGraphModelTypeEnum = RDFGraphModelTypeEnum;
declare const index_d$3_RDFGraphModelTypeEnum: typeof RDFGraphModelTypeEnum;
declare const index_d$3_RDFGraphToJSON: typeof RDFGraphToJSON;
type index_d$3_RequestContext = RequestContext;
type index_d$3_RequestOpts = RequestOpts;
type index_d$3_RequiredError = RequiredError;
declare const index_d$3_RequiredError: typeof RequiredError;
type index_d$3_ResponseContext = ResponseContext;
type index_d$3_ResponseError = ResponseError;
declare const index_d$3_ResponseError: typeof ResponseError;
type index_d$3_ResponseTransformer<T> = ResponseTransformer<T>;
type index_d$3_TextApiResponse = TextApiResponse;
declare const index_d$3_TextApiResponse: typeof TextApiResponse;
type index_d$3_Theme = Theme;
declare const index_d$3_ThemeFromJSON: typeof ThemeFromJSON;
declare const index_d$3_ThemeFromJSONTyped: typeof ThemeFromJSONTyped;
declare const index_d$3_ThemeToJSON: typeof ThemeToJSON;
type index_d$3_TypesEnum = TypesEnum;
declare const index_d$3_TypesEnum: typeof TypesEnum;
declare const index_d$3_TypesEnumFromJSON: typeof TypesEnumFromJSON;
declare const index_d$3_TypesEnumFromJSONTyped: typeof TypesEnumFromJSONTyped;
declare const index_d$3_TypesEnumToJSON: typeof TypesEnumToJSON;
type index_d$3_Viewport = Viewport;
declare const index_d$3_ViewportFromJSON: typeof ViewportFromJSON;
declare const index_d$3_ViewportFromJSONTyped: typeof ViewportFromJSONTyped;
declare const index_d$3_ViewportToJSON: typeof ViewportToJSON;
type index_d$3_VoidApiResponse = VoidApiResponse;
declare const index_d$3_VoidApiResponse: typeof VoidApiResponse;
declare const index_d$3_canConsumeForm: typeof canConsumeForm;
declare const index_d$3_exists: typeof exists;
declare const index_d$3_instanceOfAnnotation: typeof instanceOfAnnotation;
declare const index_d$3_instanceOfAnnotationOp: typeof instanceOfAnnotationOp;
declare const index_d$3_instanceOfClassInstanceEntity: typeof instanceOfClassInstanceEntity;
declare const index_d$3_instanceOfClassInstanceEntityAllOf: typeof instanceOfClassInstanceEntityAllOf;
declare const index_d$3_instanceOfDataPropertyValue: typeof instanceOfDataPropertyValue;
declare const index_d$3_instanceOfDiagram: typeof instanceOfDiagram;
declare const index_d$3_instanceOfDiagramOp: typeof instanceOfDiagramOp;
declare const index_d$3_instanceOfEdge: typeof instanceOfEdge;
declare const index_d$3_instanceOfEdgeAllOf: typeof instanceOfEdgeAllOf;
declare const index_d$3_instanceOfElement: typeof instanceOfElement;
declare const index_d$3_instanceOfElementOp: typeof instanceOfElementOp;
declare const index_d$3_instanceOfEntity: typeof instanceOfEntity;
declare const index_d$3_instanceOfEntityOp: typeof instanceOfEntityOp;
declare const index_d$3_instanceOfHierarchy: typeof instanceOfHierarchy;
declare const index_d$3_instanceOfHierarchyOp: typeof instanceOfHierarchyOp;
declare const index_d$3_instanceOfHierarchySuperclassesInner: typeof instanceOfHierarchySuperclassesInner;
declare const index_d$3_instanceOfNamespace: typeof instanceOfNamespace;
declare const index_d$3_instanceOfNamespaceOp: typeof instanceOfNamespaceOp;
declare const index_d$3_instanceOfNode: typeof instanceOfNode;
declare const index_d$3_instanceOfNodeAllOf: typeof instanceOfNodeAllOf;
declare const index_d$3_instanceOfPosition: typeof instanceOfPosition;
declare const index_d$3_instanceOfPropertyOp: typeof instanceOfPropertyOp;
declare const index_d$3_instanceOfRDFGraph: typeof instanceOfRDFGraph;
declare const index_d$3_instanceOfRDFGraphConfig: typeof instanceOfRDFGraphConfig;
declare const index_d$3_instanceOfRDFGraphMetadata: typeof instanceOfRDFGraphMetadata;
declare const index_d$3_instanceOfTheme: typeof instanceOfTheme;
declare const index_d$3_instanceOfViewport: typeof instanceOfViewport;
declare const index_d$3_mapValues: typeof mapValues;
declare const index_d$3_querystring: typeof querystring;
declare namespace index_d$3 {
  export {
    Annotation$1 as Annotation,
    index_d$3_AnnotationFromJSON as AnnotationFromJSON,
    index_d$3_AnnotationFromJSONTyped as AnnotationFromJSONTyped,
    index_d$3_AnnotationOp as AnnotationOp,
    index_d$3_AnnotationOpFromJSON as AnnotationOpFromJSON,
    index_d$3_AnnotationOpFromJSONTyped as AnnotationOpFromJSONTyped,
    index_d$3_AnnotationOpToJSON as AnnotationOpToJSON,
    index_d$3_AnnotationToJSON as AnnotationToJSON,
    index_d$3_ApiResponse as ApiResponse,
    index_d$3_BASE_PATH as BASE_PATH,
    index_d$3_BaseAPI as BaseAPI,
    index_d$3_BlobApiResponse as BlobApiResponse,
    index_d$3_COLLECTION_FORMATS as COLLECTION_FORMATS,
    ClassInstanceEntity$1 as ClassInstanceEntity,
    index_d$3_ClassInstanceEntityAllOf as ClassInstanceEntityAllOf,
    index_d$3_ClassInstanceEntityAllOfFromJSON as ClassInstanceEntityAllOfFromJSON,
    index_d$3_ClassInstanceEntityAllOfFromJSONTyped as ClassInstanceEntityAllOfFromJSONTyped,
    index_d$3_ClassInstanceEntityAllOfToJSON as ClassInstanceEntityAllOfToJSON,
    index_d$3_ClassInstanceEntityFromJSON as ClassInstanceEntityFromJSON,
    index_d$3_ClassInstanceEntityFromJSONTyped as ClassInstanceEntityFromJSONTyped,
    index_d$3_ClassInstanceEntityToJSON as ClassInstanceEntityToJSON,
    index_d$3_Configuration as Configuration,
    index_d$3_ConfigurationParameters as ConfigurationParameters,
    index_d$3_Consume as Consume,
    index_d$3_DataPropertyValue as DataPropertyValue,
    index_d$3_DataPropertyValueFromJSON as DataPropertyValueFromJSON,
    index_d$3_DataPropertyValueFromJSONTyped as DataPropertyValueFromJSONTyped,
    index_d$3_DataPropertyValueToJSON as DataPropertyValueToJSON,
    index_d$3_DefaultConfig as DefaultConfig,
    Diagram$1 as Diagram,
    index_d$3_DiagramFromJSON as DiagramFromJSON,
    index_d$3_DiagramFromJSONTyped as DiagramFromJSONTyped,
    index_d$3_DiagramOp as DiagramOp,
    index_d$3_DiagramOpFromJSON as DiagramOpFromJSON,
    index_d$3_DiagramOpFromJSONTyped as DiagramOpFromJSONTyped,
    index_d$3_DiagramOpToJSON as DiagramOpToJSON,
    index_d$3_DiagramToJSON as DiagramToJSON,
    index_d$3_Edge as Edge,
    index_d$3_EdgeAllOf as EdgeAllOf,
    index_d$3_EdgeAllOfFromJSON as EdgeAllOfFromJSON,
    index_d$3_EdgeAllOfFromJSONTyped as EdgeAllOfFromJSONTyped,
    index_d$3_EdgeAllOfToJSON as EdgeAllOfToJSON,
    index_d$3_EdgeFromJSON as EdgeFromJSON,
    index_d$3_EdgeFromJSONTyped as EdgeFromJSONTyped,
    index_d$3_EdgeToJSON as EdgeToJSON,
    Element$1 as Element,
    index_d$3_ElementFromJSON as ElementFromJSON,
    index_d$3_ElementFromJSONTyped as ElementFromJSONTyped,
    index_d$3_ElementOp as ElementOp,
    index_d$3_ElementOpFromJSON as ElementOpFromJSON,
    index_d$3_ElementOpFromJSONTyped as ElementOpFromJSONTyped,
    index_d$3_ElementOpPreviousState as ElementOpPreviousState,
    index_d$3_ElementOpPreviousStateFromJSON as ElementOpPreviousStateFromJSON,
    index_d$3_ElementOpPreviousStateFromJSONTyped as ElementOpPreviousStateFromJSONTyped,
    index_d$3_ElementOpPreviousStateToJSON as ElementOpPreviousStateToJSON,
    index_d$3_ElementOpSubject as ElementOpSubject,
    index_d$3_ElementOpSubjectFromJSON as ElementOpSubjectFromJSON,
    index_d$3_ElementOpSubjectFromJSONTyped as ElementOpSubjectFromJSONTyped,
    index_d$3_ElementOpSubjectToJSON as ElementOpSubjectToJSON,
    index_d$3_ElementOpToJSON as ElementOpToJSON,
    index_d$3_ElementToJSON as ElementToJSON,
    Entity$1 as Entity,
    index_d$3_EntityFromJSON as EntityFromJSON,
    index_d$3_EntityFromJSONTyped as EntityFromJSONTyped,
    index_d$3_EntityOp as EntityOp,
    index_d$3_EntityOpFromJSON as EntityOpFromJSON,
    index_d$3_EntityOpFromJSONTyped as EntityOpFromJSONTyped,
    index_d$3_EntityOpToJSON as EntityOpToJSON,
    index_d$3_EntityToJSON as EntityToJSON,
    index_d$3_ErrorContext as ErrorContext,
    index_d$3_FetchAPI as FetchAPI,
    index_d$3_FetchError as FetchError,
    index_d$3_FetchParams as FetchParams,
    index_d$3_FunctionPropertiesEnum as FunctionPropertiesEnum,
    index_d$3_FunctionPropertiesEnumFromJSON as FunctionPropertiesEnumFromJSON,
    index_d$3_FunctionPropertiesEnumFromJSONTyped as FunctionPropertiesEnumFromJSONTyped,
    index_d$3_FunctionPropertiesEnumToJSON as FunctionPropertiesEnumToJSON,
    index_d$3_HTTPBody as HTTPBody,
    index_d$3_HTTPHeaders as HTTPHeaders,
    index_d$3_HTTPMethod as HTTPMethod,
    index_d$3_HTTPQuery as HTTPQuery,
    index_d$3_HTTPRequestInit as HTTPRequestInit,
    Hierarchy$1 as Hierarchy,
    index_d$3_HierarchyFromJSON as HierarchyFromJSON,
    index_d$3_HierarchyFromJSONTyped as HierarchyFromJSONTyped,
    index_d$3_HierarchyOp as HierarchyOp,
    index_d$3_HierarchyOpFromJSON as HierarchyOpFromJSON,
    index_d$3_HierarchyOpFromJSONTyped as HierarchyOpFromJSONTyped,
    index_d$3_HierarchyOpToJSON as HierarchyOpToJSON,
    index_d$3_HierarchySuperclassesInner as HierarchySuperclassesInner,
    index_d$3_HierarchySuperclassesInnerFromJSON as HierarchySuperclassesInnerFromJSON,
    index_d$3_HierarchySuperclassesInnerFromJSONTyped as HierarchySuperclassesInnerFromJSONTyped,
    index_d$3_HierarchySuperclassesInnerToJSON as HierarchySuperclassesInnerToJSON,
    index_d$3_HierarchyToJSON as HierarchyToJSON,
    index_d$3_InitOverrideFunction as InitOverrideFunction,
    index_d$3_JSONApiResponse as JSONApiResponse,
    index_d$3_Json as Json,
    index_d$3_Middleware as Middleware,
    index_d$3_ModelPropertyNaming as ModelPropertyNaming,
    Namespace$1 as Namespace,
    index_d$3_NamespaceFromJSON as NamespaceFromJSON,
    index_d$3_NamespaceFromJSONTyped as NamespaceFromJSONTyped,
    index_d$3_NamespaceOp as NamespaceOp,
    index_d$3_NamespaceOpFromJSON as NamespaceOpFromJSON,
    index_d$3_NamespaceOpFromJSONTyped as NamespaceOpFromJSONTyped,
    index_d$3_NamespaceOpToJSON as NamespaceOpToJSON,
    index_d$3_NamespaceToJSON as NamespaceToJSON,
    index_d$3_Node as Node,
    index_d$3_NodeAllOf as NodeAllOf,
    index_d$3_NodeAllOfFromJSON as NodeAllOfFromJSON,
    index_d$3_NodeAllOfFromJSONTyped as NodeAllOfFromJSONTyped,
    index_d$3_NodeAllOfToJSON as NodeAllOfToJSON,
    index_d$3_NodeFromJSON as NodeFromJSON,
    index_d$3_NodeFromJSONTyped as NodeFromJSONTyped,
    index_d$3_NodeToJSON as NodeToJSON,
    index_d$3_Position as Position,
    index_d$3_PositionFromJSON as PositionFromJSON,
    index_d$3_PositionFromJSONTyped as PositionFromJSONTyped,
    index_d$3_PositionToJSON as PositionToJSON,
    index_d$3_PropertyOp as PropertyOp,
    index_d$3_PropertyOpFromJSON as PropertyOpFromJSON,
    index_d$3_PropertyOpFromJSONTyped as PropertyOpFromJSONTyped,
    index_d$3_PropertyOpToJSON as PropertyOpToJSON,
    index_d$3_RDFGraph as RDFGraph,
    index_d$3_RDFGraphConfig as RDFGraphConfig,
    index_d$3_RDFGraphConfigEntityNameTypeEnum as RDFGraphConfigEntityNameTypeEnum,
    index_d$3_RDFGraphConfigFiltersEnum as RDFGraphConfigFiltersEnum,
    index_d$3_RDFGraphConfigFromJSON as RDFGraphConfigFromJSON,
    index_d$3_RDFGraphConfigFromJSONTyped as RDFGraphConfigFromJSONTyped,
    index_d$3_RDFGraphConfigToJSON as RDFGraphConfigToJSON,
    index_d$3_RDFGraphFromJSON as RDFGraphFromJSON,
    index_d$3_RDFGraphFromJSONTyped as RDFGraphFromJSONTyped,
    index_d$3_RDFGraphMetadata as RDFGraphMetadata,
    index_d$3_RDFGraphMetadataFromJSON as RDFGraphMetadataFromJSON,
    index_d$3_RDFGraphMetadataFromJSONTyped as RDFGraphMetadataFromJSONTyped,
    index_d$3_RDFGraphMetadataToJSON as RDFGraphMetadataToJSON,
    index_d$3_RDFGraphModelTypeEnum as RDFGraphModelTypeEnum,
    index_d$3_RDFGraphToJSON as RDFGraphToJSON,
    index_d$3_RequestContext as RequestContext,
    index_d$3_RequestOpts as RequestOpts,
    index_d$3_RequiredError as RequiredError,
    index_d$3_ResponseContext as ResponseContext,
    index_d$3_ResponseError as ResponseError,
    index_d$3_ResponseTransformer as ResponseTransformer,
    index_d$3_TextApiResponse as TextApiResponse,
    index_d$3_Theme as Theme,
    index_d$3_ThemeFromJSON as ThemeFromJSON,
    index_d$3_ThemeFromJSONTyped as ThemeFromJSONTyped,
    index_d$3_ThemeToJSON as ThemeToJSON,
    index_d$3_TypesEnum as TypesEnum,
    index_d$3_TypesEnumFromJSON as TypesEnumFromJSON,
    index_d$3_TypesEnumFromJSONTyped as TypesEnumFromJSONTyped,
    index_d$3_TypesEnumToJSON as TypesEnumToJSON,
    index_d$3_Viewport as Viewport,
    index_d$3_ViewportFromJSON as ViewportFromJSON,
    index_d$3_ViewportFromJSONTyped as ViewportFromJSONTyped,
    index_d$3_ViewportToJSON as ViewportToJSON,
    index_d$3_VoidApiResponse as VoidApiResponse,
    index_d$3_canConsumeForm as canConsumeForm,
    index_d$3_exists as exists,
    index_d$3_instanceOfAnnotation as instanceOfAnnotation,
    index_d$3_instanceOfAnnotationOp as instanceOfAnnotationOp,
    index_d$3_instanceOfClassInstanceEntity as instanceOfClassInstanceEntity,
    index_d$3_instanceOfClassInstanceEntityAllOf as instanceOfClassInstanceEntityAllOf,
    index_d$3_instanceOfDataPropertyValue as instanceOfDataPropertyValue,
    index_d$3_instanceOfDiagram as instanceOfDiagram,
    index_d$3_instanceOfDiagramOp as instanceOfDiagramOp,
    index_d$3_instanceOfEdge as instanceOfEdge,
    index_d$3_instanceOfEdgeAllOf as instanceOfEdgeAllOf,
    index_d$3_instanceOfElement as instanceOfElement,
    index_d$3_instanceOfElementOp as instanceOfElementOp,
    index_d$3_instanceOfEntity as instanceOfEntity,
    index_d$3_instanceOfEntityOp as instanceOfEntityOp,
    index_d$3_instanceOfHierarchy as instanceOfHierarchy,
    index_d$3_instanceOfHierarchyOp as instanceOfHierarchyOp,
    index_d$3_instanceOfHierarchySuperclassesInner as instanceOfHierarchySuperclassesInner,
    index_d$3_instanceOfNamespace as instanceOfNamespace,
    index_d$3_instanceOfNamespaceOp as instanceOfNamespaceOp,
    index_d$3_instanceOfNode as instanceOfNode,
    index_d$3_instanceOfNodeAllOf as instanceOfNodeAllOf,
    index_d$3_instanceOfPosition as instanceOfPosition,
    index_d$3_instanceOfPropertyOp as instanceOfPropertyOp,
    index_d$3_instanceOfRDFGraph as instanceOfRDFGraph,
    index_d$3_instanceOfRDFGraphConfig as instanceOfRDFGraphConfig,
    index_d$3_instanceOfRDFGraphMetadata as instanceOfRDFGraphMetadata,
    index_d$3_instanceOfTheme as instanceOfTheme,
    index_d$3_instanceOfViewport as instanceOfViewport,
    index_d$3_mapValues as mapValues,
    index_d$3_querystring as querystring,
  };
}

/**
 * Class representing a namespace
 * @property {string[]} prefixes - array of prefixes
 * @property {string} value - namespace lexical form
 * @property {boolean} standard - bool saying if the namespace is standard or user defined
 */
declare class Namespace implements Namespace$1 {
    private _prefixes;
    private _value;
    private _standard;
    constructor(prefixes: string[], value: string, standard?: boolean);
    get prefixes(): string[];
    set prefixes(value: string[]);
    private set value(value);
    get value(): string;
    toString(): string;
    private set standard(value);
    /**
     * Wether the namespace is standard (`true`) or user defined (`false`)
     */
    isStandard(): boolean;
    /**
     * Check if the passed prefix is assigned to this namespace
     * @param prefix the prefix to check
     */
    hasPrefix(prefix: string): boolean;
    addPrefix(newPrefix: string): void;
}

declare const DefaultNamespaces: {
    RDFS: Namespace;
    OWL: Namespace;
};

declare class Iri {
    private _namespace?;
    private _remainder;
    constructor(iri: string, namespaces: Namespace[], remainder?: string);
    set remainder(value: string);
    get remainder(): string;
    private set namespace(value);
    get namespace(): Namespace | undefined;
    get prefix(): string | undefined;
    get fullIri(): string;
    get prefixed(): string;
    equals(iriToCheck: string | Iri): boolean;
    hasPrefix(prefixToCheck: string): boolean;
}

declare class Annotation implements Annotation$1 {
    private _property;
    lexicalForm: string;
    language: string;
    datatype: string;
    constructor(property: Iri, lexicalForm: string, language?: string, datatype?: string);
    equals(annotation: Annotation): boolean;
    get property(): string;
    get kind(): string;
}

declare class AnnotatedElement {
    private _annotations;
    constructor();
    set annotations(annotations: Annotation[]);
    addAnnotation(newAnnotation: Annotation): void;
    removeAnnotation(annotation: Annotation): void;
    getAnnotations(language?: string, annotationProperty?: Iri): Annotation[];
    getLabels(language?: string): Annotation[];
    getComments(language?: string): Annotation[];
}

declare class Breakpoint implements Position {
    x: number;
    y: number;
    distance: number;
    weight: number;
    private deltaX;
    private deltaY;
    private angularCoefficient;
    private intersectionPoint;
    private distanceSourceTarget;
    private distanceIntersectionSource;
    private breakpointRelativeToSource;
    constructor(x?: number, y?: number);
    /**
     * Date le posizioni di source, target e del breakpoint,
     * la funzione calcola i due parametri peso e distanza del breakpoint
     * @param source posizione del nodo source
     * @param target posizione del nodo target
     */
    setSourceTarget(source: Position, target: Position): void;
    private setWeight;
    private setDistance;
}

/**
 * Shapes assigned to Graphol nodes. These are [Cytoscape.js shapes](https =//js.cytoscape.org/#style/node-body)
 * @enum {string}
 * @property {string} RECTANGLE rectangle
 * @property {string} DIAMOND diamond
 * @property {string} ELLIPSE ellipse
 * @property {string} HEXAGON hexagon
 * @property {string} ROUND_RECTANGLE roundrectangle
 * @property {string} OCTAGON octagon
 * @property {string} POLYGON polygon
 */
declare enum Shape {
    /** @type {"rectangle"} */
    RECTANGLE = "rectangle",
    /** @type {"diamond"} */
    DIAMOND = "diamond",
    /** @type {"ellipse"} */
    ELLIPSE = "ellipse",
    /** @type {"hexagon"} */
    HEXAGON = "hexagon",
    /** @type {"roundrectangle"} */
    ROUND_RECTANGLE = "roundrectangle",
    /** @type {"octagon"} */
    OCTAGON = "octagon",
    /** @type {"polygon"} */
    POLYGON = "polygon"
}
declare const POLYGON_POINTS = "-0.9 -1 1 -1 0.9 1 -1 1";
/**
 * Enumeration having `type`, `shape` and `identity` for each Graphol node
 */
type GrapholNodeInfo = {
    TYPE: TypesEnum;
    SHAPE: Shape;
    IDENTITY: TypesEnum;
    LABEL?: string;
    SHAPE_POINTS?: string;
};
declare const GrapholNodesEnum: {
    [x in TypesEnum]?: GrapholNodeInfo;
};

declare class GrapholNode extends GrapholElement implements Node {
    static newFromSwagger(n: Node): GrapholNode;
    private _x;
    private _y;
    private _renderedX?;
    private _renderedY?;
    private _shape;
    private _identity;
    private _height;
    private _width;
    private _fillColor;
    private _labelHeight;
    private _hierarchyID?;
    private _hierarchyForcedComplete?;
    private _labelXpos?;
    private _labelXcentered?;
    private _labelYpos?;
    private _labelYcentered?;
    private _fontSize?;
    protected _fakeNodes: GrapholNode[];
    private _inputs?;
    private _shapePoints?;
    get position(): Position;
    set position(pos: Position);
    get renderedPosition(): Position | undefined;
    set renderedPosition(pos: Position | undefined);
    get x(): number;
    set x(valX: number);
    get y(): number;
    set y(valY: number);
    get shape(): Shape;
    set shape(shape: Shape);
    get hierarchyID(): string | undefined;
    set hierarchyID(hierarchyID: string | undefined);
    get hierarchyForcedComplete(): boolean | undefined;
    set hierarchyForcedComplete(complete: boolean | undefined);
    get identity(): TypesEnum;
    set identity(identity: TypesEnum);
    get width(): number;
    set width(width: number);
    get height(): number;
    set height(height: number);
    get fillColor(): string;
    set fillColor(fillColor: string);
    get labelXpos(): number | undefined;
    set labelXpos(labelXpos: number | undefined);
    setLabelXposFromXML(labelXpos: number): void;
    get labelHeight(): number;
    set labelHeight(value: number);
    get labelYpos(): number | undefined;
    set labelYpos(labelYpos: number | undefined);
    setLabelYposFromXML(labelYpos: number): void;
    get isLabelXcentered(): boolean | undefined;
    get isLabelYcentered(): boolean | undefined;
    get fontSize(): number | undefined;
    set fontSize(value: number | undefined);
    get inputs(): string[] | undefined;
    set inputs(inputs: string[] | undefined);
    get shapePoints(): string | undefined;
    set shapePoints(shapePoints: string | undefined);
    get fakeNodes(): GrapholNode[];
    isHierarchy: () => boolean;
    addFakeNode(newFakeNode: GrapholNode): void;
    getCytoscapeRepr(grapholEntity?: GrapholEntity): ElementDefinition[];
    clone(): GrapholNode;
    json(): Node;
}
declare function isGrapholNode(elem: GrapholElement): elem is GrapholNode;

declare class GrapholElement implements Element$1 {
    private _id;
    private _type;
    private _displayedName?;
    private _originalId?;
    private _iri?;
    private _diagramId;
    constructor(_id: string, _type: TypesEnum);
    get id(): string;
    set id(value: string);
    get type(): TypesEnum;
    set type(type: TypesEnum);
    get displayedName(): string | undefined;
    set displayedName(displayedName: string | undefined);
    get originalId(): string | undefined;
    set originalId(id: string | undefined);
    get iri(): string | undefined;
    set iri(iri: string | undefined);
    get diagramId(): number;
    set diagramId(newdiagramId: number);
    /**
     * Check if element is of a certain type
     * @param type
     */
    is(type: TypesEnum): boolean;
    isHierarchy: () => boolean;
    /**
     *
     * @returns whether node is an entity
     */
    isEntity(): boolean;
    getCytoscapeRepr(grapholEntity?: GrapholEntity): ElementDefinition[];
    clone(): GrapholElement;
    json(): Element$1;
    equals(grapholElement: GrapholElement): boolean;
    isNode(): this is GrapholNode;
    isEdge(): this is GrapholEdge;
}

declare class GrapholEdge extends GrapholElement implements Edge {
    static newFromSwagger(n: Edge): GrapholEdge;
    private _sourceId;
    private _targetId;
    private _breakpoints;
    private _targetLabel?;
    private _sourceLabel?;
    private _sourceEndpoint?;
    private _targetEndpoint?;
    constructor(id: string, type: TypesEnum);
    addBreakPoint(breakpoint: Breakpoint): void;
    computeBreakpointsDistancesWeights(sourcePosition: Position, targetPosition: Position): void;
    get sourceEndpoint(): Position | undefined;
    set sourceEndpoint(endpoint: Position | undefined);
    get targetEndpoint(): Position | undefined;
    set targetEndpoint(endpoint: Position | undefined);
    /**
     * Returns an array of mid-edge breakpoints (without source/target endpoints)
     */
    get breakpoints(): Breakpoint[];
    /**
     * Returns an array of all the breakpoints (including source/target endpoints)
     */
    get controlpoints(): Breakpoint[];
    set controlpoints(newControlPoints: Breakpoint[]);
    get sourceId(): string;
    set sourceId(sourceId: string);
    get targetId(): string;
    set targetId(targetId: string);
    get targetLabel(): string | undefined;
    set targetLabel(targetLabel: string | undefined);
    get sourceLabel(): string | undefined;
    set sourceLabel(sourceLabel: string | undefined);
    get type(): TypesEnum;
    set type(newType: TypesEnum);
    isHierarchy: () => boolean;
    getCytoscapeRepr(grapholEntity?: GrapholEntity): cytoscape$1.ElementDefinition[];
    clone(): GrapholEdge;
    json(): Edge;
}
declare function isGrapholEdge(elem: GrapholElement): elem is GrapholEdge;

/**
 * @typedef {object} Filter
 * @property {string} Filter.selector Cytoscape selector identifying the elements to filter out
 * [cytoscape selectors](https://js.cytoscape.org/#selectors)
 * @property {boolean} Filter.active whether the filter is currently active or not
 * @property {boolean} Filter.activable whether the filter is currently activable
 * @property {string} Filter.class the class to add to filtered elems to easily retrieve them later on
 * @property {string} Filter.key unique key to identify a filter
 */
declare class Filter {
    private _key;
    private _compareFn;
    active: boolean;
    private _locked;
    /**
     *
     * @param key Unique identifier
     * @param compareFn Function receiving a GrapholElement and returning true if the element should be filtered, false otherwise
     */
    constructor(key: string, compareFn: (grapholElement: GrapholElement) => boolean);
    get key(): string;
    get filterTag(): string;
    get locked(): boolean;
    lock(): void;
    unlock(): void;
    shouldFilter(grapholElement: GrapholElement): boolean;
}
declare const getDefaultFilters: () => {
    readonly DATA_PROPERTY: Filter;
    readonly VALUE_DOMAIN: Filter;
    readonly INDIVIDUAL: Filter;
    readonly UNIVERSAL_QUANTIFIER: Filter;
    readonly COMPLEMENT: Filter;
    readonly HAS_KEY: Filter;
};

declare enum ColoursNames {
    /** Foreground color, used for main texts */
    fg_default = "fg-default",
    /** Foreground muted, should be darker than default. Used for secondary text */
    fg_muted = "fg-muted",
    /** Foreground muted, should be lighter and softer than default.
     * Used for placeholders, tips and text used for clarifying UI objects
     */
    fg_subtle = "fg-subtle",
    /** Foreground text colour placed on a surface of a emphasy color such as accent, danger, success and so on */
    fg_on_emphasis = "fg-on-emphasis",
    /** Main background surface colours used in UI widgets */
    bg_default = "bg-default",
    /** Background color to create a higher or lower level with respect to bg_default color */
    bg_inset = "bg-inset",
    /** Borders main color */
    border_default = "border-default",
    /** Softer than default, used for creating softer separations between UI objects */
    border_subtle = "border-subtle",
    shadow = "shadow",
    /** Used to emphasize secondary elements or texts. Like active elements */
    neutral = "neutral",
    /** Emphasize secondary elements, should be darker than default */
    neutral_muted = "neutral-muted",
    /** Emphasize secondary elements, used for active elements borders */
    neutral_subtle = "neutral-subtle",
    /** Primary color for selected/active elements in diagram or activable elemnts like toggles */
    accent = "accent",
    /** Primary color in darker tone, used for decorations like surfaces or borders */
    accent_muted = "accent-muted",
    /** Primary color in lighter tone, used for decorations like toggle's background color */
    accent_subtle = "accent-subtle",
    /** Color for denoting a successful action */
    success = "success",
    /** Denote successful action in darker tone, used for texts or borders */
    success_muted = "success-muted",
    /** Denote successful action in lighter tone, used for backgrounds or surfaces */
    success_subtle = "success-subtle",
    /** Color for denoting warnings */
    attention = "attention",
    /** Color for denoting warnings in darker tone, used for texts or borders */
    attention_muted = "attention-muted",
    /** Color for denoting warnings in lighter tone, used for backgrounds or surfaces */
    attention_subtle = "attention-subtle",
    /** Color for denoting errors */
    danger = "danger",
    /** Color for denoting errors in darker tone, used for texts or borders */
    danger_muted = "danger-muted",
    /** Color for denoting errors in lighter tone, used for backgrounds or surfaces */
    danger_subtle = "danger-subtle",
    /** Color used for classes' nodes bodies */
    class = "class",
    /** Color used for classes' nodes borders */
    class_contrast = "class-contrast",
    /** Color used for object properties' nodes bodies */
    object_property = "object-property",
    /** Color used for object properties' nodes borders */
    object_property_contrast = "object-property-contrast",
    /** Color used for data properties' nodes bodies */
    data_property = "data-property",
    /** Color used for data properties' nodes borders */
    data_property_contrast = "data-property-contrast",
    /** Color used for individual's nodes bodies */
    individual = "individual",
    /** Color used for individual's nodes borders */
    individual_contrast = "individual-contrast",
    /** Background color used in the diagram canvas */
    bg_graph = "bg-graph",
    /** Body color for nodes that are white in plain Graphol */
    bg_node_light = "bg-node-light",
    /** Body color for nodes that are black in plain Graphol */
    bg_node_dark = "bg-node-dark",
    /** Body border color */
    border_node = "border-node",
    /** Nodes/Edges label color */
    label = "label",
    /** Opposite color of label */
    label_contrast = "label-contrast",
    /** Edges lines color */
    edge = "edge",
    class_instance = "class-instance",
    class_instance_contrast = "class-instance-contrast"
}
type ColourMap = {
    [key in ColoursNames]?: string;
};

declare class GrapholscapeTheme implements Theme {
    private _id;
    private _name;
    colours: ColourMap;
    constructor(id: string, colours?: ColourMap, name?: string);
    get id(): string;
    get name(): string;
    set name(newName: string);
    getColour(name: ColoursNames): string | undefined;
    setColour(name: ColoursNames, colourValue: string): void;
}

declare enum LifecycleEvent {
    DiagramChange = "diagramChange",
    RendererChange = "rendererChange",
    ThemeChange = "themeChange",
    EntitySelection = "entitySelection",
    NodeSelection = "nodeSelection",
    EdgeSelection = "edgeSelection",
    LanguageChange = "languageChange",
    EntityNameTypeChange = "entityNameTypeChange",
    Filter = "filter",
    Unfilter = "unfilter",
    FilterRequest = "filterRequest",
    UnfilterRequest = "unfilterRequest",
    BackgroundClick = "backgroundClick",
    ContextClick = "contextClick",
    DoubleTap = "doubleTap",
    EntityWikiLinkClick = "entityWikiLinkClick",
    MouseOver = "mouseOver",
    MouseOut = "mouseOut"
}
interface IonEvent$1 {
    (event: LifecycleEvent.EntitySelection, callback: (entity: GrapholEntity, instance: GrapholElement) => void): void;
    (event: LifecycleEvent.NodeSelection, callback: (node: GrapholNode) => void): void;
    (event: LifecycleEvent.EdgeSelection, callback: (edge: GrapholEdge) => void): void;
    (event: LifecycleEvent.ThemeChange, callback: (theme: GrapholscapeTheme) => void): void;
    (event: LifecycleEvent.DiagramChange, callback: (diagram: Diagram) => void): void;
    (event: LifecycleEvent.RendererChange, callback: (renderer: RendererStatesEnum) => void): void;
    (event: LifecycleEvent.LanguageChange, callback: (language: string) => void): void;
    (event: LifecycleEvent.EntityNameTypeChange, callback: (nameType: RDFGraphConfigEntityNameTypeEnum) => void): void;
    (event: LifecycleEvent.Filter, callback: (filter: Filter) => void): void;
    (event: LifecycleEvent.Unfilter, callback: (filter: Filter) => void): void;
    (event: LifecycleEvent.FilterRequest, callback: (filter: Filter) => boolean): void;
    (event: LifecycleEvent.UnfilterRequest, callback: (filter: Filter) => boolean): void;
    (event: LifecycleEvent.BackgroundClick, callback: () => void): void;
    (event: LifecycleEvent.ContextClick, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.DoubleTap, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.MouseOver, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.MouseOut, callback: (eventObject: EventObject) => void): void;
    (event: LifecycleEvent.EntityWikiLinkClick, callback: (iri: string) => void): void;
}
interface IEventTriggers {
    (event: LifecycleEvent.EntitySelection, entity: GrapholEntity, instance: GrapholElement): void;
    (event: LifecycleEvent.NodeSelection, node: GrapholNode): void;
    (event: LifecycleEvent.EdgeSelection, edge: GrapholEdge): void;
    (event: LifecycleEvent.ThemeChange, theme: GrapholscapeTheme): void;
    (event: LifecycleEvent.DiagramChange, diagram: Diagram): void;
    (event: LifecycleEvent.RendererChange, renderer: RendererStatesEnum): void;
    (event: LifecycleEvent.LanguageChange, language: string): void;
    (event: LifecycleEvent.EntityNameTypeChange, nameType: RDFGraphConfigEntityNameTypeEnum): void;
    (event: LifecycleEvent.Filter, filter: Filter): void;
    (event: LifecycleEvent.Unfilter, filter: Filter): void;
    (event: LifecycleEvent.FilterRequest, filter: Filter): boolean;
    (event: LifecycleEvent.UnfilterRequest, filter: Filter): boolean;
    (event: LifecycleEvent.BackgroundClick): void;
    (event: LifecycleEvent.ContextClick, eventObject: EventObject): void;
    (event: LifecycleEvent.DoubleTap, eventObject: EventObject): void;
    (event: LifecycleEvent.MouseOver, eventObject: EventObject): void;
    (event: LifecycleEvent.MouseOut, eventObject: EventObject): void;
    (event: LifecycleEvent.EntityWikiLinkClick, iri: string): void;
}
declare class Lifecycle {
    private diagramChange;
    private rendererChange;
    private themeChange;
    private entitySelection;
    private nodeSelection;
    private edgeSelection;
    private languageChange;
    private entityNameTypeChange;
    private filter;
    private unfilter;
    private filterRequest;
    private unfilterRequest;
    private backgroundClick;
    private contextClick;
    private doubleTap;
    private mouseOver;
    private mouseOut;
    entityWikiLinkClick: ((iri: string) => void)[];
    trigger: IEventTriggers;
    on: IonEvent$1;
}

declare class Renderer {
    private _container;
    cy?: cytoscape__default.Core;
    private _renderState?;
    filters: Map<string, Filter>;
    diagram?: Diagram;
    private _theme;
    private _lifecycle;
    FOCUS_ZOOM_LEVEL: number;
    renderStateData: {
        [x: string]: any;
    };
    constructor(renderState?: RenderState);
    set lifecycle(lc: Lifecycle);
    set renderState(rs: RenderState | undefined);
    get renderState(): RenderState | undefined;
    get theme(): GrapholscapeTheme;
    render(diagram: Diagram): void;
    mount(): void;
    addElement(element: ElementDefinition): void;
    /**
     * Filter elements on the diagram.
     * It will be actually applied only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be applied.
     * @param filter Can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    filter: (filter: Filter | RDFGraphConfigFiltersEnum | string) => void;
    private performFilter;
    /**
     * Unfilter elements on the diagram.
     * It will be actually deactivated only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be deactivated.
     * @param filter Can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    unfilter: (filter: Filter | RDFGraphConfigFiltersEnum | string) => void;
    private getFilter;
    private applyActiveFilters;
    private performAllFilters;
    stopRendering(): void;
    /**
     * Select a node or an edge in the current diagram given its unique id
     * @param {string} elementId elem id (node or edge)
     */
    selectElement(elementId: string): void;
    /**
     * Unselect every selected element in this diagram
     */
    unselect(): void;
    /**
     * Fit viewport to diagram
     */
    fit(): void;
    /**
     * Put a set of elements (nodes and/or edges) at the center of the viewport.
     * If just one element then the element will be at the center.
     * @param elementId the element's ID
     * @param zoom the zoom level to apply, if not passed, zoom level won't be changed
     */
    centerOnElementById(elementId: string, zoom?: number | undefined, select?: boolean): void;
    centerOnElement(element: GrapholElement, zoom?: number, select?: boolean): void;
    centerOnModelPosition(xPos: number, yPos: number, zoom?: number): void;
    centerOnRenderedPosition(xPos: number, yPos: number, zoom?: number): void;
    zoom(zoomValue: number): void;
    zoomIn(zoomValue: number): void;
    zoomOut(zoomValue: number): void;
    setTheme(theme: GrapholscapeTheme): void;
    applyTheme(): void;
    updateElement(grapholElement: GrapholElement): void;
    get isThemeApplied(): cytoscape__default.ElementStylesheetStyle | cytoscape__default.ElementStylesheetCSS | undefined;
    get grapholElements(): Map<string, GrapholElement> | undefined;
    get selectedElement(): GrapholElement | undefined;
    get viewportState(): {
        zoom: number;
        pan: cytoscape__default.Position;
    } | undefined;
    set container(container: HTMLElement);
    get container(): HTMLElement;
    /**
     * Getter
     */
    get nodes(): string[] | undefined;
    /**
     * Getter
     */
    get edges(): string[] | undefined;
}

declare class GrapholRendererState extends BaseRenderer {
    layout: cytoscape.Layouts;
    id: RendererStatesEnum;
    cyConfig: cytoscape.CytoscapeOptions;
    filterManager: FilterManager;
    render(): void;
    stopRendering(): void;
    runLayout(): void;
    stopLayout(): void;
    getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    transformOntology(ontology: Ontology): void;
}

declare class LiteRendererState extends BaseRenderer {
    readonly id: RendererStatesEnum;
    filterManager: FilterManager;
    cyConfig: CytoscapeOptions;
    private _layout;
    runLayout(): void;
    render(): void;
    stopRendering(): void;
    stopLayout(): void;
    getGraphStyle(theme: GrapholscapeTheme): cytoscape$1.Stylesheet[];
    transformOntology(ontology: Ontology): void;
    get layout(): cytoscape$1.Layouts;
    set layout(newLayout: cytoscape$1.Layouts);
}

declare class FloatyRendererState extends BaseRenderer {
    readonly id: RendererStatesEnum;
    filterManager: FilterManager;
    protected _layout: cytoscape__default.Layouts;
    set renderer(newRenderer: Renderer);
    get renderer(): Renderer;
    transformOntology(ontology: Ontology): void;
    runLayout(): void;
    render(): void;
    stopRendering(): void;
    getGraphStyle(theme: GrapholscapeTheme): cytoscape__default.Stylesheet[];
    stopLayout(): void;
    runLayoutInfinitely(): void;
    pinNode(nodeOrId: NodeSingular | string): void;
    unpinAll(): void;
    private setPopperStyle;
    private updatePopper;
    unpinNode(nodeOrId: string | NodeSingular): void;
    private removeUnlockButton;
    protected setDragAndPinEventHandlers(): void;
    private grabHandler;
    private freeHandler;
    protected get defaultLayoutOptions(): {
        name: string;
        avoidOverlap: boolean;
        edgeLength: (edge: any) => any;
        fit: boolean;
        maxSimulationTime: number;
        infinite: boolean;
        handleDisconnected: boolean;
        centerGraph: boolean;
    };
    centerOnElementById(elementId: string, zoom?: number, select?: boolean): void;
    get floatyLayoutOptions(): any;
    set floatyLayoutOptions(newOptions: any);
    protected automoveOptions: {
        nodesMatching: (node: NodeSingular) => boolean | undefined;
        reposition: string;
        dragWith: string;
    };
    get isLayoutInfinite(): boolean;
    get dragAndPin(): boolean;
    set dragAndPin(isActive: boolean);
    protected get popperContainer(): HTMLDivElement | undefined;
    protected get popperContainers(): Map<number, HTMLDivElement>;
    get layout(): cytoscape__default.Layouts;
}

/**
 * The incremental renderer state is a kind of floaty renderer state in which
 * ontology's diagrams are used only to compute what to show.
 * There is only a single empty diagram and any render() call just render the same diagram
 * no matter what was the input diagram.
 *
 * This renderer state is logic agnostic, meaning that it does not control what to show and when.
 * You can decide what to show/hide outside, based on lifecycle and/or other custom developed widgets.
 */
declare class IncrementalRendererState extends FloatyRendererState {
    readonly id = RendererStatesEnum.INCREMENTAL;
    filterManager: FilterManager;
    private previousDiagram;
    render(): void;
    runLayout(): void;
    runCustomLayout(cyLayoutOptions: any): void;
    /** lock all nodes */
    freezeGraph(): void;
    /** unlock all nodes that are not pinned (pinned can be unlocked only with unpin) */
    unFreezeGraph(): void;
    stopRendering(): void;
    transformOntology(ontology: Ontology): void;
    getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    reset(): void;
    filter(elementId: string, filter: Filter): void;
    unfilter(elementId: string, filter: Filter): void;
    set renderer(newRenderer: Renderer);
    get renderer(): Renderer;
    protected get defaultLayoutOptions(): {
        name: string;
        avoidOverlap: boolean;
        edgeLength: (edge: EdgeSingular) => number;
        fit: boolean;
        maxSimulationTime: number;
        infinite: boolean;
        handleDisconnected: boolean;
        centerGraph: boolean;
    };
}

interface FilterManager {
    filters: Map<string, Filter>;
    filterActivation: (filter: Filter) => boolean;
    filterDeactivation: (filter: Filter) => boolean;
}
declare abstract class BaseFilterManager implements FilterManager {
    protected _filters: Map<string, Filter>;
    protected lockedFilters: RDFGraphConfigFiltersEnum[];
    filterActivation(filter: Filter): boolean;
    filterDeactivation(filter: Filter): boolean;
    get filters(): Map<string, Filter>;
    set filters(filters: Map<string, Filter>);
}

declare enum RendererStatesEnum {
    GRAPHOL = "graphol",
    GRAPHOL_LITE = "lite",
    FLOATY = "floaty",
    INCREMENTAL = "incremental"
}
interface RenderState {
    id: RendererStatesEnum;
    renderer: Renderer;
    filterManager: FilterManager;
    layout: cytoscape.Layouts;
    layoutRunning: boolean;
    render(): void;
    stopRendering(): void;
    filter(elementId: string, filter: Filter): void;
    unfilter(elementId: string, filter: Filter): void;
    runLayout(): void;
    stopLayout(): void;
    getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    transformOntology(ontology: Ontology): void;
    centerOnElementById(elementId: string, zoom?: number, select?: boolean): void;
}

declare class GrapholEntity extends AnnotatedElement implements Entity$1 {
    static newFromSwagger(iri: Iri, e: Entity$1): GrapholEntity;
    private _iri;
    private _occurrences;
    private _datatype;
    private _isDataPropertyFunctional;
    private _functionProperties;
    private _color?;
    constructor(iri: Iri);
    addOccurrence(newGrapholElement: GrapholElement, representationKind?: RendererStatesEnum): void;
    removeOccurrence(grapholElement: GrapholElement, representationKind: RendererStatesEnum): void;
    /**
     * Get all occurrences of the entity in a given diagram
     * @param diagramId the diagram in which the entity must occurr
     * @param representationKind the diagram representation identifier ({@link RendererStatesEnum})
     * if not set, all representations will be considered
     * @returns A map with the occurrences in the original Graphol representation and other
     * replicated occurrences in other diagram representations
     */
    getOccurrencesByDiagramId(diagramId: number, representationKind?: RendererStatesEnum): Map<RendererStatesEnum, GrapholElement[]>;
    get types(): Set<TypesEnum>;
    /**
     * Check if entity is of a certain type
     * @param type
     */
    is(type: TypesEnum): boolean;
    get occurrences(): Map<RendererStatesEnum, GrapholElement[]>;
    set iri(val: Iri);
    get iri(): Iri;
    get fullIri(): string;
    get functionProperties(): FunctionPropertiesEnum[];
    set functionProperties(properties: FunctionPropertiesEnum[]);
    get isDataPropertyFunctional(): boolean;
    set isDataPropertyFunctional(value: boolean);
    get datatype(): string;
    set datatype(datatype: string);
    get color(): string | undefined;
    set color(color: string | undefined);
    getOccurrenceByType(type: TypesEnum, rendererState: RendererStatesEnum): GrapholElement | undefined;
    getOccurrencesByType(type: TypesEnum, rendererState: RendererStatesEnum): GrapholElement[] | undefined;
    hasFunctionProperty(property: FunctionPropertiesEnum): boolean;
    hasOccurrenceInDiagram(diagramId: number, representationKind: RendererStatesEnum): boolean;
    getDisplayedName(nameType: RDFGraphConfigEntityNameTypeEnum, currentLanguage?: string): string;
    getEntityOriginalNodeId(): string | undefined;
    getIdInDiagram(diagramId: number, type: TypesEnum, rendererState: RendererStatesEnum): string | undefined;
    json(): Entity$1;
}

declare class DiagramRepresentation {
    private _cy;
    private _grapholElements;
    private _hasEverBeenRendered;
    lastViewportState?: Viewport;
    constructor(cyConfig?: cytoscape__default.CytoscapeOptions);
    get cy(): cytoscape__default.Core;
    set cy(newCy: cytoscape__default.Core);
    get hasEverBeenRendered(): boolean;
    set hasEverBeenRendered(value: boolean);
    /**
     * Add a new element (node or edge) to the diagram
     * @param newElement the GrapholElement to add to the diagram
     */
    addElement(newElement: GrapholElement, grapholEntity?: GrapholEntity): cytoscape__default.CollectionReturnValue;
    removeElement(elementId: string): void;
    clear(): void;
    updateElement(element: GrapholElement, grapholEntity?: GrapholEntity, updatePosition?: boolean): void;
    updateElement(elementId: string, grapholEntity?: GrapholEntity, updatePosition?: boolean): void;
    containsEntity(iriOrGrapholEntity: Iri | GrapholEntity): boolean;
    filter(elementId: string, filterTag: string): void;
    unfilter(elementId: string, filterTag: string): void;
    getNewId(nodeOrEdge: 'node' | 'edge'): string;
    get grapholElements(): Map<string, GrapholElement>;
    set grapholElements(newElementMap: Map<string, GrapholElement>);
    /**
     * Getter
     */
    get nodes(): string[];
    /**
     * Getter
     */
    get edges(): string[];
    get nodesCounter(): number;
    get edgesCounter(): number;
}

/**
 * @property {string} name - diagram's name
 * @property {string | number} id - diagram's identifier
 */
declare class Diagram implements Diagram$1 {
    name: string;
    id: number;
    representations: Map<RendererStatesEnum, DiagramRepresentation>;
    lastViewportState: Viewport;
    /**
     * @param {string} name
     * @param {number} id
     */
    constructor(name: string, id: number);
    /**
     * Add a new element (node or edge) to the diagram's representation
     * @param newElement the GrapholElement to add to the diagram
     */
    addElement(newElement: GrapholElement, grapholEntity?: GrapholEntity): void;
    /**
     * Delete every element from a diagram
     * @param rendererState optional, if you pass a particular rendererState, only its representation will be cleared.
     * If you don't pass any rendererState, all representations will be cleared
     */
    clear(rendererState?: RendererStatesEnum): void;
    removeElement(elementId: string, rendererState: RendererStatesEnum): void;
    containsEntity(iriOrGrapholEntity: Iri | GrapholEntity, rendererState: RendererStatesEnum): boolean | undefined;
}

declare class Hierarchy implements Hierarchy$1 {
    type: TypesEnum.UNION | TypesEnum.DISJOINT_UNION;
    forcedComplete: boolean;
    private _id;
    private _inputs;
    private _superclasses;
    /**
     *
     * @param id
     * @param type
     * @param forcedComplete if the hierarchy is forced to be complete, any superclass edge
     * will have type COMPLETE_UNION / COMPLETE_DISJOINT_UNION, regardless if they are created
     * as complete or not.
     */
    constructor(id: string, type: TypesEnum.UNION | TypesEnum.DISJOINT_UNION, forcedComplete?: boolean);
    addInput(classEntity: GrapholEntity): void;
    removeInput(classEntity: GrapholEntity): void;
    addSuperclass(classEntity: GrapholEntity, complete?: boolean): void;
    removeSuperclass(classEntity: GrapholEntity): void;
    get inputs(): GrapholEntity[];
    get superclasses(): {
        classEntity: GrapholEntity;
        complete: boolean;
    }[];
    set id(newId: string);
    get id(): string;
    getUnionGrapholNode(position?: Position): GrapholNode | undefined;
    getInputGrapholEdges(diagramId: number, rendererState: RendererStatesEnum): GrapholEdge[] | undefined;
    getInclusionEdges(diagramId: number, rendererState: RendererStatesEnum): GrapholEdge[] | undefined;
    isDisjoint(): boolean;
    private isValid;
}

declare const DefaultAnnotationProperties: {
    [x: string]: Iri;
};
declare class AnnotationProperty extends Iri {
}

/**
 * # Ontology
 * Class used as the Model of the whole app.
 */
declare class Ontology extends AnnotatedElement implements RDFGraphMetadata {
    name: string;
    version: string;
    namespaces: Namespace[];
    annProperties: AnnotationProperty[];
    diagrams: Diagram[];
    languages: string[];
    defaultLanguage?: string;
    iri?: string;
    private _entities;
    private _hierarchies;
    private _subHierarchiesMap;
    private _superHierarchiesMap;
    private _inclusions;
    addHierarchy(hierarchy: Hierarchy): void;
    removeHierarchy(hiearchyId: string): void;
    removeHierarchy(hiearchyId: Hierarchy): void;
    getHierarchy(hierarchyId: string): Hierarchy | undefined;
    getHierarchiesOf(classIri: string | Iri): Hierarchy[];
    /**
     * @param superClassIri the superclass iri
     * @returns The arrary of hiearchies for which a class appear as superclass
     */
    getSubHierarchiesOf(superClassIri: string | Iri): Hierarchy[];
    /**
     *
     * @param subClassIri
     * @returns The arrary of hiearchies for which a class appear as subclass
     */
    getSuperHierarchiesOf(subClassIri: string | Iri): Hierarchy[];
    getSubclassesOf(superClassIri: string | Iri): Set<GrapholEntity>;
    getSuperclassesOf(superClassIri: string | Iri): Set<GrapholEntity>;
    addSubclassOf(subclassIri: string | Iri, superclassIri: string | Iri): void;
    addSubclassOf(subclass: GrapholEntity, superclass: GrapholEntity): void;
    removeSubclassOf(subclassIri: string | Iri, superclassIri: string | Iri): void;
    removeSubclassOf(subclass: GrapholEntity, superclass: GrapholEntity): void;
    /**
     * @param {string} name
     * @param {string} version
     * @param {Namespace[]} namespaces
     * @param {AnnotationProperty[]} annProperties
     * @param {Diagram[]} diagrams
     */
    constructor(name: string, version: string, iri?: string, namespaces?: Namespace[], annProperties?: AnnotationProperty[], diagrams?: Diagram[]);
    /** @param {Namespace} namespace */
    addNamespace(namespace: Namespace): void;
    /**
     * Get the Namspace object given its IRI string
     * @param {string} iriValue the IRI assigned to the namespace
     * @returns {Namespace}
     */
    getNamespace(iriValue: string): Namespace | undefined;
    /**
     * Get the Namespace given one of its prefixes
     * @param {string} prefix
     * @returns {Namespace}
     */
    getNamespaceFromPrefix(prefix: string): Namespace | undefined;
    getNamespaces(): Namespace[];
    /** @param {AnnotationProperty} annProperty */
    addAnnotationProperty(annProperty: AnnotationProperty): void;
    /**
     * Get the Namspace object given its IRI string
     * @param {string} iriValue the IRI assigned to the namespace
     * @returns {AnnotationProperty}
     */
    getAnnotationProperty(iriValue: string): AnnotationProperty | undefined;
    getAnnotationProperties(): AnnotationProperty[];
    /** @param {Diagram} diagram */
    addDiagram(diagram: Diagram): void;
    /**
     * Get the diagram with the given id
     */
    getDiagram(diagramId: number): Diagram | undefined;
    getDiagramByName(name: string): Diagram | undefined;
    addEntity(entity: GrapholEntity): void;
    getEntity(iri: string | Iri): GrapholEntity | undefined;
    getEntitiesByType(entityType: TypesEnum): GrapholEntity[];
    getEntityFromOccurrence(entityOccurrence: GrapholElement): GrapholEntity | undefined;
    getGrapholElement(elementId: string, diagramId?: number, renderState?: RendererStatesEnum): GrapholElement | undefined;
    getGrapholNode(nodeId: string, diagramId?: number, renderState?: RendererStatesEnum): GrapholNode | undefined;
    getGrapholEdge(edgeId: string, diagramId?: number, renderState?: RendererStatesEnum): GrapholNode | undefined;
    /**
     * Retrieve an entity by its IRI.
     * @param {string} iri - The IRI in full or prefixed form.
     * i.e. : `grapholscape:world` or `https://examples/grapholscape/world`
     * @returns {cytoscape.CollectionReturnValue} The cytoscape object representation.
     */
    /**
     * Retrieve all occurrences of an entity by its IRI.
     * @param {string} iri - The IRI in full or prefixed form.
     * i.e. : `grapholscape:world` or `https://examples/grapholscape/world`
     * @returns An array of EntityOccurrence objects
     */
    getEntityOccurrences(iri: string, diagramId?: number, renderState?: RendererStatesEnum): Map<RendererStatesEnum, GrapholElement[]> | undefined;
    /**
     * Get the entities in the ontology
     * @returns {Object.<string, cytoscape.CollectionReturnValue[]>} a map of IRIs, with an array of entity occurrences (object[iri].occurrences)
     */
    /**
     * Check if entity has the specified iri in full or prefixed form
     * @param {Entity} entity
     * @param {string} iri
     * @returns {boolean}
     */
    /**
     * Retrieve the full IRI given a prefixed IRI
     * @param {string} prefixedIri a prefixed IRI
     * @returns {string} full IRI
     */
    prefixedToFullIri(prefixedIri: string): string | undefined;
    computeDatatypesOnDataProperties(): void;
    get isEntitiesEmpty(): boolean;
    get entities(): Map<string, GrapholEntity>;
    set entities(newEntities: Map<string, GrapholEntity>);
}

/** @internal */
declare class ClassInstanceEntity extends GrapholEntity implements ClassInstanceEntity$1 {
    private _parentClassIris;
    private _dataProperties;
    constructor(iri: Iri, parentClassIris?: Iri[]);
    /**
     * Set the instance to be instance of a particular Class.
     * If it is already instance of such a class, no changes will be made.
     * @param parentClassIri the IRI of the Class
     */
    addParentClass(parentClassIri: Iri): void;
    /**
     * Check if the instance is instance of a class with such an IRI
     * @param parentClassIri
     * @returns
     */
    hasParentClassIri(parentClassIri: string | Iri): boolean;
    get isRDFTypeUnknown(): boolean;
    get parentClassIris(): Iri[];
    get dataProperties(): DataPropertyValue[];
    set dataProperties(newProperties: DataPropertyValue[]);
}

declare class IncrementalDiagram extends Diagram {
    static ID: number;
    /** @internal */
    classInstances?: Map<string, ClassInstanceEntity>;
    constructor();
    addElement(newElement: GrapholElement, grapholEntity?: GrapholEntity): void;
    removeElement(elementId: string): void;
    containsEntity(iriOrGrapholEntity: Iri | GrapholEntity): boolean | undefined;
    get representation(): DiagramRepresentation | undefined;
}

declare enum DefaultThemesEnum {
    GRAPHOLSCAPE = "grapholscape",
    GRAPHOL = "graphol",
    DARK = "dark",
    COLORFUL_LIGHT = "colorful-light",
    COLORFUL_DARK = "colorful-dark"
}
declare const gscapeColourMap: ColourMap;
declare const classicColourMap: ColourMap;
declare const darkColourMap: ColourMap;
declare const autoLightColourMap: ColourMap;
declare const autoDarkColourMap: ColourMap;
declare const DefaultThemes: {
    [key in DefaultThemesEnum]?: GrapholscapeTheme;
};

declare const CSS_PROPERTY_NAMESPACE = "--gscape-color";

declare abstract class BaseRenderer implements RenderState {
    protected _renderer: Renderer;
    abstract id: RendererStatesEnum;
    abstract filterManager: FilterManager;
    abstract layout: cytoscape.Layouts;
    abstract render(): void;
    abstract stopRendering(): void;
    abstract runLayout(): void;
    abstract stopLayout(): void;
    abstract getGraphStyle(theme: GrapholscapeTheme): Stylesheet[];
    abstract transformOntology(ontology: Ontology): void;
    layoutRunning: boolean;
    constructor(renderer?: Renderer);
    centerOnElementById(elementId: string, zoom?: number, select?: boolean): void;
    set renderer(newRenderer: Renderer);
    get renderer(): Renderer;
    filter(elementId: string, filter: Filter): void;
    unfilter(elementId: string, filter: Filter): void;
}

declare enum WidgetEnum {
    DIAGRAM_SELECTOR = "diagram-selector",
    ENTITY_DETAILS = "details",
    ENTITY_SELECTOR = "entity-selector",
    FILTERS = "filters",
    FIT_BUTTON = "fit-button",
    FULLSCREEN_BUTTON = "fullscreen-button",
    ONTOLOGY_EXPLORER = "ontology-explorer",
    ONTOLOGY_INFO = "ontology-info",
    OWL_VISUALIZER = "owl-visualizer",
    RENDERER_SELECTOR = "renderer-selector",
    LAYOUT_SETTINGS = "layout-settings",
    SETTINGS = "settings",
    ZOOM_TOOLS = "zoom-tools",
    INITIAL_RENDERER_SELECTOR = "initial-renderer-selector",
    ENTITY_COLOR_LEGEND = "entity-color-legend",
    /** @internal */
    CLASS_INSTANCE_DETAILS = "class-instance-details",
    /** @internal */
    INSTANCES_EXPLORER = "instances-explorer",
    /** @internal */
    NAVIGATION_MENU = "naviagtion-menu",
    /** @internal */
    VKG_PREFERENCES = "vkg-preferences",
    INCREMENTAL_INITIAL_MENU = "incremental-initial-menu",
    DESIGNER_TOOLBOX = "designer-toolbox"
}

declare enum Language {
    DE = "de",
    EN = "en",
    ES = "es",
    FR = "fr",
    IT = "it"
}
type WidgetsConfig = {
    [key in WidgetEnum]?: boolean;
};
type ThemeConfig = GrapholscapeTheme | DefaultThemesEnum;
type GrapholscapeConfig = {
    themes?: ThemeConfig[];
    selectedTheme?: string;
    language?: Language | string;
    entityNameType?: RDFGraphConfigEntityNameTypeEnum;
    renderers?: RendererStatesEnum[];
    selectedRenderer?: RendererStatesEnum;
    widgets?: WidgetsConfig;
    initialRendererSelection?: boolean;
};

/**
 * Load config from local storage
 */
declare function loadConfig(): GrapholscapeConfig;
/**
 * Store a single setting in local storage
 * @param {string} k the key of the setting to store
 * @param {any} value the value of the setting to store
 */
declare function storeConfigEntry(k: string, value: any): void;
declare function clearLocalStorage(): void;

declare const _default$b: CytoscapeOptions;

declare const liteOptions: {
    layout: {
        name: string;
    };
    autoungrabify: boolean;
    maxZoom: number;
    minZoom: number;
    wheelSensitivity: number;
};
declare const floatyOptions: {
    layout: {
        name: string;
    };
    autoungrabify: boolean;
    maxZoom: number;
    minZoom: number;
    wheelSensitivity: number;
};

type MastroEndpoint = {
    description?: string;
    name: string;
    mastroID?: MastroID;
    needRestart?: boolean;
    user?: string;
};
type MastroID = {
    avpID: string;
    datasourceID: string;
    mappingID: string;
    ontologyID: {
        ontologyName: string;
        ontologyVersion: string;
    };
};
declare enum QueryStatusEnum {
    FINISHED = "FINISHED",
    UNAVAILABLE = "UNAVAILABLE",
    ERROR = "ERROR",
    RUNNING = "RUNNING",
    READY = "READY",
    STOPPED = "STOPPED"
}
type RequestOptions = {
    basePath: string;
    version: string;
    name: string;
    headers: any;
    onError: (errorObject: any) => void;
};
type MWSEntity = {
    entityIRI: string;
    entityID: string;
    entityPrefixIRI: string;
    entityRemainder: string;
    entityType: string;
};
type EmptyUnfoldingEntities = {
    emptyUnfoldingClasses: MWSEntity[];
    emptyUnfoldingDataProperties: MWSEntity[];
    emptyUnfoldingObjectProperties: MWSEntity[];
};
type MaterializedCounts = {
    countsMap: Map<string, CountEntry>;
    endTime: number;
    percentage: number;
    startTime: number;
    state: QueryStatusEnum;
};
type CountEntry = {
    count: number;
    error?: string;
    state: QueryStatusEnum;
    entity: MWSEntity;
};

/**
 * Swagger Sparqling WS
 * This server will expose an API to Sparqling front end to create new SPARQL queries with a combinations of point and click on the [GRAPHOLscape](https://github.com/obdasystems/grapholscape) graph.  Sparqling will be released as a standalone appication but also the server will embedded in [MWS](https://github.com/obdasystems/mws) and Sparqling will be integrated in [Monolith](https://www.monolith.obdasystems.com/).
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: info@obdasystems.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Entity
 */
interface Entity {
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    type?: EntityTypeEnum;
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    iri?: string;
    /**
     *
     * @type {string}
     * @memberof Entity
     */
    prefixedIri?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Entity
     */
    labels?: {
        [key: string]: string;
    };
}
/**
 * @export
 */
declare const EntityTypeEnum: {
    readonly Class: "class";
    readonly ObjectProperty: "objectProperty";
    readonly InverseObjectProperty: "inverseObjectProperty";
    readonly DataProperty: "dataProperty";
    readonly Annotation: "annotation";
};
type EntityTypeEnum = typeof EntityTypeEnum[keyof typeof EntityTypeEnum];

/**
 * Swagger Sparqling WS
 * This server will expose an API to Sparqling front end to create new SPARQL queries with a combinations of point and click on the [GRAPHOLscape](https://github.com/obdasystems/grapholscape) graph.  Sparqling will be released as a standalone appication but also the server will embedded in [MWS](https://github.com/obdasystems/mws) and Sparqling will be integrated in [Monolith](https://www.monolith.obdasystems.com/).
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: info@obdasystems.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface OntologyPath
 */
interface OntologyPath {
    /**
     * Starts with lastSelectedIRI and ends with clickedIRI. In between the nodes and edges traversed in the path (ISA edge are marked as ISA)
     * @type {Array<Entity>}
     * @memberof OntologyPath
     */
    entities?: Array<Entity>;
}

/**
 * Swagger Sparqling WS
 * This server will expose an API to Sparqling front end to create new SPARQL queries with a combinations of point and click on the [GRAPHOLscape](https://github.com/obdasystems/grapholscape) graph.  Sparqling will be released as a standalone appication but also the server will embedded in [MWS](https://github.com/obdasystems/mws) and Sparqling will be integrated in [Monolith](https://www.monolith.obdasystems.com/).
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: info@obdasystems.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface Branch
 */
interface Branch {
    /**
     *
     * @type {string}
     * @memberof Branch
     */
    objectPropertyIRI?: string;
    /**
     * It is true when domain and range are the same class.
     * @type {boolean}
     * @memberof Branch
     */
    cyclic?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Branch
     */
    direct?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof Branch
     */
    relatedClasses?: Array<string>;
}

/**
 * Swagger Sparqling WS
 * This server will expose an API to Sparqling front end to create new SPARQL queries with a combinations of point and click on the [GRAPHOLscape](https://github.com/obdasystems/grapholscape) graph.  Sparqling will be released as a standalone appication but also the server will embedded in [MWS](https://github.com/obdasystems/mws) and Sparqling will be integrated in [Monolith](https://www.monolith.obdasystems.com/).
 *
 * The version of the OpenAPI document: 1.0.3
 * Contact: info@obdasystems.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface Highlights
 */
interface Highlights {
    /**
     * Subclasses or brother classes
     * @type {Array<string>}
     * @memberof Highlights
     */
    classes?: Array<string>;
    /**
     *
     * @type {Array<Branch>}
     * @memberof Highlights
     */
    objectProperties?: Array<Branch>;
    /**
     *
     * @type {Array<string>}
     * @memberof Highlights
     */
    dataProperties?: Array<string>;
}

type ClassInstance = {
    iri: string;
    shortIri?: string;
    label?: {
        language?: string;
        value: string;
    };
    searchMatch?: string;
};
interface IVirtualKnowledgeGraphApi {
    getInstances: (iri: string, includeLabels: boolean, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, onStop?: () => void, searchText?: string) => void;
    getNewResults: (executionId: string, pageNumber: number, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, onStop?: () => void, pageSize?: number) => Promise<void>;
    getInstancesByPropertyValue: (classIri: string, propertyIri: string, propertyType: string, propertyValue: string, includeLabels: boolean, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, isDirect?: boolean, onStop?: () => void) => void;
    getInstancesNumber: (iri: string, onResult: (resultCount: number) => void, onStop?: () => void) => void;
    getHighlights: (iri: string) => Promise<Highlights>;
    getEntitiesEmptyUnfoldings: (endpoint: MastroEndpoint) => Promise<EmptyUnfoldingEntities>;
    getInstanceDataPropertyValues: (instanceIri: string, dataPropertyIri: string, onNewResults: (values: string[]) => void, onStop?: () => void) => void;
    getInstancesThroughObjectProperty: (instanceIri: string, objectPropertyIri: string, isDirect: boolean, includeLabels: boolean, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, rangeClassesIri?: string[], dataPropertyFilterIri?: string, textSearch?: string, onStop?: () => void, customLimit?: number, keepAlive?: boolean) => void;
    setEndpoint: (endpoint: MastroEndpoint) => void;
    instanceCheck: (instanceIri: string, classesToCheck: string[], onResult: (classIris: string[]) => void, onStop: () => void) => Promise<void>;
    stopAllQueries: () => void;
    getInstanceLabels: (instanceIri: string, onResult: (result: {
        value: string;
        lang?: string;
    }[]) => void) => Promise<void>;
    getIntensionalShortestPath: (sourceClassIri: string, targetClassIri: string, kShortest?: boolean) => Promise<OntologyPath[]>;
    getExtensionalShortestPath: (sourceInstanceIri: string, targetIri: string, path: OntologyPath, onNewResult: (rdfGraph?: RDFGraph) => void) => Promise<void>;
    pageSize: number;
}
declare class VKGApi implements IVirtualKnowledgeGraphApi {
    private requestOptions;
    pageSize: number;
    private queryManager;
    language: string;
    constructor(requestOptions: RequestOptions, endpoint: MastroEndpoint, pageSize: number);
    getInstances(iri: string, includeLabels: boolean, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, onStop?: () => void, searchText?: string, pageSize?: number): Promise<string>;
    getNewResults(executionId: string, pageNumber: number, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, onStop?: () => void, pageSize?: number): Promise<void>;
    getInstancesByPropertyValue(classIri: string, propertyIri: string, propertyType: string, propertyValue: string, includeLabels: boolean, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, isDirect?: boolean, onStop?: (() => void), pageSize?: number): Promise<string>;
    getInstancesNumber(iri: string, onResult: (resultCount: number) => void, onStop?: () => void): Promise<void>;
    getHighlights(classIri: string): Promise<any>;
    getEntitiesEmptyUnfoldings(endpoint: MastroEndpoint): Promise<EmptyUnfoldingEntities>;
    getInstanceDataPropertyValues(instanceIri: string, dataPropertyIri: string, onNewResults: (values: string[]) => void, onStop?: (() => void), onError?: (() => void)): Promise<void>;
    getInstancesThroughObjectProperty(instanceIri: string, objectPropertyIri: string, isDirect: boolean, includeLabels: boolean, onNewResults: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void, rangeClassesIri?: string[], dataPropertyIriFilter?: string, textSearch?: string, onStop?: (() => void), customLimit?: number, keepAlive?: boolean): Promise<string>;
    instanceCheck(instanceIri: string, classesToCheck: string[], onResult: (resultClass: string[]) => void, onStop?: () => void): Promise<void>;
    getMaterializedCounts(endpoint: MastroEndpoint): Promise<MaterializedCounts>;
    stopAllQueries(): void;
    stopCountsQueries(): void;
    stopInstancesQueries(): void;
    setEndpoint(endpoint: MastroEndpoint): void;
    getInstanceLabels(instanceIri: string, onResult: (result: {
        value: string;
        language?: string;
    }[]) => void): Promise<void>;
    getIntensionalShortestPath(sourceClassIri: string, targetClassIri: string, kShortest?: boolean): Promise<any>;
    getExtensionalShortestPath(sourceInstanceIri: string, targetIri: string, path: OntologyPath, onNewResult: (rdfGraph?: RDFGraph) => void): Promise<void>;
    shouldQueryUseLabels(executionId: string): Promise<boolean>;
    private getClassInstanceFromQueryResult;
    private parseLabel;
}

declare enum IncrementalEvent {
    RequestStopped = "requestStopped",
    NewInstances = "newInstances",
    InstancesSearchFinished = "instancesSearchFinished",
    LimitChange = "limitChange",
    EndpointChange = "endpointChange",
    Reset = "reset",
    ClassInstanceSelection = "classInstanceSselection",
    ClassSelection = "classSelection",
    ContextClick = "contextClick",
    DoubleTap = "doubleTap",
    DiagramUpdated = "diagramUpdated",
    ReasonerSet = "reasonerSet",
    NewDataPropertyValues = "newDataPropertyValues",
    DataPropertyValuesLoadingFinished = "dpvaluesloadfinish",
    InstanceCheckingStarted = "instanceCheckingStarted",
    InstanceCheckingFinished = "instanceCheckingFinished",
    CountStarted = "countStarted",
    NewCountResult = "newCountResult",
    LoadingStarted = "loadingStarted",
    LoadingFinished = "loadingFinished"
}
interface IonEvent {
    (event: IncrementalEvent.RequestStopped, callback: () => void): void;
    (event: IncrementalEvent.NewInstances, callback: (classInstances: ClassInstance[][], numberResultsAvailable: number) => void): void;
    (event: IncrementalEvent.InstancesSearchFinished, callback: () => void): void;
    (event: IncrementalEvent.LimitChange, callback: (limit: number) => void): void;
    (event: IncrementalEvent.EndpointChange, callback: (endpoint: MastroEndpoint) => void): void;
    (event: IncrementalEvent.Reset, callback: () => void): void;
    (event: IncrementalEvent.ClassInstanceSelection, callback: (classInstanceEntity: ClassInstanceEntity) => void): void;
    (event: IncrementalEvent.ClassSelection, callback: (classEntity: GrapholEntity) => void): void;
    (event: IncrementalEvent.DiagramUpdated, callback: () => void): void;
    (event: IncrementalEvent.ReasonerSet, callback: () => void): void;
    (event: IncrementalEvent.NewDataPropertyValues, callback: (instanceIri: string, dataPropertyIri: string, newValues: string[]) => void): void;
    (event: IncrementalEvent.DataPropertyValuesLoadingFinished, callback: (instanceIri: string, dataPropertyIri: string) => void): void;
    (event: IncrementalEvent.InstanceCheckingStarted, callback: (instanceIri: string) => void): void;
    (event: IncrementalEvent.InstanceCheckingFinished, callback: (instanceIri: string) => void): void;
    (event: IncrementalEvent.NewCountResult, callback: (classIri: string, result?: {
        value: number;
        materialized: boolean;
        date?: string;
    }) => void): void;
    (event: IncrementalEvent.CountStarted, callback: (classIri: string) => void): void;
    (event: IncrementalEvent.LoadingStarted, callback: (entityIri: string, entityType: TypesEnum) => void): void;
    (event: IncrementalEvent.LoadingFinished, callback: (entityIri: string, entityType: TypesEnum) => void): void;
}
declare class IncrementalLifecycle {
    private requestStopped;
    private newInstances;
    private instancesSearchFinished;
    private limitChange;
    private endpointChange;
    private reset;
    private classInstanceSselection;
    private classSelection;
    private diagramUpdated;
    private reasonerSet;
    private newDataPropertyValues;
    private dpvaluesloadfinish;
    private instanceCheckingStarted;
    private instanceCheckingFinished;
    private newCountResult;
    private countStarted;
    private loadingStarted;
    private loadingFinished;
    constructor();
    trigger(event: IncrementalEvent.RequestStopped): void;
    trigger(event: IncrementalEvent.NewInstances, classInstances: ClassInstance[][], numberResultsAvailable: number): void;
    trigger(event: IncrementalEvent.InstancesSearchFinished): void;
    trigger(event: IncrementalEvent.LimitChange, limit: number): void;
    trigger(event: IncrementalEvent.EndpointChange, endpoint: MastroEndpoint): void;
    trigger(event: IncrementalEvent.Reset): void;
    trigger(event: IncrementalEvent.ClassInstanceSelection, classInstanceEntity: ClassInstanceEntity): void;
    trigger(event: IncrementalEvent.ClassSelection, classEntity: GrapholEntity): void;
    trigger(event: IncrementalEvent.DiagramUpdated): void;
    trigger(event: IncrementalEvent.ReasonerSet): void;
    trigger(event: IncrementalEvent.NewDataPropertyValues, instanceIri: string, dataPropertyIri: string, newValues: string[]): void;
    trigger(event: IncrementalEvent.DataPropertyValuesLoadingFinished, instanceIri: string, dataPropertyIri: string): void;
    trigger(event: IncrementalEvent.InstanceCheckingStarted, instanceIri: string): void;
    trigger(event: IncrementalEvent.InstanceCheckingFinished, instanceIri: string): void;
    trigger(event: IncrementalEvent.NewCountResult, classIri: string, result?: {
        value: number;
        materialized: boolean;
        date?: string;
    }): void;
    trigger(event: IncrementalEvent.CountStarted, classIri: string): void;
    trigger(event: IncrementalEvent.LoadingStarted, entityIri: string, entityType: TypesEnum): void;
    trigger(event: IncrementalEvent.LoadingFinished, entityIri: string, entityType: TypesEnum): void;
    on: IonEvent;
}

declare class HighlightsManager {
    vkgApi: IVirtualKnowledgeGraphApi;
    private emptyUnfoldingEntities;
    private _dataProperties;
    private _objectProperties;
    private highlightsCallsPromises;
    private computationPromise;
    lastClassIris: string[];
    private currentClassIris;
    private emptyUnfoldingsDataProperties;
    private emptyUnfoldingsObjectProperties;
    private emptyUnfoldingsClasses;
    constructor(vkgApi: IVirtualKnowledgeGraphApi, emptyUnfoldingEntities: EmptyUnfoldingEntities);
    computeHighlights(classesIri: string[]): Promise<void>;
    computeHighlights(classIri: string): Promise<void>;
    clear(): Promise<void>;
    dataProperties(): Promise<string[]>;
    objectProperties(): Promise<Branch[]>;
    getShortestPath(sourceClassIri: string, targetClassIri: string): Promise<OntologyPath[]>;
    getShortestKPaths(sourceClassIri: string, targetClassIri: string): Promise<OntologyPath[]>;
    hasUnfoldings(entityIri: string, entityType: TypesEnum): boolean;
}

declare class EndpointController {
    private requestOptions;
    private lifecycle;
    private endpointApi;
    private endpoints;
    private selectedEndpoint?;
    vkgApi?: VKGApi;
    highlightsManager?: HighlightsManager;
    pageSize: number;
    constructor(requestOptions: RequestOptions, lifecycle: IncrementalLifecycle);
    getRunningEndpoints(): Promise<MastroEndpoint[]>;
    setEndpoint(endpoint: MastroEndpoint): Promise<void>;
    setEndpoint(endpointName: string): Promise<void>;
    setPageSize(newPageSize: number): void;
    clear(): void;
    stopRequests(requestType?: 'instances' | 'counts' | 'all'): void;
    requestInstancesForClass(classIri: string, includeLabels?: boolean, searchText?: string, propertyIriFilter?: string, propertyType?: TypesEnum.OBJECT_PROPERTY | TypesEnum.DATA_PROPERTY, isDirect?: boolean): Promise<string> | undefined;
    requestNewInstances(requestId: string, pageNumber: number): void;
    requestInstancesThroughObjectProperty(instanceIri: string, objectPropertyIri: string, isDirect?: boolean, includeLabels?: boolean, rangeClassIri?: string[], propertyIriFilter?: string, searchText?: string): Promise<string> | undefined;
    requestDataPropertyValues(instanceIri: string, dataPropertyIri: string): void;
    requestCountForClass(classIri: string): void;
    shouldQueryUseLabels(queryExecutionId: string): Promise<boolean> | undefined;
    getMaterializedCounts(): Promise<MaterializedCounts | undefined>;
    instanceCheck(instanceIri: string, classesToCheck: string[]): Promise<string[]>;
    requestInstancesPath(sourceInstanceIri: string, targetIri: string, path: OntologyPath): Promise<RDFGraph | undefined>;
    setLanguage(lang: string): void;
    isReasonerAvailable(): boolean;
    get endpoint(): MastroEndpoint | undefined;
}

type ObjectPropertyConnectedClasses = {
    list: GrapholEntity[];
    direct: boolean;
};
declare class NeighbourhoodFinder {
    private ontology;
    constructor(ontology: Ontology);
    getDataProperties(classIriString: string): GrapholEntity[];
    getObjectProperties(classIriString: string): Map<GrapholEntity, ObjectPropertyConnectedClasses>;
    /**
     * Given a class and an object property, get all classes connected to the given class through such an
     * object property.
     * @param sourceClassIriString the class' iri involved in the object property
     * either as domain or range
     * @param objectPropertyIriString the object property's iri for which to retrieve the connected classes' iris
     * @returns an array of entities
     */
    getClassesConnectedToObjectProperty(sourceClassIriString: string, objectPropertyIriString: string): GrapholEntity[];
    private getConnectedClassesIrisByType;
    getSubclassesIris(classIri: string): string[];
    getEquivalentClassesIris(classIri: string): string[];
    getSuperclassesIris(classIri: string): string[];
    private getIriObject;
}

/** @internal */
declare class IncrementalController {
    grapholscape: Grapholscape;
    private diagramBuilder;
    neighbourhoodFinder: NeighbourhoodFinder;
    classInstanceEntities: Map<string, ClassInstanceEntity>;
    lastClassIri?: string;
    lastInstanceIri?: string;
    diagram: IncrementalDiagram;
    endpointController?: EndpointController;
    private actionsWithBlockedGraph;
    private entitySelectionTimeout;
    counts: Map<string, {
        value: number;
        materialized: boolean;
        date?: string;
    }>;
    countersEnabled: boolean;
    classFilterMap: Map<string, Filter>;
    lifecycle: IncrementalLifecycle;
    on: IonEvent;
    /**
     * Callback called when user click on data lineage command
     */
    onShowDataLineage: (entityIri: string) => void;
    addEdge: (sourceId: string, targetId: string, edgeType: TypesEnum.INCLUSION | TypesEnum.INPUT | TypesEnum.EQUIVALENCE | TypesEnum.INSTANCE_OF) => GrapholEdge | undefined;
    constructor(grapholscape: Grapholscape);
    showDiagram(viewportState?: Viewport): void;
    performActionWithBlockedGraph(action: () => void | Promise<void>, customLayoutOptions?: any): Promise<void>;
    /**
     * @internal
     *
     * Create new EndpointApi object with current mastro request options
     */
    setMastroConnection(mastroRequestOptions: RequestOptions): void;
    /**
     * Inject in the current diagram the results from a construct query in RDFGraph form.
     * Here we assume entities are already in the loaded ontology.
     * If grapholscape is started right away with construct results, then the function
     * performing the init must take care of loading all the entities beforehand.
     * The only entities that will be loaded here are instance entities (individuals).
     * @param rdfGraph the graph to add to current vkg instance
     * @returns
     */
    addRDFGraph(rdfGraph: RDFGraph): void;
    /**
     * Given source instance and target instance IRIs and a path to traverse,
     * add to the diagram the set of instances/object properties resulting
     * from the CONSTRUCT query over the path.
     */
    addInstancesPath(sourceIri: string, targetIri: string, path: OntologyPath): Promise<void>;
    addClass(iri: string, centerOnIt?: boolean, position?: Position$1): GrapholNode | undefined;
    areHierarchiesVisible(hierarchies: Hierarchy[]): boolean;
    areAllConnectedClassesVisibleForClass(classIri: string, connectedClassesIris: string[], positionType: 'sub' | 'super' | 'equivalent'): boolean;
    reset(): void;
    clearState(): void;
    private updateEntityNameType;
    /**
     * Remove a class, an instance or a data property node from the diagram.
     * Entities left with no other connections are recurisvely removed too.
     * Called when the user click on the remove button on a entity node
     * @param entityIri
     */
    removeEntity(entityIri: GrapholEntity, entitiesIrisToKeep?: string[]): void;
    removeEntity(entityIri: string, entitiesIrisToKeep?: string[]): void;
    addInstance(instance: ClassInstance, parentClassesIris?: string[] | string, position?: Position$1): ClassInstanceEntity;
    /**
     * Add object property edge between two classes.
     * @param objectPropertyIri the object property iri to add
     * @param sourceClassIri
     * @param targetClassIri
     */
    addIntensionalObjectProperty(objectPropertyIri: string, sourceClassIri: string, targetClassIri: string): GrapholEdge | undefined;
    /**
     * Add object property edge between two instances
     * @param objectPropertyIri
     * @param sourceInstanceIri
     * @param targetInstanceIri
     */
    addExtensionalObjectProperty(objectPropertyIri: string, sourceInstanceIri: string, targetInstanceIri: string): void;
    /**
     * Shows the domain/range types of an extensional object property
     * hence only if object property connects two instances, shows their rdf:types
     * and add the intensional object property between them.
     * @param objectPropertyIri
     * @param sourceClassInstanceIri
     * @param targetClassInstanceIri
     */
    showObjectPropertyTypes(objectPropertyIri: string, sourceClassInstanceIri: string, targetClassInstanceIri: string): void;
    /**
     * Show hierarchies for which the specified class is a subclass.
     * @param classIri
     */
    showSuperHierarchiesOf(classIri: string): void;
    /**
     * Show hierarchies for which the specified class is a superclass.
     * @param classIri
     */
    showSubHierarchiesOf(classIri: string): void;
    /**
     * Hide hierarchies for which the specified class is a subClass (i.e. an input class).
     * Hierarchies are pre-computed, after the floaty-transformation is performed.
     * @param classIri
     */
    hideSuperHierarchiesOf(classIri: string): void;
    /**
     * Show hierarchies for which the specified class is a superclass (i.e. an input class).
     * Hierarchies are pre-computed, after the floaty-transformation is performed.
     * @param classIri
     */
    hideSubHierarchiesOf(classIri: string): void;
    private showOrHideHierarchies;
    private removeHierarchy;
    showSubClassesOf(classIri: string, subclassesIris?: string[]): void;
    showSuperClassesOf(classIri: string, superclassesIris?: string[]): void;
    showEquivalentClassesOf(classIri: string, equivalentClassesIris?: string[]): void;
    private showClassesInIsa;
    /**
     * Given the iri of a class, retrieve connected object properties.
     * These object properties are inferred if the reasoner is available.
     * Otherwise only object properties directly asserted in the ontology
     * will be retrieved.
     * @param classIri
     * @returns
     */
    getObjectPropertiesByClasses(classIris: string[]): Promise<Map<GrapholEntity, ObjectPropertyConnectedClasses>>;
    getDataPropertiesByClasses(classIris: string[]): Promise<GrapholEntity[]>;
    getDataPropertiesByClassInstance(instanceIri: string): Promise<GrapholEntity[]>;
    expandObjectPropertiesOnInstance(instanceIri: string): Promise<void>;
    /**
     * Retrieve all class instances participating to an object property
     * with another instance and add it to diagram with the extensional
     * object property.
     * (called by navigation menu to auto expand an object property)
     * @param instanceIri
     * @param objectPropertyIri
     * @param isDirect
     */
    expandObjectPropertyOnInstance(instanceIri: string, objectPropertyIri: string, isDirect: boolean): void;
    /**
     * Retrieve first page of results for instances of a given class.
     * Then add instances and instance-of edges (if possible) to parent class
     * @param classIri
     * @param pageSize
     * @returns
     */
    expandInstancesOnClass(classIri: string, pageSize?: number): void;
    focusInstance(classInstance: ClassInstance): void;
    private addResultsFromFocus;
    addPath(path: Entity[]): Promise<void>;
    pinNode: (node: NodeSingular | string) => void | undefined;
    unpinNode: (node: NodeSingular | string) => void | undefined;
    postDiagramEdit(oldElemsNumber: number, customLayoutOptions?: any): void;
    countInstancesForClass(classIri: string, askFreshValue?: boolean): Promise<void>;
    updateMaterializedCounts(): Promise<void>;
    setIncrementalEventHandlers(): void;
    private get ontology();
    private get incrementalRenderer();
    getIDByIRI(iri: string, type: TypesEnum): string | undefined;
    get numberOfElements(): number;
}

/** @internal */
declare function initIncremental(grapholscape: Grapholscape): void;

declare class Grapholscape {
    renderer: Renderer;
    private availableRenderers;
    container: HTMLElement;
    readonly lifecycle: Lifecycle;
    ontology: Ontology;
    private entityNavigator;
    private displayedNamesManager;
    private themesManager;
    widgets: Map<string, HTMLElement>;
    widgetsInitialStates: WidgetsConfig;
    constructor(ontology: Ontology, container: HTMLElement, config?: GrapholscapeConfig);
    /**
     * Show a certain diagram by its ID
     * @param diagramId the diagram's id to display
     * @param viewportState set a custom {@link !model.ViewportState}, if not set, last one available will be used
     */
    showDiagram(diagramId: number, viewportState?: Viewport): void;
    /**
     * Change the current renderer (Graphol - Lite - Floaty).
     *
     * @remarks
     * A RendererState is an implementation for the {@link !model.iRenderState} interface
     * that changes the way the {@link Renderer} performs the main operations on a
     * {@link !model.Diagram} such as rendering it and filtering elements in it.
     * The renderer states included in Grapholscape are: {@link GrapholRendererState},
     * {@link LiteRendererState} and {@link FloatyRendererState}.
     *
     * @param newRenderState the renderer state instance to set, if you want to reuse
     * these instances it's totally up to you.
     *
     *
     * @example
     * ```ts
     * // Setting the floaty renderer state
     * import { FloatyRendererState } from 'grapholscape'
     *
     * grapholscape.setRenderer(new FloatyRendererState())
     * ```
     */
    setRenderer(newRenderState: RenderState): void;
    /**
     * Center the viewport on a single element.
     * @remarks
     * If you specify a different diagram from the current one, it will be displayed
     * @param elementId the element's id (can be a node or an edge)
     * @param diagramId the diagram's id (**default**: the current one)
     * @param zoom the level zoom to apply, do not pass it if you don't want zoom to change
     */
    centerOnElement(elementId: string, diagramId?: number, zoom?: number): void;
    /**
     * Select an element in a diagram.
     * @remarks
     * If you specify a different diagram from the current one, it will be displayed
     * @param elementId the element's id (can be a node or an edge)
     * @param diagramId the diagram's id (**default**: the current one)
     */
    selectElement(elementId: string, diagramId?: number): void;
    /** Unselect any selected element in the current diagram */
    unselect(): void;
    /** Fit viewport to diagram */
    fit(): void;
    /**
     * Apply a certain level of zoom
     * @param value level of zoom to set
     */
    zoom(value: number): void;
    /**
     * Increase the zooom level by a certain amount
     * @param amount the amount of zoom to add
     */
    zoomIn(amount: number): void;
    /**
     * Decrease the zooom level by a certain amount
     * @param amount the amount of zoom to remove
     */
    zoomOut(amount: number): void;
    /**
     * Filter elements on the diagram.
     * @remarks
     * It will be currently applied only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be applied.
     * @param filter the filter to apply, can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    filter(filter: string | Filter | RDFGraphConfigFiltersEnum): void;
    /**
     * Unfilter elements on the diagram.
     * @remarks
     * It will be currently deactivated only if the user defined callback on the event
     * {@link !model.LifecycleEvent.FilterRequest} returns true and if the internal logic
     * allows for the filter to be deactivated.
     * @param filter the filter to disable, can be an object of type {@link !model.Filter}, {@link !model.DefaultFilterKeyEnum}
     * or a string representing the unique key of a defined filter
     */
    unfilter(filter: string | Filter | RDFGraphConfigFiltersEnum): void;
    /** The current diagram's id */
    get diagramId(): number | undefined;
    /** The current renderer state */
    get renderState(): RendererStatesEnum | undefined;
    /** The current selected Entity */
    get selectedEntity(): GrapholEntity | undefined;
    /** An array of available renderer's state for this Grapholscape instance */
    get renderers(): RendererStatesEnum[];
    /**
     * Center viewport on a single entity occurrence given its IRI
     * @param iri the iri of the entity to find and center on
     * @param diagramId the diagram containing the entity.
     * If not specified, the first entity occurrence in any diagram will be used.
     * @param zoom the level of zoom to apply.
     * If not specified, zoom level won't be changed.
     */
    centerOnEntity(iri: string, diagramId?: number, zoom?: number): void;
    /**
     * Center viewport on a single entity occurrence and selects it given its IRI
     * @param iri the iri of the entity to find and center on
     * @param diagramId the diagram containing the entity.
     * If not specified, the first entity occurrence in any diagram will be used.
     * @param zoom the level of zoom to apply.
     * If not specified, zoom level won't be changed.
     */
    selectEntity(iri: string, diagramId?: number, zoom?: number): void;
    /**
     * Change the displayed entity's names.
     * @param newEntityNametype the entity name type to set
     */
    setEntityNameType(newEntityNametype: RDFGraphConfigEntityNameTypeEnum): void;
    /**
     * Change the language used for the labels and comments
     * @remarks The language must be supported by the ontology or the first available
     * language for a given label/comment wil be used as fallback
     * @param newLanguage the language to set {@link !config.Language}
     */
    setLanguage(newLanguage: string): void;
    /** The current selected language */
    get language(): Language;
    /** The current selected entity name type (label, full iri or prefixed iri) */
    get entityNameType(): RDFGraphConfigEntityNameTypeEnum;
    /**
     * Apply a given theme
     * @param themeId the theme's ID
     */
    setTheme(themeId: string): void;
    /**
     * @ignore
     * // TODO: make this method update settings widget before publishing in docs
     * Add a new theme in the list of available themes
     * @param newTheme the new theme
     * @experimental
     */
    addTheme(newTheme: GrapholscapeTheme): void;
    /**
     * @ignore
     * // TODO: make this method update settings widget before publishing in docs
     * Remove a theme in the list of available themes
     * @param newTheme the new theme
     * @experimental
     */
    removeTheme(newTheme: GrapholscapeTheme): void;
    /** The current theme used by Grapholscape */
    get theme(): GrapholscapeTheme;
    /** The available themes for this Grapholscape instance */
    get themeList(): GrapholscapeTheme[];
    /**
     * Register a callback for a given event.
     * @remarks
     * Check {@link !model.LifecycleEvent} and {@link !model.IonEvent} for the
     * full list of events/callbacks types
     * @param event The event for which register a callback.
     * @param callback Function to call when the specified event occurs
     *
     * @example reacting to a node selection
     * ```js
     *  import { LifecycleEvent } from 'grapholscape'
     *
     *  // ...init grapholscape
     *
     * grapholscape.on(LifecycleEvent.NodeSelection, (selectedNode) => {
     *  // here you can do whatever you want with selectedNode, like printing its shape
     *  console.log(selectedNode.shape)
     * })
     * ```
     */
    on: IonEvent$1;
    /**
     * The container in which Grapholscape places the UI components.
     * You can use this container to add new widgets or dialogs if you want to.
     */
    get uiContainer(): Element | null;
    /**
     * The container in which the bottom-right buttons are placed.
     * You can use this container to add your own Buttons if you want to.
     */
    get buttonsTray(): Element | null | undefined;
    /**
     * @ignore
     * @privateRemarks // TODO: Be sure this method reflects on UI before publishing it in to the docs
     * Apply a new custom configuration
     * @param newConfig the config object to apply
     * @experimental
     */
    setConfig(newConfig: GrapholscapeConfig): void;
    /**
     * Export current diagram and download it as a PNG image.
     * @param fileName custom file name. Defaults to {@link exportFileName}
     */
    exportToPng(fileName?: string): void;
    /**
     * Export current diagram and download it as an SVG.
     * @param fileName custom file name. Defaults to {@link exportFileName}
     */
    exportToSvg(fileName?: string): void;
    exportToRdfGraph(): RDFGraph;
    /**
     * Filename for exports.
     * String in the form: "[ontology name]-[diagram name]-v[ontology version]"
     */
    get exportFileName(): string;
    /** @internal */
    incremental?: IncrementalController;
}

declare enum DesignerEvent {
    EntityAddition = "entityAddition",
    EntityRemoval = "entityRemoval",
    DiagramAddition = "diagramAddition",
    DiagramRemoval = "diagramRemoval",
    AnnotationAddition = "annotationAddition",
    AnnotationEdit = "annotationEdit",
    AnnotationRemoval = "annotationRemoval",
    SaveDraft = "saveDraft",
    SaveVersion = "saveDraft"
}
interface IonDesignerEvent extends IonEvent$1 {
    (event: DesignerEvent.EntityAddition, callback: (entity: GrapholEntity, diagramId: number) => void): void;
    (event: DesignerEvent.EntityRemoval, callback: (entity: GrapholEntity, diagramId: number) => void): void;
    (event: DesignerEvent.DiagramAddition, callback: (diagram: Diagram) => void): void;
    (event: DesignerEvent.DiagramRemoval, callback: (diagram: Diagram) => void): void;
    (event: DesignerEvent.AnnotationAddition, callback: (entity: GrapholEntity | Ontology, annotation: Annotation) => void): void;
    (event: DesignerEvent.AnnotationEdit, callback: (entity: GrapholEntity | Ontology, annotation: Annotation) => void): void;
    (event: DesignerEvent.AnnotationRemoval, callback: (entity: GrapholEntity | Ontology, annotation: Annotation) => void): void;
    (event: DesignerEvent.AnnotationRemoval, callback: (entity: GrapholEntity | Ontology, annotation: Annotation) => void): void;
    (event: DesignerEvent.SaveDraft, callback: (rdfGraph: RDFGraph, annotation: Annotation) => void): void;
    (event: DesignerEvent.SaveVersion, callback: (rdfGraph: RDFGraph, annotation: Annotation) => void): void;
}
interface IDesignerTriggers extends IEventTriggers {
    (event: DesignerEvent.EntityAddition, entity: GrapholEntity, diagramId: number): void;
    (event: DesignerEvent.EntityRemoval, entity: GrapholEntity, diagramId: number): void;
    (event: DesignerEvent.DiagramAddition, diagram: Diagram): void;
    (event: DesignerEvent.DiagramRemoval, diagram: Diagram): void;
    (event: DesignerEvent.AnnotationAddition, entity: GrapholEntity | Ontology, annotation: Annotation): void;
    (event: DesignerEvent.AnnotationEdit, entity: GrapholEntity | Ontology, annotation: Annotation): void;
    (event: DesignerEvent.AnnotationRemoval, entity: GrapholEntity | Ontology, annotation: Annotation): void;
    (event: DesignerEvent.SaveDraft, rdfGraph: RDFGraph): void;
    (event: DesignerEvent.SaveVersion, rdfGraph: RDFGraph): void;
}
declare class DesignerLifeCycle extends Lifecycle {
    private entityAddition;
    private entityRemoval;
    private diagramAddition;
    private diagramRemoval;
    private annotationAddition;
    private annotationEdit;
    private annotationRemoval;
    trigger: IDesignerTriggers;
    on: IonDesignerEvent;
}

declare class GrapholscapeDesigner extends Grapholscape {
    readonly lifecycle: DesignerLifeCycle;
    constructor(ontology: Ontology, container: HTMLElement, config: GrapholscapeConfig | undefined);
}

type OntologyDesignerConfig = {
    themes?: ThemeConfig[];
    selectedTheme?: string;
    language?: Language | string;
    entityNameType?: RDFGraphConfigEntityNameTypeEnum;
    widgets?: WidgetsConfig;
};

declare function setGraphEventHandlers(diagram: Diagram, lifecycle: Lifecycle, ontology: Ontology): void;

declare function toPNG(fileName: string, cy?: Core, backgroundColor?: string): void;
declare function toSVG(fileName: string, cy?: Core, backgroundColor?: string): void;

declare const diagrams: lit_html.TemplateResult<2>;
declare const triangle_up: lit_html.TemplateResult<2>;
declare const triangle_down: lit_html.TemplateResult<2>;
declare const arrow_right: lit_html.TemplateResult<2>;
declare const arrowDown: lit_html.TemplateResult<2>;
declare const explore: lit_html.TemplateResult<2>;
declare const info_outline: lit_html.TemplateResult<2>;
declare const enterFullscreen: lit_html.TemplateResult<2>;
declare const exitFullscreen: lit_html.TemplateResult<2>;
declare const centerDiagram: lit_html.TemplateResult<2>;
declare const filter: lit_html.TemplateResult<2>;
declare const bubbles: lit_html.TemplateResult<2>;
declare const lite: lit_html.TemplateResult<2>;
declare const settings_icon: lit_html.TemplateResult<2>;
declare const infoFilled: lit_html.TemplateResult<2>;
declare const plus: lit_html.TemplateResult<2>;
declare const minus: lit_html.TemplateResult<2>;
declare const save: lit_html.TemplateResult<2>;
declare const close: lit_html.TemplateResult<2>;
declare const blankSlateDiagrams: lit_html.TemplateResult<2>;
declare const check: lit_html.TemplateResult<2>;
declare const searchOff: lit_html.TemplateResult<2>;
/**
 * Author: Simran
 * Source: https://github.com/Templarian/MaterialDesign/blob/master/svg/checkbox-multiple-blank-circle.svg
 */
declare const move_bubbles: lit_html.TemplateResult<2>;
/**
 * Author: Simran
 * Source: https://github.com/Templarian/MaterialDesign/blob/master/svg/owl.svg
 */
declare const owl_icon: lit_html.TemplateResult<2>;
declare const graphol_icon: lit_html.TemplateResult<2>;
declare const tune: lit_html.TemplateResult<2>;
declare const settings_play: lit_html.TemplateResult<2>;
declare const filterOff: lit_html.TemplateResult<2>;
declare const incremental: lit_html.TemplateResult<2>;
declare const refresh: lit_html.TemplateResult<2>;
declare const instancesIcon: lit_html.TemplateResult<2>;
declare const superHierarchies: lit_html.TemplateResult<2>;
declare const subHierarchies: lit_html.TemplateResult<2>;
declare const rubbishBin: lit_html.TemplateResult<2>;
declare const mastroEndpointIcon: lit_html.TemplateResult<2>;
declare const stopCircle: lit_html.TemplateResult<2>;
declare const equivalentClasses: lit_html.TemplateResult<2>;
declare const search$1: lit_html.TemplateResult<2>;
declare const insertInGraph: lit_html.TemplateResult<2>;
declare const cross: lit_html.TemplateResult<2>;
declare const counter: lit_html.TemplateResult<2>;
declare const labelIcon: lit_html.TemplateResult<2>;
declare const commentIcon: lit_html.TemplateResult<2>;
declare const authorIcon: lit_html.TemplateResult<2>;
declare const addDiagramIcon: lit_html.TemplateResult<2>;
declare const addClassIcon: lit_html.TemplateResult<2>;
declare const addDataPropertyIcon: lit_html.TemplateResult<2>;
declare const addIndividualIcon: lit_html.TemplateResult<2>;
declare const addObjectPropertyIcon: lit_html.TemplateResult<2>;
declare const addISAIcon: lit_html.TemplateResult<2>;
declare const addInstanceIcon: lit_html.TemplateResult<2>;
declare const addParentClassIcon: lit_html.TemplateResult<2>;
declare const addChildClassIcon: lit_html.TemplateResult<2>;
declare const addSubhierarchyIcon: lit_html.TemplateResult<2>;
declare const addInputIcon: lit_html.TemplateResult<2>;
declare const renameIcon: lit_html.TemplateResult<2>;
declare const editIcon: lit_html.TemplateResult<2>;
declare const sankey: lit_html.TemplateResult<2>;
declare const pathIcon: lit_html.TemplateResult<2>;
declare const tools: lit_html.TemplateResult<2>;
declare const undo: lit_html.TemplateResult<2>;
declare const redo: lit_html.TemplateResult<2>;
declare const addPack: lit_html.TemplateResult<2>;
declare const protocol: lit_html.TemplateResult<2>;
declare const notes: lit_html.TemplateResult<2>;
declare const colorPalette: lit_html.TemplateResult<2>;
declare const entityIcons: {
    [x in TypesEnum.CLASS | TypesEnum.OBJECT_PROPERTY | TypesEnum.DATA_PROPERTY | TypesEnum.INDIVIDUAL | TypesEnum.CLASS_INSTANCE]: SVGTemplateResult;
};
declare const annotationIcons: {
    [x: string]: SVGTemplateResult | undefined;
};

declare const _default$a: lit_html.TemplateResult<2>;

declare const _default$9: lit_html.TemplateResult<2>;

declare const _default$8: lit_html.TemplateResult<2>;

declare const _default$7: lit_html.TemplateResult<2>;

declare const _default$6: lit_html.TemplateResult<2>;

declare const _default$5: lit_html.TemplateResult<1>;

declare const index_d$2_addChildClassIcon: typeof addChildClassIcon;
declare const index_d$2_addClassIcon: typeof addClassIcon;
declare const index_d$2_addDataPropertyIcon: typeof addDataPropertyIcon;
declare const index_d$2_addDiagramIcon: typeof addDiagramIcon;
declare const index_d$2_addISAIcon: typeof addISAIcon;
declare const index_d$2_addIndividualIcon: typeof addIndividualIcon;
declare const index_d$2_addInputIcon: typeof addInputIcon;
declare const index_d$2_addInstanceIcon: typeof addInstanceIcon;
declare const index_d$2_addObjectPropertyIcon: typeof addObjectPropertyIcon;
declare const index_d$2_addPack: typeof addPack;
declare const index_d$2_addParentClassIcon: typeof addParentClassIcon;
declare const index_d$2_addSubhierarchyIcon: typeof addSubhierarchyIcon;
declare const index_d$2_annotationIcons: typeof annotationIcons;
declare const index_d$2_arrowDown: typeof arrowDown;
declare const index_d$2_arrow_right: typeof arrow_right;
declare const index_d$2_authorIcon: typeof authorIcon;
declare const index_d$2_blankSlateDiagrams: typeof blankSlateDiagrams;
declare const index_d$2_bubbles: typeof bubbles;
declare const index_d$2_centerDiagram: typeof centerDiagram;
declare const index_d$2_check: typeof check;
declare const index_d$2_close: typeof close;
declare const index_d$2_colorPalette: typeof colorPalette;
declare const index_d$2_commentIcon: typeof commentIcon;
declare const index_d$2_counter: typeof counter;
declare const index_d$2_cross: typeof cross;
declare const index_d$2_diagrams: typeof diagrams;
declare const index_d$2_editIcon: typeof editIcon;
declare const index_d$2_enterFullscreen: typeof enterFullscreen;
declare const index_d$2_entityIcons: typeof entityIcons;
declare const index_d$2_equivalentClasses: typeof equivalentClasses;
declare const index_d$2_exitFullscreen: typeof exitFullscreen;
declare const index_d$2_explore: typeof explore;
declare const index_d$2_filter: typeof filter;
declare const index_d$2_filterOff: typeof filterOff;
declare const index_d$2_graphol_icon: typeof graphol_icon;
declare const index_d$2_incremental: typeof incremental;
declare const index_d$2_infoFilled: typeof infoFilled;
declare const index_d$2_info_outline: typeof info_outline;
declare const index_d$2_insertInGraph: typeof insertInGraph;
declare const index_d$2_instancesIcon: typeof instancesIcon;
declare const index_d$2_labelIcon: typeof labelIcon;
declare const index_d$2_lite: typeof lite;
declare const index_d$2_mastroEndpointIcon: typeof mastroEndpointIcon;
declare const index_d$2_minus: typeof minus;
declare const index_d$2_move_bubbles: typeof move_bubbles;
declare const index_d$2_notes: typeof notes;
declare const index_d$2_owl_icon: typeof owl_icon;
declare const index_d$2_pathIcon: typeof pathIcon;
declare const index_d$2_plus: typeof plus;
declare const index_d$2_protocol: typeof protocol;
declare const index_d$2_redo: typeof redo;
declare const index_d$2_refresh: typeof refresh;
declare const index_d$2_renameIcon: typeof renameIcon;
declare const index_d$2_rubbishBin: typeof rubbishBin;
declare const index_d$2_sankey: typeof sankey;
declare const index_d$2_save: typeof save;
declare const index_d$2_searchOff: typeof searchOff;
declare const index_d$2_settings_icon: typeof settings_icon;
declare const index_d$2_settings_play: typeof settings_play;
declare const index_d$2_stopCircle: typeof stopCircle;
declare const index_d$2_subHierarchies: typeof subHierarchies;
declare const index_d$2_superHierarchies: typeof superHierarchies;
declare const index_d$2_tools: typeof tools;
declare const index_d$2_triangle_down: typeof triangle_down;
declare const index_d$2_triangle_up: typeof triangle_up;
declare const index_d$2_tune: typeof tune;
declare const index_d$2_undo: typeof undo;
declare namespace index_d$2 {
  export {
    index_d$2_addChildClassIcon as addChildClassIcon,
    index_d$2_addClassIcon as addClassIcon,
    index_d$2_addDataPropertyIcon as addDataPropertyIcon,
    index_d$2_addDiagramIcon as addDiagramIcon,
    index_d$2_addISAIcon as addISAIcon,
    index_d$2_addIndividualIcon as addIndividualIcon,
    index_d$2_addInputIcon as addInputIcon,
    index_d$2_addInstanceIcon as addInstanceIcon,
    index_d$2_addObjectPropertyIcon as addObjectPropertyIcon,
    index_d$2_addPack as addPack,
    index_d$2_addParentClassIcon as addParentClassIcon,
    index_d$2_addSubhierarchyIcon as addSubhierarchyIcon,
    index_d$2_annotationIcons as annotationIcons,
    index_d$2_arrowDown as arrowDown,
    index_d$2_arrow_right as arrow_right,
    index_d$2_authorIcon as authorIcon,
    index_d$2_blankSlateDiagrams as blankSlateDiagrams,
    index_d$2_bubbles as bubbles,
    index_d$2_centerDiagram as centerDiagram,
    index_d$2_check as check,
    _default$a as classIcon,
    _default$6 as classInstanceIcon,
    index_d$2_close as close,
    index_d$2_colorPalette as colorPalette,
    index_d$2_commentIcon as commentIcon,
    index_d$2_counter as counter,
    index_d$2_cross as cross,
    _default$8 as dataPropertyIcon,
    index_d$2_diagrams as diagrams,
    index_d$2_editIcon as editIcon,
    index_d$2_enterFullscreen as enterFullscreen,
    index_d$2_entityIcons as entityIcons,
    index_d$2_equivalentClasses as equivalentClasses,
    index_d$2_exitFullscreen as exitFullscreen,
    index_d$2_explore as explore,
    index_d$2_filter as filter,
    index_d$2_filterOff as filterOff,
    index_d$2_graphol_icon as graphol_icon,
    _default$5 as grapholscapeLogo,
    index_d$2_incremental as incremental,
    _default$7 as individualIcon,
    index_d$2_infoFilled as infoFilled,
    index_d$2_info_outline as info_outline,
    index_d$2_insertInGraph as insertInGraph,
    index_d$2_instancesIcon as instancesIcon,
    index_d$2_labelIcon as labelIcon,
    index_d$2_lite as lite,
    index_d$2_mastroEndpointIcon as mastroEndpointIcon,
    index_d$2_minus as minus,
    index_d$2_move_bubbles as move_bubbles,
    index_d$2_notes as notes,
    _default$9 as objectPropertyIcon,
    index_d$2_owl_icon as owl_icon,
    index_d$2_pathIcon as pathIcon,
    index_d$2_plus as plus,
    index_d$2_protocol as protocol,
    index_d$2_redo as redo,
    index_d$2_refresh as refresh,
    index_d$2_renameIcon as renameIcon,
    index_d$2_rubbishBin as rubbishBin,
    index_d$2_sankey as sankey,
    index_d$2_save as save,
    search$1 as search,
    index_d$2_searchOff as searchOff,
    index_d$2_settings_icon as settings_icon,
    index_d$2_settings_play as settings_play,
    index_d$2_stopCircle as stopCircle,
    index_d$2_subHierarchies as subHierarchies,
    index_d$2_superHierarchies as superHierarchies,
    index_d$2_tools as tools,
    index_d$2_triangle_down as triangle_down,
    index_d$2_triangle_up as triangle_up,
    index_d$2_tune as tune,
    index_d$2_undo as undo,
  };
}

declare enum SizeEnum {
    S = "s",
    M = "m",
    L = "l"
}
declare class GscapeButton extends LitElement {
    disabled: boolean;
    asSwitch: boolean;
    active: boolean;
    label: string;
    size: SizeEnum;
    type: string;
    fullWidth: string;
    private toggled;
    static properties: {
        active: {
            type: BooleanConstructor;
            reflect: boolean;
        };
        label: {
            type: StringConstructor;
            reflect: boolean;
        };
        title: {
            type: StringConstructor;
            reflect: boolean;
        };
        disabled: {
            type: BooleanConstructor;
            reflect: boolean;
        };
        asSwitch: {
            type: BooleanConstructor;
            attribute: string;
            reflect: boolean;
        };
        size: {
            type: StringConstructor;
            reflect: boolean;
        };
        type: {
            type: StringConstructor;
            reflect: boolean;
        };
        fullWidth: {
            type: StringConstructor;
            attribute: string;
            reflect: boolean;
        };
        toggled: {
            type: BooleanConstructor;
            state: boolean;
        };
    };
    static styles: lit.CSSResult[];
    constructor();
    render(): lit_html.TemplateResult<1>;
    private clickHandler;
    private get altIcon();
}

type Constructor$3<T = {}> = new (...args: any[]) => T;
declare class IBaseMixin {
    hide(): void;
    show(): void;
    showInPosition(position?: {
        x: number;
        y: number;
    }): void;
    enable(): void;
    disable(): void;
    onStateChange(): void;
    isVisible: boolean;
    enabled: boolean;
}
declare const BaseMixin: <T extends Constructor$3<LitElement>>(superClass: T) => Constructor$3<IBaseMixin> & T;

type Constructor$2<T = {}> = new (...args: any[]) => T;
declare class IDropPanelMixin {
    protected isDefaultClosed: boolean;
    togglePanel(): void;
    openPanel(): void;
    closePanel(): void;
    protected get panel(): HTMLElement | undefined | null;
    onTogglePanel(): void;
    isPanelClosed(): boolean;
}
declare const DropPanelMixin: <T extends Constructor$2<LitElement>>(superClass: T) => Constructor$2<IDropPanelMixin> & T;
declare function hasDropPanel(element: any): element is IDropPanelMixin;

type Constructor$1<T = {}> = new (...args: any[]) => T;
declare class IModalMixin {
    hide(): void;
    show(): void;
    protected modalBackground: HTMLDivElement;
}
declare const ModalMixin: <T extends Constructor$1<LitElement & IBaseMixin>>(superClass: T) => Constructor$1<IModalMixin> & T;

type Constructor<T = {}> = new (...args: any[]) => T;
declare class IContextualWidgetMixin {
    hide(): void;
    /**
     * Attach cxt widget and show it
     * @param element the target html elment
     */
    attachTo(element: HTMLElement): void;
    /**
     * Attach cxt widget and do not show it, if it was visible it stays visible
     * @param element the target html element
     */
    attachToSilently(element: HTMLElement): void;
    cxtWidgetProps: Partial<Props>;
    tippyWidget: Instance<Props>;
}
declare const ContextualWidgetMixin: <T extends Constructor<LitElement>>(superClass: T) => Constructor<IContextualWidgetMixin> & T;

declare const NodeButton_base: (new (...args: any[]) => IContextualWidgetMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class NodeButton extends NodeButton_base {
    content: TemplateResult | SVGTemplateResult | string | number;
    contentType: 'icon' | 'template';
    node?: NodeSingular;
    highlighted?: boolean;
    cxtWidgetProps: Partial<Props>;
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    constructor(content: TemplateResult | SVGTemplateResult | string | number, contentType?: 'icon' | 'template');
    render(): TemplateResult<1>;
}

declare const _default$4: lit.CSSResult;

/**
 * A command for the context menu
 */
interface Command {
    /** the string to show */
    content: string;
    /** optional icon */
    icon?: SVGTemplateResult;
    /** callback to execute on selection */
    select: () => void;
}
declare const GscapeContextMenu_base: (new (...args: any[]) => IContextualWidgetMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeContextMenu extends GscapeContextMenu_base {
    commands: Command[];
    customElements: (LitElement | HTMLElement | TemplateResult)[];
    showFirst: 'commands' | 'elements';
    onCommandRun: () => void;
    static properties: PropertyDeclarations;
    static styles: CSSResultArray;
    render(): TemplateResult<1>;
    attachTo(element: HTMLElement, commands?: Command[], elements?: (LitElement | HTMLElement | TemplateResult)[]): void;
    attachToPosition(position: {
        x: number;
        y: number;
    }, container: Element, commands?: Command[], elements?: (LitElement | HTMLElement | TemplateResult)[]): void;
    private handleCommandClick;
    private get commandsTemplate();
    private get customElementsTemplate();
}

declare class GscapeActionListItem extends LitElement {
    label: string;
    selected: boolean;
    private expanded;
    subtle: boolean;
    disabled: boolean;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    constructor();
    render(): lit_html.TemplateResult<1>;
    private clickHandler;
    private get hiddenContent();
}

declare const _default$3: lit.CSSResult;

declare class GscapeEntityListItem extends LitElement {
    private _types;
    private _color?;
    displayedName: string;
    iri: string;
    actionable: boolean;
    asAccordion: boolean;
    disabled: boolean;
    private isAccordionOpen;
    static properties: PropertyDeclarations;
    static styles: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private iconNameSlotTemplate;
    private handleDetailsClick;
    openAccordion(): void;
    closeAccordion(): void;
    set types(newTypes: Set<string> | undefined);
    get types(): Set<string> | undefined;
    set color(newColor: string | undefined);
    get color(): string | undefined;
}

declare const textSpinner: () => lit_html.TemplateResult<1>;
declare const textSpinnerStyle: lit.CSSResult;

declare function getContentSpinner(): lit_html.TemplateResult<1>;
declare const contentSpinnerStyle: lit.CSSResult;
declare class ContentSpinner extends LitElement {
    color: string;
    static styles: lit.CSSResult[];
    static properties: PropertyDeclarations;
    render: typeof getContentSpinner;
    setColor(newColor: string): void;
}

declare class GscapeTextSearch extends LitElement {
    private _onSearchCallback;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    onSearch(callback: (e: KeyboardEvent) => void): void;
}

type ViewObjectPropertyUnfolding = EntityViewDataUnfolding & {
    connectedClasses: EntityViewDataUnfolding[];
    direct: boolean;
};
type EntityViewDataUnfolding = {
    entityViewData: EntityViewData;
    loading?: boolean;
    hasUnfolding?: boolean;
};
type EntityViewData = {
    displayedName: string;
    value: {
        iri: Iri;
        types: Set<TypesEnum>;
    } & AnnotatedElement;
    viewOccurrences?: Map<DiagramViewData, OccurrenceIdViewData[]>;
};
interface IEntityFilters {
    [TypesEnum.CLASS]?: number;
    [TypesEnum.DATA_PROPERTY]?: number;
    [TypesEnum.OBJECT_PROPERTY]?: number;
    [TypesEnum.INDIVIDUAL]?: number;
    areAllFiltersDisabled: boolean;
}

declare const GscapeEntitySearch_base: (new (...args: any[]) => IDropPanelMixin) & typeof LitElement;
declare class GscapeEntitySearch extends GscapeEntitySearch_base implements IEntityFilters {
    areAllFiltersDisabled: boolean;
    [TypesEnum.CLASS]?: number;
    [TypesEnum.DATA_PROPERTY]?: number;
    [TypesEnum.OBJECT_PROPERTY]?: number;
    [TypesEnum.INDIVIDUAL]?: number;
    [TypesEnum.CLASS_INSTANCE]?: number;
    private isSearchTextEmpty;
    private searchTimeout;
    static properties: PropertyDeclarations;
    static styles?: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private handleKeyPress;
    private handleSearch;
    clearSearch(): void;
    private get atLeastTwoFilters();
    private get input();
}
type SearchEvent = CustomEvent<{
    searchText: string;
}>;

declare const GscapeEntityTypeFilters_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeEntityTypeFilters extends GscapeEntityTypeFilters_base implements IEntityFilters {
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    _class?: number;
    _dataproperty?: number;
    _objectproperty?: number;
    _individual?: number;
    _classInstance?: number;
    render(): lit_html.TemplateResult<1>;
    private getChipTemplate;
    private _handleFilterStateChange;
    get areAllFiltersDisabled(): boolean;
    set [TypesEnum.CLASS](v: number | undefined);
    get [TypesEnum.CLASS](): number | undefined;
    set [TypesEnum.DATA_PROPERTY](v: number | undefined);
    get [TypesEnum.DATA_PROPERTY](): number | undefined;
    set [TypesEnum.OBJECT_PROPERTY](v: number | undefined);
    get [TypesEnum.OBJECT_PROPERTY](): number | undefined;
    set [TypesEnum.INDIVIDUAL](v: number | undefined);
    get [TypesEnum.INDIVIDUAL](): number | undefined;
    set [TypesEnum.CLASS_INSTANCE](v: number | undefined);
    get [TypesEnum.CLASS_INSTANCE](): number | undefined;
}
type EntityFilterEvent = CustomEvent<IEntityFilters>;

declare enum ToggleLabelPosition {
    LEFT = "left",
    RIGHT = "right"
}
declare class GscapeToggle extends LitElement {
    key: string;
    checked: boolean;
    disabled: boolean;
    label: string;
    labelPosition: ToggleLabelPosition;
    static ToggleLabelPosition: typeof ToggleLabelPosition;
    static get properties(): {
        disabled: {
            type: BooleanConstructor;
            reflect: boolean;
        };
        label: {
            type: StringConstructor;
            reflect: boolean;
        };
        labelPosition: {
            type: StringConstructor;
            reflect: boolean;
            attribute: string;
        };
        key: {
            type: StringConstructor;
            reflect: boolean;
        };
        checked: {
            type: BooleanConstructor;
            reflect: boolean;
        };
    };
    static styles: lit.CSSResult[];
    render(): lit_html.TemplateResult<1>;
}

declare const GscapeConfirmDialog_base: (new (...args: any[]) => IModalMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeConfirmDialog extends GscapeConfirmDialog_base {
    message?: string | undefined;
    dialogTitle: string;
    private _onConfirm?;
    private _onCancel?;
    constructor(message?: string | undefined, dialogTitle?: string);
    static properties: PropertyDeclarations;
    static styles: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private handleConfirm;
    private handleCancel;
    onConfirm(callback: () => void): GscapeConfirmDialog;
    onCancel(callback: () => void): GscapeConfirmDialog;
}
declare function showMessage(message: string, title: string, container: any): GscapeConfirmDialog;

type SelectOption = {
    id: string;
    text: string;
    trailingIcon?: SVGTemplateResult;
    leadingIcon?: SVGTemplateResult;
    disabled?: boolean;
};
declare const GscapeSelect_base: (new (...args: any[]) => IDropPanelMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeSelect extends GscapeSelect_base {
    private readonly PLACEHOLDER_ID;
    defaultIcon: SVGTemplateResult;
    selectedOptionsId: Set<string>;
    defaultOptionId?: string;
    options: SelectOption[];
    size: SizeEnum;
    clearable: boolean;
    multipleSelection: boolean;
    private _placeholder;
    onSelection: (optionId: string) => void;
    static properties: PropertyDeclarations;
    static styles: lit.CSSResult[];
    render(): lit_html.TemplateResult<1>;
    private handleSelection;
    private getButton;
    clear(): void;
    private isSelectionEmpty;
    private isIdSelected;
    get selectedOptions(): SelectOption[];
    get defaultOption(): SelectOption;
    get placeholder(): SelectOption;
    set placeholder(placeHolder: SelectOption);
}

interface IEntitySelector {
    onClassSelection(callback: (iri: string) => void): void;
}
declare const GscapeEntitySelector_base: (new (...args: any[]) => IDropPanelMixin) & (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeEntitySelector extends GscapeEntitySelector_base {
    title: string;
    private fullEntityList;
    private _entityList;
    private onClassSelectionCallback;
    private isSearchTextEmpty;
    private loading;
    static get properties(): {
        entityList: {
            type: ObjectConstructor;
            attribute: boolean;
        };
        isSearchTextEmpty: {
            type: BooleanConstructor;
            state: boolean;
        };
        loading: {
            type: BooleanConstructor;
            state: boolean;
        };
        onClassSelection: {
            type: ObjectConstructor;
        };
    };
    static styles: lit.CSSResult[];
    constructor();
    render(): lit_html.TemplateResult<1>;
    blur(): void;
    focusInputSearch(): Promise<void>;
    private handleEntitySelection;
    private handleKeyPressOnEntry;
    private handleSearch;
    clearSearch(): void;
    get onClassSelection(): (iri: string) => void;
    set onClassSelection(callback: (iri: string) => void);
    set entityList(newEntityList: EntityViewData[]);
    get entityList(): EntityViewData[];
    private get input();
}

type UiOption = {
    name: string;
    id: string;
    icon: SVGTemplateResult;
    description?: string;
};

declare const GscapeFullPageSelector_base: (new (...args: any[]) => IBaseMixin) & typeof LitElement;
declare class GscapeFullPageSelector extends GscapeFullPageSelector_base {
    options: (UiOption | undefined)[];
    private _title;
    onOptionSelection: (optionId: string) => void;
    static properties: PropertyDeclarations;
    static styles: CSSResultGroup;
    render(): lit_html.TemplateResult<1>;
    private handleRendererSelection;
}

declare function initInitialRendererSelector(grapholscape: Grapholscape): void;

/**
 * Initialize the UI
 */
declare function export_default$2(grapholscape: Grapholscape): void;

declare const _default$2: lit.CSSResult;

declare const BOTTOM_RIGHT_WIDGET: lit.CSSResult;
declare const _default$1: lit.CSSResult;

declare const _default: lit_html.TemplateResult<1>;

type DiagramViewData = {
    id: number;
    name: string;
};
type OccurrenceIdViewData = {
    originalId: string;
    realId: string;
};
declare function getEntityOccurrencesTemplate(occurrences: Map<DiagramViewData, OccurrenceIdViewData[]>, onNodeNavigation: (elementId: string, diagramId: number) => void): lit_html.TemplateResult<1>;

declare function createEntitiesList(grapholscape: Grapholscape, entityFilters?: IEntityFilters): EntityViewData[];
declare function search(searchValue: string, entities: EntityViewData[]): Promise<EntityViewData[]>;

declare function export_default$1(slotName: string, icon: SVGTemplateResult): HTMLSpanElement;

type TabProps = {
    id: number;
    icon?: SVGTemplateResult;
    label: string;
};

/** @module UI */

declare const index_d$1_BaseMixin: typeof BaseMixin;
type index_d$1_Command = Command;
type index_d$1_ContentSpinner = ContentSpinner;
declare const index_d$1_ContentSpinner: typeof ContentSpinner;
declare const index_d$1_ContextualWidgetMixin: typeof ContextualWidgetMixin;
type index_d$1_DiagramViewData = DiagramViewData;
declare const index_d$1_DropPanelMixin: typeof DropPanelMixin;
type index_d$1_EntityFilterEvent = EntityFilterEvent;
type index_d$1_EntityViewData = EntityViewData;
type index_d$1_EntityViewDataUnfolding = EntityViewDataUnfolding;
type index_d$1_GscapeActionListItem = GscapeActionListItem;
declare const index_d$1_GscapeActionListItem: typeof GscapeActionListItem;
type index_d$1_GscapeButton = GscapeButton;
declare const index_d$1_GscapeButton: typeof GscapeButton;
type index_d$1_GscapeConfirmDialog = GscapeConfirmDialog;
declare const index_d$1_GscapeConfirmDialog: typeof GscapeConfirmDialog;
type index_d$1_GscapeContextMenu = GscapeContextMenu;
declare const index_d$1_GscapeContextMenu: typeof GscapeContextMenu;
type index_d$1_GscapeEntityListItem = GscapeEntityListItem;
declare const index_d$1_GscapeEntityListItem: typeof GscapeEntityListItem;
type index_d$1_GscapeEntitySearch = GscapeEntitySearch;
declare const index_d$1_GscapeEntitySearch: typeof GscapeEntitySearch;
type index_d$1_GscapeEntitySelector = GscapeEntitySelector;
declare const index_d$1_GscapeEntitySelector: typeof GscapeEntitySelector;
type index_d$1_GscapeEntityTypeFilters = GscapeEntityTypeFilters;
declare const index_d$1_GscapeEntityTypeFilters: typeof GscapeEntityTypeFilters;
type index_d$1_GscapeFullPageSelector = GscapeFullPageSelector;
declare const index_d$1_GscapeFullPageSelector: typeof GscapeFullPageSelector;
type index_d$1_GscapeSelect = GscapeSelect;
declare const index_d$1_GscapeSelect: typeof GscapeSelect;
type index_d$1_GscapeTextSearch = GscapeTextSearch;
declare const index_d$1_GscapeTextSearch: typeof GscapeTextSearch;
type index_d$1_GscapeToggle = GscapeToggle;
declare const index_d$1_GscapeToggle: typeof GscapeToggle;
type index_d$1_IBaseMixin = IBaseMixin;
declare const index_d$1_IBaseMixin: typeof IBaseMixin;
type index_d$1_IContextualWidgetMixin = IContextualWidgetMixin;
declare const index_d$1_IContextualWidgetMixin: typeof IContextualWidgetMixin;
type index_d$1_IDropPanelMixin = IDropPanelMixin;
declare const index_d$1_IDropPanelMixin: typeof IDropPanelMixin;
type index_d$1_IEntityFilters = IEntityFilters;
type index_d$1_IEntitySelector = IEntitySelector;
type index_d$1_IModalMixin = IModalMixin;
declare const index_d$1_IModalMixin: typeof IModalMixin;
declare const index_d$1_ModalMixin: typeof ModalMixin;
type index_d$1_NodeButton = NodeButton;
declare const index_d$1_NodeButton: typeof NodeButton;
type index_d$1_OccurrenceIdViewData = OccurrenceIdViewData;
type index_d$1_SearchEvent = SearchEvent;
type index_d$1_SelectOption = SelectOption;
type index_d$1_SizeEnum = SizeEnum;
declare const index_d$1_SizeEnum: typeof SizeEnum;
type index_d$1_TabProps = TabProps;
type index_d$1_ToggleLabelPosition = ToggleLabelPosition;
declare const index_d$1_ToggleLabelPosition: typeof ToggleLabelPosition;
type index_d$1_UiOption = UiOption;
type index_d$1_ViewObjectPropertyUnfolding = ViewObjectPropertyUnfolding;
type index_d$1_WidgetEnum = WidgetEnum;
declare const index_d$1_WidgetEnum: typeof WidgetEnum;
declare const index_d$1_contentSpinnerStyle: typeof contentSpinnerStyle;
declare const index_d$1_createEntitiesList: typeof createEntitiesList;
declare const index_d$1_getContentSpinner: typeof getContentSpinner;
declare const index_d$1_getEntityOccurrencesTemplate: typeof getEntityOccurrencesTemplate;
declare const index_d$1_hasDropPanel: typeof hasDropPanel;
declare const index_d$1_initInitialRendererSelector: typeof initInitialRendererSelector;
declare const index_d$1_search: typeof search;
declare const index_d$1_showMessage: typeof showMessage;
declare const index_d$1_textSpinner: typeof textSpinner;
declare const index_d$1_textSpinnerStyle: typeof textSpinnerStyle;
declare namespace index_d$1 {
  export {
    BOTTOM_RIGHT_WIDGET as BOTTOM_RIGHT_WIDGET_CLASS,
    index_d$1_BaseMixin as BaseMixin,
    index_d$1_Command as Command,
    index_d$1_ContentSpinner as ContentSpinner,
    index_d$1_ContextualWidgetMixin as ContextualWidgetMixin,
    index_d$1_DiagramViewData as DiagramViewData,
    index_d$1_DropPanelMixin as DropPanelMixin,
    index_d$1_EntityFilterEvent as EntityFilterEvent,
    index_d$1_EntityViewData as EntityViewData,
    index_d$1_EntityViewDataUnfolding as EntityViewDataUnfolding,
    index_d$1_GscapeActionListItem as GscapeActionListItem,
    _default$3 as GscapeActionListStyle,
    index_d$1_GscapeButton as GscapeButton,
    _default$4 as GscapeButtonStyle,
    index_d$1_GscapeConfirmDialog as GscapeConfirmDialog,
    index_d$1_GscapeContextMenu as GscapeContextMenu,
    index_d$1_GscapeEntityListItem as GscapeEntityListItem,
    index_d$1_GscapeEntitySearch as GscapeEntitySearch,
    index_d$1_GscapeEntitySelector as GscapeEntitySelector,
    index_d$1_GscapeEntityTypeFilters as GscapeEntityTypeFilters,
    index_d$1_GscapeFullPageSelector as GscapeFullPageSelector,
    index_d$1_GscapeSelect as GscapeSelect,
    index_d$1_GscapeTextSearch as GscapeTextSearch,
    index_d$1_GscapeToggle as GscapeToggle,
    index_d$1_IBaseMixin as IBaseMixin,
    index_d$1_IContextualWidgetMixin as IContextualWidgetMixin,
    index_d$1_IDropPanelMixin as IDropPanelMixin,
    index_d$1_IEntityFilters as IEntityFilters,
    index_d$1_IEntitySelector as IEntitySelector,
    index_d$1_IModalMixin as IModalMixin,
    index_d$1_ModalMixin as ModalMixin,
    index_d$1_NodeButton as NodeButton,
    index_d$1_OccurrenceIdViewData as OccurrenceIdViewData,
    index_d$1_SearchEvent as SearchEvent,
    index_d$1_SelectOption as SelectOption,
    index_d$1_SizeEnum as SizeEnum,
    index_d$1_TabProps as TabProps,
    index_d$1_ToggleLabelPosition as ToggleLabelPosition,
    index_d$1_UiOption as UiOption,
    index_d$1_ViewObjectPropertyUnfolding as ViewObjectPropertyUnfolding,
    index_d$1_WidgetEnum as WidgetEnum,
    _default$1 as baseStyle,
    index_d$1_contentSpinnerStyle as contentSpinnerStyle,
    index_d$1_createEntitiesList as createEntitiesList,
    _default as emptySearchBlankState,
    _default$2 as entityListItemStyle,
    index_d$1_getContentSpinner as getContentSpinner,
    index_d$1_getEntityOccurrencesTemplate as getEntityOccurrencesTemplate,
    export_default$1 as getIconSlot,
    index_d$1_hasDropPanel as hasDropPanel,
    index_d$2 as icons,
    index_d$1_initInitialRendererSelector as initInitialRendererSelector,
    export_default$2 as initUI,
    index_d$1_search as search,
    index_d$1_showMessage as showMessage,
    index_d$1_textSpinner as textSpinner,
    index_d$1_textSpinnerStyle as textSpinnerStyle,
  };
}

declare function export_default(text: string): string;

declare function grapholEntityToEntityViewData(grapholEntity: GrapholEntity, grapholscape: Grapholscape): EntityViewData;
declare function getEntityViewDataUnfolding(entity: GrapholEntity, grapholscape: Grapholscape, hasUnfoldings?: (iri: string, type: TypesEnum) => boolean): EntityViewDataUnfolding;

declare const index_d_getEntityViewDataUnfolding: typeof getEntityViewDataUnfolding;
declare const index_d_grapholEntityToEntityViewData: typeof grapholEntityToEntityViewData;
declare namespace index_d {
  export {
    export_default as capitalizeFirstChar,
    index_d_getEntityViewDataUnfolding as getEntityViewDataUnfolding,
    index_d_grapholEntityToEntityViewData as grapholEntityToEntityViewData,
  };
}

/**
 * Create a full instance of Grapholscape with diagrams and widgets
 *
 * @remarks
 * Once the promise is fulfilled, you get a {@link !core.Grapholscape}.
 * Hence the API you will most likely want to use will be the one of the {@link !core.Grapholscape} class.
 * You can change diagram, zoom, focus elements, select them, filter them and so on with that class.
 *
 * @param file the ontology, can be an object of the
 * [Web API interface File](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * or a String representing the .graphol file to be displayed
 * @param container a DOM element in which the ontology will be rendered in
 * @param config a config object, please read more about [settings](https://github.com/obdasystems/grapholscape/wiki/Settings)
 * @returns a promise that will be fulfilled with a {@link !core.Grapholscape} object
 * @see [Getting started](https://obdasystems.github.io/grapholscape/pages/getting-started.html)
 * @see [Configuration](https://obdasystems.github.io/grapholscape/pages/configuration.html)
 */
declare function fullGrapholscape(file: string | File, container: HTMLElement, config?: GrapholscapeConfig): Promise<Grapholscape | undefined>;
/**
 * Create a bare instance of Grapholscape, only diagrams, no widgets
 *
 * @remarks
 * Once the promise is fulfilled, you get a {@link !core.Grapholscape}.
 * Hence the API you will most likely want to use will be the one of the {@link !core.Grapholscape} class.
 * You can change diagram, zoom, focus elements, select them, filter them and so on with that class.
 *
 * @param file the ontology, can be an object of the
 * [Web API interface File](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * or a String representing the .graphol file to be displayed
 * @param container a DOM element in which the ontology will be rendered in
 * @param config a config object, please read more about [settings](https://github.com/obdasystems/grapholscape/wiki/Settings)
 * @returns a promise that will be fulfilled with a {@link !core.Grapholscape} object
 * @see [Getting started](https://obdasystems.github.io/grapholscape/pages/getting-started.html)
 * @see [Configuration](https://obdasystems.github.io/grapholscape/pages/configuration.html)
 */
declare function bareGrapholscape(file: string | File, container: HTMLElement, config?: GrapholscapeConfig): Promise<Grapholscape | undefined>;
declare function loadRDFGraph(rdfGraph: RDFGraph, container: HTMLElement, mastroConnection?: RequestOptions): Grapholscape;
declare function builder(rdfGraph: RDFGraph, container: HTMLElement, mastroConnection?: RequestOptions): Promise<Grapholscape>;
declare function buildFromScratch(name: string, iri: string, container: HTMLElement, mastroConnection?: RequestOptions, config?: OntologyDesignerConfig): Promise<GrapholscapeDesigner>;

export { AnnotatedElement, Annotation, AnnotationProperty, BaseFilterManager, BaseRenderer, Breakpoint, CSS_PROPERTY_NAMESPACE, ClassInstanceEntity, ColourMap, ColoursNames, DefaultAnnotationProperties, RDFGraphConfigFiltersEnum as DefaultFilterKeyEnum, DefaultNamespaces, DefaultThemes, DefaultThemesEnum, Diagram, DiagramRepresentation, RDFGraphConfigEntityNameTypeEnum as EntityNameType, Filter, FloatyRendererState, FunctionPropertiesEnum as FunctionalityEnum, GrapholEdge, GrapholElement, GrapholEntity, GrapholNode, GrapholNodeInfo, GrapholNodesEnum, GrapholRendererState, Grapholscape, GrapholscapeConfig, GrapholscapeTheme, Hierarchy, IEventTriggers, IncrementalController, IncrementalDiagram, IncrementalRendererState, IonEvent$1 as IonEvent, Iri, Language, Lifecycle, LifecycleEvent, LiteRendererState, Namespace, Ontology, POLYGON_POINTS, Position, Renderer, RendererStatesEnum, Shape, index_d$3 as SwaggerModel, ThemeConfig, TypesEnum, Viewport, WidgetsConfig, autoDarkColourMap, autoLightColourMap, bareGrapholscape, buildFromScratch, builder, classicColourMap, clearLocalStorage, darkColourMap, floatyOptions, fullGrapholscape, getDefaultFilters, _default$b as grapholOptions, gscapeColourMap, FilterManager as iFilterManager, RenderState as iRenderState, initIncremental, isGrapholEdge, isGrapholNode, liteOptions, loadConfig, loadRDFGraph, setGraphEventHandlers, storeConfigEntry, toPNG, toSVG, index_d$1 as ui, index_d as util };
