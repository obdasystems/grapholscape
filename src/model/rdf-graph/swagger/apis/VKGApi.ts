/* tslint:disable */
/* eslint-disable */
/**
 * Grapholscape API model
 * This is the API for retaining a Grapholscape\'s loaded ontology (or graph) in order to restart navigation from a previous state.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: obdasystems@info.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RDFGraph,
  VKGSnapshot,
} from '../models';
import {
    RDFGraphFromJSON,
    RDFGraphToJSON,
    VKGSnapshotFromJSON,
    VKGSnapshotToJSON,
} from '../models';

export interface GetRDFGraphConstructRequest {
    name: string;
    queryID: string;
    pageSize: number;
    pageNumber: number;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest {
    ontologyName: string;
    version: string;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest {
    ontologyName: string;
    version: string;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogGetRequest {
    ontologyName: string;
    version: string;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest {
    ontologyName: string;
    version: string;
    additive?: boolean;
    body?: string;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogPostRequest {
    ontologyName: string;
    version: string;
    vKGSnapshot?: VKGSnapshot;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest {
    ontologyName: string;
    version: string;
    snapshotId: number;
}

export interface OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest {
    ontologyName: string;
    version: string;
    snapshotId: number;
    vKGSnapshot?: VKGSnapshot;
}

/**
 * 
 */
export class VKGApi extends runtime.BaseAPI {

    /**
     * Returns RDFGraph for CONSTRUCT visualization
     */
    async getRDFGraphConstructRaw(requestParameters: GetRDFGraphConstructRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RDFGraph>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getRDFGraphConstruct.');
        }

        if (requestParameters.queryID === null || requestParameters.queryID === undefined) {
            throw new runtime.RequiredError('queryID','Required parameter requestParameters.queryID was null or undefined when calling getRDFGraphConstruct.');
        }

        if (requestParameters.pageSize === null || requestParameters.pageSize === undefined) {
            throw new runtime.RequiredError('pageSize','Required parameter requestParameters.pageSize was null or undefined when calling getRDFGraphConstruct.');
        }

        if (requestParameters.pageNumber === null || requestParameters.pageNumber === undefined) {
            throw new runtime.RequiredError('pageNumber','Required parameter requestParameters.pageNumber was null or undefined when calling getRDFGraphConstruct.');
        }

        const queryParameters: any = {};

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/endpoint/{name}/cquery/{queryID}/results/rdfGraph`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"queryID"}}`, encodeURIComponent(String(requestParameters.queryID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RDFGraphFromJSON(jsonValue));
    }

    /**
     * Returns RDFGraph for CONSTRUCT visualization
     */
    async getRDFGraphConstruct(requestParameters: GetRDFGraphConstructRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RDFGraph> {
        const response = await this.getRDFGraphConstructRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete all the saved RDFGraph for VKGs exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogDeleteRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VKGSnapshot>>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogDelete.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogDelete.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VKGSnapshotFromJSON));
    }

    /**
     * Delete all the saved RDFGraph for VKGs exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogDelete(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VKGSnapshot>> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the catalog as a FileInfo
     */
    async owlOntologyOntologyNameVersionVkgCatalogExportGetRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogExportGet.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogExportGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog/export`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns the catalog as a FileInfo
     */
    async owlOntologyOntologyNameVersionVkgCatalogExportGet(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogExportGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogExportGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the saved RDFGraph for VKGs exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogGetRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VKGSnapshot>>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogGet.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VKGSnapshotFromJSON));
    }

    /**
     * Returns the saved RDFGraph for VKGs exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogGet(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VKGSnapshot>> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Import a FileInfo in the ontology VKG\'s catalog
     */
    async owlOntologyOntologyNameVersionVkgCatalogImportPostRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VKGSnapshot>>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogImportPost.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogImportPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters.additive !== undefined) {
            queryParameters['additive'] = requestParameters.additive;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog/import`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VKGSnapshotFromJSON));
    }

    /**
     * Import a FileInfo in the ontology VKG\'s catalog
     */
    async owlOntologyOntologyNameVersionVkgCatalogImportPost(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogImportPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VKGSnapshot>> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogImportPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Save a new VKG exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogPostRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VKGSnapshot>>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogPost.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VKGSnapshotToJSON(requestParameters.vKGSnapshot),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VKGSnapshotFromJSON));
    }

    /**
     * Save a new VKG exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogPost(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VKGSnapshot>> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the VKG exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VKGSnapshot>>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDelete.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDelete.');
        }

        if (requestParameters.snapshotId === null || requestParameters.snapshotId === undefined) {
            throw new runtime.RequiredError('snapshotId','Required parameter requestParameters.snapshotId was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDelete.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog/{snapshotId}`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))).replace(`{${"snapshotId"}}`, encodeURIComponent(String(requestParameters.snapshotId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VKGSnapshotFromJSON));
    }

    /**
     * Delete the VKG exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDelete(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VKGSnapshot>> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogSnapshotIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify a VKG exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRaw(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<VKGSnapshot>>> {
        if (requestParameters.ontologyName === null || requestParameters.ontologyName === undefined) {
            throw new runtime.RequiredError('ontologyName','Required parameter requestParameters.ontologyName was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPut.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPut.');
        }

        if (requestParameters.snapshotId === null || requestParameters.snapshotId === undefined) {
            throw new runtime.RequiredError('snapshotId','Required parameter requestParameters.snapshotId was null or undefined when calling owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPut.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/owlOntology/{ontologyName}/version/vkg/catalog/{snapshotId}`.replace(`{${"ontologyName"}}`, encodeURIComponent(String(requestParameters.ontologyName))).replace(`{${"snapshotId"}}`, encodeURIComponent(String(requestParameters.snapshotId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: VKGSnapshotToJSON(requestParameters.vKGSnapshot),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(VKGSnapshotFromJSON));
    }

    /**
     * Modify a VKG exploration
     */
    async owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPut(requestParameters: OwlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<VKGSnapshot>> {
        const response = await this.owlOntologyOntologyNameVersionVkgCatalogSnapshotIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
